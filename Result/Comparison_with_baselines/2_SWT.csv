code
"package swttest;  import org.eclipse.swt.SWT; import org.eclipse.swt.events.PaintEvent; import org.eclipse.swt.events.PaintListener; import org.eclipse.swt.graphics.Font; import org.eclipse.swt.graphics.FontData; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.graphics.Region; import org.eclipse.swt.widgets.Canvas; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell;  public class Test {      public static void main(String[] args) {         Test test = new Test();          test.show();     }      public void show() {         Display display = new Display();         // Create a shell with no trim         final Shell shell = new Shell(display, SWT.NO_TRIM);         shell.setForeground(display.getSystemColor(SWT.COLOR_WHITE));          //set the transparent canvas on the shell         Canvas canvas = new Canvas(shell, SWT.NO_BACKGROUND);          //create an area to paint the text         Rectangle size = new Rectangle(0, 0, 200, 200);         canvas.setBounds(size);          Region region = canvas.getRegion();          //mucking about with fonts         Font font = display.getSystemFont();          FontData[] fd = font.getFontData();          fd[0].setHeight(24);         fd[0].setStyle(SWT.BOLD);          Font bigFont = new Font(display, fd[0]);         canvas.setFont(bigFont);          // define the shape of the shell using setRegion         shell.setRegion(region);         shell.setSize(size.width, size.height);          canvas.addPaintListener(new PaintListener() {             public void paintControl(PaintEvent e) {                 e.gc.drawString(""Hello"", 10, 10, true);             }         });          shell.open();         while (!shell.isDisposed()) {             if (!display.readAndDispatch())                 display.sleep();         }         region.dispose();         display.dispose();     } }"
"package com.ggl.testing;  import java.awt.Color; import java.awt.Dimension; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.geom.Ellipse2D;  import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.SwingUtilities;  public class SimplePainting implements Runnable {      @Override     public void run() {         JFrame frame = new JFrame(""Simple Painting"");         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);          PaintPanel paintPanel = new PaintPanel();         frame.add(paintPanel);          frame.setLocationByPlatform(true);         frame.pack();         frame.setVisible(true);     }      public static void main(String[] args) {         SwingUtilities.invokeLater(new SimplePainting());     }      class PaintPanel extends JPanel {          private static final long serialVersionUID =                  -5950526117015270963L;          private Ellipse2D myEllipse =                  new Ellipse2D.Double(20, 20, 100, 100);          private String myText = ""Testing, one, two, three"";          public PaintPanel() {             this.setPreferredSize(new Dimension(400, 200));         }          @Override         protected void paintComponent(Graphics g) {             super.paintComponent(g);             Graphics2D g2d = (Graphics2D) g;             g2d.setXORMode(Color.WHITE);              g2d.setColor(Color.RED);             g2d.fill(myEllipse);              g2d.setColor(Color.CYAN);             g2d.drawString(myText, 70, 70);          }     }  }"
"package org.mypackage.program; import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Image; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; public class Demo {     /**      * @param args      */     public static void main(String[] args) {         // TODO Auto-generated method stub             Display display = new Display();             Shell shell = new Shell(display);             Image img;             shell.setMaximized(true);             img= new Image(display,"".\\src\\org\\mypackage\\program\\car_image.gif"");             Composite comp= new Composite(shell, SWT.NONE);             comp.setBackgroundImage(img);             shell.setLayout(new FillLayout());             shell.open();             while (!shell.isDisposed())             {                        if (!display.readAndDispatch())                 {                              display.sleep();                        }                  }                  display.dispose();     } }"
"import java.lang.reflect.Method;  import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Composite; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Menu; import org.eclipse.swt.widgets.MenuItem; import org.eclipse.swt.widgets.Shell;  public class MenuTest {      public static void main (String [] args)      {         Display display = new Display ();         final Shell shell = new Shell (display);         final Menu bar = new Menu (shell, SWT.BAR);         shell.setMenuBar (bar);          final Composite c = new Composite(shell, SWT.NONE);         c.setLayout(new GridLayout());         c.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true,true));          MenuItem fileItem = new MenuItem (bar, SWT.CASCADE);         fileItem.setText (""&amp;File"");         Menu submenu = new Menu (shell, SWT.DROP_DOWN);         fileItem.setMenu (submenu);         MenuItem item = new MenuItem (submenu, SWT.PUSH);         item.addListener (SWT.Selection, new Listener () {             public void handleEvent (Event e) {                 System.out.println(shell.getSize().y -  shell.getClientArea().height);                 System.out.println(getMenuHeight(bar));             }         });           item.setText (""Select &amp;All\tCtrl+A"");         item.setAccelerator (SWT.MOD1 + 'A');         shell.setSize (200, 200);         shell.open ();         while (!shell.isDisposed()) {             if (!display.readAndDispatch ()) display.sleep ();         }         display.dispose ();     }      static int getMenuHeight(Menu parent)     {         try {             Method m = Menu.class.getDeclaredMethod(""getBounds"", null);             m.setAccessible(true);             Rectangle r = (Rectangle) m.invoke(parent, null);             return r.height;         } catch (Exception e) {             e.printStackTrace();             return 0;         }     } }"
"package test;  import java.io.InputStream;  import org.eclipse.swt.graphics.Image; import org.eclipse.swt.layout.FillLayout; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell;  public class IconTest  {     public static void main(String[] args)     {         final Display display = new Display();          Shell shell = new Shell(display);         shell.setLayout(new FillLayout());         shell.setSize(200, 200);         shell.setLocation(20, 20);          InputStream stream = IconTest.class.getResourceAsStream(""/test/icon.ico"");           Image imgTrayIcon = new Image(display, stream);          shell.setImage(imgTrayIcon);          shell.open();         while (!shell.isDisposed()) {                 if (!display.readAndDispatch())                         display.sleep();         }          if(imgTrayIcon != null)             imgTrayIcon.dispose();          display.dispose();     } }"
"package stackoverflow;  import java.awt.BorderLayout; import java.awt.Color; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.Image;  import javax.swing.ImageIcon; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.SwingUtilities;  public class SplashScreen extends JFrame {     public static void main(String[] args)      {         SwingUtilities.invokeLater(new Runnable()         {             @Override             public void run()             {                 new SplashScreen();             }         });     }          private PaintPanel paintPanel;      public SplashScreen()     {         setTitle(""BlueJay"");         setDefaultCloseOperation(EXIT_ON_CLOSE);          getContentPane().setBackground(Color.BLACK);         getContentPane().setLayout(new BorderLayout());          paintPanel = new PaintPanel();         getContentPane().add(paintPanel, BorderLayout.CENTER);          setSize(900,600);         setLocationRelativeTo(null);         setFocusable(true);         requestFocus();         setVisible(true);          startAnimation();     }      void startAnimation()     {         Thread thread = new Thread(new Runnable()         {             int x = 100;             int y = 100;             int w = 0;             int h = 0;              @Override             public void run()             {                 try                 {                     Thread.sleep(500);                 }                 catch (InterruptedException ex)                 {                     Thread.currentThread().interrupt();                     return;                 }                  while (true)                 {                     if (y == 200)                     {                         // new MainMenu_BlueJay().setVisible(true);                         dispose();                     }                      x += 2;                     y += 1;                     w += 1;                     h += 1;                     paintPanel.setImageCoordinates(x, y, w, h);                      repaint();                     try                     {                         Thread.sleep(10);                     }                     catch (InterruptedException ex)                     {                         Thread.currentThread().interrupt();                         return;                     }                  }             }         });         thread.start();     } }   class PaintPanel extends JPanel {     private final Image image;     private int imageX, imageY;     private int imageW, imageH;      PaintPanel()     {         image = new ImageIcon(""Clipboard02.jpg"").getImage();         imageX = 0;         imageY = 0;         imageW = 0;         imageH = 0;     }      void setImageCoordinates(int imageX, int imageY, int imageW, int imageH)     {         this.imageX = imageX;         this.imageY = imageY;         this.imageW = imageW;         this.imageH = imageH;         repaint();     }      @Override     protected void paintComponent(Graphics gr)     {         super.paintComponent(gr);         Graphics2D g = (Graphics2D) gr;          float scalingX = (float) imageW / image.getWidth(null);         float scalingY = (float) imageH / image.getHeight(null);         g.scale(scalingX, scalingY);          int ix = (int)(imageX / scalingX);         int iy = (int)(imageY / scalingY);         g.drawImage(image, ix, iy, null);     } }"
"import java.util.ArrayList; import java.util.Arrays;  import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.List; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Shell;  public class MiniExample {      public static void main(String[] args) {         Display display = Display.getDefault();         final Shell shell = new Shell(display);         shell.setLayout(new GridLayout(1, false));          // Fill your ArrayList with its content         ArrayList&lt;String&gt; printer = new ArrayList&lt;String&gt;();         printer.add(""Epson"");         printer.add(""Canon"");         printer.add(""HP"");          final List printerList = new List(shell, SWT.MULTI | SWT.BORDER);          // Fill the ArrayList into the SWT List         for(String print : printer)             printerList.add(print);          // Print selection         printerList.addListener(SWT.Selection, new Listener() {             @Override             public void handleEvent(Event arg0) {                 if(printerList.getSelectionCount() &gt; 0)                     System.out.println(Arrays.toString(printerList.getSelection()));             }         });          shell.pack();         shell.open();         while (!shell.isDisposed()) {             if (!display.readAndDispatch())                 display.sleep();         }     } }"
"package de.professional_webworkx.blog.colorgradient;  import javafx.application.Application; import javafx.event.ActionEvent; import javafx.event.EventHandler; import javafx.scene.Scene; import javafx.scene.control.ColorPicker; import javafx.scene.layout.BorderPane; import javafx.scene.layout.Pane; import javafx.scene.layout.VBox; import javafx.scene.paint.Color; import javafx.stage.Stage;  /**  *  * @author ottp  */ public class ColorGradient extends Application {      @Override     public void start(Stage primaryStage) {          final Pane pane = new BorderPane();         pane.setPrefWidth(300);         pane.setPrefHeight(200);         pane.setStyle(""-fx-background-color: linear-gradient(from 25% 25% to 100% 100%, #dc143c, #661a33)"");           final ColorPicker picker = new ColorPicker();         picker.setOnAction(new EventHandler&lt;ActionEvent&gt;() {              @Override             public void handle(ActionEvent t) {                 Color value = picker.getValue();                 String colorString = value.toString();                 String substring = colorString.substring(2, colorString.length()-2);                 pane.setStyle(""-fx-background-color: linear-gradient(from 25% 25% to 100% 100%, #"" + substring + "", #661a33)"");             }         });           VBox vBox = new VBox();         vBox.getChildren().add(pane);         vBox.getChildren().add(picker);          Scene scene = new Scene(vBox);         primaryStage.setScene(scene);         primaryStage.show();     }      public static void main(String[] args) {         launch(args);     }  }"
"import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method;  import org.eclipse.swt.SWT; import org.eclipse.swt.graphics.Point; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.widgets.Control; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.ScrollBar; import org.eclipse.swt.widgets.Scrollable;  /**  * The standard platform behavior on Windows is to scroll the widget with  * keyboard focus when the user turns the mouse wheel, instead of the widget  * currently under the mouse pointer. Many consider this annoying and Windows  * itself, as well as many popular Windows software, breaks this rule and  * implements the behavior seen on other platforms, which is to scroll the  * widget under the mouse.  *   * Win32MouseWheelFilter is a Listener implementation which will filter for  * SWT.MouseWheel events delivered to any Widget and try to redirect the event  * to the widget under the mouse or one of it's parents. The widget, or one of  * it's parents is considered a suitable target, if it either has Listeners for  * SWT.MouseWheel attached (assuming that those listeners would do something  * sensible with the event), or if its style bits contain SWT.H_SCROLL and/or  * SWT.V_SCROLL. In the later case a low level system event is generated, which  * is necessary to get the event handled by the native ScrollBar widgets. A  * vertical ScrollBar is preferred as the target, unless it is for some reason  * unsuitable for scrolling. In that case, horizontal scrolling would take  * place, if there is a suitable horizontal ScrollBar.  *   * Simply creating a new Win32MouseWheelFilter instance will install it as an  * event filter in the Display passed to the constructor. At an appropriate  * time, you may call dispose() to remove the filter again. On SWT platforms  * other than ""win32"", constructing an Win32MouseWheelFilter will have no effect.  */ public class Win32MouseWheelFilter implements Listener {      private final Display   fDisplay;      private int             WM_VSCROLL;     private int             WM_HSCROLL;     private int             SB_LINEUP;     private int             SB_LINEDOWN;      private Method          fSendEventMethod32;     private Method          fSendEventMethod64;      /**      * Creates a new Win32MouseWheelFilter instance and registers it as global      * event filter in the provided Display. Nothing will happen if the SWT      * platform is not ""win32"". If for some reason some SWT internals have      * changed since the writing of this class, and the Reflection-based      * extraction of some win32 specific fields of the SWT OS class fails,      * no filtering of wheel events will take place either.      *       * @param display      *      The Display instance that the Win32MouseWheelFilter should install      *      itself into as global event filter.      */     public Win32MouseWheelFilter(Display display) {         fDisplay = display;          if (!SWT.getPlatform().equals(""win32""))             return;          try {             Class&lt;?&gt; os = Class.forName(""org.eclipse.swt.internal.win32.OS"");             WM_VSCROLL = os.getDeclaredField(""WM_VSCROLL"").getInt(null);             WM_HSCROLL = os.getDeclaredField(""WM_HSCROLL"").getInt(null);             SB_LINEUP = os.getDeclaredField(""SB_LINEUP"").getInt(null);             SB_LINEDOWN = os.getDeclaredField(""SB_LINEDOWN"").getInt(null);              try {                 // Try the 32-bit version first                 fSendEventMethod32 = os.getDeclaredMethod(""SendMessage"",                     int.class, int.class, int.class, int.class);             } catch (NoSuchMethodException e) {                 // Fall back to the 64-bit version                 fSendEventMethod64 = os.getDeclaredMethod(""SendMessage"",                     long.class, int.class, long.class, long.class);             }              display.addFilter(SWT.MouseWheel, this);             return;          } catch (ClassNotFoundException e) {             e.printStackTrace();         } catch (IllegalArgumentException e) {             e.printStackTrace();         } catch (SecurityException e) {             e.printStackTrace();         } catch (IllegalAccessException e) {             e.printStackTrace();         } catch (NoSuchFieldException e) {             e.printStackTrace();         } catch (NoSuchMethodException e) {             e.printStackTrace();         }          System.out.println(""Warning: Running on win32 SWT platform, ""             + ""but unable to install Win32MouseWheelFilter filter."");     }      /**      * If the receiver had previously installed itself as global event filter,      * this method will remove it again from the display's filters.      */     public final void dispose() {         fDisplay.removeFilter(SWT.MouseWheel, this);     }      public final void handleEvent(Event event) {         Control cursorControl = event.display.getCursorControl();         if (event.widget == cursorControl || cursorControl == null)             return;          if (event.widget instanceof Control) {             // If the original target control's bounds contain the mouse             // location, do not re-target the event, since it may indeed be the             // Control that needs to handle scrolling for an embedded Control             // that has focus.             Control control = (Control) event.widget;             Rectangle bounds = control.getBounds();             bounds.x = 0;             bounds.y = 0;             Point cursorPos = control.toControl(display.getCursorLocation());             if (bounds.contains(cursorPos))                 return;         }          // Try to find the best target widget for the event, based on the         // cursorControl. A suitable target control is either one that has         // a listener for SWT.MouseWheel attached, or one that has either         // SWT.H_SCROLL or SWT.V_SCROLL in its style bits.         Control wheelControl = cursorControl;         int scrollStyle = SWT.H_SCROLL | SWT.V_SCROLL;         while (wheelControl != null             &amp;&amp; (wheelControl.getStyle() &amp; scrollStyle) == 0             &amp;&amp; wheelControl.getListeners(SWT.MouseWheel).length == 0) {             wheelControl = wheelControl.getParent();         }         if (wheelControl == null) {             // The event would not be handled by anyone, bail out.             return;         }          int style = wheelControl.getStyle();          if ((style &amp; scrollStyle) != 0 &amp;&amp; wheelControl instanceof Scrollable) {             // Construct the data for the low level event based on which             // direction the target can scroll in. We need to use a low-level             // event since otherwise it won't be handled by the native             // ScrollBar widgets.             int msg;              // Prefer vertical scrolling. However, if the             // there is no vertical ScrollBar, or if it's somehow disabled,             // then switch to horizontal scrolling instead.             if ((style &amp; SWT.V_SCROLL) != 0 ) {                 ScrollBar vBar = ((Scrollable) wheelControl).getVerticalBar();                 if (vBar == null                     || ((vBar.getMinimum() == 0                         &amp;&amp; vBar.getMaximum() == 0                         &amp;&amp; vBar.getSelection() == 0)                             || !vBar.isEnabled()                             || !vBar.isVisible())) {                     // There is no vertical ScrollBar, or it can't be used.                     msg = WM_HSCROLL;                 } else                     msg = WM_VSCROLL;             } else {                 msg = WM_HSCROLL;             }              int count = event.count;             int wParam = SB_LINEUP;             if (event.count &lt; 0) {                 count = -count;                 wParam = SB_LINEDOWN;             }              try {                 // Obtain the control's handle via Reflection and                 // deliver the event using the low level platform method.                 // (64 and 32 bit versions)                 if (fSendEventMethod32 != null) {                     int handle = org.eclipse.swt.widgets.Control.class                         .getDeclaredField(""handle"").getInt(wheelControl);                     for (int i = 0; i &lt; count; i++)                         fSendEventMethod32.invoke(null, handle, msg, wParam, 0);                 } else {                     long handle = org.eclipse.swt.widgets.Control.class                         .getDeclaredField(""handle"").getLong(wheelControl);                     for (int i = 0; i &lt; count; i++)                         fSendEventMethod64.invoke(null, handle, msg, wParam, 0);                 }              } catch (IllegalArgumentException e) {                 e.printStackTrace();             } catch (IllegalAccessException e) {                 e.printStackTrace();             } catch (InvocationTargetException e) {                 e.printStackTrace();             } catch (SecurityException e) {                 e.printStackTrace();             } catch (NoSuchFieldException e) {                 e.printStackTrace();             }         } else {             // It makes no sense using the low-level OS event delivery, since             // Widgets without the scrolling style bits won't receive this             // event. Since we selected this widget based on the fact that it             // has SWT.MouseWheel listeners attached, use the regular SWT event             // notification system.              // Convert mouse location, since the event contains it in the wrong             // coordinate space (the one of the original event target).             Point cursorPos = wheelControl.toControl(                 event.display.getCursorLocation());             event.x = cursorPos.x;             event.y = cursorPos.y;              event.widget = wheelControl;             wheelControl.notifyListeners(event.type, event);         }          // We re-targeted the event, or re-posted a new event to another widget,         // so prevent this event from being processed any further.         event.type = SWT.None;         event.doit = false;     } }"
"import java.awt.Color; import java.awt.GradientPaint; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.RenderingHints;  import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.SwingUtilities;  public class TestPanel extends JPanel {      @Override     protected void paintComponent(Graphics g) {         super.paintComponent(g);         Graphics2D g2d = (Graphics2D) g;         g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);         int w = getWidth();         int h = getHeight();         Color color1 = Color.RED;         Color color2 = Color.GREEN;         GradientPaint gp = new GradientPaint(0, 0, color1, 0, h, color2);         g2d.setPaint(gp);         g2d.fillRect(0, 0, w, h);     }      public static void main(String[] args) {         SwingUtilities.invokeLater(new Runnable() {             @Override             public void run() {                 JFrame frame = new JFrame();                 TestPanel panel = new TestPanel();                 frame.add(panel);                 frame.setSize(200, 200);                 frame.setLocationRelativeTo(null);                 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);                 frame.setVisible(true);             }         });     } }"
"import javax.swing.*; import java.awt.*;  class ChordEditor extends JPanel {      public ChordEditor() {         this.repaint();     }      @Override     public void paint(Graphics g) {         System.out.println(""entering paint function"");         super.paint(g);         Graphics2D g2d = (Graphics2D) g;         Toolkit.getDefaultToolkit().sync();         System.out.println(""drawing line"");         g2d.drawLine(10, 10, 40, 40);         //g.dispose();     }      public static void main(String[] args) {         JFrame m_frame = new JFrame();         m_frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         m_frame.setSize(600, 400);         m_frame.setVisible(true);         ChordEditor ce = new ChordEditor();         m_frame.getContentPane().removeAll();         m_frame.add(ce);         m_frame.getContentPane().repaint();         m_frame.validate();     } }"
"import javafx.animation.*; import javafx.application.Application; import javafx.scene.*; import javafx.scene.image.Image; import javafx.scene.layout.StackPane; import javafx.scene.paint.*; import javafx.scene.shape.Sphere; import javafx.scene.transform.Rotate; import javafx.stage.Stage; import javafx.util.Duration;  public class EarthViewer extends Application {    private static final double EARTH_RADIUS  = 400;   private static final double VIEWPORT_SIZE = 800;   private static final double ROTATE_SECS   = 30;    private static final double MAP_WIDTH  = 8192 / 2d;   private static final double MAP_HEIGHT = 4092 / 2d;    private static final String DIFFUSE_MAP =       ""http://planetmaker.wthr.us/img/earth_gebco8_texture_8192x4096.jpg"";   private static final String NORMAL_MAP =       ""http://planetmaker.wthr.us/img/earth_normalmap_flat_8192x4096.jpg"";   private static final String SPECULAR_MAP =       ""http://planetmaker.wthr.us/img/earth_specularmap_flat_8192x4096.jpg"";    private Group buildScene() {     Sphere earth = new Sphere(EARTH_RADIUS);     earth.setTranslateX(VIEWPORT_SIZE / 2d);     earth.setTranslateY(VIEWPORT_SIZE / 2d);      PhongMaterial earthMaterial = new PhongMaterial();     earthMaterial.setDiffuseMap(       new Image(         DIFFUSE_MAP,         MAP_WIDTH,         MAP_HEIGHT,         true,         true       )     );     earthMaterial.setBumpMap(       new Image(         NORMAL_MAP,         MAP_WIDTH,         MAP_HEIGHT,         true,         true       )     );     earthMaterial.setSpecularMap(       new Image(         SPECULAR_MAP,         MAP_WIDTH,         MAP_HEIGHT,         true,         true       )     );      earth.setMaterial(         earthMaterial     );      return new Group(earth);   }    @Override   public void start(Stage stage) {     Group group = buildScene();      Scene scene = new Scene(       new StackPane(group),       VIEWPORT_SIZE, VIEWPORT_SIZE,       true,       SceneAntialiasing.BALANCED     );      scene.setFill(Color.rgb(10, 10, 40));      scene.setCamera(new PerspectiveCamera());      stage.setScene(scene);     stage.show();      stage.setFullScreen(true);      rotateAroundYAxis(group).play();   }    private RotateTransition rotateAroundYAxis(Node node) {     RotateTransition rotate = new RotateTransition(       Duration.seconds(ROTATE_SECS),        node     );     rotate.setAxis(Rotate.Y_AXIS);     rotate.setFromAngle(360);     rotate.setToAngle(0);     rotate.setInterpolator(Interpolator.LINEAR);     rotate.setCycleCount(RotateTransition.INDEFINITE);      return rotate;   }    public static void main(String[] args) {     launch(args);   } }"
"import javafx.application.Application; import javafx.geometry.Insets; import javafx.scene.Scene; import javafx.scene.canvas.*; import javafx.scene.image.Image; import javafx.scene.layout.StackPane; import javafx.scene.paint.Color; import javafx.scene.transform.Rotate; import javafx.stage.Stage;  /** Rotates images round pivot points and places them in a canvas */ public class RotatedImageInCanvas extends Application {     /**      * Sets the transform for the GraphicsContext to rotate around a pivot point.      *      * @param gc the graphics context the transform to applied to.      * @param angle the angle of rotation.      * @param px the x pivot co-ordinate for the rotation (in canvas co-ordinates).      * @param py the y pivot co-ordinate for the rotation (in canvas co-ordinates).      */     private void rotate(GraphicsContext gc, double angle, double px, double py) {         Rotate r = new Rotate(angle, px, py);         gc.setTransform(r.getMxx(), r.getMyx(), r.getMxy(), r.getMyy(), r.getTx(), r.getTy());     }      /**      * Draws an image on a graphics context.      *      * The image is drawn at (tlpx, tlpy) rotated by angle pivoted around the point:      *   (tlpx + image.getWidth() / 2, tlpy + image.getHeight() / 2)      *      * @param gc the graphics context the image is to be drawn on.      * @param angle the angle of rotation.      * @param tlpx the top left x co-ordinate where the image will be plotted (in canvas co-ordinates).      * @param tlpy the top left y co-ordinate where the image will be plotted (in canvas co-ordinates).      */     private void drawRotatedImage(GraphicsContext gc, Image image, double angle, double tlpx, double tlpy) {         gc.save(); // saves the current state on stack, including the current transform         rotate(gc, angle, tlpx + image.getWidth() / 2, tlpy + image.getHeight() / 2);         gc.drawImage(image, tlpx, tlpy);         gc.restore(); // back to original state (before rotation)     }      @Override public void start(Stage stage) {         Image image = new Image(             ""http://worldpress.org/images/maps/world_600w.jpg"", 350, 0, true, true         );          // creates a canvas on which rotated images are rendered.         Canvas canvas = new Canvas(600, 400);         GraphicsContext gc = canvas.getGraphicsContext2D();          drawRotatedImage(gc, image,  40,   0,   0);         drawRotatedImage(gc, image, -50, 400, 200);          // supplies a tiled background image on which the canvas is drawn.         StackPane stack = new StackPane();         stack.setMaxSize(canvas.getWidth(), canvas.getHeight());         stack.setStyle(""-fx-background-image: url('http://1.bp.blogspot.com/_wV5JMD1OISg/TDYTYxuxR4I/AAAAAAAAvSo/a0zT8nwPV8U/s400/louis-vuitton-nice-beautiful.jpg');"");         stack.getChildren().add(                 canvas         );          // places a resizable padded frame around the canvas.         StackPane frame = new StackPane();         frame.setPadding(new Insets(20));         frame.getChildren().add(stack);          stage.setScene(new Scene(frame, Color.BURLYWOOD));         stage.show();     }      public static void main(String[] args) { launch(RotatedImageInCanvas.class); } }"
"import java.awt.Color; import java.awt.Desktop; import java.awt.Graphics2D; import java.awt.RenderingHints; import java.awt.image.BufferedImage; import java.io.File; import java.io.FileOutputStream; import java.io.IOException;  import javax.imageio.ImageIO; import javax.swing.JLabel; import javax.swing.SwingUtilities;  class TestPaint {      protected void initUI() {         StringBuilder sb = new StringBuilder(""&lt;html&gt;"");         sb.append(""&lt;table&gt;"");         for (int i = 0; i &lt; 5; i++) {             sb.append(""&lt;tr&gt;"");             for (int j = 0; j &lt; 5; j++) {                 sb.append(""&lt;td&gt;"");                 sb.append(""Cell "").append(i + 1).append(' ').append(j + 1);                 sb.append(""&lt;/td&gt;"");             }             sb.append(""&lt;/tr&gt;"");         }         sb.append(""&lt;/table&gt;"");         JLabel label = new JLabel(sb.toString());         label.setSize(label.getPreferredSize());         BufferedImage image = new BufferedImage(label.getWidth(), label.getHeight(), BufferedImage.TYPE_INT_ARGB);         Graphics2D g2d = (Graphics2D) image.getGraphics();         g2d.setColor(Color.WHITE);         g2d.setRenderingHint(RenderingHints.KEY_TEXT_ANTIALIASING, RenderingHints.VALUE_TEXT_ANTIALIAS_ON);         label.paint(g2d);         g2d.dispose();         File file = new File(""/tmp/test.png"");         if (!file.getParentFile().exists()) {             file.getParentFile().mkdirs();         }         FileOutputStream baos = null;         try {             baos = new FileOutputStream(file);             ImageIO.write(image, ""png"", baos);           Desktop.getDesktop().open(file);         } catch (IOException e) {             e.printStackTrace();         } finally {             if (baos != null) {                 try {                     baos.close();                 } catch (IOException e) {                     e.printStackTrace();                 }             }         }      }      public static void main(String[] args) {         SwingUtilities.invokeLater(new Runnable() {             @Override             public void run() {                 new TestPaint().initUI();             }          });     } }"
"package cmyk;  import java.awt.color.ColorSpace; import java.awt.image.BufferedImage; import java.awt.image.ColorConvertOp; import java.io.File; import java.io.IOException;  import javax.imageio.ImageIO;  import org.apache.commons.lang.StringUtils;  public class Main {      /**      * Creates new RGB images from all the CMYK images passed      * in on the command line.      * The new filename generated is, for example ""GIF_original_filename.gif"".      *      */     public static void main(String[] args)     {         for (int ii = 0; ii &lt; args.length; ii++)         {             String filename = args[ii];             boolean cmyk = isCMYK(filename);             System.out.println(cmyk + "": "" + filename);             if (cmyk)             {                 try                 {                     String rgbFile = cmyk2rgb(filename);                     System.out.println(isCMYK(rgbFile) + "": "" + rgbFile);                 }                 catch (IOException e)                 {                     System.out.println(e.getMessage());                 }             }         }     }      /**      * If 'filename' is a CMYK file, then convert the image into RGB,      * store it into a JPEG file, and return the new filename.      *      * @param filename      */     private static String cmyk2rgb(String filename) throws IOException     {         // Change this format into any ImageIO supported format.         String format = ""gif"";         File imageFile = new File(filename);         String rgbFilename = filename;         BufferedImage image = ImageIO.read(imageFile);         if (image != null)         {             int colorSpaceType = image.getColorModel().getColorSpace().getType();             if (colorSpaceType == ColorSpace.TYPE_CMYK)             {                 BufferedImage rgbImage =                     new BufferedImage(                         image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);                 ColorConvertOp op = new ColorConvertOp(null);                 op.filter(image, rgbImage);                  rgbFilename = changeExtension(imageFile.getName(), format);                 rgbFilename = new File(imageFile.getParent(), format + ""_"" + rgbFilename).getPath();                 ImageIO.write(rgbImage, format, new File(rgbFilename));             }         }         return rgbFilename;     }      /**      * Change the extension of 'filename' to 'newExtension'.      *      * @param filename      * @param newExtension      * @return filename with new extension      */     private static String changeExtension(String filename, String newExtension)     {         String result = filename;         if (filename != null &amp;&amp; newExtension != null &amp;&amp; newExtension.length() != 0);         {             int dot = filename.lastIndexOf('.');             if (dot != -1)             {                 result = filename.substring(0, dot) + '.' + newExtension;             }         }         return result;     }      private static boolean isCMYK(String filename)     {         boolean result = false;         BufferedImage img = null;         try         {             img = ImageIO.read(new File(filename));         }         catch (IOException e)         {             System.out.println(e.getMessage() + "": "" + filename);         }         if (img != null)         {             int colorSpaceType = img.getColorModel().getColorSpace().getType();             result = colorSpaceType == ColorSpace.TYPE_CMYK;         }          return result;     } }"
"import java.awt.*; import javax.swing.*; import java.io.*; import javax.imageio.*;  public class MyApplication extends javax.swing.JFrame {  /** Creates new form MyApplication */     Image backgroundImage = Toolkit.getDefaultToolkit().getImage(""mong.jpg"");      public MyApplication() throws IOException     {          this.setContentPane(new JPanel()         {              @Override             public void paintComponent(Graphics g)             {                 super.paintComponent(g);                 g.drawImage(backgroundImage, 0, 0, null);             }         });          pack();         setVisible(true);     }       public static void main(String[] args)         throws Exception     {         new MyApplication();     } }"
"import org.eclipse.swt.SWT; import org.eclipse.swt.events.KeyEvent; import org.eclipse.swt.events.KeyListener; import org.eclipse.swt.graphics.Color; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Shell;  public class ControlF  {     public static void main(String[] args)      {          Display display = new Display ();          final Shell shell = new Shell (display);         final Color green = display.getSystemColor (SWT.COLOR_GREEN);         final Color orig = shell.getBackground();          display.addFilter(SWT.KeyDown, new Listener() {              public void handleEvent(Event e) {                 if(((e.stateMask &amp; SWT.CTRL) == SWT.CTRL) &amp;&amp; (e.keyCode == 'f'))                 {                     System.out.println(""From Display I am the Key down !!"" + e.keyCode);                 }             }         });          shell.addKeyListener(new KeyListener() {             public void keyReleased(KeyEvent e) {                 if(((e.stateMask &amp; SWT.CTRL) == SWT.CTRL) &amp;&amp; (e.keyCode == 'f'))                 {                     shell.setBackground(orig);                     System.out.println(""Key up !!"");                 }             }             public void keyPressed(KeyEvent e) {                 if(((e.stateMask &amp; SWT.CTRL) == SWT.CTRL) &amp;&amp; (e.keyCode == 'f'))                 {                     shell.setBackground(green);                     System.out.println(""Key down !!"");                 }             }         });          shell.setSize (200, 200);         shell.open ();         while (!shell.isDisposed()) {             if (!display.readAndDispatch ()) display.sleep ();         }         display.dispose ();      } }"
"import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTable;  import java.awt.Color; import java.awt.Graphics; import java.awt.Dimension; import java.awt.BorderLayout;  public class Sandbox extends JFrame {     class MyPanel extends JPanel     {         public void paintComponent(Graphics g)         {             g.setColor(Color.RED);             g.fillRect(0, 0, this.getWidth(), this.getHeight());         }     }      public static void main(String[] args)     {         Sandbox s = new Sandbox();     }      public Sandbox()     {         this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         this.setLayout(new BorderLayout());          MyPanel panelRight = new MyPanel();         panelRight.setPreferredSize(new Dimension(150, 300));         this.getContentPane().add(panelRight, BorderLayout.EAST);          JPanel panelCenter = new JPanel();         this.getContentPane().add(panelCenter, BorderLayout.CENTER);          JScrollPane scrollPane = new JScrollPane(new JTable());         panelCenter.add(scrollPane);          JPanel panelBottom = new JPanel();         this.getContentPane().add(panelBottom, BorderLayout.SOUTH);          this.setSize(400, 400);         this.setVisible(true);     } }"
"import java.awt.*; import java.awt.event.*; import javax.swing.*; import javax.swing.border.*;  public class OverlayPanel extends JPanel {     private static int ctr = 1;      public OverlayPanel(String name)     {         setName( name );         add( new JLabel(""Label "" + ctr++) );     }      @Override     protected void paintComponent(Graphics g)     {         System.out.println(""Painting: "" + getName());         super.paintComponent(g);     }      private static void createAndShowUI()     {         JPanel panel = new JPanel();         panel.setLayout( new OverlayLayout(panel) );          panel.add( new OverlayPanel(""first"") );         panel.add( new OverlayPanel(""second"") );          JPanel third = new OverlayPanel(""third"");         third.setVisible(false);         panel.add(third);          JFrame frame = new JFrame(""OverlayPanel"");         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         frame.add( panel );         frame.pack();         frame.setLocationByPlatform( true );         frame.setVisible( true );     }      public static void main(String[] args)     {         EventQueue.invokeLater(new Runnable()         {             public void run()             {                 createAndShowUI();             }         });     } }"
"import java.awt.BasicStroke; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.Rectangle; import java.awt.RenderingHints; import java.awt.geom.AffineTransform; import java.awt.geom.Ellipse2D; import javax.swing.JFrame; import javax.swing.JPanel;  public class Test {     /**      * @param args      */     public static void main(String[] args) {         JPanel circlePanel = new JPanel() {             @Override             public void paint(Graphics g) {                  Graphics2D g2d = (Graphics2D) g;                 g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);                  g2d.setStroke(new BasicStroke(1));                 //g2d.drawOval(0, 0, 200, 200);                 g2d.draw(new Ellipse2D.Double(0, 0, 200, 200));                  AffineTransform old = g2d.getTransform();                  g2d.scale(10000, 10000);                 g2d.setStroke(new BasicStroke(0.001f));                 g2d.draw(new Ellipse2D.Double(0, 0, 0.025, 0.025));                  g2d.setTransform(old);              }         };          JFrame frame = new JFrame();         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);          frame.setLayout(null);         circlePanel.setBounds(new Rectangle(0, 0, 300, 300));         frame.add(circlePanel);          frame.setBounds(0, 0, 350, 300);          //frame.pack();         frame.setVisible(true);     } }"
"import org.eclipse.swt.SWT; import org.eclipse.swt.events.ShellEvent; import org.eclipse.swt.events.ShellListener; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Menu; import org.eclipse.swt.widgets.Shell;  public class MenuTest {      public static void main (String [] args)      {         Display display = new Display ();         final Shell shell = new Shell (display);          GridLayout layout = new GridLayout();         layout.marginHeight = 0;         layout.marginWidth = 0;         layout.horizontalSpacing = 0;         layout.verticalSpacing = 0;         layout.numColumns = 1;         shell.setLayout(layout);         shell.setLayoutData(new GridData(SWT.FILL, SWT.FILL, true,true));         final Menu bar = new Menu (shell, SWT.BAR);         shell.setMenuBar (bar);          shell.addShellListener(new ShellListener() {              public void shellIconified(ShellEvent e) {             }             public void shellDeiconified(ShellEvent e) {             }             public void shellDeactivated(ShellEvent e) {             }             public void shellClosed(ShellEvent e) {                 System.out.println(""Client Area: "" + shell.getClientArea());             }             public void shellActivated(ShellEvent e) {                 int frameX = shell.getSize().x - shell.getClientArea().width;                 int frameY = shell.getSize().y - shell.getClientArea().height;                 shell.setSize(300 + frameX, 250 + frameY);             }         });               shell.open ();         while (!shell.isDisposed()) {             if (!display.readAndDispatch ()) display.sleep ();         }         display.dispose ();     } }"
"import javafx.application.Application; import javafx.scene.*; import javafx.scene.layout.Pane; import javafx.scene.paint.Color; import javafx.scene.shape.Line; import javafx.scene.shape.LineBuilder; import javafx.scene.shape.StrokeType; import javafx.scene.text.Text; import javafx.stage.Stage;  /** http://stackoverflow.com/questions/11886230/how-to-draw-a-crisp-opaque-hairline-in-javafx-2-2 */ public class LineWidths extends Application {   public static void main(String[] args) { launch(args); }    @Override public void start(Stage stage) {     Line fuzzyline = LineBuilder.create()         .startX(5).startY(50)         .endX(90).endY(50)         .stroke(Color.BLACK).strokeWidth(1)       .build();     Line hairline = LineBuilder.create()         .startX(4.5).startY(99.5)         .endX(89.5).endY(99.5)         .stroke(Color.BLACK).strokeWidth(1)       .build();     Line fatline = LineBuilder.create()         .startX(5).startY(150)         .endX(90).endY(150)         .stroke(Color.BLACK).strokeWidth(1).strokeType(StrokeType.OUTSIDE)       .build();     Pane snappedPane = new Pane();     Line insideline = LineBuilder.create()         .startX(5).startY(25)         .endX(90).endY(25)         .stroke(Color.BLACK).strokeWidth(1)       .build();     snappedPane.setSnapToPixel(true);     snappedPane.getChildren().add(insideline);     snappedPane.setPrefSize(100, 50);     snappedPane.relocate(-0.5, 174.5);      stage.setScene(       new Scene(         new Group(           fuzzyline, hairline, fatline, snappedPane,           new Text(10, 40, ""fuzzyline""),             new Text(10, 90, ""hairline""),             new Text(10, 140, ""fatline""),             new Text(10, 190, ""snappedPane"")         ), 100, 250       )     );     stage.show();   } }"
"import java.awt.Color; import java.awt.Dimension; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.Polygon; import java.awt.Rectangle; import java.awt.Shape; import java.awt.geom.Ellipse2D; import java.io.IOException;  import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JTabbedPane; import javax.swing.SwingUtilities;  /* This program create a graphics component that draws a polygon   */ public class SelectShape extends JPanel {      // Constants     private static final int[] x = { 20, 40, 50, 65, 80, 95 }; // Co-ords for a polygon     private static final int[] y = { 60, 105, 105, 110, 95, 95 };      private static final Polygon POLYGON = new Polygon(x, y, Math.min(x.length, y.length));     private static final Ellipse2D CIRCLE = new Ellipse2D.Double(100, 40, 45, 45);      // Class variables     private final Shape shape;     private Dimension preferredSize;      public SelectShape(Shape shape) {         this.shape = shape;         Rectangle bounds = shape.getBounds();         this.preferredSize = new Dimension(bounds.x + bounds.width, bounds.y + bounds.height);     }      @Override     public Dimension getPreferredSize() {         return preferredSize;     }      @Override     public void paintComponent(Graphics g) {         super.paintComponent(g);         Graphics2D g2 = (Graphics2D) g;         g.setColor(Color.BLUE);         g2.draw(shape);         g2.fill(shape);     }      public static void main(String[] args) throws IOException {         SwingUtilities.invokeLater(new Runnable() {             @Override             public void run() {                 JFrame mainFrame = new JFrame(""Program"");                 mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);                 SelectShape polygon = new SelectShape(POLYGON);                 SelectShape circle = new SelectShape(CIRCLE);                 // Create a tabbed pane                 JTabbedPane tabbedPane = new JTabbedPane();                 tabbedPane.addTab(""Polygon"", polygon);                 tabbedPane.addTab(""Circle"", circle);                 mainFrame.add(tabbedPane);                 mainFrame.pack();                 mainFrame.setVisible(true);             }         });      } }"
"package org.eclipse.jface.snippets;  import org.eclipse.swt.SWT; import org.eclipse.swt.events.SelectionAdapter; import org.eclipse.swt.events.SelectionEvent; import org.eclipse.swt.graphics.Rectangle; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Shell; import org.eclipse.swt.widgets.Text;  public class Bla {     public static void main(String[] args) {         Display display = new Display();         Shell shell = new Shell(display);          final Text t = new Text(shell,SWT.BORDER);         t.setBounds(new Rectangle(10,10,200,30));         System.err.println(t.toDisplay(1, 1));          Button b = new Button(shell,SWT.PUSH);         b.setText(""Show size"");         b.setBounds(new Rectangle(220,10,100,20));         b.addSelectionListener(new SelectionAdapter() {              public void widgetSelected(SelectionEvent e) {                 System.err.println(t.toDisplay(1, 1));              }          });          shell.open();          while (!shell.isDisposed()) {             if (!display.readAndDispatch())                 display.sleep();         }          display.dispose();     } }"
"import org.eclipse.swt.SWT; import org.eclipse.swt.layout.GridData; import org.eclipse.swt.layout.GridLayout; import org.eclipse.swt.widgets.Button; import org.eclipse.swt.widgets.Display; import org.eclipse.swt.widgets.Event; import org.eclipse.swt.widgets.Label; import org.eclipse.swt.widgets.Listener; import org.eclipse.swt.widgets.Shell;  public class HideLabel  {     public static void main(String[] args)     {         Display display = new Display();         final Shell shell = new Shell(display);         shell.setLayout(new GridLayout(1, false));         shell.setText(""Hide Label"");          Label label = new Label(shell, SWT.NONE);         label.setText(""Label 1"");          final Label bHidden = new Label(shell, SWT.NONE);         bHidden.setText(""Label 2"");         GridData data = new GridData();         data.exclude = false;         data.horizontalAlignment = SWT.FILL;         bHidden.setLayoutData(data);          label = new Label(shell, SWT.NONE);         label.setText(""Label 3"");          Button button = new Button(shell, SWT.CHECK);         button.setText(""hide"");         button.addListener(SWT.Selection, new Listener() {             public void handleEvent(Event e) {                 Button b = (Button) e.widget;                 GridData data = (GridData) bHidden.getLayoutData();                 data.exclude = b.getSelection();                 bHidden.setVisible(!data.exclude);                 shell.layout(false);             }         });         shell.setSize(200, 200);         shell.open();         while (!shell.isDisposed()) {             if (!display.readAndDispatch())                 display.sleep();         }         display.dispose();     } }"
"import java.awt.AlphaComposite; import java.awt.Color; import java.awt.Component; import java.awt.Dimension; import java.awt.Graphics; import java.awt.Graphics2D;  import javax.swing.JFrame; import javax.swing.JPanel;  public class ClickThrough {      public static void main(String[] args) {         JFrame.setDefaultLookAndFeelDecorated(true);         JFrame f = new JFrame(""Test"");         f.setAlwaysOnTop(true);         Component c = new JPanel() {             @Override             public void paintComponent(Graphics g) {                 Graphics2D g2 = (Graphics2D)g.create();                 g2.setColor(Color.gray);                 int w = getWidth();                 int h = getHeight();                 g2.fillRect(0, 0, w,h);                 g2.setComposite(AlphaComposite.Clear);                 g2.fillRect(w/4, h/4, w-2*(w/4), h-2*(h/4));             }         };         c.setPreferredSize(new Dimension(300, 300));         f.getContentPane().add(c);         f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         f.pack();         f.setVisible(true);         com.sun.awt.AWTUtilities.setWindowOpaque(f,false);     }  }"
"import javafx.application.Application; import javafx.scene.Group; import javafx.scene.Scene; import javafx.scene.paint.Color; import javafx.scene.shape.Circle; import javafx.stage.Stage;  /**  *  * @author jeffreyguenther  */ public class ListTest extends Application{      @Override     public void start(Stage stage) throws Exception {         Circle c = new Circle();         c.setRadius(100);         c.setCenterX(100);         c.setCenterY(100);         c.setFill(Color.AQUA);         c.setStroke(Color.BLACK);         c.setStrokeWidth(3);          c.setOnMousePressed((e) -&gt;{              switch(e.getClickCount()){                 case 1:                     System.out.println(""One click"");                     break;                 case 2:                     System.out.println(""Two clicks"");                     break;                 case 3:                     System.out.println(""Three clicks"");                     break;             }          });          stage.setScene(new Scene(new Group(c)));         stage.show();     }      public static void main(String[] args) {         launch(args);     } }"
"import java.awt.*; import java.awt.event.*; import java.util.*; import javax.swing.*;  public class Sketch extends JComponent {     private Vector&lt;JComponent&gt; controls = new Vector&lt;JComponent&gt;();      public void addControl(JComponent c)     {         c.setSize(100, 50);         int location = controls.size() * 50;         c.setLocation(location, location);         controls.add(c);         repaint();     }      @Override     public void paintComponent(Graphics g)     {         super.paintComponent(g);          for(int i=controls.size()-1; i&gt;=0; i--)         {             JComponent c = controls.get(i);             Point location = c.getLocation();             g.translate(location.x, location.y);             c.paint(g);             g.translate(-location.x, -location.y);         }     }      private static void createAndShowUI()     {         Sketch sketch = new Sketch();         sketch.addControl( new JButton(""button"") );         sketch.addControl( new JTextField(10) );         sketch.addControl( new JCheckBox(""Checkbox"") );          JFrame frame = new JFrame(""Sketch"");         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         frame.add( sketch );         frame.setSize(400, 400);         frame.setLocationByPlatform( true );         frame.setVisible( true );     }      public static void main(String[] args)     {         EventQueue.invokeLater(new Runnable()         {             public void run()             {                 createAndShowUI();             }         });     } }"
"import java.awt.Color; import java.awt.Dimension; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.Point; import java.awt.event.MouseEvent; import java.awt.event.MouseMotionAdapter; import java.awt.geom.Rectangle2D;  import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.SwingUtilities;  public class PaintedButton extends JPanel {     private static final Color HOVER_COLOR = Color.BLUE;     private static final Color NON_HOVER_COLOR = Color.GREEN;     private static final Rectangle2D RECTANGLE = new Rectangle2D.Double(50, 50,             200, 100);      private Color color = NON_HOVER_COLOR;      public PaintedButton() {         addMouseMotionListener(new MouseMotionAdapter() {             public void mouseMoved(MouseEvent e) {                 Point p = e.getPoint();                 if (RECTANGLE.contains(p)) {                     color = HOVER_COLOR;                 } else {                     color = NON_HOVER_COLOR;                 }                 repaint();             }         });     }      @Override     protected void paintComponent(Graphics g) {         super.paintComponent(g);         Graphics2D g2 = (Graphics2D) g;         g2.setPaint(color);         g2.fill(RECTANGLE);      }      @Override     public Dimension getPreferredSize() {         return new Dimension(300, 200);     }      public static void main(String[] args) {         SwingUtilities.invokeLater(new Runnable() {             public void run() {                 JFrame frame = new JFrame();                 frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);                 frame.add(new PaintedButton());                 frame.pack();                 frame.setLocationRelativeTo(null);                 frame.setVisible(true);             }         });     } }"
"import java.awt.Color; import java.awt.Font; import java.awt.FontMetrics; import java.awt.Graphics2D; import java.awt.RenderingHints; import java.awt.image.BufferedImage; import java.io.File; import java.io.IOException; import javax.imageio.ImageIO;  public class TextToGraphics {      public static void main(String[] args) {         String text = ""Hello"";          /*            Because font metrics is based on a graphics context, we need to create            a small, temporary image so we can ascertain the width and height            of the final image          */         BufferedImage img = new BufferedImage(1, 1, BufferedImage.TYPE_INT_ARGB);         Graphics2D g2d = img.createGraphics();         Font font = new Font(""Arial"", Font.PLAIN, 48);         g2d.setFont(font);         FontMetrics fm = g2d.getFontMetrics();         int width = fm.stringWidth(text);         int height = fm.getHeight();         g2d.dispose();          img = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);         g2d = img.createGraphics();         g2d.setRenderingHint(RenderingHints.KEY_ALPHA_INTERPOLATION, RenderingHints.VALUE_ALPHA_INTERPOLATION_QUALITY);         g2d.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);         g2d.setRenderingHint(RenderingHints.KEY_COLOR_RENDERING, RenderingHints.VALUE_COLOR_RENDER_QUALITY);         g2d.setRenderingHint(RenderingHints.KEY_DITHERING, RenderingHints.VALUE_DITHER_ENABLE);         g2d.setRenderingHint(RenderingHints.KEY_FRACTIONALMETRICS, RenderingHints.VALUE_FRACTIONALMETRICS_ON);         g2d.setRenderingHint(RenderingHints.KEY_INTERPOLATION, RenderingHints.VALUE_INTERPOLATION_BILINEAR);         g2d.setRenderingHint(RenderingHints.KEY_RENDERING, RenderingHints.VALUE_RENDER_QUALITY);         g2d.setRenderingHint(RenderingHints.KEY_STROKE_CONTROL, RenderingHints.VALUE_STROKE_PURE);         g2d.setFont(font);         fm = g2d.getFontMetrics();         g2d.setColor(Color.BLACK);         g2d.drawString(text, 0, fm.getAscent());         g2d.dispose();         try {             ImageIO.write(img, ""png"", new File(""Text.png""));         } catch (IOException ex) {             ex.printStackTrace();         }      }  }"
