code
"import org.apache.poi.xwpf.usermodel.ParagraphAlignment; import org.apache.poi.xwpf.usermodel.XWPFDocument; import org.apache.poi.xwpf.usermodel.XWPFParagraph; import org.apache.poi.xwpf.usermodel.XWPFRun; import org.apache.poi.xwpf.usermodel.VerticalAlign;  import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException;  public class ApachePOI {         public static void main(String[] args) {      XWPFDocument document = new XWPFDocument();      XWPFParagraph paragraphOne = document.createParagraph();      paragraphOne.setAlignment(ParagraphAlignment.CENTER);      XWPFRun paragraphOneRunOne = paragraphOne.createRun();     paragraphOneRunOne.setFontSize(25);     paragraphOneRunOne.setBold(true);     paragraphOneRunOne.setText(""Oxygene - O"");      XWPFRun paragraphOneRunTwo = paragraphOne.createRun();     paragraphOneRunTwo.setFontSize(17);     paragraphOneRunTwo.setBold(true);     paragraphOneRunTwo.setSubscript(VerticalAlign.SUBSCRIPT);     paragraphOneRunTwo.setText(""2"");      try {         FileOutputStream fos = new FileOutputStream(""C://test.docx"");         document.write(fos);         fos.close();         } catch (FileNotFoundException e) {             e.printStackTrace();         } catch (IOException e) {             e.printStackTrace();         }     } }"
"import java.io.File;  import javax.xml.bind.JAXBException;  import org.apache.log4j.Logger; import org.docx4j.openpackaging.packages.PresentationMLPackage; import org.docx4j.openpackaging.parts.PartName; import org.docx4j.openpackaging.parts.PresentationML.MainPresentationPart; import org.docx4j.openpackaging.parts.PresentationML.SlideLayoutPart; import org.docx4j.openpackaging.parts.PresentationML.SlidePart; import org.docx4j.openpackaging.parts.WordprocessingML.BinaryPartAbstractImage; import org.docx4j.relationships.Relationship; import org.pptx4j.jaxb.Context; import org.pptx4j.pml.Pic;   public class InsertPicture  {      protected static Logger log = Logger.getLogger(InsertPicture.class);      public static void main(String[] args) throws Exception {          // Where will we save our new .pptx?         String outputfilepath = System.getProperty(""user.dir"") + ""/pptx-picture.pptx"";          // Create skeletal package, including a MainPresentationPart and a SlideLayoutPart         PresentationMLPackage presentationMLPackage = PresentationMLPackage.createPackage();           // Need references to these parts to create a slide         // Please note that these parts *already exist* - they are         // created by createPackage() above.  See that method         // for instruction on how to create and add a part.         MainPresentationPart pp = (MainPresentationPart)presentationMLPackage.getParts().getParts().get(                 new PartName(""/ppt/presentation.xml""));              SlideLayoutPart layoutPart = (SlideLayoutPart)presentationMLPackage.getParts().getParts().get(                 new PartName(""/ppt/slideLayouts/slideLayout1.xml""));          // OK, now we can create a slide         SlidePart slidePart = presentationMLPackage.createSlidePart(pp, layoutPart,                  new PartName(""/ppt/slides/slide1.xml""));          // Add image part         File file = new File(System.getProperty(""user.dir"") + ""/src/test/resources/images/greentick.png"" );         BinaryPartAbstractImage imagePart              = BinaryPartAbstractImage.createImagePart(presentationMLPackage, slidePart, file);           // Add p:pic to slide         slidePart.getJaxbElement().getCSld().getSpTree().getSpOrGrpSpOrGraphicFrame().add(                 createPicture(imagePart.getSourceRelationship().getId()));           // Do it again on another slide         SlidePart slidePart2 = presentationMLPackage.createSlidePart(pp, layoutPart,                  new PartName(""/ppt/slides/slide2.xml""));         Relationship rel = slidePart2.addTargetPart(imagePart);          slidePart2.getJaxbElement().getCSld().getSpTree().getSpOrGrpSpOrGraphicFrame().add(                 createPicture(rel.getId()));          // All done: save it         presentationMLPackage.save(new java.io.File(outputfilepath));          System.out.println(""\n\n done .. saved "" + outputfilepath);      }         private static Object createPicture(String relId) throws JAXBException {          // Create p:pic                  java.util.HashMap&lt;String, String&gt;mappings = new java.util.HashMap&lt;String, String&gt;();          mappings.put(""id1"", ""4"");         mappings.put(""name"", ""Picture 3"");         mappings.put(""descr"", ""greentick.png"");         mappings.put(""rEmbedId"", relId );         mappings.put(""offx"", Long.toString(4214812));         mappings.put(""offy"", Long.toString(3071812));         mappings.put(""extcx"", Long.toString(714375));         mappings.put(""extcy"", Long.toString(714375));          return org.docx4j.XmlUtils.unmarshallFromTemplate(SAMPLE_PICTURE,                  mappings, Context.jcPML, Pic.class ) ;          }       private static String SAMPLE_PICTURE =                     ""&lt;p:pic xmlns:a=\""http://schemas.openxmlformats.org/drawingml/2006/main\"" xmlns:r=\""http://schemas.openxmlformats.org/officeDocument/2006/relationships\"" xmlns:p=\""http://schemas.openxmlformats.org/presentationml/2006/main\""&gt; ""             + ""&lt;p:nvPicPr&gt;""               + ""&lt;p:cNvPr id=\""${id1}\"" name=\""${name}\"" descr=\""${descr}\""/&gt;""               + ""&lt;p:cNvPicPr&gt;""                 + ""&lt;a:picLocks noChangeAspect=\""1\""/&gt;""               + ""&lt;/p:cNvPicPr&gt;""               + ""&lt;p:nvPr/&gt;""             + ""&lt;/p:nvPicPr&gt;""             + ""&lt;p:blipFill&gt;""               + ""&lt;a:blip r:embed=\""${rEmbedId}\"" cstate=\""print\""/&gt;""               + ""&lt;a:stretch&gt;""                 + ""&lt;a:fillRect/&gt;""               + ""&lt;/a:stretch&gt;""             + ""&lt;/p:blipFill&gt;""             + ""&lt;p:spPr&gt;""               + ""&lt;a:xfrm&gt;""                 + ""&lt;a:off x=\""${offx}\"" y=\""${offy}\""/&gt;""                 + ""&lt;a:ext cx=\""${extcx}\"" cy=\""${extcy}\""/&gt;""               + ""&lt;/a:xfrm&gt;""               + ""&lt;a:prstGeom prst=\""rect\""&gt;""                 + ""&lt;a:avLst/&gt;""               + ""&lt;/a:prstGeom&gt;""             + ""&lt;/p:spPr&gt;""           + ""&lt;/p:pic&gt;"";   }"
"import java.io.File; import org.apache.avro.Schema; import org.apache.avro.file.DataFileWriter; import org.apache.avro.file.DataFileReader; import org.apache.avro.file.CodecFactory; import org.apache.avro.io.DatumWriter; import org.apache.avro.io.DatumReader; import org.apache.avro.reflect.ReflectData; import org.apache.avro.reflect.ReflectDatumWriter; import org.apache.avro.reflect.ReflectDatumReader; import org.apache.avro.reflect.Nullable;  public class Reflect {    public static class Packet {     int cost;     @Nullable TimeStamp stamp;     public Packet() {}                        // required to read     public Packet(int cost, TimeStamp stamp){       this.cost = cost;       this.stamp = stamp;     }   }    public static class TimeStamp {     int hour = 0;     int second = 0;     public TimeStamp() {}                     // required to read     public TimeStamp(int hour, int second){       this.hour = hour;       this.second = second;     }   }    public static void main(String[] args) throws Exception {     // one argument: a file name     File file = new File(args[0]);      // get the reflected schema for packets     Schema schema = ReflectData.get().getSchema(Packet.class);      // create a file of packets     DatumWriter&lt;Packet&gt; writer = new ReflectDatumWriter&lt;Packet&gt;(Packet.class);     DataFileWriter&lt;Packet&gt; out = new DataFileWriter&lt;Packet&gt;(writer)       .setCodec(CodecFactory.deflateCodec(9))       .create(schema, file);      // write 100 packets to the file, odds with null timestamp     for (int i = 0; i &lt; 100; i++) {       out.append(new Packet(i, (i%2==0) ? new TimeStamp(12, i) : null));     }      // close the output file     out.close();      // open a file of packets     DatumReader&lt;Packet&gt; reader = new ReflectDatumReader&lt;Packet&gt;(Packet.class);     DataFileReader&lt;Packet&gt; in = new DataFileReader&lt;Packet&gt;(file, reader);      // read 100 packets from the file &amp; print them as JSON     for (Packet packet : in) {       System.out.println(ReflectData.get().toString(packet));     }      // close the input file     in.close();   }  }"
"import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import org.apache.poi.hwpf.HWPFDocument; import org.apache.poi.hwpf.usermodel.CharacterRun; import org.apache.poi.hwpf.usermodel.Paragraph; import org.apache.poi.hwpf.usermodel.Range; import org.apache.poi.hwpf.usermodel.Section; import org.apache.poi.poifs.filesystem.POIFSFileSystem;  public class HWPFTest {     public static void main(String[] args){         String filePath = ""F:\\Sample.doc"";         POIFSFileSystem fs = null;                 try {                         fs = new POIFSFileSystem(new FileInputStream(filePath));                         HWPFDocument doc = new HWPFDocument(fs);             doc = replaceText(doc, ""$VAR"", ""MyValue1"");             saveWord(filePath, doc);         }         catch(FileNotFoundException e){             e.printStackTrace();         }         catch(IOException e){             e.printStackTrace();         }     }      private static HWPFDocument replaceText(HWPFDocument doc, String findText, String replaceText){         Range r1 = doc.getRange();           for (int i = 0; i &lt; r1.numSections(); ++i ) {              Section s = r1.getSection(i);              for (int x = 0; x &lt; s.numParagraphs(); x++) {                  Paragraph p = s.getParagraph(x);                  for (int z = 0; z &lt; p.numCharacterRuns(); z++) {                      CharacterRun run = p.getCharacterRun(z);                      String text = run.text();                     if(text.contains(findText)) {                         run.replaceText(findText, replaceText);                     }                  }             }         }          return doc;     }      private static void saveWord(String filePath, HWPFDocument doc) throws FileNotFoundException, IOException{         FileOutputStream out = null;         try{             out = new FileOutputStream(filePath);             doc.write(out);         }         finally{             out.close();         }     } }"
"import java.net.URI; import java.net.URL; import java.util.ArrayList; import java.util.List;  import org.apache.http.HttpHost; import org.apache.http.HttpResponse; import org.apache.http.NameValuePair; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.utils.URIUtils; import org.apache.http.client.utils.URLEncodedUtils; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.conn.tsccm.ThreadSafeClientConnManager; import org.apache.http.message.BasicNameValuePair; import org.apache.http.util.EntityUtils;  public class GooglePlacesRequest {      public static void main(String[] args) throws Exception {          // Web API related         String apiKey = ""YOUR_API_KEY_HERE"";         // search params         String location = ""51.527277,-0.128625"";// lat,lon         String types = ""food"";         String name = ""pret"";          List&lt;NameValuePair&gt; parameters = new ArrayList&lt;NameValuePair&gt;();         parameters.add(new BasicNameValuePair(""location"", location));         parameters.add(new BasicNameValuePair(""radius"", ""500""));         parameters.add(new BasicNameValuePair(""types"", types));         parameters.add(new BasicNameValuePair(""name"", name));         parameters.add(new BasicNameValuePair(""sensor"", ""false""));         parameters.add(new BasicNameValuePair(""key"", apiKey));          URL url = new URL(                 ""https://maps.googleapis.com/maps/api/place/search/json"");         URI finalURI = URIUtils.createURI(                 url.getProtocol(),                  url.getHost(),                 url.getPort(),                  url.getPath(),                 URLEncodedUtils.format(parameters, ""UTF-8""),                  null);          HttpGet get = new HttpGet(finalURI);         System.out.println(""using getRequestLine(): "" + get.getRequestLine());         System.out.println(""using getURI(): "" + get.getURI().toString());          DefaultHttpClient httpClient = new DefaultHttpClient(new ThreadSafeClientConnManager());         try {             HttpResponse response = httpClient.execute(get);             System.out.println(""response: ""                     + response.getStatusLine().toString());             System.out.println( ""Response content is:"" );             System.out.println( EntityUtils.toString( response.getEntity() ) );         } catch (Exception e) {             System.err.println(""HttpClient: An error occurred- "");             e.printStackTrace();         }      }  }"
"package com.rorlig; import java.io.IOException; import java.util.StringTokenizer; import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.IntWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.Reducer; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat;  public class WordCountJob {   public static class TokenizerMapper       extends Mapper&lt;Object, Text, Text, IntWritable&gt;{   private final static IntWritable one = new IntWritable(1);  private Text word = new Text();   public void map(Object key, Text value, Context context                 ) throws IOException, InterruptedException {   StringTokenizer itr = new StringTokenizer(value.toString());   while (itr.hasMoreTokens()) {     word.set(itr.nextToken());     context.write(word, one);    }  } }  public static class IntSumReducer     extends Reducer&lt;Text,IntWritable,Text,IntWritable&gt; { private IntWritable result = new IntWritable();  public void reduce(Text key, Iterable&lt;IntWritable&gt; values,                     Context context                    ) throws IOException, InterruptedException {   int sum = 0;   for (IntWritable val : values) {     sum += val.get();   }   result.set(sum);   context.write(key, result);   } }  public static void main(String[] args) throws Exception {  Configuration conf = new Configuration();  if (args.length != 3) {   System.err.println(""Usage: wordcount &lt;in&gt; &lt;out&gt; &lt;iterations&gt;"");   System.exit(2); } int iterations = new Integer(args[2]); Path inPath = new Path(args[0]); Path outPath =  null; for (int i = 0; i&lt;iterations; ++i){     outPath = new Path(args[1]+i);     Job job = new Job(conf, ""word count"");     job.setJarByClass(WordCountJob.class);     job.setMapperClass(TokenizerMapper.class);     job.setCombinerClass(IntSumReducer.class);     job.setReducerClass(IntSumReducer.class);     job.setOutputKeyClass(Text.class);     job.setOutputValueClass(IntWritable.class);     FileInputFormat.addInputPath(job, inPath);     FileOutputFormat.setOutputPath(job, outPath);     job.waitForCompletion(true);     inPath = outPath;    }  } }"
"import java.io.File; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.HttpVersion; import org.apache.http.client.HttpClient; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.mime.MultipartEntity; import org.apache.http.entity.mime.content.ContentBody; import org.apache.http.entity.mime.content.FileBody; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.params.CoreProtocolPNames; import org.apache.http.util.EntityUtils;   public class PostFile {   public static void main(String[] args) throws Exception {     HttpClient httpclient = new DefaultHttpClient();     httpclient.getParams().setParameter(CoreProtocolPNames.PROTOCOL_VERSION, HttpVersion.HTTP_1_1);      HttpPost httppost = new HttpPost(""http://localhost:9001/upload.php"");     File file = new File(""c:/TRASH/zaba_1.jpg"");      MultipartEntity mpEntity = new MultipartEntity();     ContentBody cbFile = new FileBody(file, ""image/jpeg"");     mpEntity.addPart(""userfile"", cbFile);       httppost.setEntity(mpEntity);     System.out.println(""executing request "" + httppost.getRequestLine());     HttpResponse response = httpclient.execute(httppost);     HttpEntity resEntity = response.getEntity();      System.out.println(response.getStatusLine());     if (resEntity != null) {       System.out.println(EntityUtils.toString(resEntity));     }     if (resEntity != null) {       resEntity.consumeContent();     }      httpclient.getConnectionManager().shutdown();   } }"
"import java.io.File;  import org.apache.commons.io.FileUtils; import org.apache.hadoop.conf.Configured; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import org.apache.hadoop.util.Tool; import org.apache.hadoop.util.ToolRunner;  public class MapReduceExample extends Configured implements Tool {      static class MyMapper extends Mapper&lt;LongWritable, Text, LongWritable, Text&gt; {         public MyMapper(){          }          protected void map(                 LongWritable key,                 Text value,                 org.apache.hadoop.mapreduce.Mapper&lt;LongWritable, Text, LongWritable, Text&gt;.Context context)                 throws java.io.IOException, InterruptedException {             context.getCounter(""mygroup"", ""jeff"").increment(1);             context.write(key, value);         };     }      @Override     public int run(String[] args) throws Exception {         Job job = new Job();         job.setMapperClass(MyMapper.class);         FileInputFormat.setInputPaths(job, new Path(args[0]));         FileOutputFormat.setOutputPath(job, new Path(args[1]));          job.waitForCompletion(true);         return 0;     }      public static void main(String[] args) throws Exception {         FileUtils.deleteDirectory(new File(""data/output""));         args = new String[] { ""data/input"", ""data/output"" };         ToolRunner.run(new MapReduceExample(), args);     } }"
"import java.util.ArrayList; import java.util.List; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.NameValuePair; import org.apache.http.client.entity.UrlEncodedFormEntity; import org.apache.http.client.methods.HttpGet; import org.apache.http.client.methods.HttpPost; import org.apache.http.cookie.Cookie; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.message.BasicNameValuePair; import org.apache.http.protocol.HTTP;  /**  * A example that demonstrates how HttpClient APIs can be used to perform  * form-based logon.  */ public class ClientFormLogin {      public static void main(String[] args) throws Exception {          DefaultHttpClient httpclient = new DefaultHttpClient();          HttpGet httpget = new HttpGet(&quot;https://portal.sun.com/portal/dt&quot;);          HttpResponse response = httpclient.execute(httpget);         HttpEntity entity = response.getEntity();          System.out.println(&quot;Login form get: &quot; + response.getStatusLine());         if (entity != null) {             entity.consumeContent();         }         System.out.println(&quot;Initial set of cookies:&quot;);         List&lt;Cookie&gt; cookies = httpclient.getCookieStore().getCookies();         if (cookies.isEmpty()) {             System.out.println(&quot;None&quot;);         } else {             for (int i = 0; i &lt; cookies.size(); i++) {                 System.out.println(&quot;- &quot; + cookies.get(i).toString());             }         }          HttpPost httpost = new HttpPost(&quot;https://portal.sun.com/amserver/UI/Login?&quot; +                 &quot;org=self_registered_users&amp;&quot; +                 &quot;goto=/portal/dt&amp;&quot; +                 &quot;gotoOnFail=/portal/dt?error=true&quot;);          List &lt;NameValuePair&gt; nvps = new ArrayList &lt;NameValuePair&gt;();         nvps.add(new BasicNameValuePair(&quot;IDToken1&quot;, &quot;username&quot;));         nvps.add(new BasicNameValuePair(&quot;IDToken2&quot;, &quot;password&quot;));          httpost.setEntity(new UrlEncodedFormEntity(nvps, HTTP.UTF_8));          response = httpclient.execute(httpost);         entity = response.getEntity();          System.out.println(&quot;Login form get: &quot; + response.getStatusLine());         if (entity != null) {             entity.consumeContent();         }          System.out.println(&quot;Post logon cookies:&quot;);         cookies = httpclient.getCookieStore().getCookies();         if (cookies.isEmpty()) {             System.out.println(&quot;None&quot;);         } else {             for (int i = 0; i &lt; cookies.size(); i++) {                 System.out.println(&quot;- &quot; + cookies.get(i).toString());             }         }          // When HttpClient instance is no longer needed,          // shut down the connection manager to ensure         // immediate deallocation of all system resources         httpclient.getConnectionManager().shutdown();             } }"
"import java.net.URI; import java.util.List;  import javax.ws.rs.core.MediaType; import javax.ws.rs.core.UriBuilder;  import com.sun.jersey.api.client.GenericType; import com.sun.jersey.api.client.WebResource; import com.sun.jersey.client.apache.ApacheHttpClient; import com.sun.jersey.client.apache.config.ApacheHttpClientConfig; import com.sun.jersey.client.apache.config.DefaultApacheHttpClientConfig;  public Client {      private final URI fServerURI;     private final ApacheHttpClient fClient;     private final MediaType fMediaType= MediaType.APPLICATION_XML_TYPE;      public Client() {             final String apiEndpoint= ""..."";             final DefaultApacheHttpClientConfig clientConfig;             fServerURI= UriBuilder.fromUri(apiEndpoint).build();             clientConfig= new DefaultApacheHttpClientConfig();             clientConfig.getProperties().put(ApacheHttpClientConfig.PROPERTY_HANDLE_COOKIES, true);             fClient= ApacheHttpClient.create(clientConfig);     }      private &lt;T&gt; T call(WebResource resource, RequestType requestType, Object requestEntity, GenericType&lt;T&gt; acceptType, String taskMessage) {             return acceptCall(resource, requestType, acceptType, requestEntity);     }      private &lt;T&gt; T acceptCall(WebResource resource, RequestType requestType, GenericType&lt;T&gt; acceptType, Object requestEntity) {            switch (requestType) {            case POST:                 return resource.accept(fMediaType).post(acceptType, requestEntity);            case PUT:                 return resource.accept(fMediaType).put(acceptType, requestEntity);            case DELETE:                 resource.accept(fMediaType).delete();                 return null;            default:                 return resource.accept(fMediaType).get(acceptType);     }      public MyArrayList sendArrayList(MyArrayList list) {            WebResource resource= createResource();            resource= resource.path(""webservice"").path(""sendarraylist"");            resource= resource.queryParam(""arraylist"", list);            return call(resource, RequestType.POST, null, new GenericType&lt;MyArrayList&gt;() {     }, ""Send my array list"");     }      public static void main(String ... args) {            Client c= new Client();            MyArrayList result= c.sendArrayList(new MyArrayList(/*whatevs goes inside*/));     }  }"
"import java.io.IOException; import java.util.List;  import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.FileSystem; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.SequenceFile; import org.apache.hadoop.io.Writable; import org.apache.hadoop.mapreduce.InputSplit; import org.apache.hadoop.mapreduce.JobContext; import org.apache.hadoop.mapreduce.RecordReader; import org.apache.hadoop.mapreduce.TaskAttemptContext; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.input.FileSplit; import org.apache.hadoop.mapreduce.lib.input.SequenceFileInputFormat;  public class SequenceFileOffsetInputFormat&lt;V extends Writable&gt; extends FileInputFormat&lt;PathOffsetWritable, V&gt; {      private static class SequenceFileOffsetRecordReader&lt;V extends Writable&gt; extends RecordReader&lt;PathOffsetWritable, V&gt; {          private SequenceFile.Reader in;         private long start;         private long end;         private boolean more = true;         private PathOffsetWritable key = null;         private Writable k = null;         private V value = null;         private Configuration conf;          @Override         public void initialize(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException {             FileSplit fileSplit = (FileSplit) split;             conf = context.getConfiguration();             Path path = fileSplit.getPath();             FileSystem fs = path.getFileSystem(conf);             this.in = new SequenceFile.Reader(fs, path, conf);             try {                 this.k = (Writable) in.getKeyClass().newInstance();                 this.value = (V) in.getValueClass().newInstance();             } catch (InstantiationException e) {                 throw new IOException(e);             } catch (IllegalAccessException e) {                 throw new IOException(e);             }             this.end = fileSplit.getStart() + fileSplit.getLength();              if (fileSplit.getStart() &gt; in.getPosition()) {                 in.sync(fileSplit.getStart());             }              this.start = in.getPosition();             more = start &lt; end;              key = new PathOffsetWritable(path, start);         }          @Override         public boolean nextKeyValue() throws IOException, InterruptedException {             if (!more) {                 return false;             }             long pos = in.getPosition();              more = in.next(k, value);             if (!more || (pos &gt;= end &amp;&amp; in.syncSeen())) {                 key = null;                 value = null;                 more = false;             } else {                 key.setOffset(pos);             }             return more;         }          @Override         public PathOffsetWritable getCurrentKey() {             return key;         }          @Override         public V getCurrentValue() {             return value;         }          @Override         public float getProgress() throws IOException, InterruptedException {             if (end == start) {                 return 0.0f;             } else {                 return Math.min(1.0f, (in.getPosition() - start) / (float)(end - start));             }         }          @Override         public void close() throws IOException {             in.close();         }      }      @Override     public RecordReader&lt;PathOffsetWritable, V&gt; createRecordReader(InputSplit split, TaskAttemptContext context) throws IOException, InterruptedException {         return new SequenceFileOffsetRecordReader&lt;V&gt;();     }      @Override     public List&lt;InputSplit&gt; getSplits(JobContext context) throws IOException {         return new SequenceFileInputFormat&lt;PathOffsetWritable, V&gt;().getSplits(context);     }      @Override     public long getFormatMinSplitSize() {         return SequenceFile.SYNC_INTERVAL;     }   }"
"import java.io.*; import java.util.logging.Level; import java.util.logging.Logger; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import org.apache.batik.apps.rasterizer.DestinationType; import org.apache.batik.apps.rasterizer.SVGConverter; import org.apache.batik.dom.svg.SAXSVGDocumentFactory; import org.apache.batik.util.XMLResourceDescriptor; import org.w3c.dom.Document;   public class DOMRasterizer {  public Document createDocument(InputStream in) {     Document doc = null ;     try {         // Create a new svg document.         String parser = XMLResourceDescriptor.getXMLParserClassName();         SAXSVGDocumentFactory f = new SAXSVGDocumentFactory(parser);         doc = f.createSVGDocument(null, in);      } catch (IOException ex) {         Logger.getLogger(DOMRasterizer.class.getName()).log(Level.SEVERE, null, ex);     }     return doc; }  public static void main(String[] args) throws Exception {      DOMRasterizer rasterizer = new DOMRasterizer();     InputStream in = new FileInputStream(new File(""your svg path""));     Document svgXmlDoc = rasterizer.createDocument(in);      // Save this SVG into a file (required by SVG -&gt; PNG transformation process)     File svgFile = File.createTempFile(""graphic-"", "".svg"");     Transformer transformer = TransformerFactory.newInstance().newTransformer();     DOMSource source = new DOMSource(svgXmlDoc);     FileOutputStream fos = new FileOutputStream(svgFile);     try {         transformer.transform(source, new StreamResult(fos));     } finally {         fos.close();     }     // Convert the SVG into PNG     File outputFile =new File(""output path"");     SVGConverter converter = new SVGConverter();     converter.setDestinationType(DestinationType.PNG);     converter.setSources(new String[]{svgFile.toString()});     converter.setDst(outputFile);     converter.execute(); } }"
"import java.util.ArrayList; import java.util.Iterator; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.Executor; import java.util.concurrent.FutureTask; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.BasicResponseHandler; import org.apache.http.impl.client.DefaultHttpClient; import org.springframework.stereotype.Controller; import org.springframework.ui.Model; import org.springframework.web.bind.annotation.RequestMapping;  @Controller public class MyController {     //inject this     private Executor executor;      @RequestMapping(""/your/path/here"")     public String myMVCControllerGETdataMethod(Model model) {         //define all async requests and give them to injected Executor         List&lt;GetRequestTask&gt; tasks = new ArrayList&lt;GetRequestTask&gt;();         tasks.add(new GetRequestTask(""http://api/data?type=1"", this.executor));         tasks.add(new GetRequestTask(""http://api/data?type=2"", this.executor));         //...         //do other work here         //...         //now wait for all async tasks to complete         while(!tasks.isEmpty()) {             for(Iterator&lt;GetRequestTask&gt; it = tasks.iterator(); it.hasNext();) {                 GetRequestTask task = it.next();                 if(task.isDone()) {                     String request = task.getRequest();                     String response = task.getResponse();                     //PUT YOUR CODE HERE                     //possibly aggregate request and response in Map&lt;String,String&gt;                     //or do something else with request and response                     it.remove();                 }             }             //avoid tight loop in ""main"" thread             if(!tasks.isEmpty()) Thread.sleep(100);         }         //now you have all responses for all async requests          //the following from your original code         //note: you should probably pass the responses from above         //to this next method (to keep your controller stateless)         String results = doWorkwithMultipleDataReturned();         model.addAttribute(results, results);         return ""index"";     }      //abstraction to wrap Callable and Future     class GetRequestTask {         private GetRequestWork work;         private FutureTask&lt;String&gt; task;         public GetRequestTask(String url, Executor executor) {             this.work = new GetRequestWork(url);             this.task = new FutureTask&lt;String&gt;(work);             executor.execute(this.task);         }         public String getRequest() {             return this.work.getUrl();         }         public boolean isDone() {             return this.task.isDone();         }         public String getResponse() {             try {                 return this.task.get();             } catch(Exception e) {                 throw new RuntimeException(e);             }         }     }      //Callable representing actual HTTP GET request     class GetRequestWork implements Callable&lt;String&gt; {         private final String url;         public GetRequestWork(String url) {             this.url = url;         }         public String getUrl() {             return this.url;         }         public String call() throws Exception {             return new DefaultHttpClient().execute(new HttpGet(getUrl()), new BasicResponseHandler());         }     } }"
"package com.displaytag.export.views;   import java.io.IOException; import java.io.OutputStream; import java.util.Iterator; import javax.servlet.jsp.JspException; import org.apache.commons.lang.ObjectUtils; import org.apache.commons.lang.StringUtils; import org.displaytag.export.BinaryExportView; import org.displaytag.model.Column; import org.displaytag.model.ColumnIterator; import org.displaytag.model.HeaderCell; import org.displaytag.model.RowIterator; import org.displaytag.model.TableModel; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.CellStyle; import org.apache.poi.ss.usermodel.IndexedColors; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.util.CellRangeAddress; import org.apache.poi.xssf.usermodel.XSSFFont; import org.apache.poi.xssf.usermodel.XSSFSheet; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import com.lowagie.text.BadElementException;  public class myExcel2007ExportView implements BinaryExportView{   //private static Log log = LogFactory.getLog(myExcel2007ExportView.class); private TableModel model; private boolean exportFull; private boolean header; private boolean decorated; private XSSFWorkbook workbook; private XSSFSheet sheet; private int rowCount=0; private CellStyle normalstyle=null; private CellStyle headerstyle=null; private CellStyle captionstyle=null;  private XSSFFont defaultFont; private XSSFFont headerFont; private XSSFFont captionFont;  public String getMimeType() {      return &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;; }  public void setParameters(TableModel tableModel, boolean exportFullList, boolean includeHeader,        boolean decorateValues) {    this.model = tableModel;    this.exportFull = true;    this.header = includeHeader;    this.decorated = decorateValues; }  public boolean outputPage() {     return false; }  protected void initTable() throws BadElementException {     //Blank workbook     workbook = new XSSFWorkbook();           //Create a blank sheet     sheet = workbook.createSheet(&quot;Server Management System&quot;);               defaultFont= workbook.createFont();     defaultFont.setFontHeightInPoints((short)10);     defaultFont.setFontName(&quot;Arial&quot;);     defaultFont.setColor(IndexedColors.BLACK.getIndex());     defaultFont.setBold(false);     defaultFont.setItalic(false);      headerFont= workbook.createFont();     headerFont.setFontHeightInPoints((short)10);     headerFont.setFontName(&quot;Arial&quot;);     headerFont.setColor(IndexedColors.WHITE.getIndex());     headerFont.setBold(true);     headerFont.setItalic(false);          captionFont= workbook.createFont();     captionFont.setFontHeightInPoints((short)15);     captionFont.setFontName(&quot;Arial&quot;);     captionFont.setColor(IndexedColors.BLACK.getIndex());     captionFont.setBold(true);     captionFont.setItalic(false);               normalstyle= workbook.createCellStyle();      normalstyle.setFillBackgroundColor(IndexedColors.WHITE.getIndex());     normalstyle.setFillPattern(CellStyle.BIG_SPOTS);     normalstyle.setAlignment(CellStyle.ALIGN_CENTER);     normalstyle.setFont(defaultFont);          headerstyle= workbook.createCellStyle();      headerstyle.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());     headerstyle.setFillPattern(CellStyle.BIG_SPOTS);     headerstyle.setAlignment(CellStyle.ALIGN_CENTER);     headerstyle.setFont(headerFont);          captionstyle= workbook.createCellStyle();      captionstyle.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());     captionstyle.setFillPattern(CellStyle.BIG_SPOTS);     captionstyle.setAlignment(CellStyle.ALIGN_CENTER);     captionstyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER);     captionstyle.setFont(captionFont);      }  protected void generateXLSXTable() throws JspException, BadElementException {     //adding caption     if(this.model.getCaption()!=null &amp;&amp; this.model.getCaption()!=&quot;&quot;)     {      Row blankrow = sheet.createRow(rowCount++);      Row row = sheet.createRow(rowCount++);            row.setHeight((short)5000);      int columnCount=0;      Cell captionCell = row.createCell(columnCount++);      captionCell.setCellValue(this.model.getCaption());      captionCell.setCellStyle(captionstyle);      sheet.addMergedRegion(new CellRangeAddress(              rowCount-1, //first row (0-based)              rowCount-1, //last row  (0-based)              columnCount-1, //first column (0-based)              columnCount+5  //last column  (0-based)      ));      Row blankrow2 = sheet.createRow(rowCount++);     }          if (this.header)     {         generateHeaders();     }          generateRows();          //adding footer     if(this.model.getFooter()!=null &amp;&amp; this.model.getFooter()!=&quot;&quot;)     {      Row blankrow = sheet.createRow(rowCount++);      Row blankrow2 = sheet.createRow(rowCount++);      Row row = sheet.createRow(rowCount++);            row.setHeight((short)1000);      int columnCount=0;      Cell captionCell = row.createCell(columnCount++);      captionCell.setCellValue(this.model.getFooter());      captionCell.setCellStyle(captionstyle);      sheet.addMergedRegion(new CellRangeAddress(              rowCount-1, //first row (0-based)              rowCount-1, //last row  (0-based)              columnCount-1, //first column (0-based)              columnCount+5  //last column  (0-based)      ));     } }  protected void generateHeaders() throws BadElementException {     Iterator&lt;HeaderCell&gt; iterator = this.model.getHeaderCellList().iterator();     Row row = sheet.createRow(rowCount++);          int columnCount=0;     while (iterator.hasNext())     {         sheet.autoSizeColumn(columnCount);         HeaderCell headerCell = iterator.next();          String columnHeader = headerCell.getTitle();          if (columnHeader == null)         {             columnHeader = StringUtils.capitalize(headerCell.getBeanPropertyName());         }          Cell hdrCell = row.createCell(columnCount++);         hdrCell.setCellValue(columnHeader);         hdrCell.setCellStyle(headerstyle);     } }  protected void generateRows() throws JspException, BadElementException {     // get the correct iterator (full or partial list according to the exportFull field)     RowIterator rowIterator = this.model.getRowIterator(this.exportFull);     // iterator on rows     while (rowIterator.hasNext())     {         Row newrow = sheet.createRow(rowCount++);         org.displaytag.model.Row row = rowIterator.next();         // iterator on columns         ColumnIterator columnIterator = row.getColumnIterator(this.model.getHeaderCellList());         int columnCount=0;         while (columnIterator.hasNext())         {             Column column = columnIterator.nextColumn();              // Get the value to be displayed for the column             Object value = column.getValue(this.decorated);              Cell Cell = newrow.createCell(columnCount++);             Cell.setCellValue(ObjectUtils.toString(value));         }     }      }  @Override public void doExport(OutputStream out) throws IOException, JspException {          try {         // Initialize the table with the appropriate number of columns         initTable();                  generateXLSXTable();              } catch (BadElementException e) {         // TODO Auto-generated catch block         e.printStackTrace();     }                 workbook.write(out);     out.close(); } }"
"import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.File; import java.util.logging.Level; import java.util.logging.Logger; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JPanel; import javax.swing.JProgressBar; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.HttpVersion; import org.apache.http.client.HttpClient; import org.apache.http.client.methods.HttpPut; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.params.BasicHttpParams; import org.apache.http.params.HttpParams; import org.apache.http.params.HttpProtocolParams; import org.apache.http.util.EntityUtils;  public class ApplicationView implements ActionListener {    File file = new File(""C:/Temp/my-upload.avi"");   JProgressBar progressBar = null;    public ApplicationView()   {     super();   }    public void createView()   {     JFrame frame = new JFrame(""File Upload with progress bar - Example"");     frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);     frame.setBounds(0, 0, 300, 200);     frame.setVisible(true);      progressBar = new JProgressBar(0, 100);     progressBar.setBounds(20, 20, 200, 30);     progressBar.setStringPainted(true);     progressBar.setVisible(true);      JButton button = new JButton(""upload"");     button.setBounds(progressBar.getX(),             progressBar.getY() + progressBar.getHeight() + 20,             100,             40);     button.addActionListener(this);      JPanel panel = (JPanel) frame.getContentPane();     panel.setLayout(null);     panel.add(progressBar);     panel.add(button);     panel.setVisible(true);   }    public void actionPerformed(ActionEvent e)   {     try     {       sendFile(this.file, this.progressBar);     }     catch (Exception ex)     {       System.out.println(ex.getLocalizedMessage());     }   }    private void sendFile(File file, JProgressBar progressBar) throws Exception   {     String serverResponse = null;     HttpParams params = new BasicHttpParams();     params.setParameter(HttpProtocolParams.USE_EXPECT_CONTINUE, true);     HttpProtocolParams.setVersion(params, HttpVersion.HTTP_1_1);     HttpClient client = new DefaultHttpClient(params);     HttpPut put = new HttpPut(""http://localhost:8080/"" + file.getName());      ProgressBarListener listener = new ProgressBarListener(progressBar);     FileEntityWithProgressBar fileEntity = new FileEntityWithProgressBar(file, ""binary/octet-stream"", listener);     put.setEntity(fileEntity);      HttpResponse response = client.execute(put);     HttpEntity entity = response.getEntity();     if (entity != null)     {       serverResponse = EntityUtils.toString(entity);       System.out.println(serverResponse);     }   } }"
"package com.arisglobal.aglite.network;  import java.io.InputStream; import java.security.KeyStore;  import org.apache.http.conn.ClientConnectionManager; import org.apache.http.conn.scheme.PlainSocketFactory; import org.apache.http.conn.scheme.Scheme; import org.apache.http.conn.scheme.SchemeRegistry; import org.apache.http.conn.ssl.SSLSocketFactory; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.impl.conn.SingleClientConnManager;  import com.arisglobal.aglite.activity.R;  import android.content.Context;  public class MyHttpClient extends DefaultHttpClient {      final Context context;      public MyHttpClient(Context context) {         this.context = context;     }      @Override     protected ClientConnectionManager createClientConnectionManager() {         SchemeRegistry registry = new SchemeRegistry();          registry.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));          // Register for port 443 our SSLSocketFactory with our keystore to the ConnectionManager         registry.register(new Scheme(""https"", newSslSocketFactory(), 443));         return new SingleClientConnManager(getParams(), registry);     }      private SSLSocketFactory newSslSocketFactory() {         try {             // Get an instance of the Bouncy Castle KeyStore format             KeyStore trusted = KeyStore.getInstance(""BKS"");              // Get the raw resource, which contains the keystore with your trusted certificates (root and any intermediate certs)             InputStream in = context.getResources().openRawResource(R.raw.aglite);             try {                 // Initialize the keystore with the provided trusted certificates.                 // Also provide the password of the keystore                 trusted.load(in, ""aglite"".toCharArray());             } finally {                 in.close();             }              // Pass the keystore to the SSLSocketFactory. The factory is responsible for the verification of the server certificate.             SSLSocketFactory sf = new SSLSocketFactory(trusted);              // Hostname verification from certificate             // http://hc.apache.org/httpcomponents-client-ga/tutorial/html/connmgmt.html#d4e506             sf.setHostnameVerifier(SSLSocketFactory.ALLOW_ALL_HOSTNAME_VERIFIER);             return sf;         } catch (Exception e) {             throw new AssertionError(e);         }     } }"
"package de.pdark.epen.editor;  import java.io.File; import java.lang.reflect.Constructor; import java.lang.reflect.Method; import java.net.URL; import java.net.URLClassLoader;  import org.apache.commons.lang.SystemUtils; import org.apache.commons.lang.exception.ExceptionUtils; import org.slf4j.Logger; import org.slf4j.LoggerFactory;  import ch.qos.logback.classic.LoggerContext; import ch.qos.logback.core.util.StatusPrinter; import de.pdark.epen.exceptions.WikiException;  public class Main {     public final static String VERSION = ""V0.9 (13.05.2010)""; //$NON-NLS-1$     private final static Logger log = LoggerFactory.getLogger (Main.class);      private static final String ORG_ECLIPSE_SWT_WIDGETS_SHELL = ""org.eclipse.swt.widgets.Shell""; //$NON-NLS-1$      /**     * @param args     */     @SuppressWarnings({""nls"", ""PMD.SystemPrintln""})     public static void main (String[] args)     {         String msg = ""Starting ePen ""+VERSION;         System.out.println (msg);         log.info (msg);          LoggerContext lc = (LoggerContext)LoggerFactory.getILoggerFactory ();         StatusPrinter.print (lc);          int rc = 1;         try         {             Main main = new Main ();             main.run (args);             rc = 0;         }         catch (Throwable t) //NOPMD         {             ExceptionUtils.printRootCauseStackTrace (t);         }         finally         {             System.out.println (""Done."");             log.info (""Exit {}"", rc);             System.exit (rc); //NOPMD         }     }      @SuppressWarnings({""nls"", ""PMD.SystemPrintln"", ""PMD.SignatureDeclareThrowsException""})     private void run (String[] args) throws Exception     {         if (!SystemUtils.isJavaVersionAtLeast (150))         {             System.out.println (""Version=""+SystemUtils.JAVA_VERSION_INT);             throw new WikiException (""Need at least Java 5 but this Java is only ""+SystemUtils.JAVA_VERSION);         }          loadSwtJar ();          URLClassLoader cl = (URLClassLoader) getClass().getClassLoader(); //NOPMD         Class&lt;?&gt; c = cl.loadClass (""de.pdark.epen.editor.EPenEditor"");         Class&lt;?&gt; shellClass = cl.loadClass (ORG_ECLIPSE_SWT_WIDGETS_SHELL);          Constructor&lt;?&gt; ctor = c.getConstructor (shellClass);         Object obj = ctor.newInstance (new Object[] { null });         Method run = c.getMethod (""run"", args.getClass ()); //$NON-NLS-1$         run.invoke (obj, new Object[] { args });     }      @SuppressWarnings({""nls"", ""PMD""})     private void loadSwtJar ()     {         try {             Class.forName (ORG_ECLIPSE_SWT_WIDGETS_SHELL);             // Already on classpath             return;         } catch (ClassNotFoundException e) {             // Add the JAR         }          String osName = SystemUtils.OS_NAME.toLowerCase ();         String osArch = SystemUtils.OS_ARCH.toLowerCase ();          String swtFileNameOsPart =              osName.contains(""win"") ? ""win32"" :             osName.contains(""mac"") ? ""macosx"" :             osName.contains(""linux"") || osName.contains(""nix"") ? ""linux"" :             null;         String swtFileNameUiPart =              osName.contains(""win"") ? ""win32"" :             osName.contains(""mac"") ? ""cocoa"" :             osName.contains(""linux"") || osName.contains(""nix"") ? ""gtk"" :             null;          if (null == swtFileNameOsPart)         {             throw new RuntimeException (""Can't determine name of SWT Jar from os.name=["" + osName + ""] and os.arch=[""                     + osArch + ""]"");         }          String swtFileNameArchPart = osArch.contains (""64"") ? "".x86_64"" : "".x86"";         if("".x86"".equals(swtFileNameArchPart) &amp;&amp; ""macosx"".equals(swtFileNameOsPart)) {             swtFileNameArchPart = """";         }          String swtFileName = ""org.eclipse.swt."" + swtFileNameUiPart + ""."" + swtFileNameOsPart + swtFileNameArchPart + ""-3.6.0.jar"";         File file = new File (""swt"", swtFileName);         if (!file.exists ())         {             throw new RuntimeException (""Can't locate SWT Jar "" + file.getAbsolutePath ());         }         try         {             URLClassLoader classLoader = (URLClassLoader) getClass ().getClassLoader ();             Method addUrlMethod = URLClassLoader.class.getDeclaredMethod (""addURL"", URL.class);             addUrlMethod.setAccessible (true);              URL swtFileUrl = file.toURI ().toURL ();             log.info (""Adding {} to the classpath"", swtFileUrl);             addUrlMethod.invoke (classLoader, swtFileUrl);         }         catch (Exception e)         {             throw new RuntimeException (""Unable to add the swt jar to the class path: "" + file.getAbsoluteFile (), e);         }     } }"
"package org.woopi.stackoverflow.q22853574;  import org.apache.hadoop.io.*; import org.apache.hadoop.mapreduce.lib.input.*; import org.apache.hadoop.mapreduce.lib.output.*; import org.apache.hadoop.mapreduce.*; import org.apache.hadoop.fs.Path; import java.io.IOException; import org.apache.hadoop.conf.Configuration;  public class MapReduceJob {    public static class MapClass extends Mapper&lt;Object, Text, Text, LongWritable&gt; {      public void map(Object key, Text value, Context context) throws IOException, InterruptedException {         // your map code goes here         String[] fields = value.toString().split("","");          for(String str : fields) {             context.write(new Text(str), new LongWritable(1L));         }     }   }      public int run(String args[]) throws Exception {         Configuration conf = new Configuration();         Job job = Job.getInstance(conf);         job.setJarByClass(MapReduceJob.class);          job.setMapperClass(MapClass.class);          FileInputFormat.setInputPaths(job, new Path(args[0]));         FileOutputFormat.setOutputPath(job, new Path(args[1]));          job.setJobName(""MapReduceJob"");         job.setOutputKeyClass(Text.class);         job.setOutputValueClass(LongWritable.class);         job.setNumReduceTasks(0);         job.setInputFormatClass(TextInputFormat.class);         boolean success = job.waitForCompletion(true);         return success ? 0 : 1;     }    public static void main(String args[]) throws Exception {     MapReduceJob j = new MapReduceJob();     int ret = j.run(args);     System.exit(ret);   }"
"import java.io.File;  import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathFactory;  import org.htmlcleaner.CleanerProperties; import org.htmlcleaner.DomSerializer; import org.htmlcleaner.HtmlCleaner; import org.htmlcleaner.TagNode; import org.w3c.dom.Document; import org.w3c.dom.NamedNodeMap; import org.w3c.dom.Node;    public class Teste {      public static void main(String[] args) {         try {             // read and clean document             TagNode tagNode = new HtmlCleaner().clean(new File(""test.xml""));             Document document = new DomSerializer(new CleanerProperties()).createDOM(tagNode);              // use XPath to find target node             XPath xpath = XPathFactory.newInstance().newXPath();             Node node = (Node) xpath.evaluate(""//*[text()='content']"", document, XPathConstants.NODE);              // assembles jquery/css selector             String result = """";             while (node != null &amp;&amp; node.getParentNode() != null) {                 result = readPath(node) + "" "" + result;                 node = node.getParentNode();             }             System.out.println(result);             // returns html body div#myDiv.foo.bar p#tID           } catch (Exception e) {             e.printStackTrace();         }     }      // Gets id and class attributes of this node     private static String readPath(Node node) {         NamedNodeMap attributes = node.getAttributes();         String id = readAttribute(attributes.getNamedItem(""id""), ""#"");         String clazz = readAttribute(attributes.getNamedItem(""class""), ""."");         return node.getNodeName() + id + clazz;     }      // Read attribute     private static String readAttribute(Node node, String token) {         String result = """";         if(node != null) {             result = token + node.getTextContent().replace("" "", token);         }         return result;     }  }"
"import java.util.HashMap; import java.util.LinkedList; import java.util.List; import java.util.Map;  import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlRootElement; import javax.xml.bind.annotation.XmlType; import javax.xml.bind.annotation.adapters.XmlAdapter;  public class MapAdapter&lt;K, V&gt; extends XmlAdapter&lt;Adapter&lt;K, V&gt;, Map&lt;K, V&gt;&gt; {      @Override     public Map&lt;K, V&gt; unmarshal(Adapter&lt;K, V&gt; v) throws Exception {         if (v == null) {             return null;         }         Map&lt;K, V&gt; map = new HashMap&lt;K, V&gt;();         for (MyEntry&lt;K, V&gt; mapEntryType : v.getEntries()) {             map.put(rUnmarshal(mapEntryType.getKey()),     rUnmarshal(mapEntryType.getValue()));         }         return map;     }      @Override     public Adapter&lt;K, V&gt; marshal(Map&lt;K, V&gt; v) throws Exception {         if (v == null) {             return null;         }         return new Adapter&lt;K, V&gt;(v);     }      @SuppressWarnings(""unchecked"")     private static &lt;T&gt; T rUnmarshal(T obj) throws Exception {         if (obj instanceof Adapter) {             return (T) new MapAdapter&lt;&gt;().unmarshal((Adapter&lt;Object, Object&gt;) obj);         }         return obj;     }      @SuppressWarnings(""unchecked"")     static &lt;T&gt; T rMarshal(T obj) throws Exception {         if (obj instanceof Map) {             return (T) new MapAdapter&lt;&gt;().marshal((Map&lt;Object, Object&gt;) obj);         }         return obj;     }      @XmlType     @XmlRootElement     public final static class Adapter&lt;K, V&gt; {          @XmlElement         protected List&lt;MyEntry&lt;K, V&gt;&gt; fEntries = new LinkedList&lt;MyEntry&lt;K, V&gt;&gt;();          // needed for JAXB         @SuppressWarnings(""unused"")         private Adapter() {         }          public Adapter(Map&lt;K, V&gt; original) throws Exception {             for (Map.Entry&lt;K, V&gt; entry : original.entrySet()) {                 this.fEntries.add(new MyEntry&lt;K, V&gt;(entry));             }         }          public List&lt;MyEntry&lt;K, V&gt;&gt; getEntries() {             return this.fEntries;         }      }      @XmlType     @XmlRootElement     public final static class MyEntry&lt;K, V&gt; {          @XmlElement         protected K fKey;          @XmlElement         protected V fValue;          // needed for JAXB         @SuppressWarnings(""unused"")         private MyEntry() {         }          public MyEntry(Map.Entry&lt;K, V&gt; original) throws Exception {             this.fKey = rMarshal(original.getKey());             this.fValue = rMarshal(original.getValue());         }          public K getKey() {             return this.fKey;         }          public V getValue() {             return this.fValue;         }      }  }"
"import java.util.logging.Level; import java.util.logging.Logger; import org.apache.wicket.markup.html.WebPage; import org.apache.wicket.markup.html.basic.Label; import org.apache.wicket.markup.html.link.Link; import org.apache.wicket.model.IModel; import org.apache.wicket.model.Model;  public class ConcurrentClickPage extends WebPage {      public ConcurrentClickPage() {         final IModel&lt;String&gt; model = new Model&lt;String&gt;(""initial"");         Label status = new Label(""status"", model);         add(status);         add(new Link(""link1""){             @Override             public void onClick() {                 try {                     Thread.sleep(3000);                 } catch (InterruptedException ex) {                     Logger.getLogger(ConcurrentClickPage.class.getName()).log(Level.SEVERE, null, ex);                 }                 model.setObject(""link 1 clicked"");             }         });         add(new Link(""link2""){             @Override             public void onClick() {                 model.setObject(""link 2 clicked"");             }         });     }  }"
"package client;  import java.net.InetSocketAddress; import java.nio.charset.CharacterCodingException; import java.nio.charset.Charset; import java.util.logging.Level; import org.apache.mina.core.buffer.IoBuffer; import org.apache.mina.core.future.ConnectFuture; import org.apache.mina.core.future.IoFutureListener; import org.apache.mina.core.future.ReadFuture; import org.apache.mina.core.service.IoConnector; import org.apache.mina.core.service.IoHandlerAdapter; import org.apache.mina.core.session.IdleStatus; import org.apache.mina.core.session.IoSession; import org.apache.mina.example.udp.client.MemMonClient; import org.apache.mina.transport.socket.nio.NioDatagramConnector;  /**  *  * @author az  */ public class CustomClient extends IoHandlerAdapter{      private IoSession session;     private IoConnector connector;     private ConnectFuture connFuture;      public CustomClient() throws InterruptedException{         connector = new NioDatagramConnector();         connector.setHandler(this);         connFuture = connector.connect(new InetSocketAddress(""192.168.3.22"",6502));           connFuture.addListener(new IoFutureListener&lt;ConnectFuture&gt;() {             public void operationComplete(ConnectFuture future) {                 if (future.isConnected()) {                                         session = future.getSession();                     try {                         try {                             sendData();                           //  connFuture.await();                          } catch (CharacterCodingException ex) {                             java.util.logging.Logger.getLogger(MemMonClient.class.getName()).log(Level.SEVERE, null, ex);                         }                     } catch (InterruptedException e) {                         e.printStackTrace();                     }                 }              }         });      }     private void sendData() throws InterruptedException, CharacterCodingException {               IoBuffer buffer = IoBuffer.allocate(8);             buffer.setAutoExpand(true);             buffer.putString(""any"", Charset.forName(""UTF-8"").newEncoder());             buffer.flip();             session.write(buffer);     }       @Override     public void exceptionCaught(IoSession session, Throwable cause)             throws Exception {         cause.printStackTrace();     }     @Override     public void messageReceived(IoSession session, Object message)             throws Exception {         connFuture.getSession().getConfig().setUseReadOperation(true);          ReadFuture r = connFuture.getSession().read();         connFuture.await();         connFuture.getSession().getConfig().setUseReadOperation(true);           Object obj = r.getMessage();         System.out.println(""r.getMessage(); ""+obj);         IoBuffer buffer = IoBuffer.allocate(2048);                         buffer.setAutoExpand(true);                                              Object objReceived = buffer.getObject();                         System.out.println(objReceived.toString());          System.out.println(""reveived Session recv..."");     }      @Override     public void messageSent(IoSession session, Object message) throws Exception {         System.out.println(""Message sent..."");     }      @Override     public void sessionClosed(IoSession session) throws Exception {         System.out.println(""Session closed..."");     }      @Override     public void sessionCreated(IoSession session) throws Exception {         System.out.println(""Session created..."");     }      @Override     public void sessionIdle(IoSession session, IdleStatus status)             throws Exception {         System.out.println(""Session idle..."");     }      @Override     public void sessionOpened(IoSession session) throws Exception {         System.out.println(""Session opened..."");     }     public static void main (String are[]){         try{         new CustomClient();         }catch(Exception ex){ex.printStackTrace();}     } }  POJO Java package pojo;  import java.io.Serializable;  /**  *  * @author az  */ public class kojo implements Serializable{     private String name = ""null"";     private String address = ""null"";      /**      * @return the name      */     public String getName() {         return name;     }      /**      * @param name the name to set      */     public void setName(String name) {         this.name = name;     }      /**      * @return the address      */     public String getAddress() {         return address;     }      /**      * @param address the address to set      */     public void setAddress(String address) {         this.address = address;     }  }  Custom Server Java package server;  import java.io.IOException; import java.net.InetSocketAddress; import org.apache.mina.transport.socket.DatagramSessionConfig; import org.apache.mina.transport.socket.nio.NioDatagramAcceptor;  /**  *  * @author az  */ public class CustomServer {      public CustomServer(){         try {             NioDatagramAcceptor acceptor = new NioDatagramAcceptor();             acceptor.setHandler(new ServerHandler(this));             //DefaultIoFilterChainBuilder filter = acceptor.getFilterChain();             DatagramSessionConfig dcfg = acceptor.getSessionConfig();             dcfg.setReuseAddress(true);             acceptor.bind(new InetSocketAddress(6501));         } catch (IOException ex) {             ex.printStackTrace();         }     }      public void receiveUpdate(){      }     public static void main(String are[]){         new CustomServer();     } }  Server Handler package server;  import java.nio.charset.Charset; import org.apache.mina.core.buffer.IoBuffer; import org.apache.mina.core.future.WriteFuture; import org.apache.mina.core.service.IoHandlerAdapter; import org.apache.mina.core.session.IdleStatus; import org.apache.mina.core.session.IoSession;  /**  *  * @author az  */ public class ServerHandler extends IoHandlerAdapter {      private CustomServer server;      public ServerHandler(CustomServer server) {         this.server = server;     }      @Override     public void messageReceived(IoSession session, Object message)             throws Exception {          if (message instanceof IoBuffer) {             //decode POJO and send to client             IoBuffer buffer = (IoBuffer) message;             System.out.println(buffer.getString(Charset.forName(""UTF-8"").newDecoder()));             buffer.setAutoExpand(true);             buffer.putObject(new pojo.POJO());             buffer.flip();             session.write(buffer);              System.out.print(""Object Attached and Sent"");          }     }      @Override     public void messageSent(IoSession session, Object message) {         System.out.println(""Message sent"");     }      @Override     public void sessionClosed(IoSession session) throws Exception {         System.out.println(""Session closed..."");     }      @Override     public void sessionCreated(IoSession session) throws Exception {         System.out.println(""Session created..."");     }      @Override     public void sessionIdle(IoSession session, IdleStatus status)             throws Exception {         System.out.println(""Session idle..."");     }      @Override     public void sessionOpened(IoSession session) throws Exception {         System.out.println(""Session Opened..."");     } }"
"package com.excel2pdfconvert.example; import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.UnsupportedEncodingException;  import org.apache.http.Header; import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.client.ClientProtocolException; import org.apache.http.client.HttpClient; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.mime.HttpMultipartMode; import org.apache.http.entity.mime.MultipartEntity; import org.apache.http.entity.mime.content.FileBody; import org.apache.http.impl.client.DefaultHttpClient;  public class Xls2PDFConvertBean {      private File file;     private String outputDir;       private String filesize;     private String filename;        public void setOutputDir(String outputDir) {         this.outputDir = outputDir;     }     public void setExcelFile(File file) {         this.file = file;     }      public String getFilesize() {         return filesize;     }     public String getFilename() {         return filename;     }       /**      * Run request for page conversion      * @return resultcode ""0"" in error, ""1"" in success      * @throws UnsupportedEncodingException       */     public String doRequest() throws UnsupportedEncodingException{          String resultcode = ""0"";           HttpPost httppost = new HttpPost(""http://do.convertapi.com/Excel2Pdf"");          MultipartEntity entity = new MultipartEntity( HttpMultipartMode.BROWSER_COMPATIBLE );          // For File parameters         entity.addPart(""file"", new FileBody(file, ""binary/octet-stream""));          httppost.setEntity( entity );          HttpClient httpclient = new DefaultHttpClient();         try {             HttpResponse response = httpclient.execute(httppost);             Header rcHeader = response.getFirstHeader(""result"");             if(rcHeader != null){                  resultcode = rcHeader.getValue();                  if(""True"".equals(resultcode)){                      filesize = response.getFirstHeader(""filesize"").getValue();                     filename = response.getFirstHeader(""OutputFileName"").getValue();                      HttpEntity hentity = response.getEntity();                     if(hentity != null){                          InputStream istream = hentity.getContent();                         File file = new File(outputDir+File.separator+filename);                         FileOutputStream ostream = new FileOutputStream(file);                          byte[] b = new byte[1024];                         int num = 0;                         while( (num = istream.read(b, 0, b.length)) &gt; 0)                             ostream.write(b, 0, num);                         istream.close();                         ostream.flush();                         ostream.close();                      }                 }             }          } catch (ClientProtocolException e) {             e.printStackTrace();         } catch (IOException e) {             e.printStackTrace();         }           return resultcode;     }  }"
"package my.taglibs;  import java.io.Writer; import java.util.Map; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import org.apache.commons.logging.Log; import org.apache.commons.logging.LogFactory; import org.apache.struts2.components.Component; import org.apache.struts2.views.jsp.ComponentTagSupport; import com.opensymphony.xwork2.util.ValueStack;  public class ParamTag extends ComponentTagSupport {      private String map;     private static final long serialVersionUID = 2522878390854066408L;     Log log = LogFactory.getLog(ParamTag.class);      @Override     public Component getBean(ValueStack stack, HttpServletRequest req, HttpServletResponse res) {         return new Param(stack);     }      @Override     protected void populateParams() {         super.populateParams();          Param param = (Param) component;         param.setMap(map);     }      public void setMap(String map) {         this.map = map;     }      public class Param extends Component {          private String map;           public Param(ValueStack stack) {             super(stack);         }          @Override         public boolean end(Writer writer, String body) {             Component component = findAncestor(Component.class);             if (this.map == null) {                        log.warn(""Attribute map is mandatory."");                 return super.end(writer, """");             }             Object o = findValue(this.map); //find map in vs             if(o == null) {                 log.warn(""map not found in ValueStack"");                 return super.end(writer, """");             }             if(!(o instanceof Map)) {                 log.warn(""Error in JSP. Attribute map must evaluate to java.util.Map. Found type: "" + o.getClass().getName());                 return super.end(writer, """");             }              component.addAllParameters((Map) o);             return super.end(writer, """");         }          public void setMap(String map) {             this.map = map;         }     } }"
"import org.apache.commons.lang.SerializationUtils; import org.springframework.stereotype.Component;  import javax.ws.rs.core.MediaType; import javax.ws.rs.core.MultivaluedMap; import javax.ws.rs.ext.MessageBodyReader; import javax.ws.rs.ext.MessageBodyWriter; import javax.ws.rs.ext.Provider; import java.io.InputStream; import java.io.OutputStream; import java.io.Serializable; import java.lang.annotation.Annotation; import java.lang.reflect.Type;  /**  * Created with IntelliJ IDEA.  * User: ryan  * Date: 2/25/13  * Time: 2:07 PM  */ @Component @Provider public class SerializationMessageBodyReaderAndWriter         implements MessageBodyReader&lt;Serializable&gt;, MessageBodyWriter&lt;Serializable&gt; {     public static final String APPLICATION_JAVA_SERIALIZED_OBJECT =             ""application/x-java-serialized-object"";     public static final MediaType APPLICATION_JAVA_SERIALIZED_OBJECT_TYPE =             MediaType.valueOf(APPLICATION_JAVA_SERIALIZED_OBJECT);      @Override     public boolean isReadable(Class&lt;?&gt; type,                               Type genericType,                               Annotation[] annotations,                               MediaType mediaType) {         return mediaType.isCompatible(APPLICATION_JAVA_SERIALIZED_OBJECT_TYPE)                 &amp;&amp; Serializable.class.isAssignableFrom(type);     }      @Override     public Serializable readFrom(Class&lt;Serializable&gt; type,                                  Type genericType,                                  Annotation[] annotations,                                  MediaType mediaType,                                  MultivaluedMap&lt;String, String&gt; httpHeaders,                                  InputStream entityStream) {         return (Serializable) SerializationUtils.deserialize(entityStream);     }      @Override     public boolean isWriteable(Class&lt;?&gt; type,                                Type genericType,                                Annotation[] annotations,                                MediaType mediaType) {         return mediaType.isCompatible(APPLICATION_JAVA_SERIALIZED_OBJECT_TYPE)                 &amp;&amp; Serializable.class.isAssignableFrom(type);     }      @Override     public long getSize(Serializable o,                         Class&lt;?&gt; type,                         Type genericType,                         Annotation[] annotations,                         MediaType mediaType) {         return -1;     }      @Override     public void writeTo(Serializable o,                         Class&lt;?&gt; type,                         Type genericType,                         Annotation[] annotations,                         MediaType mediaType,                         MultivaluedMap&lt;String, Object&gt; httpHeaders,                         OutputStream entityStream) {         SerializationUtils.serialize(o, entityStream);     } }"
"import java.io.IOException;  import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapred.FileSplit; import org.apache.hadoop.mapred.InputSplit; import org.apache.hadoop.mapred.JobConf; import org.apache.hadoop.mapred.LineRecordReader; import org.apache.hadoop.mapred.RecordReader; import org.apache.hadoop.mapred.Reporter; import org.apache.hadoop.mapred.lib.CombineFileInputFormat; import org.apache.hadoop.mapred.lib.CombineFileRecordReader; import org.apache.hadoop.mapred.lib.CombineFileSplit;  @SuppressWarnings(""deprecation"") public class CombinedInputFormat extends CombineFileInputFormat&lt;LongWritable, Text&gt; {      @SuppressWarnings({ ""unchecked"", ""rawtypes"" })     @Override     public RecordReader&lt;LongWritable, Text&gt; getRecordReader(InputSplit split, JobConf conf, Reporter reporter) throws IOException {          return new CombineFileRecordReader(conf, (CombineFileSplit) split, reporter, (Class) myCombineFileRecordReader.class);     }      public static class myCombineFileRecordReader implements RecordReader&lt;LongWritable, Text&gt; {         private final LineRecordReader linerecord;          public myCombineFileRecordReader(CombineFileSplit split, Configuration conf, Reporter reporter, Integer index) throws IOException {             FileSplit filesplit = new FileSplit(split.getPath(index), split.getOffset(index), split.getLength(index), split.getLocations());             linerecord = new LineRecordReader(conf, filesplit);         }          @Override         public void close() throws IOException {             linerecord.close();          }          @Override         public LongWritable createKey() {             // TODO Auto-generated method stub             return linerecord.createKey();         }          @Override         public Text createValue() {             // TODO Auto-generated method stub             return linerecord.createValue();         }          @Override         public long getPos() throws IOException {             // TODO Auto-generated method stub             return linerecord.getPos();         }          @Override         public float getProgress() throws IOException {             // TODO Auto-generated method stub             return linerecord.getProgress();         }          @Override         public boolean next(LongWritable key, Text value) throws IOException {              // TODO Auto-generated method stub             return linerecord.next(key, value);         }      } }"
"package com.officedrop.uploader;  import java.io.File; import java.net.URL;  import org.apache.http.HttpHost; import org.apache.http.HttpResponse; import org.apache.http.client.methods.HttpPost; import org.apache.http.entity.mime.HttpMultipartMode; import org.apache.http.entity.mime.MultipartEntity; import org.apache.http.entity.mime.content.FileBody; import org.apache.http.impl.client.DefaultHttpClient;  public class SampleUploader {      public static void main(String[] args) throws Exception {          DefaultHttpClient httpclient = new DefaultHttpClient();         String basePath = ""http://localhost/"";          URL url = new URL( basePath );          HttpHost targetHost = new HttpHost( url.getHost(), url.getPort(), url.getProtocol() );            HttpPost httpost = new HttpPost( String.format( ""%s%s"", basePath, ""ze/api/documents.xml""));          MultipartEntity entity = new MultipartEntity(HttpMultipartMode.BROWSER_COMPATIBLE);          entity.addPart(""file_1"", new FileBody( new File( ""path-to-file.pdf"" ) , ""file.pdf"", ""application/pdf"", null));         entity.addPart(""uploaded_data_1"", new FileBody( new File( ""path-to-file.json"" ) , ""file.json"", ""application/json"", null));              httpost.setEntity(entity);          HttpResponse response = httpclient.execute( targetHost, httpost);      }  }"
"package my.package;  import org.apache.cxf.binding.soap.SoapHeader; import org.apache.cxf.headers.Header; import org.apache.cxf.message.Message; import org.apache.cxf.phase.AbstractPhaseInterceptor; import org.apache.cxf.phase.Phase; import org.w3c.dom.Element;  import javax.xml.namespace.QName; import java.util.ArrayList; import java.util.List; import java.util.UUID;  public class HeaderInterceptor extends AbstractPhaseInterceptor&lt;Message&gt; {      private static final String SOAP_HEADER_KEY = ""org.apache.cxf.headers.Header.list"";     private static final String NAMESPACE_URI   = ""http://www.w3.org/2005/08/addressing"";     private static final String QUALIFIED_NAME  = ""wsa:MessageID"";     private static final String LOCAL_NAME      = ""MessageID"";      public HeaderInterceptor() {         // phases: http://cxf.apache.org/docs/interceptors.html         // 'pre protocol' seems to be the best moment to check the header, if we do it earlier the headers don't exist in the message object so we can't re-use the 'owner document'         // if we do it later the unmarshalMAPs method (in MAPCodec.java) will already have processed the headers and will not process our added header         super(Phase.PRE_PROTOCOL);     }      @Override     public void handleMessage(Message message) throws Fault {         ArrayList&lt;SoapHeader&gt; headers = (ArrayList&lt;SoapHeader&gt;) message.get(SOAP_HEADER_KEY);          // if the header doesn't exist and we have at least one header to access 'owner document' we can create and add our own MessageID header         if(!messageIdHeaderExists(headers) &amp;&amp; headers.size() &gt; 0) {             Element existingHeaderElement = (Element) headers.get(0).getObject();              // use the existing header element to create our own MessageID header with random UUID             Element element = existingHeaderElement.getOwnerDocument().createElementNS(NAMESPACE_URI, QUALIFIED_NAME);             element.appendChild(existingHeaderElement.getOwnerDocument().createTextNode(""uuid:"" + UUID.randomUUID().toString()));              QName qname = new QName(NAMESPACE_URI, LOCAL_NAME);             SoapHeader header = new SoapHeader(qname, element);              // by default a SoapHeader is created with 'direction out'             header.setDirection(Header.Direction.DIRECTION_IN);              headers.add(header);         }     }      /**      * Checks if the MessageID header exists in the list of headers.      *      * @param headers list of headers      * @return true if the MessageID header exists, false if not      */     private Boolean messageIdHeaderExists(ArrayList&lt;SoapHeader&gt; headers) {         for(SoapHeader header:headers) {             if(header.getName().getLocalPart().equalsIgnoreCase(LOCAL_NAME)) {                 return true;             }         }         return false;     }          }"
"import java.util.Random;  import org.apache.http.HttpEntity; import org.apache.http.HttpHost; import org.apache.http.HttpResponse; import org.apache.http.auth.AuthScope; import org.apache.http.auth.UsernamePasswordCredentials; import org.apache.http.client.AuthCache; import org.apache.http.client.ResponseHandler; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.auth.DigestScheme; import org.apache.http.impl.client.BasicResponseHandler; import org.apache.http.impl.client.DefaultHttpClient; import org.apache.http.client.protocol.ClientContext; import org.apache.http.impl.client.BasicAuthCache; import org.apache.http.protocol.BasicHttpContext; import org.apache.http.util.EntityUtils;  /**  * A simple example that uses HttpClient to execute an HTTP request against a  * target site that requires user authentication.  */ public class RestClient {  public static void main(String args[]) throws Exception {      HttpHost targetHost = new HttpHost(""localhost"", 8001, ""http"");     DefaultHttpClient httpclient = new DefaultHttpClient();      final String userName = ""admin"";     final String password = ""password"";      httpclient.getCredentialsProvider().setCredentials(             new AuthScope(""localhost"", 8001),              new UsernamePasswordCredentials(userName, password));          // Create AuthCache instance     AuthCache authCache = new BasicAuthCache();     // Generate DIGEST scheme object, initialize it and add it to the local     // auth cache     DigestScheme digestAuth = new DigestScheme();     // Suppose we already know the realm name     digestAuth.overrideParamter(""realm"", ""some realm"");     // Suppose we already know the expected nonce value     digestAuth.overrideParamter(""nonce"", ""whatever"");     authCache.put(targetHost, digestAuth);      // Add AuthCache to the execution context     BasicHttpContext localcontext = new BasicHttpContext();     localcontext.setAttribute(ClientContext.AUTH_CACHE, authCache);      HttpGet httpget = new HttpGet(""http://localhost:8001/rest/test"");      try {         HttpResponse response = httpclient.execute(targetHost, httpget, localcontext);         HttpEntity entity = response.getEntity();          System.out.println(""----------------------------------------"");         System.out.println(response.getStatusLine());         if (entity != null) {             System.out.println(""Response content length: "" + entity.getContentLength());         }         EntityUtils.consume(entity);     } finally {         httpclient.getConnectionManager().shutdown();     } } }"
"import org.apache.http.HttpEntity; import org.apache.http.HttpResponse; import org.apache.http.client.HttpClient; import org.apache.http.client.methods.HttpGet; import org.apache.http.impl.client.HttpClients; import org.apache.http.ssl.SSLContexts; import org.apache.http.util.EntityUtils; import org.junit.Test;  import javax.net.ssl.SSLContext; import java.io.InputStream; import java.security.KeyStore;  import static org.junit.Assert.assertEquals; import static org.junit.Assert.assertNotNull;  public class MyClientCertTest {      private static final String KEYSTOREPATH = ""/clientkeystore.jks""; // or .p12     private static final String KEYSTOREPASS = ""keystorepass"";     private static final String KEYPASS = ""keypass"";      KeyStore readStore() throws Exception {         try (InputStream keyStoreStream = this.getClass().getResourceAsStream(KEYSTOREPATH)) {             KeyStore keyStore = KeyStore.getInstance(""JKS""); // or ""PKCS12""             keyStore.load(keyStoreStream, KEYSTOREPASS.toCharArray());             return keyStore;         }     }     @Test     public void readKeyStore() throws Exception {         assertNotNull(readStore());     }     @Test     public void performClientRequest() throws Exception {         SSLContext sslContext = SSLContexts.custom()                 .loadKeyMaterial(readStore(), KEYPASS.toCharArray()) // use null as second param if you don't have a separate key password                 .build();          HttpClient httpClient = HttpClients.custom().setSSLContext(sslContext).build();         HttpResponse response = httpClient.execute(new HttpGet(""https://slsh.iki.fi/client-certificate/protected/""));         assertEquals(200, response.getStatusLine().getStatusCode());         HttpEntity entity = response.getEntity();          System.out.println(""----------------------------------------"");         System.out.println(response.getStatusLine());         EntityUtils.consume(entity);     } }"
