code
"import java.io.IOException; import java.util.EnumSet;  import javax.servlet.DispatcherType; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import org.eclipse.jetty.server.Server; import org.eclipse.jetty.servlet.ServletHandler;  public class JettyFilter {    public static void main(final String[] args) throws Exception {     Server server = new Server(8080);      ServletHandler handler = new ServletHandler();     server.setHandler(handler);      handler.addServletWithMapping(HelloServlet.class, ""/*"");     handler.addFilterWithMapping(HelloPrintingFilter.class, ""/*"",         EnumSet.of(DispatcherType.REQUEST));      server.start();     server.join();   }    public static class HelloServlet extends HttpServlet {     private static final long serialVersionUID = 1L;      @Override     protected void doGet(HttpServletRequest request, HttpServletResponse response)         throws ServletException, IOException {       response.setContentType(""text/html"");       response.setStatus(HttpServletResponse.SC_OK);       response.getWriter().println(""&lt;h1&gt;Hello SimpleServlet&lt;/h1&gt;"");     }   }    public static class HelloPrintingFilter implements Filter {     @Override     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)         throws IOException, ServletException {       System.out.print(""hello from filter"");     }      @Override     public void init(FilterConfig arg0) throws ServletException {      }      @Override     public void destroy() {}   } }"
"import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream;  import javax.servlet.ServletException; import javax.servlet.http.HttpServlet;  import javax.servlet.http.HttpServletRequest;  import javax.servlet.http.HttpServletResponse;  import org.apache.commons.fileupload.FileItemIterator;  import org.apache.commons.fileupload.FileItemStream;  import org.apache.commons.fileupload.servlet.ServletFileUpload;   public class FileUpload extends HttpServlet{     public void doPost(HttpServletRequest request, HttpServletResponse response)  throws ServletException, IOException {         ServletFileUpload upload = new ServletFileUpload();          try{             FileItemIterator iter = upload.getItemIterator(request);              while (iter.hasNext()) {                 FileItemStream item = iter.next();                  String name = item.getFieldName();                 InputStream stream = item.openStream();                   // Process the input stream                 ByteArrayOutputStream out = new ByteArrayOutputStream();                 int len;                 byte[] buffer = new byte[8192];                 while ((len = stream.read(buffer, 0, buffer.length)) != -1) {                     out.write(buffer, 0, len);                 }                  int maxFileSize = 10*(1024*1024); //10 megs max                  if (out.size() &gt; maxFileSize) {                      throw new RuntimeException(""File is &gt; than "" + maxFileSize);                 }             }         }         catch(Exception e){             throw new RuntimeException(e);         }      } }"
"import java.io.IOException;  import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse;  import org.apache.catalina.Container; import org.apache.catalina.connector.Connector; import org.apache.catalina.core.StandardContext; import org.apache.catalina.core.StandardEngine; import org.apache.commons.lang3.reflect.FieldUtils;  public class TestFilter implements Filter {      @Override     public void destroy() {         // TODO Auto-generated method stub      }      @Override     public void doFilter(ServletRequest arg0, ServletResponse arg1,             FilterChain arg2) throws IOException, ServletException {         arg2.doFilter(arg0, arg1);      }      @Override     public void init(FilterConfig arg0) throws ServletException {         ServletContext ctx = arg0.getServletContext();          try {             Object o = FieldUtils.readField(ctx, ""context"", true);             StandardContext sCtx = (StandardContext) FieldUtils.readField(o, ""context"", true);             Container container = (Container) sCtx;              Container c = container.getParent();         while (c != null &amp;&amp; !(c instanceof StandardEngine)) {             c = c.getParent();         }          if (c != null) {             StandardEngine engine = (StandardEngine) c;             for (Connector connector : engine.getService().findConnectors()) {                 // Get port for each connector. Store it in the ServletContext or whatever                 System.out.println(connector.getPort());             }         }         } catch (Exception e) {             e.printStackTrace();         }       }  }"
"import java.io.IOException;  import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.io.UnsupportedEncodingException; import java.util.HashMap; import java.util.Locale; import java.util.Map;  import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpServletResponseWrapper;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.ui.Model; import org.springframework.web.servlet.View; import org.springframework.web.servlet.ViewResolver;  public class InternalRenderer {      private final static String ENCODE = ""UTF-8"";      @Autowired     private ViewResolver viewResolver;      public String evalView(HttpServletRequest request, HttpServletResponse response, Model model, Locale locale, String viewName) throws Exception {          CustomHttpServletResponse customResponse = new CustomHttpServletResponse(response);          View view = viewResolver.resolveViewName(viewName, locale);          if(view != null){              view.render(fillModelMap(model), request, customResponse);              OutputStream os = customResponse.getOutputStream();              return os.toString();          }          throw new Exception(""no view found"");     }      private Map&lt;String, Object&gt; fillModelMap(Model model) {          if(model == null)             return new HashMap&lt;String,Object&gt;();          return model.asMap();     }      class CustomServletOutPutStream extends ServletOutputStream {          private StringBuilder stringBuilder = new StringBuilder();          @Override         public String toString() {             return stringBuilder.toString();         }          @Override         public void write(int b) {             stringBuilder.append(b);         }          @Override         public void write(byte b[], int off, int len) throws IOException {             stringBuilder.append(new String(b, off, len, ENCODE));         }     }      class CustomHttpServletResponse extends HttpServletResponseWrapper {          private ServletOutputStream outputStream;         private PrintWriter printWriter;          public CustomHttpServletResponse(HttpServletResponse response) throws UnsupportedEncodingException {             super(response);              this.outputStream = new CustomServletOutPutStream();             this.printWriter = new PrintWriter(new OutputStreamWriter(outputStream, ENCODE));          }          @Override         public ServletOutputStream getOutputStream() {             return this.outputStream;         }          @Override         public PrintWriter getWriter() throws IOException {             return this.printWriter;         }     }  }"
"import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream;  import javax.print.Doc; import javax.print.DocFlavor; import javax.print.DocPrintJob; import javax.print.PrintException; import javax.print.PrintService; import javax.print.PrintServiceLookup; import javax.print.SimpleDoc;  import javax.print.attribute.HashPrintRequestAttributeSet; import javax.print.attribute.PrintRequestAttributeSet; import javax.print.attribute.standard.Copies;  import javax.print.event.PrintJobAdapter; import javax.print.event.PrintJobEvent;  public class PrintText {    public static void main(String[] args) throws PrintException, IOException {      String defaultPrinter =        PrintServiceLookup.lookupDefaultPrintService().getName();     System.out.println(""Default printer: "" + defaultPrinter);     PrintService service = PrintServiceLookup.lookupDefaultPrintService();      // prints the famous hello world! plus a form feed     InputStream is = new ByteArrayInputStream(""hello world!\f"".getBytes(""UTF8""));      PrintRequestAttributeSet  pras = new HashPrintRequestAttributeSet();     pras.add(new Copies(1));      DocFlavor flavor = DocFlavor.INPUT_STREAM.AUTOSENSE;     Doc doc = new SimpleDoc(is, flavor, null);     DocPrintJob job = service.createPrintJob();      PrintJobWatcher pjw = new PrintJobWatcher(job);     job.print(doc, pras);     pjw.waitForDone();     is.close();   } }  class PrintJobWatcher {   boolean done = false;    PrintJobWatcher(DocPrintJob job) {     job.addPrintJobListener(new PrintJobAdapter() {       public void printJobCanceled(PrintJobEvent pje) {         allDone();       }       public void printJobCompleted(PrintJobEvent pje) {         allDone();       }       public void printJobFailed(PrintJobEvent pje) {         allDone();       }       public void printJobNoMoreEvents(PrintJobEvent pje) {         allDone();       }       void allDone() {         synchronized (PrintJobWatcher.this) {           done = true;           System.out.println(""Printing done ..."");           PrintJobWatcher.this.notify();         }       }     });   }   public synchronized void waitForDone() {     try {       while (!done) {         wait();       }     } catch (InterruptedException e) {     }   } }"
"import java.io.IOException; import java.io.OutputStream;  import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import jxl.Workbook; import jxl.write.Label; import jxl.write.WritableSheet; import jxl.write.WritableWorkbook;  public class Sample extends HttpServlet {  public void doGet(HttpServletRequest request, HttpServletResponse response)  throws ServletException, IOException  {   OutputStream out = null;   try   {    response.setContentType(""application/vnd.ms-excel"");    response.setHeader(""Content-Disposition"", ""attachment; filename=sampleName.xls"");    WritableWorkbook w = Workbook.createWorkbook(response.getOutputStream());    WritableSheet s = w.createSheet(""Demo"", 0);    s.addCell(new Label(0, 0, ""Hello World""));    w.write();    w.close();   } catch (Exception e)   {    throw new ServletException(""Exception in Excel Sample Servlet"", e);   } finally   {    if (out != null)     out.close();   }  } }"
"package com.example;  import java.io.IOException; import java.io.PrintWriter; import java.util.ArrayList; import java.util.Enumeration; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.regex.Pattern;  import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse;  /**  * Applies search and replace patterns. To initialize this filter, the  * param-names should be ""search1"", ""replace1"", ""search2"", ""replace2"", etc.  */ public final class RegexFilter implements Filter {     private List&lt;Pattern&gt; searchPatterns;     private List&lt;String&gt; replaceStrings;      /**      * Finds the search and replace strings in the configuration file. Looks for      * matching searchX and replaceX parameters.      */     public void init(FilterConfig filterConfig) {         Map&lt;String, String&gt; patternMap = new HashMap&lt;String, String&gt;();          // Walk through the parameters to find those whose names start with         // search         Enumeration&lt;String&gt; names = (Enumeration&lt;String&gt;) filterConfig.getInitParameterNames();         while (names.hasMoreElements()) {             String name = names.nextElement();             if (name.startsWith(""search"")) {                 patternMap.put(name.substring(6), filterConfig.getInitParameter(name));             }         }         this.searchPatterns = new ArrayList&lt;Pattern&gt;(patternMap.size());         this.replaceStrings = new ArrayList&lt;String&gt;(patternMap.size());          // Walk through the parameters again to find the matching replace params         names = (Enumeration&lt;String&gt;) filterConfig.getInitParameterNames();         while (names.hasMoreElements()) {             String name = names.nextElement();             if (name.startsWith(""replace"")) {                 String searchString = patternMap.get(name.substring(7));                 if (searchString != null) {                     this.searchPatterns.add(Pattern.compile(searchString));                     this.replaceStrings.add(filterConfig.getInitParameter(name));                 }             }         }     }      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {         // Wrap the response in a wrapper so we can get at the text after calling the next filter         PrintWriter out = response.getWriter();         CharResponseWrapper wrapper = new CharResponseWrapper((HttpServletResponse) response);         chain.doFilter(request, wrapper);          // Extract the text from the completed servlet and apply the regexes         String modifiedHtml = wrapper.toString();         for (int i = 0; i &lt; this.searchPatterns.size(); i++) {             modifiedHtml = this.searchPatterns.get(i).matcher(modifiedHtml).replaceAll(this.replaceStrings.get(i));         }          // Write our modified text to the real response         response.setContentLength(modifiedHtml.getBytes().length);         out.write(modifiedHtml);         out.close();     }      public void destroy() {         this.searchPatterns = null;         this.replaceStrings = null;     } }"
"package com.example;  import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream;  import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public class ZipFileServlet extends HttpServlet {      private static final int DEFAULT_BUFFER_SIZE = 10240; // 10KB.     private YourFileDAO yourFileDAO = YourDAOFactory.getYourFileDAO();      @Override     protected void doPost(HttpServletRequest request, HttpServletResponse response)         throws ServletException, IOException     {         String[] fileIds = request.getParameterValues(""fileId"");         response.setContentType(""application/zip"");         response.setHeader(""Content-Disposition"", ""attachment; filename=\""allfiles.zip\"""");         ZipOutputStream output = null;         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];          try {             output = new ZipOutputStream(new BufferedOutputStream(response.getOutputStream(), DEFAULT_BUFFER_SIZE));              for (String fileId : fileIds) {                 YourFileItem item = yourFileDAO.find(fileId);                 if (item == null) continue; // Handle yourself. The fileId may be wrong/spoofed.                 InputStream input = null;                  try {                     input = new BufferedInputStream(item.getInputStream(), DEFAULT_BUFFER_SIZE);                     output.putNextEntry(new ZipEntry(item.getName()));                     for (int length = 0; (length = input.read(buffer)) &gt; 0;) {                         output.write(buffer, 0, length);                     }                     output.closeEntry();                 } finally {                     if (input != null) try { input.close(); } catch (IOException logOrIgnore) { /**/ }                 }             }         } finally {             if (output != null) try { output.close(); } catch (IOException logOrIgnore) { /**/ }         }     }  }"
"import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.util.Enumeration; import java.util.HashMap; import java.util.Map;  import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  @WebServlet(name=""fooServlet"", urlPatterns=""/foo"") public class FooServlet extends HttpServlet {     @Override     protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         InputStream is = req.getInputStream();         ByteArrayOutputStream os = new ByteArrayOutputStream();         byte[] buf = new byte[32];         int r=0;         while( r &gt;= 0 ) {             r = is.read(buf);             if( r &gt;= 0 ) os.write(buf, 0, r);         }         String s = new String(os.toByteArray(), ""UTF-8"");         String decoded = URLDecoder.decode(s, ""UTF-8"");         System.err.println(""&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; DECODED: "" + decoded);          System.err.println(""================================"");          Enumeration&lt;String&gt; e = req.getParameterNames();         while( e.hasMoreElements() ) {             String ss = (String) e.nextElement();             System.err.println(""    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; "" + ss);         }          System.err.println(""================================"");          Map&lt;String,String&gt; map = makeQueryMap(s);         System.err.println(map);         //////////////////////////////////////////////////////////////////         //// HERE YOU CAN DO map.get(""id"") AND THE SENT VALUE WILL BE ////         //// RETURNED AS EXPECTED WITH request.getParameter(""id"")     ////         //////////////////////////////////////////////////////////////////          System.err.println(""================================"");          resp.setContentType(""application/json; charset=UTF-8"");         resp.getWriter().println(""{'result':true}"");     }      // Based on code from: http://www.coderanch.com/t/383310/java/java/parse-url-query-string-parameter     private static Map&lt;String, String&gt; makeQueryMap(String query) throws UnsupportedEncodingException {         String[] params = query.split(""&amp;"");         Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();         for( String param : params ) {             String[] split = param.split(""="");             map.put(URLDecoder.decode(split[0], ""UTF-8""), URLDecoder.decode(split[1], ""UTF-8""));         }         return map;     } }"
"package cz.literak.demo;  import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter;  public class JarServlet extends HttpServlet {      @Override     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         String path = request.getPathInfo();         setContentType(path, response);          InputStream streamIn = null;         try {             streamIn = getClass().getResourceAsStream(path);             PrintWriter writer = response.getWriter();             int c;             while ((c = streamIn.read()) != -1) {                 writer.write(c);             }         } catch (IOException e) {             streamIn.close();         }     }      private void setContentType(String path, HttpServletResponse response) {         if (path.toLowerCase().endsWith("".css"")) {             response.setContentType(""text/css"");         }         // TODO other mime types     } }"
"import java.io.BufferedReader; import java.io.ByteArrayInputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.lang.annotation.Annotation; import java.lang.reflect.Type;  import javax.servlet.ServletContext; import javax.ws.rs.Consumes; import javax.ws.rs.WebApplicationException; import javax.ws.rs.core.Context; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.MultivaluedMap; import javax.ws.rs.ext.MessageBodyReader; import javax.ws.rs.ext.Provider;  import org.codehaus.jackson.map.ObjectMapper;  import at.fhj.ase.dao.data.Address; import at.fhj.ase.xmlvalidation.msbreader.MessageBodyReaderValidationException;  import com.fasterxml.jackson.databind.JsonNode; import com.github.fge.jackson.JsonLoader; import com.github.fge.jsonschema.exceptions.ProcessingException; import com.github.fge.jsonschema.main.JsonSchemaFactory; import com.github.fge.jsonschema.main.JsonValidator; import com.github.fge.jsonschema.report.ProcessingReport;  @Provider @Consumes(MediaType.APPLICATION_JSON) public class AddressJsonValidationReader implements MessageBodyReader&lt;Address&gt; {      private final String jsonSchemaFileAsString;      public AddressJsonValidationReader(@Context ServletContext servletContext) {         this.jsonSchemaFileAsString = servletContext                 .getRealPath(""/json/Address.json"");     }      @Override     public boolean isReadable(Class&lt;?&gt; type, Type genericType,             Annotation[] annotations, MediaType mediaType) {         if (type == Address.class) {             return true;         }         return false;     }      @Override     public Address readFrom(Class&lt;Address&gt; type, Type genericType,             Annotation[] annotations, MediaType mediaType,             MultivaluedMap&lt;String, String&gt; httpHeaders, InputStream entityStream)             throws IOException, WebApplicationException {          final String jsonData = getStringFromInputStream(entityStream);         System.out.println(jsonData);          InputStream isSchema = new FileInputStream(jsonSchemaFileAsString);         String jsonSchema = getStringFromInputStream(isSchema);          /*          * Perform JSON data validation against schema          */         validateJsonData(jsonSchema, jsonData);          /*          * Convert stream to data entity          */         ObjectMapper m = new ObjectMapper();         Address addr = m.readValue(stringToStream(jsonData), Address.class);          return addr;     }      /**      * Validate the given JSON data against the given JSON schema      *       * @param jsonSchema      *            as String      * @param jsonData      *            as String      * @throws MessageBodyReaderValidationException      *             in case of an error during validation process      */     private void validateJsonData(final String jsonSchema, final String jsonData)             throws MessageBodyReaderValidationException {         try {             final JsonNode d = JsonLoader.fromString(jsonData);             final JsonNode s = JsonLoader.fromString(jsonSchema);              final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();             JsonValidator v = factory.getValidator();              ProcessingReport report = v.validate(s, d);             System.out.println(report);             if (!report.toString().contains(""success"")) {                 throw new MessageBodyReaderValidationException(                         report.toString());             }          } catch (IOException e) {             throw new MessageBodyReaderValidationException(                     ""Failed to validate json data"", e);         } catch (ProcessingException e) {             throw new MessageBodyReaderValidationException(                     ""Failed to validate json data"", e);         }     }      /**      * Taken from &lt;a href=      * ""http://www.mkyong.com/java/how-to-convert-inputstream-to-string-in-java/""      * &gt;www.mkyong.com&lt;/a&gt;      *       * @param is      *            {@link InputStream}      * @return Stream content as String      */     private String getStringFromInputStream(InputStream is) {         BufferedReader br = null;         StringBuilder sb = new StringBuilder();          String line;         try {              br = new BufferedReader(new InputStreamReader(is));             while ((line = br.readLine()) != null) {                 sb.append(line);             }          } catch (IOException e) {             e.printStackTrace();         } finally {             if (br != null) {                 try {                     br.close();                 } catch (IOException e) {                     e.printStackTrace();                 }             }         }          return sb.toString();     }      private InputStream stringToStream(final String str) throws UnsupportedEncodingException {         return new ByteArrayInputStream(str.getBytes(""UTF-8""));     }  }"
"import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Iterator;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.apache.poi.hssf.usermodel.HSSFCell; import org.apache.poi.hssf.usermodel.HSSFRichTextString; import org.apache.poi.hssf.usermodel.HSSFRow; import org.apache.poi.hssf.usermodel.HSSFSheet; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.poifs.filesystem.POIFSFileSystem; import org.w3c.dom.Document; import org.w3c.dom.Element;  public class POIExcelReader {  public POIExcelReader (){ }  public void displayFromExcel (String xlsPath) {     InputStream inputStream = null;      try     {         inputStream = new FileInputStream (xlsPath);     }     catch (FileNotFoundException e)     {         System.out.println (""File not found in the specified path."");         e.printStackTrace ();     }      POIFSFileSystem fileSystem = null;      try {         //Initializing the XML document         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();         DocumentBuilder builder = factory.newDocumentBuilder();         Document document = builder.newDocument();         Element rootElement = document.createElement(""products"");         document.appendChild(rootElement);           fileSystem = new POIFSFileSystem (inputStream);         HSSFWorkbook      workBook = new HSSFWorkbook (fileSystem);         HSSFSheet         sheet    = workBook.getSheetAt (0);          Iterator&lt;?&gt; rows     = sheet.rowIterator ();          ArrayList&lt;ArrayList&lt;String&gt;&gt; data = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();         while (rows.hasNext ())          {             HSSFRow row = (HSSFRow) rows.next();               int rowNumber = row.getRowNum ();             // display row number             System.out.println (""Row No.: "" + rowNumber);              // get a row, iterate through cells.             Iterator&lt;?&gt; cells = row.cellIterator ();               ArrayList&lt;String&gt; rowData = new ArrayList&lt;String&gt;();             while (cells.hasNext ())             {                 HSSFCell cell = (HSSFCell) cells.next ();                 //System.out.println (""Cell : "" + cell.getCellNum ());                 switch (cell.getCellType ())                 {                 case HSSFCell.CELL_TYPE_NUMERIC :                 {                     // NUMERIC CELL TYPE                     System.out.println (""Numeric: "" + cell.getNumericCellValue ());                     rowData.add(cell.getNumericCellValue () + """");                     break;                 }                 case HSSFCell.CELL_TYPE_STRING :                  {                     // STRING CELL TYPE                     HSSFRichTextString richTextString = cell.getRichStringCellValue ();                      System.out.println (""String: "" + richTextString.getString ());                     rowData.add(richTextString.getString ());                     break;                 }                 default:                 {                     // types other than String and Numeric.                     System.out.println (""Type not supported."");                     break;                 }                 } // end switch              } // end while             data.add(rowData);           } //end while          int numOfProduct = data.size();          for (int i = 1; i &lt; numOfProduct; i++){             Element productElement = document.createElement(""product"");             rootElement.appendChild(productElement);              int index = 0;             for(String s: data.get(i)) {                 String headerString = data.get(0).get(index);                 if( data.get(0).get(index).equals(""image link"") ){                     headerString = ""image_link"";                 }                  if( data.get(0).get(index).equals(""product type"") ){                     headerString = ""product_type"";                 }                  Element headerElement = document.createElement(headerString);                 productElement.appendChild(headerElement);                 headerElement.appendChild(document.createTextNode(s));                 index++;             }         }          TransformerFactory tFactory = TransformerFactory.newInstance();          Transformer transformer = tFactory.newTransformer();         //Add indentation to output         transformer.setOutputProperty         (OutputKeys.INDENT, ""yes"");         transformer.setOutputProperty(                 ""{http://xml.apache.org/xslt}indent-amount"", ""2"");          DOMSource source = new DOMSource(document);         StreamResult result = new StreamResult(new File(""products.xml""));         //StreamResult result = new StreamResult(System.out);         transformer.transform(source, result);      }     catch(IOException e)     {         System.out.println(""IOException "" + e.getMessage());     } catch (ParserConfigurationException e) {         System.out.println(""ParserConfigurationException "" + e.getMessage());     } catch (TransformerConfigurationException e) {         System.out.println(""TransformerConfigurationException ""+ e.getMessage());     } catch (TransformerException e) {         System.out.println(""TransformerException "" + e.getMessage());     } }   public static void main (String[] args) {     POIExcelReader poiExample = new POIExcelReader ();     String xlsPath =""products.xls"";     poiExample.displayFromExcel (xlsPath); } }"
"package com.me;  import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public class EmpServlet extends HttpServlet {     @Override     protected void doPost(HttpServletRequest request, HttpServletResponse response)             throws ServletException, IOException {          PrintWriter pw=response.getWriter();          Emp emp=(Emp)request.getAttribute(""emp"");          pw.print(emp);     } }"
"import javax.jms.Connection; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.MessageProducer; import javax.jms.Session; import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener;  import org.apache.activemq.ActiveMQConnectionFactory; import org.apache.log4j.Logger;  public class MyContextListener implements ServletContextListener {     public final static String ACTIVE_MQ_SESSION = ""ActiveMQSession"";     public final static String ACTIVE_MQ_PRODUCER = ""ActiveMQProducer"";      Logger logger = Logger.getLogger(this.getClass());     private static final int ackMode = Session.AUTO_ACKNOWLEDGE;     private static final boolean transacted = false;      private static final String brokerUrl = ""vm://localhost:61616"";      private Connection connection;     private Session session;     private MessageProducer producer;      @Override     public void contextDestroyed(ServletContextEvent sce) {         try {             this.producer.close();             this.session.close();             this.connection.close();         } catch (JMSException e) {             logger.warn(""tearDown()"", e);         }      }      @Override     public void contextInitialized(ServletContextEvent sce) {         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(                 brokerUrl);          try {             connection = connectionFactory.createConnection();             connection.start();             session = connection.createSession(transacted, ackMode);             Destination destination = session.createQueue(""queue"");             producer = session.createProducer(destination);              ServletContext sc = sce.getServletContext();             sc.setAttribute(ACTIVE_MQ_SESSION, session);             sc.setAttribute(ACTIVE_MQ_PRODUCER, producer);         } catch (JMSException e) {             logger.warn(""setup() failed to setup connection brokerUrl=""                     + brokerUrl);         }     }  }"
"import javax.servlet.FilterChain import javax.servlet.http.HttpServletRequest import javax.servlet.http.HttpServletResponse import javax.servlet.ServletException import javax.servlet.ServletRequest import javax.servlet.ServletResponse import org.springframework.context.ApplicationEventPublisher import org.springframework.context.ApplicationEventPublisherAware import org.springframework.security.authentication.UsernamePasswordAuthenticationToken import org.springframework.security.core.Authentication import org.springframework.security.core.AuthenticationException import org.springframework.security.core.context.SecurityContextHolder import org.springframework.web.filter.GenericFilterBean  class CustomRememberMeAuthenticationFilter extends GenericFilterBean implements ApplicationEventPublisherAware {      def authenticationManager     def eventPublisher     def customService     def rememberMeServices     def springSecurityService      //make certain that we've specified our beans     void afterPropertiesSet() {         assert authenticationManager != null, 'authenticationManager must be specified'         assert customService != null, 'customService must be specified'         assert rememberMeServices != null, 'rememberMeServices must be specified'     }      void doFilter(ServletRequest req, ServletResponse res, FilterChain chain) throws IOException, ServletException {         HttpServletRequest request = (HttpServletRequest) req         HttpServletResponse response = (HttpServletResponse) res          if (SecurityContextHolder.getContext().getAuthentication() == null) {                        Authentication auth             try {                 auth = customService.getUsernamePasswordAuthenticationToken(request)                 if (auth != null) {                     springSecurityService.reauthenticate(auth.getPrincipal(), auth.getCredentials())                     logger.debug(""SecurityContextHolder populated with auth: '""                         + SecurityContextHolder.getContext().getAuthentication() + ""'"")                     onSuccessfulAuthentication(request, response, SecurityContextHolder.getContext().getAuthentication())                 } else {                     logger.debug('customService did not return an authentication from the request')                 }             } catch (AuthenticationException authenticationException) {                 logger.warn(""SecurityContextHolder not populated with auth, as ""                     + ""springSecurityService rejected Authentication returned by customService: '""                     + auth + ""'"", authenticationException)                 onUnsuccessfulAuthentication(request, response, auth)             } catch(e) {                 logger.warn(""Unsuccessful authentication in customRememberMeAuthenticationFilter"", e)                 onUnsuccessfulAuthentication(request, response, auth)             }         } else {             logger.debug(""SecurityContextHolder not populated with auth, as it already contained: '""                 + SecurityContextHolder.getContext().getAuthentication() + ""'"")         }         chain.doFilter(request, response)     }      protected void onSuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, Authentication authResult) {         //sets the rememberMe cookie, but cannot call ""loginSuccess"" because that filters out requests         //that don't set the rememberMe cookie, like this one         rememberMeServices.onLoginSuccess(request, response, authResult)     }      protected void onUnsuccessfulAuthentication(HttpServletRequest request, HttpServletResponse response, AuthenticationException failed) {         //clear the rememberMe cookie         rememberMeServices.loginFail(request, response)     }      public void setApplicationEventPublisher(ApplicationEventPublisher eventPublisher) {         this.eventPublisher = eventPublisher     } }"
"import java.io.ByteArrayOutputStream;     import java.io.File;     import java.io.FileInputStream;     import java.io.FileOutputStream;     import java.io.IOException;     import java.io.InputStream;     import java.io.InputStreamReader;     import java.io.OutputStream;     import java.io.PrintWriter;      import javax.xml.bind.JAXBContext;     import javax.xml.bind.Marshaller;     import javax.xml.bind.Unmarshaller;     import javax.xml.bind.annotation.XmlRootElement;      import com.google.gson.Gson;     import com.google.gson.GsonBuilder;      @XmlRootElement(name = ""Fruit"")     public class Fruit {          public final static String  XML_FILE    = ""fruit.xml"";         public final static String  JSON_FILE   = ""fruit.json"";          public static Fruit fromJson(InputStream in) {             Gson gson = new GsonBuilder().create();             Fruit result = gson.fromJson(new InputStreamReader(in), Fruit.class);             return result;         }          public static Fruit fromXML(InputStream in) throws Exception {             JAXBContext context = JAXBContext.newInstance(Fruit.class);             Unmarshaller um = context.createUnmarshaller();             return (Fruit) um.unmarshal(in);         }          public static void main(String[] args) throws Exception {              Fruit f = new Fruit(""Apple"", ""Red"", ""Sweet"");             Fruit f2 = new Fruit(""Durian"", ""White"", ""Don't ask"");              System.out.println(f.toXML());             System.out.println(f2.toJSON());              f.saveXML(new FileOutputStream(new File(XML_FILE)));             f2.saveJSON(new FileOutputStream(new File(JSON_FILE)));              Fruit f3 = Fruit.fromXML(new FileInputStream(new File(XML_FILE)));             System.out.println(f3.toJSON());              Fruit f4 = Fruit.fromJson(new FileInputStream(new File(JSON_FILE)));             System.out.println(f4.toXML());          }          private String  name;         private String  color;         private String  taste;          public Fruit() {             // Default constructor         }          public Fruit(final String name, final String color, final String taste) {             this.name = name;             this.color = color;             this.taste = taste;         }          /**          * @return the color          */         public final String getColor() {             return this.color;         }          /**          * @return the name          */         public final String getName() {             return this.name;         }          /**          * @return the taste          */         public final String getTaste() {             return this.taste;         }          public void saveJSON(OutputStream out) throws IOException {             GsonBuilder gb = new GsonBuilder();             gb.setPrettyPrinting();             gb.disableHtmlEscaping();             Gson gson = gb.create();             PrintWriter writer = new PrintWriter(out);             gson.toJson(this, writer);             writer.flush();             writer.close();         }          public void saveXML(OutputStream out) throws Exception {             JAXBContext context = JAXBContext.newInstance(Fruit.class);             Marshaller m = context.createMarshaller();             m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);             m.marshal(this, out);         }          /**          * @param color          *            the color to set          */         public final void setColor(String color) {             this.color = color;         }          /**          * @param name          *            the name to set          */         public final void setName(String name) {             this.name = name;         }          /**          * @param taste          *            the taste to set          */         public final void setTaste(String taste) {             this.taste = taste;         }          public String toJSON() throws IOException {             GsonBuilder gb = new GsonBuilder();             gb.setPrettyPrinting();             gb.disableHtmlEscaping();             Gson gson = gb.create();             return gson.toJson(this, Fruit.class);         }          public String toXML() throws Exception {             ByteArrayOutputStream out = new ByteArrayOutputStream();             JAXBContext context = JAXBContext.newInstance(Fruit.class);             Marshaller m = context.createMarshaller();             m.setProperty(Marshaller.JAXB_FORMATTED_OUTPUT, Boolean.TRUE);             m.marshal(this, out);             return out.toString();         }      }"
"package com.ziesemer.test;  import java.io.Closeable; import java.io.IOException; import java.io.InputStream; import java.net.JarURLConnection; import java.net.URL; import java.util.jar.JarEntry; import java.util.jar.JarFile;  import javax.media.Duration; import javax.media.MediaLocator; import javax.media.Time; import javax.media.protocol.ContentDescriptor; import javax.media.protocol.PullDataSource; import javax.media.protocol.PullSourceStream; import javax.media.protocol.Seekable;  /**  * @author Mark A. Ziesemer  *  &lt;a href=""http://www.ziesemer.com.""&gt;&amp;lt;www.ziesemer.com&amp;gt;&lt;/a&gt;  */ public class JarDataSource extends PullDataSource{      protected JarURLConnection conn;     protected ContentDescriptor contentType;     protected JarPullSourceStream[] sources;     protected boolean connected;      public JarDataSource(URL url) throws IOException{         setLocator(new MediaLocator(url));         connected = false;     }      @Override     public PullSourceStream[] getStreams(){         return sources;     }      @Override     public void connect() throws IOException{         conn = (JarURLConnection)getLocator().getURL().openConnection();         conn.connect();         connected = true;          JarFile jf = conn.getJarFile();         JarEntry je = jf.getJarEntry(conn.getEntryName());          String mimeType = conn.getContentType();         if(mimeType == null){             mimeType = ContentDescriptor.CONTENT_UNKNOWN;         }         contentType = new ContentDescriptor(ContentDescriptor.mimeTypeToPackageName(mimeType));          sources = new JarPullSourceStream[1];         sources[0] = new JarPullSourceStream(jf, je, contentType);     }      @Override     public String getContentType(){         return contentType.getContentType();     }      @Override     public void disconnect(){         if(connected){             try{                 sources[0].close();             }catch(IOException e){                 e.printStackTrace();             }             connected = false;         }     }      @Override     public void start() throws IOException{         // Nothing to do.     }      @Override     public void stop() throws IOException{         // Nothing to do.     }      @Override     public Time getDuration(){         return Duration.DURATION_UNKNOWN;     }      @Override     public Object[] getControls(){         return new Object[0];     }      @Override     public Object getControl(String controlName){         return null;     }      protected class JarPullSourceStream implements PullSourceStream, Seekable, Closeable{          protected final JarFile jarFile;         protected final JarEntry jarEntry;         protected final ContentDescriptor type;          protected InputStream stream;         protected long position;          public JarPullSourceStream(JarFile jarFile, JarEntry jarEntry, ContentDescriptor type) throws IOException{             this.jarFile = jarFile;             this.jarEntry = jarEntry;             this.type = type;             this.stream = jarFile.getInputStream(jarEntry);         }          @Override         public ContentDescriptor getContentDescriptor(){             return type;         }          @Override         public long getContentLength(){             return jarEntry.getSize();         }          @Override         public boolean endOfStream(){             return position &lt; getContentLength();         }          @Override         public Object[] getControls(){             return new Object[0];         }          @Override         public Object getControl(String controlType){             return null;         }          @Override         public boolean willReadBlock(){             if(endOfStream()){                 return true;             }             try{                 return stream.available() == 0;             }catch(IOException e){                 return true;             }         }          @Override         public int read(byte[] buffer, int offset, int length) throws IOException{             int read = stream.read(buffer, offset, length);             position += read;             return read;         }          @Override         public long seek(long where){             try{                 if(where &lt; position){                     stream.close();                     stream = jarFile.getInputStream(jarEntry);                     position = 0;                 }                 long skip = where - position;                 while(skip &gt; 0){                     long skipped = stream.skip(skip);                     skip -= skipped;                     position += skipped;                 }             }catch(IOException ioe){                 // Made a best effort.                 ioe.printStackTrace();             }             return position;         }          @Override         public long tell(){             return position;         }          @Override         public boolean isRandomAccess(){             return true;         }          @Override         public void close() throws IOException{             try{                 stream.close();             }finally{                 jarFile.close();             }         }      }  }"
"package ebay;  import java.io.ByteArrayInputStream; import java.io.InputStream; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathFactory; import org.w3c.dom.Document; import org.w3c.dom.Node; import org.w3c.dom.NodeList;  import ebay.URLReader;  /**  *  * @author rajeev jha (xxx@yyy.com)  *  */ public class EbayDriver {      public final static String EBAY_APP_ID = ""xxxxxxxxxxxxxxxxxxxxxxxxxxxx"";     public final static String EBAY_FINDING_SERVICE_URI = ""http://svcs.ebay.com/services/search/FindingService/v1?OPERATION-NAME=""             + ""{operation}&amp;SERVICE-VERSION={version}&amp;SECURITY-APPNAME=""             + ""{applicationId}&amp;GLOBAL-ID={globalId}&amp;keywords={keywords}""             + ""&amp;paginationInput.entriesPerPage={maxresults}"";     public static final String SERVICE_VERSION = ""1.0.0"";     public static final String OPERATION_NAME = ""findItemsByKeywords"";     public static final String GLOBAL_ID = ""EBAY-US"";     public final static int REQUEST_DELAY = 3000;     public final static int MAX_RESULTS = 10;     private int maxResults;      public EbayDriver() {         this.maxResults = MAX_RESULTS;      }      public EbayDriver(int maxResults) {         this.maxResults = maxResults;     }      public String getName() {         return IDriver.EBAY_DRIVER;     }      public void run(String tag) throws Exception {          String address = createAddress(tag);         print(""sending request to :: "", address);         String response = URLReader.read(address);         print(""response :: "", response);         //process xml dump returned from EBAY         processResponse(response);         //Honor rate limits - wait between results         Thread.sleep(REQUEST_DELAY);       }      private String createAddress(String tag) {          //substitute token         String address = EbayDriver.EBAY_FINDING_SERVICE_URI;         address = address.replace(""{version}"", EbayDriver.SERVICE_VERSION);         address = address.replace(""{operation}"", EbayDriver.OPERATION_NAME);         address = address.replace(""{globalId}"", EbayDriver.GLOBAL_ID);         address = address.replace(""{applicationId}"", EbayDriver.EBAY_APP_ID);         address = address.replace(""{keywords}"", tag);         address = address.replace(""{maxresults}"", """" + this.maxResults);          return address;      }      private void processResponse(String response) throws Exception {           XPath xpath = XPathFactory.newInstance().newXPath();         InputStream is = new ByteArrayInputStream(response.getBytes(""UTF-8""));         DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();         DocumentBuilder builder = domFactory.newDocumentBuilder();           Document doc = builder.parse(is);         XPathExpression ackExpression = xpath.compile(""//findItemsByKeywordsResponse/ack"");         XPathExpression itemExpression = xpath.compile(""//findItemsByKeywordsResponse/searchResult/item"");          String ackToken = (String) ackExpression.evaluate(doc, XPathConstants.STRING);         print(""ACK from ebay API :: "", ackToken);         if (!ackToken.equals(""Success"")) {             throw new Exception("" service returned an error"");         }          NodeList nodes = (NodeList) itemExpression.evaluate(doc, XPathConstants.NODESET);          for (int i = 0; i &lt; nodes.getLength(); i++) {              Node node = nodes.item(i);              String itemId = (String) xpath.evaluate(""itemId"", node, XPathConstants.STRING);             String title = (String) xpath.evaluate(""title"", node, XPathConstants.STRING);             String itemUrl = (String) xpath.evaluate(""viewItemURL"", node, XPathConstants.STRING);             String galleryUrl = (String) xpath.evaluate(""galleryURL"", node, XPathConstants.STRING);              String currentPrice = (String) xpath.evaluate(""sellingStatus/currentPrice"", node, XPathConstants.STRING);              print(""currentPrice"", currentPrice);             print(""itemId"", itemId);             print(""title"", title);             print(""galleryUrl"", galleryUrl);          }          is.close();      }      private void print(String name, String value) {         System.out.println(name + ""::"" + value);     }      public static void main(String[] args) throws Exception {         EbayDriver driver = new EbayDriver();         String tag = ""Velo binding machine"";         driver.run(java.net.URLEncoder.encode(tag, ""UTF-8""));      } }"
"package inlinecompiler;  import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; import java.net.URL; import java.net.URLClassLoader; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import javax.tools.Diagnostic; import javax.tools.DiagnosticCollector; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.StandardJavaFileManager; import javax.tools.ToolProvider;  public class InlineCompiler {      public static void main(String[] args) {         StringBuilder sb = new StringBuilder(64);         sb.append(""package testcompile;\n"");         sb.append(""public class HelloWorld implements inlinecompiler.InlineCompiler.DoStuff {\n"");         sb.append(""    public void doStuff() {\n"");         sb.append(""        System.out.println(\""Hello world\"");\n"");         sb.append(""    }\n"");         sb.append(""}\n"");          File helloWorldJava = new File(""testcompile/HelloWorld.java"");         if (helloWorldJava.getParentFile().exists() || helloWorldJava.getParentFile().mkdirs()) {              try {                 Writer writer = null;                 try {                     writer = new FileWriter(helloWorldJava);                     writer.write(sb.toString());                     writer.flush();                 } finally {                     try {                         writer.close();                     } catch (Exception e) {                     }                 }                  /** Compilation Requirements *********************************************************************************************/                 DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();                 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();                 StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);                  // This sets up the class path that the compiler will use.                 // I've added the .jar file that contains the DoStuff interface within in it...                 List&lt;String&gt; optionList = new ArrayList&lt;String&gt;();                 optionList.add(""-classpath"");                 optionList.add(System.getProperty(""java.class.path"") + File.pathSeparator + ""dist/InlineCompiler.jar"");                  Iterable&lt;? extends JavaFileObject&gt; compilationUnit                         = fileManager.getJavaFileObjectsFromFiles(Arrays.asList(helloWorldJava));                 JavaCompiler.CompilationTask task = compiler.getTask(                     null,                      fileManager,                      diagnostics,                      optionList,                      null,                      compilationUnit);                 /********************************************************************************************* Compilation Requirements **/                 if (task.call()) {                     /** Load and execute *************************************************************************************************/                     System.out.println(""Yipe"");                     // Create a new custom class loader, pointing to the directory that contains the compiled                     // classes, this should point to the top of the package structure!                     URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(""./"").toURI().toURL()});                     // Load the class from the classloader by name....                     Class&lt;?&gt; loadedClass = classLoader.loadClass(""testcompile.HelloWorld"");                     // Create a new instance...                     Object obj = loadedClass.newInstance();                     // Santity check                     if (obj instanceof DoStuff) {                         // Cast to the DoStuff interface                         DoStuff stuffToDo = (DoStuff)obj;                         // Run it baby                         stuffToDo.doStuff();                     }                     /************************************************************************************************* Load and execute **/                 } else {                     for (Diagnostic&lt;? extends JavaFileObject&gt; diagnostic : diagnostics.getDiagnostics()) {                         System.out.format(""Error on line %d in %s%n"",                                 diagnostic.getLineNumber(),                                 diagnostic.getSource().toUri());                     }                 }                 fileManager.close();             } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException exp) {                 exp.printStackTrace();             }         }     }      public static interface DoStuff {          public void doStuff();     }  }"
"import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathExpressionException; import javax.xml.xpath.XPathFactory; import org.w3c.dom.Document; import org.w3c.dom.Node; import org.w3c.dom.NodeList; import org.xml.sax.SAXException;  public class XPathTest {      public static void main(String[] args) {          InputStream is = null;          try {             is = new FileInputStream(""Soap.xml"");              DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();             dbf.setNamespaceAware(false);             Document doc = dbf.newDocumentBuilder().parse(is);              XPathFactory xf = XPathFactory.newInstance();             XPath xPath = xf.newXPath();              // Find direction ANY where within the document...              XPathExpression xExp = xPath.compile(""//Direction"");             NodeList nl = (NodeList) xExp.evaluate(doc, XPathConstants.NODESET);             for (int index = 0; index &lt; nl.getLength(); index++) {                 Node node = nl.item(index);                 System.out.println(node.getTextContent());             }              // Find the direction node's any where in the document             // where it's a child of Route, which has a child             // node called RouteNo with the text value of 'int'...             xExp = xPath.compile(""//Route[RouteNo = 'int']/Direction"");             nl = (NodeList) xExp.evaluate(doc, XPathConstants.NODESET);             for (int index = 0; index &lt; nl.getLength(); index++) {                 Node node = nl.item(index);                 System.out.println(node.getTextContent());             }          } catch (ParserConfigurationException | SAXException | IOException | XPathExpressionException exp) {             exp.printStackTrace();         }     } }"
"import java.io.IOException; import java.io.InputStream; import java.lang.annotation.Annotation; import java.lang.reflect.Type; import java.net.URL;  import javax.ws.rs.Consumes; import javax.ws.rs.WebApplicationException; import javax.ws.rs.core.Context; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.MultivaluedMap; import javax.ws.rs.ext.ContextResolver; import javax.ws.rs.ext.MessageBodyReader; import javax.ws.rs.ext.Provider; import javax.ws.rs.ext.Providers; import javax.xml.XMLConstants; import javax.xml.bind.JAXBContext; import javax.xml.bind.JAXBException; import javax.xml.bind.Unmarshaller; import javax.xml.validation.Schema; import javax.xml.validation.SchemaFactory;  @Provider @Consumes(""application/xml"") public class ValidatingReader implements MessageBodyReader&lt;Customer&gt; {      @Context     protected Providers providers;      private Schema schema;      public ValidatingReader() {         try {             SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);             URL schemaURL = null;             schema = sf.newSchema(schemaURL);         } catch(Exception e) {             throw new RuntimeException(e);         }     }      public boolean isReadable(Class&lt;?&gt; arg0, Type arg1, Annotation[] arg2, MediaType arg3) {         return arg0 == Customer.class;     }      public Customer readFrom(Class&lt;Customer&gt; arg0, Type arg1, Annotation[] arg2, MediaType arg3, MultivaluedMap&lt;String, String&gt; arg4, InputStream arg5)             throws IOException, WebApplicationException {         try {             JAXBContext jaxbContext = null;             ContextResolver&lt;JAXBContext&gt; resolver = providers.getContextResolver(JAXBContext.class, arg3);             if(null != resolver) {                 jaxbContext = resolver.getContext(arg0);             }             if(null == jaxbContext) {                 jaxbContext = JAXBContext.newInstance(arg0);             }             Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();             unmarshaller.setSchema(schema);             return (Customer) unmarshaller.unmarshal(arg5);         } catch(JAXBException e) {             throw new RuntimeException(e);         }     }  }"
"import javax.servlet.http.HttpSessionActivationListener; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionBindingEvent; import javax.servlet.http.HttpSessionBindingListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener;  public class SessionListener implements HttpSessionListener, HttpSessionAttributeListener, HttpSessionBindingListener, HttpSessionActivationListener {  public void valueBound(HttpSessionBindingEvent event) {     System.out.println(""valueBound: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void valueUnbound(HttpSessionBindingEvent event) {     System.out.println(""valueUnbound: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void attributeAdded(HttpSessionBindingEvent event) {     System.out.println(""attributeAdded: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void attributeRemoved(HttpSessionBindingEvent event) {     System.out.println(""attributeRemoved: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void attributeReplaced(HttpSessionBindingEvent event) {     System.out.println(""attributeReplaced: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void sessionCreated(HttpSessionEvent event) {     System.out.println(""sessionCreated: "" + event.getSession().getId());     this.printStackTrace(); }  public void sessionDestroyed(HttpSessionEvent event) {     System.out.println(""sessionDestroyed: "" + event.getSession().getId());     this.printStackTrace(); }  public void sessionDidActivate(HttpSessionEvent event) {     System.out.println(""sessionDidActivate: "" + event.getSession().getId());     this.printStackTrace(); }  @Override public void sessionWillPassivate(HttpSessionEvent event) {     System.out.println(""sessionWillPassivate: "" + event.getSession().getId());     this.printStackTrace(); }  private void printStackTrace() {     try {         if (true) {             throw new Exception();         }     } catch (Exception e) {         e.printStackTrace();     } } }"
"import javax.imageio.ImageIO; import javax.imageio.ImageReader; import javax.imageio.event.IIOReadProgressListener; import javax.imageio.stream.ImageInputStream; import java.io.File; import java.util.Iterator; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.atomic.AtomicInteger;  class MultipleJPEGDecoding {     private static int threads = Runtime.getRuntime().availableProcessors();     private static ExecutorService executorService = Executors.newFixedThreadPool(threads * 4);      public static void main(final String[] args) throws InterruptedException {         for (int i = 0; i &lt; 100; i++) {             final int index = i;              executorService.submit(new Runnable() {                 public void run() {                     try {                         ImageInputStream stream = ImageIO.createImageInputStream(new File(args[index % args.length]));                         try {                             Iterator&lt;ImageReader&gt; readers = ImageIO.getImageReaders(stream);                             if (!readers.hasNext()) {                                 System.err.println(&quot;No reader!&quot;);                                 return;                             }                              ImageReader reader = readers.next();                             reader.setInput(stream);                             reader.addIIOReadProgressListener(new ProgressListener(index));                              try {                                 reader.read(0);                             }                             finally {                                 reader.dispose();                             }                         }                         finally {                             stream.close();                         }                     }                     catch (Exception e) {                         System.err.printf(&quot;Error reading %d\n&quot;, index);                         e.printStackTrace();                     }                 }             });         }          executorService.shutdown();     }      static class ProgressListener implements IIOReadProgressListener {         final static AtomicInteger simultaneous = new AtomicInteger(0);          final int index;         int nextProgress = 25;          public ProgressListener(int index) {             this.index = index;         }          public void imageStarted(ImageReader source, int imageIndex) {             int inProgress = simultaneous.incrementAndGet();             System.err.printf(&quot;Started reading image %d (now decoding %d images simultaneous)...\n&quot;, index, inProgress);         }          public void imageComplete(ImageReader source) {             int inProgress = simultaneous.decrementAndGet();             System.err.printf(&quot;Done reading image %d%s.\n&quot;, index, inProgress &gt; 0 ? String.format(&quot; (still decoding %d other images)&quot;, inProgress) : &quot;&quot;);         }          public void imageProgress(ImageReader source, float percentageDone) {             if (percentageDone &gt; nextProgress) {                 int inProgress = simultaneous.get();                 System.err.printf(&quot;Progress on image %d (now decoding %d images simultaneous)...\n&quot;, index, inProgress);                 nextProgress += 25;             }         }          public void sequenceStarted(ImageReader source, int minIndex) {         }          public void sequenceComplete(ImageReader source) {         }          public void thumbnailStarted(ImageReader source, int imageIndex, int thumbnailIndex) {         }          public void thumbnailProgress(ImageReader source, float percentageDone) {         }          public void thumbnailComplete(ImageReader source) {         }          public void readAborted(ImageReader source) {         }     } }"
"import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.StringWriter;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathExpressionException; import javax.xml.xpath.XPathFactory;  import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.xml.sax.SAXException;  public class XmlXPathReplace {      public static void main(final String[] args) throws SAXException, IOException, ParserConfigurationException,             XPathExpressionException, TransformerException {         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();         factory.setNamespaceAware(true); // never forget this!         DocumentBuilder builder = factory.newDocumentBuilder();          // step 1.         Document doc = builder.parse(new ByteArrayInputStream(( //                 ""&lt;?xml version=\""1.0\""?&gt;"" + //                         ""&lt;people&gt;"" + //                         ""&lt;person&gt;&lt;name&gt;First Person Name&lt;/name&gt;&lt;/person&gt;"" + //                         ""&lt;person&gt;&lt;name&gt;Second Person Name&lt;/name&gt;&lt;/person&gt;"" + //                         ""&lt;/people&gt;"" //                 ).getBytes()));          // step 2         String fragment = ""&lt;name&gt;Changed Name&lt;/name&gt;"";         Document fragmentDoc = builder.parse(new ByteArrayInputStream(fragment.getBytes()));          // step 3         Node injectedNode = doc.adoptNode(fragmentDoc.getFirstChild());          // step 4         XPath xPath = XPathFactory.newInstance().newXPath();         XPathExpression expr = xPath.compile(""//people/person[2]/name"");         System.out.println();         Element nodeFound = (Element) expr.evaluate(doc, XPathConstants.NODE);          // step 5         Node parentNode = nodeFound.getParentNode();         parentNode.removeChild(nodeFound);         parentNode.appendChild(injectedNode);          DOMSource domSource = new DOMSource(doc);         Transformer transformer = TransformerFactory.newInstance().newTransformer();         StreamResult result = new StreamResult(new StringWriter());         transformer.transform(domSource, result);         System.out.println(result.getWriter().toString());     }  }"
"import java.io.IOException; import java.io.PrintWriter; import java.io.StringWriter; import java.lang.reflect.InvocationTargetException; import java.net.URI; import java.util.Arrays;  import javax.tools.Diagnostic; import javax.tools.DiagnosticCollector; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.SimpleJavaFileObject; import javax.tools.ToolProvider; import javax.tools.JavaCompiler.CompilationTask; import javax.tools.JavaFileObject.Kind;  public class CompileSourceInMemory {   public static void main(String args[]) throws IOException {     JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();     DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();      StringWriter writer = new StringWriter();     PrintWriter out = new PrintWriter(writer);     out.println(""public class HelloWorld {"");     out.println(""  public static void main(String args[]) {"");     out.println(""    System.out.println(\""This is in another java file\"");"");         out.println(""  }"");     out.println(""}"");     out.close();     JavaFileObject file = new JavaSourceFromString(""HelloWorld"", writer.toString());      Iterable&lt;? extends JavaFileObject&gt; compilationUnits = Arrays.asList(file);     CompilationTask task = compiler.getTask(null, null, diagnostics, null, null, compilationUnits);      boolean success = task.call();     for (Diagnostic diagnostic : diagnostics.getDiagnostics()) {       System.out.println(diagnostic.getCode());       System.out.println(diagnostic.getKind());       System.out.println(diagnostic.getPosition());       System.out.println(diagnostic.getStartPosition());       System.out.println(diagnostic.getEndPosition());       System.out.println(diagnostic.getSource());       System.out.println(diagnostic.getMessage(null));      }     System.out.println(""Success: "" + success);      if (success) {       try {         Class.forName(""HelloWorld"").getDeclaredMethod(""main"", new Class[] { String[].class })             .invoke(null, new Object[] { null });       } catch (ClassNotFoundException e) {         System.err.println(""Class not found: "" + e);       } catch (NoSuchMethodException e) {         System.err.println(""No such method: "" + e);       } catch (IllegalAccessException e) {         System.err.println(""Illegal access: "" + e);       } catch (InvocationTargetException e) {         System.err.println(""Invocation target: "" + e);       }     }   } }  class JavaSourceFromString extends SimpleJavaFileObject {   final String code;    JavaSourceFromString(String name, String code) {     super(URI.create(""string:///"" + name.replace('.','/') + Kind.SOURCE.extension),Kind.SOURCE);     this.code = code;   }    @Override   public CharSequence getCharContent(boolean ignoreEncodingErrors) {     return code;   } }"
"import org.w3c.dom.Document; import org.w3c.dom.Node; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathFactory; import java.io.ByteArrayInputStream; import java.io.InputStream; import java.nio.charset.Charset;  ...    String xml = ""&lt;...&gt;"";   String expression = ""/Enrollment/FirstName"";    DocumentBuilderFactory builderFactory = DocumentBuilderFactory.newInstance();   builderFactory.setNamespaceAware(true);   DocumentBuilder builder = builderFactory.newDocumentBuilder();   InputStream in = new ByteArrayInputStream(xml.getBytes(Charset.forName(""UTF-8"")));   Document document = builder.parse(in);    XPath xpath = XPathFactory.newInstance().newXPath();   Node firstNameNode = (Node) xpath.evaluate(expression, document, XPathConstants.NODE);   String firstName = firstNameNode.getTextContent();"
"import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStreamWriter; import java.io.Writer;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node;  public class XmlTest {      public static void main(String[] args) throws Exception     {         InputStream is = new FileInputStream(""test.xml"");         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();         DocumentBuilder builder = factory.newDocumentBuilder();          Document oldDoc = builder.parse(is);         Node oldRoot = oldDoc.getDocumentElement();         Document newDoc = builder.newDocument();         Element newRoot = newDoc.createElement(""newroot"");         newDoc.appendChild(newRoot);         newRoot.appendChild(newDoc.importNode(oldRoot, true));          ByteArrayOutputStream out = new ByteArrayOutputStream();         DOMSource domSource = new DOMSource(newDoc);         Writer writer = new OutputStreamWriter(out);         StreamResult result = new StreamResult(writer);         TransformerFactory tf = TransformerFactory.newInstance();         Transformer transformer = tf.newTransformer();         transformer.transform(domSource, result);         writer.flush();          InputStream isNewXML = new ByteArrayInputStream(out.toByteArray());      }  }"
"import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.StringWriter;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Document; import org.w3c.dom.Node; import org.xml.sax.SAXException;  public class FormatXml {      public static void main(String[] args) throws ParserConfigurationException,             FileNotFoundException, SAXException, IOException,             TransformerException {         DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory                 .newInstance();         DocumentBuilder documentBuilder = docBuilderFactory                 .newDocumentBuilder();         Document node = documentBuilder.parse(new FileInputStream(""data.xml""));         System.out.println(format(node, 4));     }      public static String format(Node node, int indent)             throws TransformerException {         cleanEmptyTextNodes(node);         StreamResult result = new StreamResult(new StringWriter());         getTransformer(indent).transform(new DOMSource(node), result);         return result.getWriter().toString();     }      private static Transformer getTransformer(int indent) {         Transformer transformer;         try {             transformer = TransformerFactory.newInstance().newTransformer();         } catch (Exception e) {             throw new RuntimeException(""Failed to create the Transformer"", e);         }         transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");         transformer.setOutputProperty(                 ""{http://xml.apache.org/xslt}indent-amount"",                 Integer.toString(indent));         return transformer;     }      /**      * Removes text nodes that only contains whitespace. The conditions for      * removing text nodes, besides only containing whitespace, are: If the      * parent node has at least one child of any of the following types, all      * whitespace-only text-node children will be removed: - ELEMENT child -      * CDATA child - COMMENT child      *       * The purpose of this is to make the format() method (that use a      * Transformer for formatting) more consistent regarding indenting and line      * breaks.      */     private static void cleanEmptyTextNodes(Node parentNode) {         boolean removeEmptyTextNodes = false;         Node childNode = parentNode.getFirstChild();         while (childNode != null) {             removeEmptyTextNodes |= checkNodeTypes(childNode);             childNode = childNode.getNextSibling();         }          if (removeEmptyTextNodes) {             removeEmptyTextNodes(parentNode);         }     }      private static void removeEmptyTextNodes(Node parentNode) {         Node childNode = parentNode.getFirstChild();         while (childNode != null) {             // grab the ""nextSibling"" before the child node is removed             Node nextChild = childNode.getNextSibling();              short nodeType = childNode.getNodeType();             if (nodeType == Node.TEXT_NODE) {                 boolean containsOnlyWhitespace = childNode.getNodeValue()                         .trim().isEmpty();                 if (containsOnlyWhitespace) {                     parentNode.removeChild(childNode);                 }             }             childNode = nextChild;         }     }      private static boolean checkNodeTypes(Node childNode) {         short nodeType = childNode.getNodeType();          if (nodeType == Node.ELEMENT_NODE) {             cleanEmptyTextNodes(childNode); // recurse into subtree         }          if (nodeType == Node.ELEMENT_NODE                 || nodeType == Node.CDATA_SECTION_NODE                 || nodeType == Node.COMMENT_NODE) {             return true;         } else {             return false;         }     }  }"
"package net.davymeers;  import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.UnsupportedEncodingException; import java.util.ArrayList; import java.util.Collection;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathExpressionException; import javax.xml.xpath.XPathFactory;  import org.w3c.dom.Document; import org.w3c.dom.NodeList; import org.xml.sax.SAXException;  public class XpathTest {     private static String XMLSTRING = ""&lt;data&gt;""             + ""&lt;tobject.subject tobject.subject.refnum=\""01016000\"" /&gt;\r\n""             + ""\r\n""             + ""&lt;tobject.subject tobject.subject.refnum=\""10004000\"" /&gt;""             + ""&lt;/data&gt;"";      /**      * @param args      */     public static void main(final String[] args) {          final Document doc = createDocument();         final XPath xpath = createXpath();          final NodeList nodes = findElements(                 ""//tobject.subject/@tobject.subject.refnum"", doc, xpath);         final Collection&lt;String&gt; results = convertToCollection(nodes);          for (final String result : results) {             System.out.println(result);         }     }      private static Document createDocument() {         Document doc = null;         try {             final DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory                     .newInstance();             documentBuilderFactory.setNamespaceAware(true); // never forget                                                             // this!             final DocumentBuilder builder = documentBuilderFactory                     .newDocumentBuilder();             doc = builder.parse(new ByteArrayInputStream(XMLSTRING                     .getBytes(""ISO-8859-1"")));         } catch (final UnsupportedEncodingException exception) {             // TODO handle exception         } catch (final SAXException exception) {             // TODO handle exception         } catch (final IOException exception) {             // TODO handle exception         } catch (final ParserConfigurationException exception) {             // TODO handle exception         }         return doc;     }      private static XPath createXpath() {         final XPathFactory xpathFactory = XPathFactory.newInstance();         final XPath xpath = xpathFactory.newXPath();         return xpath;     }      private static NodeList findElements(final String xpathExpression,             final Document doc, final XPath xpath) {         NodeList nodes = null;         if (doc != null) {             try {                 final XPathExpression expr = xpath.compile(xpathExpression);                 final Object result = expr                         .evaluate(doc, XPathConstants.NODESET);                 nodes = (NodeList) result;             } catch (final XPathExpressionException exception) {                 // TODO handle exception             }         }         return nodes;     }      private static Collection&lt;String&gt; convertToCollection(final NodeList nodes) {         final Collection&lt;String&gt; result = new ArrayList&lt;String&gt;();         if (nodes != null) {             for (int i = 0; i &lt; nodes.getLength(); i++) {                 result.add(nodes.item(i).getNodeValue());             }         }         return result;     }  }"
"import java.util.Iterator; import javax.xml.XMLConstants; import javax.xml.namespace.NamespaceContext; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathFactory; import org.w3c.dom.Document;  public class Demo  {     public static void main(String[] args)      {         DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();         domFactory.setNamespaceAware(true);         try          {             DocumentBuilder builder = domFactory.newDocumentBuilder();             Document dDoc = builder.parse(""c:\\path\\to\\xml\\file.xml"");             XPath xPath = XPathFactory.newInstance().newXPath();             xPath.setNamespaceContext(new UniversalNamespaceResolver(dDoc));             String query = ""//rss/channel/yweather:location/@city"";             XPathExpression expr = xPath.compile(query);             Object result = expr.evaluate(dDoc, XPathConstants.STRING);             System.out.println(result);         }          catch (Exception e)          {             e.printStackTrace();         }     }      public static class UniversalNamespaceResolver implements NamespaceContext      {         private Document sourceDocument;          public UniversalNamespaceResolver(Document document)          {             sourceDocument = document;         }          public String getNamespaceURI(String prefix)          {             if (prefix.equals(XMLConstants.DEFAULT_NS_PREFIX))                 return sourceDocument.lookupNamespaceURI(null);             else                 return sourceDocument.lookupNamespaceURI(prefix);         }          public String getPrefix(String namespaceURI)          {             return sourceDocument.lookupPrefix(namespaceURI);         }          public Iterator getPrefixes(String namespaceURI)          {             return null;         }     }    }"
