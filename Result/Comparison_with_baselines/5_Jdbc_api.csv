code
"import java.math.BigDecimal; import java.sql.Array; import java.sql.Blob; import java.sql.Clob; import java.sql.Ref; import java.sql.SQLException; import java.util.Calendar; import java.util.Collection; import java.util.Hashtable;  import javax.sql.rowset.RowSetMetaDataImpl;  import com.sun.rowset.CachedRowSetImpl;  public class FixedCachedRowSetImpl extends CachedRowSetImpl {      private static final long serialVersionUID = -9067504047398250113L;     private RowSetMetaDataImpl RowSetMD;      public FixedCachedRowSetImpl() throws SQLException {         super();     }      public FixedCachedRowSetImpl(Hashtable env) throws SQLException {         super(env);     }      private int getColIdxByName(String name) throws SQLException {         RowSetMD = (RowSetMetaDataImpl) this.getMetaData();         int cols = RowSetMD.getColumnCount();          for (int i = 1; i &lt;= cols; ++i) {             String colName = RowSetMD.getColumnLabel(i);             if (colName != null) if (name.equalsIgnoreCase(colName))                 return (i);             else                 continue;         }         throw new SQLException(resBundle.handleGetObject(&quot;cachedrowsetimpl.invalcolnm&quot;).toString());     }      @Override     public Collection&lt;?&gt; toCollection(String column) throws SQLException {         return toCollection(getColIdxByName(column));     }      @Override     public String getString(String columnName) throws SQLException {         return getString(getColIdxByName(columnName));     }      @Override     public boolean getBoolean(String columnName) throws SQLException {         return getBoolean(getColIdxByName(columnName));     }      @Override     public byte getByte(String columnName) throws SQLException {         return getByte(getColIdxByName(columnName));     }      @Override     public short getShort(String columnName) throws SQLException {         return getShort(getColIdxByName(columnName));     }      @Override     public int getInt(String columnName) throws SQLException {         return getInt(getColIdxByName(columnName));     }      @Override     public long getLong(String columnName) throws SQLException {         return getLong(getColIdxByName(columnName));     }      @Override     public float getFloat(String columnName) throws SQLException {         return getFloat(getColIdxByName(columnName));     }      @Override     public double getDouble(String columnName) throws SQLException {         return getDouble(getColIdxByName(columnName));     }      @Override     public BigDecimal getBigDecimal(String columnName, int scale) throws SQLException {         return getBigDecimal(getColIdxByName(columnName), scale);     }      @Override     public byte[] getBytes(String columnName) throws SQLException {         return getBytes(getColIdxByName(columnName));     }      @Override     public java.sql.Date getDate(String columnName) throws SQLException {         return getDate(getColIdxByName(columnName));     }      @Override     public java.sql.Time getTime(String columnName) throws SQLException {         return getTime(getColIdxByName(columnName));     }      @Override     public java.sql.Timestamp getTimestamp(String columnName) throws SQLException {         return getTimestamp(getColIdxByName(columnName));     }      @Override     public java.io.InputStream getAsciiStream(String columnName) throws SQLException {         return getAsciiStream(getColIdxByName(columnName));      }      @Override     public java.io.InputStream getUnicodeStream(String columnName) throws SQLException {         return getUnicodeStream(getColIdxByName(columnName));     }      @Override     public java.io.InputStream getBinaryStream(String columnName) throws SQLException {         return getBinaryStream(getColIdxByName(columnName));     }      @Override     public Object getObject(String columnName) throws SQLException {         return getObject(getColIdxByName(columnName));     }      @Override     public int findColumn(String columnName) throws SQLException {         return getColIdxByName(columnName);     }      @Override     public java.io.Reader getCharacterStream(String columnName) throws SQLException {         return getCharacterStream(getColIdxByName(columnName));     }      @Override     public BigDecimal getBigDecimal(String columnName) throws SQLException {         return getBigDecimal(getColIdxByName(columnName));     }      @Override     public boolean columnUpdated(String columnName) throws SQLException {         return columnUpdated(getColIdxByName(columnName));     }      @Override     public void updateNull(String columnName) throws SQLException {         updateNull(getColIdxByName(columnName));     }      @Override     public void updateBoolean(String columnName, boolean x) throws SQLException {         updateBoolean(getColIdxByName(columnName), x);     }      @Override     public void updateByte(String columnName, byte x) throws SQLException {         updateByte(getColIdxByName(columnName), x);     }      @Override     public void updateShort(String columnName, short x) throws SQLException {         updateShort(getColIdxByName(columnName), x);     }      @Override     public void updateInt(String columnName, int x) throws SQLException {         updateInt(getColIdxByName(columnName), x);     }      @Override     public void updateLong(String columnName, long x) throws SQLException {         updateLong(getColIdxByName(columnName), x);     }      @Override     public void updateFloat(String columnName, float x) throws SQLException {         updateFloat(getColIdxByName(columnName), x);     }      @Override     public void updateDouble(String columnName, double x) throws SQLException {         updateDouble(getColIdxByName(columnName), x);     }      @Override     public void updateBigDecimal(String columnName, BigDecimal x) throws SQLException {         updateBigDecimal(getColIdxByName(columnName), x);     }      @Override     public void updateString(String columnName, String x) throws SQLException {         updateString(getColIdxByName(columnName), x);     }      @Override     public void updateBytes(String columnName, byte x[]) throws SQLException {         updateBytes(getColIdxByName(columnName), x);     }      @Override     public void updateDate(String columnName, java.sql.Date x) throws SQLException {         updateDate(getColIdxByName(columnName), x);     }      @Override     public void updateTime(String columnName, java.sql.Time x) throws SQLException {         updateTime(getColIdxByName(columnName), x);     }      @Override     public void updateTimestamp(String columnName, java.sql.Timestamp x) throws SQLException {         updateTimestamp(getColIdxByName(columnName), x);     }      @Override     public void updateAsciiStream(String columnName, java.io.InputStream x, int length) throws SQLException {         updateAsciiStream(getColIdxByName(columnName), x, length);     }      @Override     public void updateBinaryStream(String columnName, java.io.InputStream x, int length) throws SQLException {         updateBinaryStream(getColIdxByName(columnName), x, length);     }      @Override     public void updateCharacterStream(String columnName, java.io.Reader reader, int length) throws SQLException {         updateCharacterStream(getColIdxByName(columnName), reader, length);     }      @Override     public void updateObject(String columnName, Object x, int scale) throws SQLException {         updateObject(getColIdxByName(columnName), x, scale);     }      @Override     public void updateObject(String columnName, Object x) throws SQLException {         updateObject(getColIdxByName(columnName), x);     }      @Override     public Object getObject(String columnName, java.util.Map&lt;String, Class&lt;?&gt;&gt; map) throws SQLException {         return getObject(getColIdxByName(columnName), map);     }      @Override     public Ref getRef(String colName) throws SQLException {         return getRef(getColIdxByName(colName));     }      @Override     public Blob getBlob(String colName) throws SQLException {         return getBlob(getColIdxByName(colName));     }      @Override     public Clob getClob(String colName) throws SQLException {         return getClob(getColIdxByName(colName));     }      @Override     public Array getArray(String colName) throws SQLException {         return getArray(getColIdxByName(colName));     }      @Override     public java.sql.Date getDate(String columnName, Calendar cal) throws SQLException {         return getDate(getColIdxByName(columnName), cal);     }      @Override     public java.sql.Time getTime(String columnName, Calendar cal) throws SQLException {         return getTime(getColIdxByName(columnName), cal);     }      @Override     public java.sql.Timestamp getTimestamp(String columnName, Calendar cal) throws SQLException {         return getTimestamp(getColIdxByName(columnName), cal);     }      @Override     public void updateRef(String columnName, java.sql.Ref ref) throws SQLException {         updateRef(getColIdxByName(columnName), ref);     }      @Override     public void updateClob(String columnName, Clob c) throws SQLException {         updateClob(getColIdxByName(columnName), c);     }      @Override     public void updateBlob(String columnName, Blob b) throws SQLException {         updateBlob(getColIdxByName(columnName), b);     }      @Override     public void updateArray(String columnName, Array a) throws SQLException {         updateArray(getColIdxByName(columnName), a);     }      @Override     public java.net.URL getURL(String columnName) throws SQLException {         return getURL(getColIdxByName(columnName));     } }"
"import java.math.BigDecimal; import java.sql.Array; import java.sql.CallableStatement; import java.sql.Connection; import java.sql.SQLException; import java.util.ArrayList; import java.util.List;  import javax.sql.DataSource;  import oracle.jdbc.OracleTypes; import oracle.sql.ARRAY; import oracle.sql.ArrayDescriptor; import oracle.sql.STRUCT;  import org.apache.log4j.Logger; import org.springframework.jdbc.core.SqlOutParameter; import org.springframework.jdbc.core.SqlParameter; import org.springframework.jdbc.object.StoredProcedure;  import com.****.****.****.ExcelListenerBean; import com.****.****.****.RevAppViewBean;  public class RevPrdBrkDwnSP extends StoredProcedure{      private final Logger log = Logger.getLogger(this.getClass().getName());      private  Connection con = null;     private DataSource ds = null;      public RevPrdBrkDwnSP(DataSource dataSource, String storeProcName) throws SQLException {          // Run the Parent         super(dataSource, storeProcName);          con = dataSource.getConnection();         ds = dataSource;          if (log.isInfoEnabled()) {             log.info(""Stored Procedure Name : ""+ storeProcName);         }         // Declare the Parameter Details         declareParameter(new SqlParameter(""IN_ARRAY"", OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY""));         declareParameter(new SqlOutParameter(""OUT_ARRAY"", OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY""));          // Compile the SP         compile();     }       public List&lt;ExcelListenerBean&gt; execute(final RevAppViewBean appViewBean$Session, DataSource dataSource) throws Exception {         dataSource = ds;         List&lt;ExcelListenerBean&gt; beans = new ArrayList&lt;ExcelListenerBean&gt;();          log.info(""Setting up the Store Procedure Params"");          String getDBUSERByUserIdSql = ""{call ****.PRCS_PROD_PRCT_BRKDWN_ENTRIES(?,?)}"";         CallableStatement cs = con.prepareCall(getDBUSERByUserIdSql);          ArrayDescriptor des = ArrayDescriptor.createDescriptor(""PBAREV.PROD_PRCT_BRKDWN_TYPE_ARRAY"", con);         ARRAY a = new ARRAY(des, con, appViewBean$Session.getExcelRecLst().toArray());         cs.setObject(1, (Object)a);          cs.registerOutParameter(2, OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY"");          if (log.isDebugEnabled()) {             log.debug(""Executing the PBAREV Store Procedure "");         }          cs.execute();         log.info(""Executed ****.PRCS_PROD_PRCT_BRKDWN_ENTRIES... Processing values to beans"");           Array arr = cs.getArray(2);          Object[] objArr = (Object[]) arr.getArray();         for(int i=0; i&lt;objArr.length;i++){             STRUCT st = (STRUCT)objArr[i];             ExcelListenerBean bean = new ExcelListenerBean();             Object[] obj = st.getAttributes();             bean.setPrntGdwIdN(((BigDecimal)obj[1]).longValue());             bean.setChldGdwIdN(((BigDecimal)obj[2]).longValue());             bean.setChldAsetPrcntN(Double.valueOf(String.valueOf(obj[4])));             bean.setStatus(String.valueOf(obj[8]));             bean.setStatusMessage(String.valueOf(obj[9]));             beans.add(bean);         }          if (log.isDebugEnabled()) {             log.info(""Finised processing SP output values to ExcelListenerBeans"");         }          return beans;     } }"
"import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.LinkedHashMap; import java.util.Map;   public class SqlDemo {      private static final String SELECT_USER_ROLE_SQL =             ""SELECT m.user_name, m.user_role "" +             ""FROM User as u "" +             ""JOIN Usermap as m"" +             ""ON u.user_name = m.user_name "";      public Map&lt;String, String&gt; getAllUserRoles(Connection connection) {         Map&lt;String, String&gt; userRoles = new LinkedHashMap&lt;String, String&gt;();          PreparedStatement ps = null;         ResultSet rs = null;          try {             ps = connection.prepareStatement(SELECT_USER_ROLE_SQL);             rs = ps.executeQuery();             while (rs.next()) {                 String user = rs.getString(""user_name"");                 String role = rs.getString(""user_role"");                 userRoles.put(user, role);             }         } catch (SQLException e) {             e.printStackTrace();         }         finally {             close(rs);             close(ps);         }          return userRoles;     }      private static void close(ResultSet rs) {         try {             if (rs != null) rs.close();         } catch (Exception e) {             e.printStackTrace();         }     }      private static void close(Statement st) {         try {             if (st != null) st.close();         } catch (Exception e) {             e.printStackTrace();         }     } }"
"package persistence;  import java.sql.Connection; import java.sql.Driver; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.List; import java.util.Map;  public class DatabaseUtils {     private static final String URL = ""jdbc:mysql://localhost:3306/contacts"";     private static final String USERNAME = ""contacts"";     private static final String PASSWORD = ""contacts"";      public static final String SELECT_SQL = ""select customer_id, name, street, city, state, zip, phone, url from customer order by customer_id"";     public static final String INSERT_SQL = ""insert into customer(name, street, city, state, zip, phone, url) values(?,?,?,?,?,?,?)"";      public static void main(String[] args)     {         Connection connection = null;          try         {             connection = getConnection(URL, USERNAME, PASSWORD);             List&lt;Map&gt; rows = findAllCustomers(connection);              for (Map row : rows)             {                 System.out.println(row);                                 }         }         catch (SQLException e)         {             e.printStackTrace();         }         finally         {             close(connection);         }     }      public static List&lt;Map&gt; findAllCustomers(Connection connection) throws SQLException     {         List&lt;Map&gt; rows = new ArrayList&lt;Map&gt;();         PreparedStatement st = null;         ResultSet rs = null;          try         {             st = connection.prepareStatement(SELECT_SQL);             rs = st.executeQuery();             while (rs.next())             {                 rows.add(map(rs));                             }         }         finally         {             close(rs);             close(st);         }          return rows;     }      private static Map&lt;String, Object&gt; map(ResultSet rs) throws SQLException     {         Map&lt;String, Object&gt; row = new LinkedHashMap&lt;String, Object&gt;();          ResultSetMetaData meta = rs.getMetaData();          int numColumns = meta.getColumnCount();         for (int i = 1; i &lt;= numColumns; ++i)         {             String column = meta.getColumnName(i);             Object value = rs.getObject(i);             row.put(column, value);         }          return row;     }      public static Connection getConnection(String url, String username, String password) throws SQLException     {         Driver driver = DriverManager.getDriver(url);          DriverManager.registerDriver(driver);          return DriverManager.getConnection(url, username, password);     }      public static void close(Connection connection)     {         try         {             if (connection != null)             {                 connection.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public static void close(Statement st)     {         try         {             if (st != null)             {                 st.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public static void close(ResultSet rs)     {         try         {             if (rs != null)             {                 rs.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public void rollback(Connection connection)     {         try         {             if (connection != null)             {                 connection.rollback();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     } }"
"package com.your.package.hibernate.types;  import java.io.Serializable; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Types;  import org.hibernate.HibernateException; import org.hibernate.usertype.UserType; import org.joda.time.DurationFieldType; import org.joda.time.Period; import org.joda.time.ReadableDuration; import org.joda.time.ReadablePeriod; import org.postgresql.util.PGInterval;  public class JodaTimeDurationType     implements UserType {      public Class&lt;?&gt; returnedClass() {         return ReadableDuration.class;     }       public int[] sqlTypes() {         return new int[] {Types.OTHER};     }       public Object nullSafeGet(ResultSet resultSet, String[] names, Object owner)         throws HibernateException, SQLException {          try {             final PGInterval pgi = (PGInterval)resultSet.getObject(names[0]);              final int years = pgi.getYears();             final int months = pgi.getMonths();             final int days = pgi.getDays();             final int hours = pgi.getHours();             final int mins = pgi.getMinutes();             final double secs = pgi.getSeconds();              return new Period(years, months, 0, days, hours, mins, (int)secs, 0).toStandardDuration();          }         catch (Exception e) {             return null;         }     }       public void nullSafeSet(PreparedStatement statement, Object value, int index)         throws HibernateException, SQLException {          if (value == null) {             statement.setNull(index, Types.OTHER);         }         else {             final ReadablePeriod period = ((ReadableDuration)value).toPeriod();              final int years = period.get(DurationFieldType.years());             final int months = period.get(DurationFieldType.months());             final int days = period.get(DurationFieldType.days());             final int hours = period.get(DurationFieldType.hours());             final int mins = period.get(DurationFieldType.minutes());             final int secs = period.get(DurationFieldType.seconds());              final PGInterval pgi = new PGInterval(years, months, days, hours, mins, secs);             statement.setObject(index, pgi);         }     }       public boolean equals(Object x, Object y)         throws HibernateException {          return x == y;     }       public int hashCode(Object x)         throws HibernateException {         return x.hashCode();     }       public Object deepCopy(Object value)         throws HibernateException {         return value;     }       public boolean isMutable() {         return false;     }       public Serializable disassemble(Object value)         throws HibernateException {         throw new HibernateException(""not implemented"");     }       public Object assemble(Serializable cached, Object owner)         throws HibernateException {         throw new HibernateException(""not implemented"");     }       public Object replace(Object original, Object target, Object owner)         throws HibernateException {         throw new HibernateException(""not implemented"");     } }"
"create or replace type stringArray is table of varchar2(4000); / CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED Parser AS import java.sql.Connection; import oracle.jdbc.OracleDriver; import oracle.jdbc.OracleConnection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Array;  public class Parser {      public static Array parseToArray(String str, String delim) throws SQLException {         OracleDriver ora = new oracle.jdbc.OracleDriver();         Connection conn = ora.defaultConnection();         OracleConnection oraConn = (OracleConnection)conn;         Array arr = oraConn.createARRAY(""STRINGARRAY"", str.split(delim));         return arr;     } } / CREATE OR REPLACE FUNCTION PARSETOARRAY (str IN VARCHAR2, delim IN VARCHAR2)  RETURN STRINGARRAY AS LANGUAGE JAVA NAME 'Parser.parseToArray (java.lang.String, java.lang.String) return java.sql.Array'; / DECLARE v_array STRINGARRAY; BEGIN   FOR testing IN (SELECT record FROM interfacelog) LOOP     v_array := PARSETOARRAY(testing.record, '|');    END LOOP; END;"
"import java.sql.SQLException; import com.hp.hpl.jena.util.FileManager; import com.hp.hpl.jena.rdf.model.Model; import com.hp.hpl.jena.rdf.model.SimpleSelector; import com.hp.hpl.jena.rdf.model.Property; import com.hp.hpl.jena.rdf.model.RDFNode; import com.hp.hpl.jena.rdf.model.Literal; import com.hp.hpl.jena.rdf.model.StmtIterator; import com.hp.hpl.jena.rdf.model.Statement; import com.hp.hpl.jena.db.DBConnection; import com.hp.hpl.jena.rdf.model.ModelMaker; import com.hp.hpl.jena.rdf.model.ModelFactory;  public class TestJena {      public static void main(String[] args) throws java.lang.ClassNotFoundException, java.sql.SQLException {         Class.forName(""com.mysql.jdbc.Driver"");                      //The database backend initialization.         DBConnection connection = new DBConnection(MY_DB, USER, PASS, ""mysql"");         ModelMaker dbMaker = ModelFactory.createModelRDBMaker(connection);          //A file manager to get the triples from the DBPedia revolvable URI.          FileManager fManager = FileManager.get();         fManager.addLocatorURL();         Model linkedDataModel =               fManager.loadModel(""http://dbpedia.org/data/Frederick_of_Sweden.rdf"");           //Now we copy the in-memory model into our DB backend.          //When the model is created you can give it the name that you like.         Model dbModel =                dbMaker.createModel(""http://dbpedia.org/resource/Frederick_of_Sweden"");          dbModel.add(linkedDataModel);          StmtIterator iter = dbModel.listStatements();         while (iter.hasNext()) {             Statement stmt = iter.nextStatement();             System.out.println(stmt);         }           linkedDataModel.close();         dbModel.close();         connection.close(); }"
"package test;  import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Arrays;  public class SQLiteTest {  public static void main(String[] args) throws SQLException,         ClassNotFoundException {     Class.forName(""org.sqlite.JDBC"");     Connection connection = DriverManager             .getConnection(""jdbc:sqlite:test.db"");     Statement statement = connection.createStatement();     createTable(statement);     insertBlob(connection);     byte[] bytes = query(statement);     System.out.println(Arrays.toString(bytes));             statement.close();     connection.close(); }  private static void createTable(Statement statement) throws SQLException {     statement.execute(""CREATE TABLE test (data BLOB)""); }  private static void insertBlob(Connection connection) throws SQLException {     PreparedStatement pStatement = connection             .prepareStatement(""INSERT INTO test VALUES (?)"");     pStatement.setBytes(1, new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });     pStatement.execute();     pStatement.close(); }  private static byte[] query(Statement statement) throws SQLException {     ResultSet rs = statement.executeQuery(""SELECT data FROM test"");     byte[] bytes = rs.getBytes(1);     return bytes; }  }"
"package org.yi.happy.mysql;  import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException;  public class RepeatQuery {     public static void main(String[] args) throws Exception {         Class.forName(""com.mysql.jdbc.Driver"").newInstance();          setupDatabase();          System.out.println(""opening database..."");         Connection connection = openConnection();         connection.setAutoCommit(false);          queryDatabase(connection);          deleteRecords();          queryDatabase(connection);          connection.close();     }      private static Connection openConnection() throws SQLException {         return DriverManager.getConnection(""jdbc:mysql://localhost/test"", null,                 null);     }      private static void setupDatabase() throws SQLException {         Connection conn = openConnection();          System.out.println(""doing insert on another connection..."");         PreparedStatement stmt = conn                 .prepareStatement(""insert into strings(id, value) values(?, ?)"");          stmt.setInt(1, 1);         stmt.setString(2, ""test"");         stmt.execute();          stmt.setInt(1, 2);         stmt.setString(2, ""data"");         stmt.execute();          stmt.close();         conn.close();     }      private static void deleteRecords() throws SQLException {         Connection conn = openConnection();         System.out.println(""doing delete on another connection..."");         PreparedStatement stmt = conn.prepareStatement(""delete from strings"");         stmt.execute();          stmt.close();         conn.close();     }      private static void queryDatabase(Connection connection)             throws SQLException {         System.out.println(""doing query..."");         PreparedStatement ps = connection                 .prepareStatement(""select id, value from strings"");         ResultSet dbResult = ps.executeQuery();          while (dbResult.next()) {             int id = dbResult.getInt(1);             String value = dbResult.getString(2);             System.out.println(id + "" &lt;=&gt; "" + value);         }     } }"
"import java.sql.Connection; import java.sql.ResultSet; import javafx.application.Application; import javafx.beans.property.SimpleStringProperty; import javafx.beans.value.ObservableValue; import javafx.collections.FXCollections; import javafx.collections.ObservableList; import javafx.scene.Scene; import javafx.scene.control.TableColumn; import javafx.scene.control.TableColumn.CellDataFeatures; import javafx.scene.control.TableView; import javafx.stage.Stage; import javafx.util.Callback;  /**  *   * @author Narayan  */  public class DynamicTable extends Application{      //TABLE VIEW AND DATA     private ObservableList&lt;ObservableList&gt; data;     private TableView tableview;      //MAIN EXECUTOR     public static void main(String[] args) {         launch(args);     }      //CONNECTION DATABASE     public void buildData(){           Connection c ;           data = FXCollections.observableArrayList();           try{             c = DBConnect.connect();             //SQL FOR SELECTING ALL OF CUSTOMER             String SQL = ""SELECT * from CUSTOMer"";             //ResultSet             ResultSet rs = c.createStatement().executeQuery(SQL);              /**********************************              * TABLE COLUMN ADDED DYNAMICALLY *              **********************************/             for(int i=0 ; i&lt;rs.getMetaData().getColumnCount(); i++){                 //We are using non property style for making dynamic table                 final int j = i;                                 TableColumn col = new TableColumn(rs.getMetaData().getColumnName(i+1));                 col.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;ObservableList,String&gt;,ObservableValue&lt;String&gt;&gt;(){                                         public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;ObservableList, String&gt; param) {                                                                                                                       return new SimpleStringProperty(param.getValue().get(j).toString());                                             }                                     });                  tableview.getColumns().addAll(col);                  System.out.println(""Column [""+i+""] "");             }              /********************************              * Data added to ObservableList *              ********************************/             while(rs.next()){                 //Iterate Row                 ObservableList&lt;String&gt; row = FXCollections.observableArrayList();                 for(int i=1 ; i&lt;=rs.getMetaData().getColumnCount(); i++){                     //Iterate Column                     row.add(rs.getString(i));                 }                 System.out.println(""Row [1] added ""+row );                 data.add(row);              }              //FINALLY ADDED TO TableView             tableview.setItems(data);           }catch(Exception e){               e.printStackTrace();               System.out.println(""Error on Building Data"");                        }       }         @Override       public void start(Stage stage) throws Exception {         //TableView         tableview = new TableView();         buildData();          //Main Scene         Scene scene = new Scene(tableview);                  stage.setScene(scene);         stage.show();       } }"
"import java.io.Serializable; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException;  import org.hibernate.HibernateException; import org.hibernate.engine.spi.SessionImplementor; import org.hibernate.id.IdentifierGenerator;  public class StringKeyGenerator implements IdentifierGenerator {      @Override     public Serializable generate(SessionImplementor session, Object collection) throws HibernateException {         Connection connection = session.connection();         PreparedStatement ps = null;         String result = """";          try {             // Oracle-specific code to query a sequence             ps = connection.prepareStatement(""SELECT TABLE_SEQ.nextval AS TABLE_PK FROM dual"");             ResultSet rs = ps.executeQuery();              if (rs.next()) {                 int pk = rs.getInt(""TABLE_PK"");                  // Convert to a String                 result = Integer.toString(pk);             }         } catch (SQLException e) {             throw new HibernateException(""Unable to generate Primary Key"");         } finally {             if (ps != null) {                 try {                     ps.close();                 } catch (SQLException e) {                     throw new HibernateException(""Unable to close prepared statement."");                 }             }         }          return result;     } }"
"import java.sql.SQLException; import java.util.List;  import org.apache.poi.hssf.record.formula.functions.T; import org.hibernate.HibernateException; import org.hibernate.Query; import org.hibernate.Session; import org.springframework.orm.hibernate3.HibernateCallback;  public class HibernateCallbackImpl      implements HibernateCallback&lt;List&lt;T&gt;&gt; {      private String queryString;     private String[] paramNames;     private Object[] values;      private int firstResult;     private int maxResults;      /**      * Fetches a {@link List} of entities from the database using pagination.      * Execute HQL query, binding a number of values to "":"" named parameters in the query string.      *       * @param queryString a query expressed in Hibernate's query language      * @param paramNames the names of the parameters      * @param values the values of the parameters       * @param firstResult a row number, numbered from 0      * @param maxResults the maximum number of rows      */     public HibernateCallbackImpl(             String queryString,              String[] paramNames,              Object[] values,             int firstResult,             int maxResults) {         this.queryString = queryString;         this.paramNames = paramNames;         this.values = values;          this.firstResult = firstResult;         this.maxResults = maxResults;     }      @Override     public List&lt;T&gt; doInHibernate(Session session) throws HibernateException,             SQLException {         Query query = session.createQuery(queryString);         query.setFirstResult(firstResult);         query.setMaxResults(maxResults);          // TODO: throw proper exception when paramNames.length != values.length          for (int c=0; c&lt;paramNames.length; c++) {             applyNamedParameterToQuery(query, paramNames[c], values[c]);         }          @SuppressWarnings(""unchecked"")         List&lt;T&gt; result = query.list();          return result;     }        /**      * Code borrowed from org.springframework.orm.hibernate3.HibernateTemplate.applyNamedParameterToQuery(Query, String, Object)      *       * Apply the given name parameter to the given Query object.      * @param queryObject the Query object      * @param paramName the name of the parameter      * @param value the value of the parameter      * @throws HibernateException if thrown by the Query object      */     protected void applyNamedParameterToQuery(Query queryObject, String paramName, Object value)             throws HibernateException {          if (value instanceof Collection) {             queryObject.setParameterList(paramName, (Collection) value);         }         else if (value instanceof Object[]) {             queryObject.setParameterList(paramName, (Object[]) value);         }         else {             queryObject.setParameter(paramName, value);         }     }  }"
"import java.sql.Driver; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Enumeration;  import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.sql.DataSource;  import org.apache.tomcat.jdbc.pool.DataSourceProxy;  public class JdbcPoolListener implements ServletContextListener {      @Override     public void contextInitialized(ServletContextEvent myServletContextEvent) {          // initialize jdbc-pool datasource to start out with pooled connections          try {             Context myContext = (Context) new InitialContext().lookup(""java:comp/env"");             DataSource myDataSource = (DataSource) myContext.lookup(""jdbc/cf"");             myServletContextEvent.getServletContext().setAttribute(""JdbcPool"", myDataSource);         } catch (NamingException e) {             System.out.println(""Error initializing jdbc-pool datasource"");             e.printStackTrace();         }     }      @Override     public void contextDestroyed(ServletContextEvent myServletContextEvent) {      // close datasource from proxy?     ServletContext myServletContext = myServletContextEvent.getServletContext();         DataSourceProxy myDataSource = (DataSourceProxy) myServletContext.getAttribute(""JdbcPool"");         myDataSource.close();                myServletContext.removeAttribute(""JdbcPool"");          // deregister JDBC driver to prevent Tomcat 7 from complaining about memory leaks         Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();         while (drivers.hasMoreElements()) {             Driver driver = drivers.nextElement();             try {                 DriverManager.deregisterDriver(driver);                 System.out.println(String.format(""Deregistering jdbc driver: %s"", driver));             } catch (SQLException e) {                 System.out.println(String.format(""Error deregistering driver %s"", driver));                 e.printStackTrace();             }         }     } }"
"public static void expMember(){     Session session=HibernateUtil.getSessionFactory().openSession();       java.util.Date utilDate=new java.util.Date();     java.sql.Date sqldate=new java.sql.Date(utilDate.getTime());      Format formatter = new SimpleDateFormat(""yyyy-MM-dd"");     String a= formatter.format(sqldate);        Query query = session.createSQLQuery ("" update tbl_member set exp_status = 'true' where renewDate=""+""'"" + a + ""';"";      int result = query.executeUpdate();      System.out.println(result);     }"
"package hibernatehelper;  import java.io.Serializable; import java.lang.reflect.Method; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Properties; import org.hibernate.HibernateException; import org.hibernate.type.AbstractSingleColumnStandardBasicType; import org.hibernate.type.TypeResolver; import org.hibernate.usertype.ParameterizedType; import org.hibernate.usertype.UserType;   public class GenericEnumUserType implements UserType, ParameterizedType {      private Class &lt;? extends Enum&gt; enumClass;      private Class &lt;?&gt; identifierType;      private Method identifierMethod;      private Method valueOfMethod;      private static final String defaultIdentifierMethodName = ""getId"";      private static final String defaultValueOfMethodName = ""parseId"";      private AbstractSingleColumnStandardBasicType type;      private int[] sqlTypes;      @Override     public void setParameterValues(Properties parameters) {         String enumClassName = parameters.getProperty(""enumClass"");         try {             enumClass = Class.forName(enumClassName).asSubclass(Enum.class);         } catch (ClassNotFoundException exception) {             throw new HibernateException(""Enum class not found"", exception);         }          String identifierMethodName =                 parameters.getProperty(""identifierMethod"",                         defaultIdentifierMethodName);          try {             identifierMethod =                     enumClass.getMethod(identifierMethodName, new Class[0]);             identifierType = identifierMethod.getReturnType();         } catch (Exception exception) {             throw new HibernateException(""Failed to optain identifier method"",                     exception);         }          TypeResolver tr = new TypeResolver();         type =                 (AbstractSingleColumnStandardBasicType) tr.basic(identifierType                         .getName());         if (type == null) {             throw new HibernateException(""Unsupported identifier type ""                     + identifierType.getName());         }         sqlTypes = new int[] {type.sqlType()};          String valueOfMethodName = parameters.getProperty(""valueOfMethod"",                 defaultValueOfMethodName);         try {             valueOfMethod = enumClass.getMethod(valueOfMethodName,                             new Class[] {identifierType});         } catch (Exception exception) {             throw new HibernateException(""Failed to optain valueOf method"",                     exception);         }     }      @Override     public Class returnedClass() {         return enumClass;     }      @Override     public Object nullSafeGet(ResultSet rs, String[] names, Object owner)             throws HibernateException, SQLException {         Object identifier = type.get(rs, names[0]);         if (identifier == null) {             return null;         }          if (valueOfMethod == null) {          }          try {             return valueOfMethod.invoke(enumClass, new Object[] {identifier});         } catch (Exception exception) {             throw new HibernateException(                     ""Exception while invoking valueOfMethod of enumeration class: "",                     exception);         }     }      public void nullSafeSet(PreparedStatement st, Object value, int index)             throws HibernateException, SQLException {         try {             Object identifier =                     value != null ? identifierMethod.invoke(value,                             new Object[0]) : null;             st.setObject(index, identifier);         } catch (Exception exception) {             throw new HibernateException(                     ""Exception while invoking identifierMethod of enumeration class: "",                     exception);          }     }      @Override     public int[] sqlTypes() {         return sqlTypes;     }      @Override     public Object assemble(Serializable cached, Object owner)             throws HibernateException {         return cached;     }      @Override     public Object deepCopy(Object value) throws HibernateException {         return value;     }      @Override     public Serializable disassemble(Object value) throws HibernateException {         return (Serializable) value;     }      @Override     public boolean equals(Object x, Object y) throws HibernateException {         return x == y;     }      @Override     public int hashCode(Object x) throws HibernateException {         return x.hashCode();     }      public boolean isMutable() {         return false;     }      public Object replace(Object original, Object target, Object owner)             throws HibernateException {         return original;     } }"
"import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; /**  * Creates a JSONARRAY from an java.sql.ResultSet.  * @author Aries  *  */ public class SQL2JSON  {      public static JSONArray convert(ResultSet rs) throws SQLException, JSONException           {             JSONArray json = new JSONArray();             ResultSetMetaData rsmd = rs.getMetaData();             rs.beforeFirst();             while(rs.next()) {                   int numColumns = rsmd.getColumnCount();                   JSONObject obj = new JSONObject();                    for(int i=1; i&lt;numColumns+1; i++) {                      String column_name = rsmd.getColumnLabel(i);  //Bugfix , works better than getColumnName() /Aries                       switch( rsmd.getColumnType( i ) ) {                       case java.sql.Types.ARRAY:                         obj.put(column_name, rs.getArray(column_name));     break;                       case java.sql.Types.BIGINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.BOOLEAN:                         obj.put(column_name, rs.getBoolean(column_name));   break;                       case java.sql.Types.BLOB:                         obj.put(column_name, rs.getBlob(column_name));      break;                       case java.sql.Types.DOUBLE:                         obj.put(column_name, rs.getDouble(column_name));    break;                       case java.sql.Types.FLOAT:                         obj.put(column_name, rs.getFloat(column_name));     break;                       case java.sql.Types.INTEGER:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.NVARCHAR:                         obj.put(column_name, rs.getNString(column_name));   break;                       case java.sql.Types.VARCHAR:                         obj.put(column_name, rs.getString(column_name));    break;                       case java.sql.Types.TINYINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.SMALLINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.DATE:                         obj.put(column_name, SQL2JSON.convertDateToString(rs.getDate(column_name)));      break;                       case java.sql.Types.TIMESTAMP:                         obj.put(column_name, SQL2JSON.convertDateToString(rs.getTimestamp(column_name))); break;                       default:                         obj.put(column_name, rs.getObject(column_name));    break;                     }                   }                    json.put(obj);                 }              return json;           } }"
"package yourPackage;  import java.io.FileInputStream; import java.io.FileOutputStream; import java.sql.Connection; import java.sql.DriverManager; import org.dbunit.DBTestCase; import org.dbunit.PropertiesBasedJdbcDatabaseTester; import org.dbunit.database.DatabaseConnection; import org.dbunit.database.IDatabaseConnection; import org.dbunit.database.QueryDataSet; import org.dbunit.dataset.xml.XmlDataSet; import org.junit.Test; import org.dbunit.dataset.IDataSet; import org.dbunit.dataset.xml.FlatXmlDataSet;  public class TestDBUnitDummy extends DBTestCase {      public TestDBUnitDummy( String name ) throws Exception     {         super( name );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, ""com.microsoft.sqlserver.jdbc.SQLServerDriver"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, ""jdbc:sqlserver://MyServer;databaseName=MyDatabase"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, ""sa"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, """" );     }      public static void Export() throws Exception     {         Class.forName(""com.microsoft.sqlserver.jdbc.SQLServerDriver"");         Connection jdbcConnection = DriverManager.getConnection(""jdbc:sqlserver://MySourceServer;databaseName=MyDatabase"", ""sa"", """");         IDatabaseConnection connection = new DatabaseConnection(jdbcConnection);          QueryDataSet partialDataSet = new QueryDataSet(connection);         partialDataSet.addTable(""TABLE-NAME"", ""SELECT * FROM [TABLE-NAME]"");         XmlDataSet.write(partialDataSet, new FileOutputStream(""table.xml""));         FlatXmlDataSet.write(partialDataSet, new FileOutputStream(""table_flat.xml""));     }      protected void setUpDatabaseConfig( DatabaseConfig config )     {     config.setProperty(DatabaseConfig.PROPERTY_ESCAPE_PATTERN , ""[?]"");     }      protected IDataSet getDataSet() throws Exception     {         Export();         return new XmlDataSet( new FileInputStream( ""table.xml"" ) );     }       @Test     public void test_001()     {         assertEquals( ""Dummy test"", true, true );            }  }"
"import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.util.Vector; import java.util.concurrent.ExecutionException; import java.util.logging.Level; import java.util.logging.Logger; import javax.swing.JTable; import javax.swing.SwingWorker; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableModel; import sun.applet.Main;  public class DataLoadWorker extends SwingWorker&lt;TableModel, TableModel&gt; {      private final JTable table;      public DataLoadWorker(JTable table) {         this.table = table;     }      @Override     protected TableModel doInBackground() throws Exception {         Vector data = new Vector();         Vector columns = new Vector();         PreparedStatement ps = null;         ResultSet rs = null;         try {             String stmt = ""SELECT * FROM APP.DATAVAULT"";             ps = Main.getPreparedStatement(stmt);             rs = ps.executeQuery();             ResultSetMetaData md = rs.getMetaData();             int columnCount = md.getColumnCount();             //store column names               for (int i = 1; i &lt;= columnCount; i++) {                 columns.add(md.getColumnName(i));             }              columns.ensureCapacity(columnCount);              Vector row;             while (rs.next()) {                  row = new Vector(columnCount);                 for (int i = 1; i &lt;= columnCount; i++) {                     row.add(rs.getString(i));                 }                 data.add(row);                  //Debugging                             }              // List.setModel(tableModel);          } finally {             try {                 ps.close();             } catch (Exception e) {             }             try {                 rs.close();             } catch (Exception e) {             }         }          DefaultTableModel tableModel = new DefaultTableModel(data, columns);         return tableModel;     }      @Override     protected void done() {         try {             TableModel model = get();             table.setModel(model);         } catch (InterruptedException | ExecutionException ex) {             ex.printStackTrace();         }     } }"
"import java.util.ArrayList; import java.sql.*;  public class OracleConnection {      public static void main(String[] args) throws Exception {         //connect to database         Class.forName(""oracle.jdbc.driver.OracleDriver"");         ArrayList&lt;String&gt; serverNames = new ArrayList&lt;String&gt;();         serverNames.add(""yourhostname1"");         serverNames.add(""yourhostname2"");         serverNames.add(""yourhostname3"");         serverNames.add(""yourhostname4"");         String portNumber = ""1521"";         String sid = ""ORCLSID"";         String url = ""jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS_LIST=(LOAD_BALANCE=ON)(FAILOVER=ON)"" ;         for (String serverName : serverNames) {               url += ""(ADDRESS=(PROTOCOL=tcp)(HOST=""+serverName+"")(PORT=""+portNumber+""))"";         }         url += "")(CONNECT_DATA=(SID=""+sid+"")))"";         String username = ""USERNAME"";         String password = ""PASSWORD"";         // System.out.println(url); // for debugging, if you want to see the url that was built         Connection conn = DriverManager.getConnection(url, username, password);     } }"
"import java.sql.ResultSet; import java.sql.SQLException; import java.util.Iterator;  public class FooResultSetIterator implements Iterator&lt;Foo&gt; {   private final ResultSet resultSet;   private boolean hasNext;    FooResultSetIterator(final ResultSet resultSet, final int fetchSize) throws SQLException   {     this.resultSet = resultSet;     this.resultSet.setFetchSize(fetchSize);     this.hasNext = resultSet.next();   }    @Override   public boolean hasNext()   {     return hasNext;   }    @Override   public Foo next()   {     final Foo foo = new Foo(resultSet);     try     {       this.hasNext = resultSet.next();     }     catch (final SQLException e)     {       throw new RuntimeException(e);     }     return foo;   }    @Override   public void remove()   {     throw new UnsupportedOperationException(""Cannot remove items from a ResultSetIterator"");   }  }  class Foo {   public Foo(ResultSet resultSet)   {     // TODO Auto-generated constructor stub   } }"
"import java.util.List; import org.apache.ibatis.annotations.SelectProvider;  public interface SqlMapper {     static class PureSqlProvider {         public String sql(String sql) {             return sql;         }          public String count(String from) {             return ""SELECT count(*) FROM "" + from;         }     }      @SelectProvider(type = PureSqlProvider.class, method = ""sql"")     public List&lt;?&gt; select(String sql);      @SelectProvider(type = PureSqlProvider.class, method = ""count"")     public Integer count(String from);      @SelectProvider(type = PureSqlProvider.class, method = ""sql"")     public Integer execute(String query); }"
"jdbcTemplate.execute(         new CallableStatementCreator() {            public CallableStatement createCallableStatement(Connection con) throws SQLException{               CallableStatement cs = con.prepareCall(""{call sys.dbms_stats.gather_table_stats(ownname=&gt;user, tabname=&gt;'"" + cachedMetadataTableName + ""', estimate_percent=&gt;20, method_opt=&gt;'FOR ALL COLUMNS SIZE 1', degree=&gt;0, granularity=&gt;'AUTO', cascade=&gt;TRUE, no_invalidate=&gt;FALSE, force=&gt;FALSE) }"");               return cs;            }         },         new CallableStatementCallback() {            public Object doInCallableStatement(CallableStatement cs) throws SQLException{               cs.execute();               return null; // Whatever is returned here is returned from the jdbcTemplate.execute method            }         }   );"
"import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.SQLException;  public class InsertPictureToMySql {   public static void main(String[] args) throws Exception, IOException, SQLException {     Class.forName(""org.gjt.mm.mysql.Driver"");     Connection conn = DriverManager.getConnection(""jdbc:mysql://localhost/databaseName"", ""root"", ""root"");     String INSERT_PICTURE = ""INSERT INTO MyPictures (photo) VALUES (?)"";      FileInputStream fis = null;     PreparedStatement ps = null;     try {       conn.setAutoCommit(false);       File file = new File(""/tmp/photo.png"");       fis = new FileInputStream(file);       ps = conn.prepareStatement(INSERT_PICTURE);       ps.setBinaryStream(1, fis, (int) file.length());       ps.executeUpdate();       conn.commit();     } finally {       ps.close();       fis.close();     }   } }"
"import java.io.FileReader; import java.sql.Connection; import java.sql.DriverManager;  import org.postgresql.copy.CopyManager; import org.postgresql.core.BaseConnection;  public class PgSqlJdbcCopyStreamsExample {      public static void main(String[] args) throws Exception {          if(args.length!=4) {             System.out.println(""Please specify database URL, user, password and file on the command line."");             System.out.println(""Like this: jdbc:postgresql://localhost:5432/test test password file"");         } else {              System.err.println(""Loading driver"");             Class.forName(""org.postgresql.Driver"");              System.err.println(""Connecting to "" + args[0]);             Connection con = DriverManager.getConnection(args[0],args[1],args[2]);              System.err.println(""Copying text data rows from stdin"");              CopyManager copyManager = new CopyManager((BaseConnection) con);              FileReader fileReader = new FileReader(args[3]);             copyManager.copyIn(""COPY t FROM STDIN"", fileReader );              System.err.println(""Done."");         }     } }"
"import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.Timestamp; import java.util.Date;  // create table x_tst_ts_tab( // os_name varchar(256) // ts timestamp, // ts_with_tz timestamp with time zone, // ts_with_local_tz timestamp with local time zone // ) class TSTest {     public static final void main(String[] argv) throws Exception {         Class.forName(""oracle.jdbc.OracleDriver"");         Connection conn = DriverManager.getConnection(             ""your_connection_string"",             ""your_user_name"",             ""your_password"");          try {             // Insert some data             Date nowDate = new Date();             Timestamp nowTimestamp = new Timestamp(nowDate.getTime());             PreparedStatement insertStmt = conn.prepareStatement(                 ""INSERT INTO x_tst_ts_tab""                 + "" (os_name, ts, ts_with_tz, ts_with_local_tz)""                 + "" VALUES (?, ?, ?, ?)"");             try {                 insertStmt.setString(1, System.getProperty(""os.name""));                 insertStmt.setTimestamp(2, nowTimestamp);                 insertStmt.setTimestamp(3, nowTimestamp);                 insertStmt.setTimestamp(4, nowTimestamp);                 insertStmt.executeUpdate();             } finally {                 try {                     insertStmt.close();                 } catch (Throwable t) {                     // do nothing                 }             }              System.out.println(""os_name, ts, ts_with_tz, ts_with_local_tz"");              // Read back everything in the DB             PreparedStatement selectStmt = conn.prepareStatement(                 ""SELECT os_name, ts, ts_with_tz, ts_with_local_tz""                 + "" FROM dom_fraud_beacon.x_tst_ts_tab"");             ResultSet result = null;             try {                 result = selectStmt.executeQuery();                 while (result.next()) {                     System.out.println(                         String.format(""%s,%s,%s,%s"",                                       result.getString(1),                                       result.getTimestamp(2).toString(),                                       result.getTimestamp(3).toString(),                                       result.getTimestamp(4).toString()                                       ));                 }             } finally {                 try {                     result.close();                 } catch (Throwable t) {                     // do nothing                 } finally {                     try {                         selectStmt.close();                     } catch (Throwable t) {                         // do nothing                     }                 }             }         } finally {             try {                 conn.close();             } catch (Throwable t) {                 // do nothing             }         }     } }"
"public List&lt;MessageSummary&gt; getMessages(Object[] params) {   // mList is filled with objects created in MessageRowMapper,   // so the length of the list equal to the number of rows in the ResultSet   List&lt;MessageSummary&gt; mList = jdbcTemplate.query(sqlStr, new MessageRowMapper(),                                                   params);   return mList; }  private final class MessageRowMapper implements RowMapper&lt;MessageSummary&gt; {   @Override   public MessageSummary mapRow(ResultSet rs, int i) throws SQLException   {     MessageSummary ms = new MessageSummary();      ms.setId(rs.getInt(""id""));     ms.setMessage(rs.getString(""message""));      return ms;   } }"
"class Demo{      public static java.lang.String getUser()                                           throws java.sql.SQLException {      java.sql.Statement stmt = null;     java.sql.ResultSet rs = null;      try{         java.sql.Connection con =                  java.sql.DriverManager.getConnection(""jdbc:default:connection"");          java.lang.String query =                    ""SELECT SYS_CONTEXT('USERENV', 'CURRENT_USER'),"" +                   ""SYS_CONTEXT('USERENV', 'SESSION_USER') FROM DUAL"";           stmt  = con.createStatement();         rs = stmt.executeQuery(query);          rs.next();          return ""Current User: ["" + rs.getString(1) + ""] ; "" +                ""Session User: ["" + rs.getString(2) + ""]"";     }     finally{         rs.close();         stmt.close();     }      }  }"
"package persistence;  import java.sql.*; import java.util.*;  /**  * util.DatabaseUtils  * User: Michael  * Date: Aug 17, 2010  * Time: 7:58:02 PM  */ public class DatabaseUtils {     private static final String DEFAULT_DRIVER = ""oracle.jdbc.driver.OracleDriver"";     private static final String DEFAULT_URL = ""jdbc:oracle:thin:@host:1521:database"";     private static final String DEFAULT_USERNAME = ""username"";     private static final String DEFAULT_PASSWORD = ""password""; /*     private static final String DEFAULT_DRIVER = ""org.postgresql.Driver"";     private static final String DEFAULT_URL = ""jdbc:postgresql://localhost:5432/party"";     private static final String DEFAULT_USERNAME = ""pgsuper"";     private static final String DEFAULT_PASSWORD = ""pgsuper""; */ /*     private static final String DEFAULT_DRIVER = ""com.mysql.jdbc.Driver"";     private static final String DEFAULT_URL = ""jdbc:mysql://localhost:3306/party"";     private static final String DEFAULT_USERNAME = ""party"";     private static final String DEFAULT_PASSWORD = ""party""; */      public static void main(String[] args) {         long begTime = System.currentTimeMillis();          String driver = ((args.length &gt; 0) ? args[0] : DEFAULT_DRIVER);         String url = ((args.length &gt; 1) ? args[1] : DEFAULT_URL);         String username = ((args.length &gt; 2) ? args[2] : DEFAULT_USERNAME);         String password = ((args.length &gt; 3) ? args[3] : DEFAULT_PASSWORD);          Connection connection = null;         // No, I loaded the driver as I intended.  It's correct.  The edit is not.         try {             connection = createConnection(driver, url, username, password);             DatabaseMetaData meta = connection.getMetaData();             System.out.println(meta.getDatabaseProductName());             System.out.println(meta.getDatabaseProductVersion());              String sqlQuery = ""SELECT PERSON_ID, FIRST_NAME, LAST_NAME FROM PERSON ORDER BY LAST_NAME"";             System.out.println(""before insert: "" + query(connection, sqlQuery, Collections.EMPTY_LIST));              connection.setAutoCommit(false);             String sqlUpdate = ""INSERT INTO PERSON(FIRST_NAME, LAST_NAME) VALUES(?,?)"";             List parameters = Arrays.asList(""Foo"", ""Bar"");             int numRowsUpdated = update(connection, sqlUpdate, parameters);             connection.commit();              System.out.println(""# rows inserted: "" + numRowsUpdated);             System.out.println(""after insert: "" + query(connection, sqlQuery, Collections.EMPTY_LIST));         } catch (Exception e) {             rollback(connection);             e.printStackTrace();         } finally {             close(connection);             long endTime = System.currentTimeMillis();             System.out.println(""wall time: "" + (endTime - begTime) + "" ms"");         }     }      public static Connection createConnection(String driver, String url, String username, String password) throws ClassNotFoundException, SQLException {         Class.forName(driver);         if ((username == null) || (password == null) || (username.trim().length() == 0) || (password.trim().length() == 0)) {             return DriverManager.getConnection(url);         } else {             return DriverManager.getConnection(url, username, password);         }     }      public static void close(Connection connection) {         try {             if (connection != null) {                 connection.close();             }         } catch (SQLException e) {             e.printStackTrace();         }     }       public static void close(Statement st) {         try {             if (st != null) {                 st.close();             }         } catch (SQLException e) {             e.printStackTrace();         }     }      public static void close(ResultSet rs) {         try {             if (rs != null) {                 rs.close();             }         } catch (SQLException e) {             e.printStackTrace();         }     }      public static void rollback(Connection connection) {         try {             if (connection != null) {                 connection.rollback();             }         } catch (SQLException e) {             e.printStackTrace();         }     }      public static List&lt;Map&lt;String, Object&gt;&gt; map(ResultSet rs) throws SQLException {         List&lt;Map&lt;String, Object&gt;&gt; results = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();         try {             if (rs != null) {                 ResultSetMetaData meta = rs.getMetaData();                 int numColumns = meta.getColumnCount();                 while (rs.next()) {                     Map&lt;String, Object&gt; row = new HashMap&lt;String, Object&gt;();                     for (int i = 1; i &lt;= numColumns; ++i) {                         String name = meta.getColumnName(i);                         Object value = rs.getObject(i);                         row.put(name, value);                     }                     results.add(row);                 }             }         } finally {             close(rs);         }         return results;     }      public static List&lt;Map&lt;String, Object&gt;&gt; query(Connection connection, String sql, List&lt;Object&gt; parameters) throws SQLException {         List&lt;Map&lt;String, Object&gt;&gt; results = null;         PreparedStatement ps = null;         ResultSet rs = null;         try {             ps = connection.prepareStatement(sql);              int i = 0;             for (Object parameter : parameters) {                 ps.setObject(++i, parameter);             }             rs = ps.executeQuery();             results = map(rs);         } finally {             close(rs);             close(ps);         }         return results;     }      public static int update(Connection connection, String sql, List&lt;Object&gt; parameters) throws SQLException {         int numRowsUpdated = 0;         PreparedStatement ps = null;         try {             ps = connection.prepareStatement(sql);              int i = 0;             for (Object parameter : parameters) {                 ps.setObject(++i, parameter);             }             numRowsUpdated = ps.executeUpdate();         } finally {             close(ps);         }         return numRowsUpdated;     } }"
"package persistence;  import java.sql.*; import java.util.*;  /**  * util.DatabaseUtils  * User: Michael  * Date: Aug 17, 2010  * Time: 7:58:02 PM  */ public class DatabaseUtils { /*     private static final String DEFAULT_DRIVER = ""oracle.jdbc.driver.OracleDriver"";     private static final String DEFAULT_URL = ""jdbc:oracle:thin:@host:1521:database"";     private static final String DEFAULT_USERNAME = ""username"";     private static final String DEFAULT_PASSWORD = ""password""; */ /*     private static final String DEFAULT_DRIVER = ""org.postgresql.Driver"";     private static final String DEFAULT_URL = ""jdbc:postgresql://localhost:5432/party"";     private static final String DEFAULT_USERNAME = ""pgsuper"";     private static final String DEFAULT_PASSWORD = ""pgsuper""; */     private static final String DEFAULT_DRIVER = ""com.mysql.jdbc.Driver"";     private static final String DEFAULT_URL = ""jdbc:mysql://localhost:3306/party"";     private static final String DEFAULT_USERNAME = ""party"";     private static final String DEFAULT_PASSWORD = ""party"";      public static void main(String[] args) {         long begTime = System.currentTimeMillis();          String driver = ((args.length &gt; 0) ? args[0] : DEFAULT_DRIVER);         String url = ((args.length &gt; 1) ? args[1] : DEFAULT_URL);         String username = ((args.length &gt; 2) ? args[2] : DEFAULT_USERNAME);         String password = ((args.length &gt; 3) ? args[3] : DEFAULT_PASSWORD);          Connection connection = null;          try {             connection = createConnection(driver, url, username, password);             DatabaseMetaData meta = connection.getMetaData();             System.out.println(meta.getDatabaseProductName());             System.out.println(meta.getDatabaseProductVersion());              String sqlQuery = ""SELECT PERSON_ID, FIRST_NAME, LAST_NAME FROM PERSON ORDER BY LAST_NAME"";             System.out.println(""before insert: "" + query(connection, sqlQuery, Collections.EMPTY_LIST));              connection.setAutoCommit(false);             String sqlUpdate = ""INSERT INTO PERSON(FIRST_NAME, LAST_NAME) VALUES(?,?)"";             List parameters = Arrays.asList(""Foo"", ""Bar"");             int numRowsUpdated = update(connection, sqlUpdate, parameters);             connection.commit();              System.out.println(""# rows inserted: "" + numRowsUpdated);             System.out.println(""after insert: "" + query(connection, sqlQuery, Collections.EMPTY_LIST));         } catch (Exception e) {             rollback(connection);             e.printStackTrace();         } finally {             close(connection);             long endTime = System.currentTimeMillis();             System.out.println(""wall time: "" + (endTime - begTime) + "" ms"");         }     }      public static Connection createConnection(String driver, String url, String username, String password) throws ClassNotFoundException, SQLException {         Class.forName(driver);         if ((username == null) || (password == null) || (username.trim().length() == 0) || (password.trim().length() == 0)) {             return DriverManager.getConnection(url);         } else {             return DriverManager.getConnection(url, username, password);         }     }      public static void close(Connection connection) {         try {             if (connection != null) {                 connection.close();             }         } catch (SQLException e) {             e.printStackTrace();         }     }       public static void close(Statement st) {         try {             if (st != null) {                 st.close();             }         } catch (SQLException e) {             e.printStackTrace();         }     }      public static void close(ResultSet rs) {         try {             if (rs != null) {                 rs.close();             }         } catch (SQLException e) {             e.printStackTrace();         }     }      public static void rollback(Connection connection) {         try {             if (connection != null) {                 connection.rollback();             }         } catch (SQLException e) {             e.printStackTrace();         }     }      public static List&lt;Map&lt;String, Object&gt;&gt; map(ResultSet rs) throws SQLException {         List&lt;Map&lt;String, Object&gt;&gt; results = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();         try {             if (rs != null) {                 ResultSetMetaData meta = rs.getMetaData();                 int numColumns = meta.getColumnCount();                 while (rs.next()) {                     Map&lt;String, Object&gt; row = new HashMap&lt;String, Object&gt;();                     for (int i = 1; i &lt;= numColumns; ++i) {                         String name = meta.getColumnName(i);                         Object value = rs.getObject(i);                         row.put(name, value);                     }                     results.add(row);                 }             }         } finally {             close(rs);         }         return results;     }      public static List&lt;Map&lt;String, Object&gt;&gt; query(Connection connection, String sql, List&lt;Object&gt; parameters) throws SQLException {         List&lt;Map&lt;String, Object&gt;&gt; results = null;         PreparedStatement ps = null;         ResultSet rs = null;         try {             ps = connection.prepareStatement(sql);              int i = 0;             for (Object parameter : parameters) {                 ps.setObject(++i, parameter);             }             rs = ps.executeQuery();             results = map(rs);         } finally {             close(rs);             close(ps);         }         return results;     }      public static int update(Connection connection, String sql, List&lt;Object&gt; parameters) throws SQLException {         int numRowsUpdated = 0;         PreparedStatement ps = null;         try {             ps = connection.prepareStatement(sql);              int i = 0;             for (Object parameter : parameters) {                 ps.setObject(++i, parameter);             }             numRowsUpdated = ps.executeUpdate();         } finally {             close(ps);         }         return numRowsUpdated;     } }"
"import java.sql.*; import java.util.logging.*; import javafx.application.Application; import javafx.collections.*; import javafx.event.ActionEvent; import javafx.event.EventHandler; import javafx.scene.Scene; import javafx.scene.control.*; import javafx.scene.layout.*; import javafx.stage.Stage;  public class H2app extends Application {   private static final Logger logger = Logger.getLogger(H2app.class.getName());   private static final String[] SAMPLE_NAME_DATA = { ""John"", ""Jill"", ""Jack"", ""Jerry"" };    public static void main(String[] args) { launch(args); }    @Override public void start(Stage stage) {     final ListView&lt;String&gt; nameView = new ListView();      final Button fetchNames = new Button(""Fetch names from the database"");     fetchNames.setOnAction(new EventHandler&lt;ActionEvent&gt;() {       @Override public void handle(ActionEvent event) {         fetchNamesFromDatabaseToListView(nameView);       }     });      final Button clearNameList = new Button(""Clear the name list"");     clearNameList.setOnAction(new EventHandler&lt;ActionEvent&gt;() {       @Override public void handle(ActionEvent event) {         nameView.getItems().clear();       }     });      VBox layout = new VBox(10);     layout.setStyle(""-fx-background-color: cornsilk; -fx-padding: 15;"");     layout.getChildren().setAll(       HBoxBuilder.create().spacing(10).children(         fetchNames,          clearNameList           ).build(),             nameView     );     layout.setPrefHeight(200);      stage.setScene(new Scene(layout));     stage.show();   }    private void fetchNamesFromDatabaseToListView(ListView listView) {     try (Connection con = getConnection()) {       if (!schemaExists(con)) {         createSchema(con);         populateDatabase(con);       }       listView.setItems(fetchNames(con));     } catch (SQLException | ClassNotFoundException ex) {       logger.log(Level.SEVERE, null, ex);     }   }    private Connection getConnection() throws ClassNotFoundException, SQLException {     logger.info(""Getting a database connection"");     Class.forName(""org.h2.Driver"");     return DriverManager.getConnection(""jdbc:h2:~/test"", ""sa"", """");   }    private void createSchema(Connection con) throws SQLException {     logger.info(""Creating schema"");     Statement st = con.createStatement();     String table = ""create table employee(id integer, name varchar(64))"";     st.executeUpdate(table);     logger.info(""Created schema"");   }    private void populateDatabase(Connection con) throws SQLException {     logger.info(""Populating database"");           Statement st = con.createStatement();           int i = 1;     for (String name: SAMPLE_NAME_DATA) {       st.executeUpdate(""insert into employee values(i,'"" + name + ""')"");       i++;     }     logger.info(""Populated database"");   }    private boolean schemaExists(Connection con) {     logger.info(""Checking for Schema existence"");           try {       Statement st = con.createStatement();             st.executeQuery(""select count(*) from employee"");       logger.info(""Schema exists"");           } catch (SQLException ex) {       logger.info(""Existing DB not found will create a new one"");       return false;     }      return true;   }    private ObservableList&lt;String&gt; fetchNames(Connection con) throws SQLException {     logger.info(""Fetching names from database"");     ObservableList&lt;String&gt; names = FXCollections.observableArrayList();      Statement st = con.createStatement();           ResultSet rs = st.executeQuery(""select name from employee"");     while (rs.next()) {       names.add(rs.getString(""name""));     }      logger.info(""Found "" + names.size() + "" names"");      return names;   } }"
