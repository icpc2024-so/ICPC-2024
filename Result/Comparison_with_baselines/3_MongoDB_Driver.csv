code
"package com.example.mongo;  import com.mongodb.BasicDBObject; import com.mongodb.MongoClient; import com.mongodb.client.MongoCollection; import com.mongodb.client.MongoDatabase; import de.flapdoodle.embed.mongo.MongodExecutable; import de.flapdoodle.embed.mongo.MongodProcess; import de.flapdoodle.embed.mongo.MongodStarter; import de.flapdoodle.embed.mongo.config.IMongodConfig; import de.flapdoodle.embed.mongo.config.MongodConfigBuilder; import de.flapdoodle.embed.mongo.config.Net; import de.flapdoodle.embed.mongo.distribution.Version; import de.flapdoodle.embed.process.runtime.Network; import java.util.Date; import org.junit.After; import static org.junit.Assert.*; import org.junit.Before; import org.junit.Test;  public class EmbeddedMongoTest {     private static final String DATABASE_NAME = ""embedded"";      private MongodExecutable mongodExe;     private MongodProcess mongod;     private MongoClient mongo;      @Before     public void beforeEach() throws Exception {         MongodStarter starter = MongodStarter.getDefaultInstance();         String bindIp = ""localhost"";         int port = 12345;         IMongodConfig mongodConfig = new MongodConfigBuilder()         .version(Version.Main.PRODUCTION)         .net(new Net(bindIp, port, Network.localhostIsIPv6()))         .build();         this.mongodExe = starter.prepare(mongodConfig);         this.mongod = mongodExe.start();         this.mongo = new MongoClient(bindIp, port);     }      @After     public void afterEach() throws Exception {         if (this.mongod != null) {             this.mongod.stop();             this.mongodExe.stop();         }     }      @Test     public void shouldCreateNewObjectInEmbeddedMongoDb() {         // given         MongoDatabase db = mongo.getDatabase(DATABASE_NAME);         db.createCollection(""testCollection"");         MongoCollection&lt;BasicDBObject&gt; col = db.getCollection(""testCollection"", BasicDBObject.class);          // when         col.insertOne(new BasicDBObject(""testDoc"", new Date()));          // then         assertEquals(1L, col.countDocuments());     }  }"
"package com.sample;  import org.restlet.Application; import org.restlet.Context; import org.restlet.Request; import org.restlet.Response; import org.restlet.Restlet; import org.restlet.data.MediaType; import org.restlet.representation.StringRepresentation; import org.restlet.routing.Router;  public class MyApplication extends Application {      public MyApplication() {         super();     }      public MyApplication(Context parentContext) {         super(parentContext);     }      public Restlet createInboundRoot() {         Router router = new Router(getContext());          router.attach(""/hello"", HelloResource.class);    Restlet mainpage = new Restlet() {             @Override             public void handle(Request request, Response response) {                 StringBuilder stringBuilder = new StringBuilder();                  stringBuilder.append(""&lt;html&gt;"");                 stringBuilder.append(""&lt;head&gt;&lt;title&gt;Hello Application "" +                         ""Servlet Page&lt;/title&gt;&lt;/head&gt;"");                 stringBuilder.append(""&lt;body bgcolor=white&gt;"");                 stringBuilder.append(""&lt;a href=\""app/hello\""&gt;hello&lt;/a&gt; --&gt; returns hello world message "" +                         ""and date string"");                 stringBuilder.append(""&lt;/body&gt;"");                 stringBuilder.append(""&lt;/html&gt;"");                 response.setEntity(new StringRepresentation(                         stringBuilder.toString(),                         MediaType.TEXT_HTML));             }         };         router.attach("""", mainpage);          return router;     }  }"
"package com.bullethq.jawr.postprocessor;  import net.jawr.web.resource.FileNameUtils; import net.jawr.web.resource.bundle.factory.util.PathNormalizer; import net.jawr.web.resource.bundle.postprocess.BundleProcessingStatus; import net.jawr.web.resource.bundle.postprocess.impl.CSSURLPathRewriterPostProcessor; import net.jawr.web.resource.bundle.postprocess.impl.PostProcessorCssImageUrlRewriter;  import java.io.IOException;  public class CustomCssUrlPathRewriterPostProcessor extends CSSURLPathRewriterPostProcessor {      public static final String CUSTOM_URL_PATH_REWRITER = ""customcsspathrewriter"";      public CustomCssUrlPathRewriterPostProcessor() {         super(CUSTOM_URL_PATH_REWRITER);     }      // ========================================================================     // ========================================================================     // ========================================================================     @Override     protected PostProcessorCssImageUrlRewriter createImageUrlRewriter(BundleProcessingStatus status) {         return new CustomPostProcessorCssImageUrlRewriter(status);     }      // ========================================================================     // ========================================================================     // ========================================================================     public class CustomPostProcessorCssImageUrlRewriter extends PostProcessorCssImageUrlRewriter {          public CustomPostProcessorCssImageUrlRewriter(BundleProcessingStatus status) {             super(status);         }          // ========================================================================         // ========================================================================         // ========================================================================         @Override         protected String getUrlPath(String match, String originalPath, String newCssPath) throws IOException {             String url = match.substring(match.indexOf('(') + 1, match.lastIndexOf(')')).trim();              // Remove any quotes if necessary.             String quoteStr = """";             if (url.startsWith(""'"") || url.startsWith(""\"""")) {                 quoteStr = String.valueOf(url.charAt(0));                 url = url.substring(1, url.length() - 1);             }              // We now check if the url ends in a known image file extension             // If not, the url is ignored.             if (FileNameUtils.hasImageExtension(url)) {                 return super.getUrlPath(match, originalPath, newCssPath);             } else {                 // We need to rewrite the path, as any relative URLs will                 // not resolve correctly if Jawr has changed the CSS path.                 url = PathNormalizer.concatWebPath(originalPath, url);                 url = PathNormalizer.getRelativeWebPath(PathNormalizer.getParentPath(newCssPath), url);                 return ""url("" + quoteStr + url + quoteStr + "")"";             }         }     } }"
"import com.sun.jna.Native; import com.sun.jna.platform.win32.WinDef.HWND; import com.sun.jna.platform.win32.WinDef.LPARAM; import com.sun.jna.platform.win32.WinDef.LRESULT; import com.sun.jna.platform.win32.WinDef.WPARAM; import com.sun.jna.platform.win32.WinUser; import com.sun.jna.win32.StdCallLibrary;  public class TurnOffMonitor {    public interface User32 extends StdCallLibrary {       User32 INSTANCE = (User32) Native.loadLibrary(""user32"", User32.class);       int SC_MONITORPOWER = 0xF170;       int SC_MONITOR_OFF = 2;       int SC_MONITOR_ON = -1;        LRESULT SendMessageA(HWND paramHWND, int paramInt, WPARAM paramWPARAM,             LPARAM paramLPARAM);        LRESULT SendMessageA(HWND paramHWND, int paramInt, int paramInt2,             LPARAM paramLPARAM);    }     private static final long SLEEP_TIME = 4 * 1000; // 4 seconds     public static void main(String[] args) {       final User32 user32 = User32.INSTANCE;       System.out.println(""Foo"");        user32.SendMessageA(WinUser.HWND_BROADCAST, WinUser.WM_SYSCOMMAND,             User32.SC_MONITORPOWER, new LPARAM(User32.SC_MONITOR_OFF));        try {          Thread.sleep(SLEEP_TIME);       } catch (InterruptedException e) {}        user32.SendMessageA(WinUser.HWND_BROADCAST, WinUser.WM_SYSCOMMAND,             User32.SC_MONITORPOWER, new LPARAM(User32.SC_MONITOR_ON));     } }"
package org.camunda.bpm;  import org.camunda.bpm.engine.HistoryService; import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.history.HistoricProcessInstance; import org.camunda.bpm.engine.repository.ProcessDefinition; import java.util.List;  public class AllFinishedProcessInstances {    public List&lt;HistoricProcessInstance&gt; getAllFinishedProcessInstances(String processDefinitionName) {     ProcessEngine processEngine = BpmPlatform.getDefaultProcessEngine();     HistoryService historyService = processEngine.getHistoryService();;     RepositoryService repositoryService = processEngine.getRepositoryService();      ProcessDefinition myProcessDefinition =         repositoryService.createProcessDefinitionQuery()             .processDefinitionName(processDefinitionName)             .latestVersion() // we are only interested in the latest version             .singleResult();      List&lt;HistoricProcessInstance&gt; processInstances =         historyService.createHistoricProcessInstanceQuery()             .processDefinitionId(myProcessDefinition.getId())             .finished() // we only want the finished process instances             .list();      return processInstances;   }  }
"package my.app;  import com.sun.jersey.spi.container.ContainerRequest; import com.sun.jersey.spi.container.ContainerResponse; import com.sun.jersey.spi.container.ContainerResponseFilter;  public class CrossOriginResourceSharingFilter implements ContainerResponseFilter {      @Override     public ContainerResponse filter(ContainerRequest creq, ContainerResponse cresp) {          cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Origin"", ""*"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Credentials"", ""true"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Methods"", ""GET, POST, DELETE, PUT"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Headers"", ""Content-Type, Accept"");          return cresp;     } }"
"import org.apache.commons.httpclient.HttpClient; import org.jboss.resteasy.client.ClientRequest; import org.jboss.resteasy.client.ClientResponse; import org.jboss.resteasy.client.ProxyFactory; import org.jboss.resteasy.client.core.executors.ApacheHttpClientExecutor; import org.jboss.resteasy.plugins.providers.RegisterBuiltin; import org.jboss.resteasy.spi.ResteasyProviderFactory;  RegisterBuiltin.register(ResteasyProviderFactory.getInstance()); HttpClient httpClient = new HttpClient(); ApacheHttpClientExecutor executor = new ApacheHttpClientExecutor(httpClient) {     @Override     public ClientResponse execute(ClientRequest request) throws Exception {         request.header(""X-My-Header"", ""value"");         return super.execute(request);     }            };  SimpleClient client = ProxyFactory.create(SimpleClient.class, ""http://localhost:8081"", executor); client.putBasic(""hello world"");"
"import com.thoughtworks.xstream.XStream; import com.thoughtworks.xstream.annotations.XStreamAlias; import com.thoughtworks.xstream.annotations.XStreamConverter; import com.thoughtworks.xstream.converters.extended.ToAttributedValueConverter;  @XStreamAlias(""response"") @XStreamConverter(value=ToAttributedValueConverter.class, strings={""response""}) public class ClientGenericResponse {      String response;      @XStreamAlias(""type"")     String status;      ClientID client_id;      public String getResponse() {         return response;     }      public void setResponse(String response) {         this.response = response;     }      public String getStatus() {         return status;     }      public void setStatus(String status) {         this.status = status;     }      public ClientID getClient_id() {         return client_id;     }      public void setClient_id(ClientID clientId) {         client_id = clientId;     }      public static void main(String[] args) {          XStream xstream = new XStream();          xstream.processAnnotations(ClientGenericResponse.class);          // Send request (this retrieves the xml above)          String xmlResponse = Utility.sendRequest(xml, true);          ClientGenericResponse response = (ClientGenericResponse)xstream.fromXML(xmlResponse);     } }"
"import net.sourceforge.pmd.cpd.Tokens import net.sourceforge.pmd.cpd.TokenEntry import net.sourceforge.pmd.cpd.Tokenizer import net.sourceforge.pmd.cpd.CPDNullListener import net.sourceforge.pmd.cpd.MatchAlgorithm import net.sourceforge.pmd.cpd.SourceCode import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader import net.sourceforge.pmd.cpd.SimpleRenderer  // Prepare empty token data. TokenEntry.clearImages() def tokens = new Tokens()  // List all source files with text. def source = new TreeMap&lt;String, SourceCode&gt;() new File('.').eachFile { file -&gt;   if (file.isFile() &amp;&amp; file.name.endsWith('.txt')) {     def analyzedText = file.text     def sourceCode = new SourceCode(new StringCodeLoader(analyzedText, file.name))     source.put(sourceCode.fileName, sourceCode)     analyzedText.eachLine { line, lineNumber -&gt;       line.split('[\\W\\s\\t\\f]+').each { token -&gt;         token = token.trim()         if (token) {           tokens.add(new TokenEntry(token, sourceCode.fileName, lineNumber + 1))         }       }     }     tokens.add(TokenEntry.getEOF())   } }  // Run matching algorithm. def maxTokenChain = 15 def matchAlgorithm = new MatchAlgorithm(source, tokens, maxTokenChain, new CPDNullListener()) matchAlgorithm.findMatches()  // Produce report. matchAlgorithm.matches().each { match -&gt;   println ""  ========================================""   match.iterator().each { mark -&gt;     println ""  DUPLICATION ERROR: &lt;${mark.tokenSrcID}:${mark.beginLine}&gt; [DUPLICATION] Found a ${match.lineCount} line (${match.tokenCount} tokens) duplication!""   }   def indentedTextSlice = """"   match.sourceCodeSlice.eachLine { line -&gt;     indentedTextSlice += ""  $line\n""   }   println ""  ----------------------------------------""   println indentedTextSlice   println ""  ========================================"" }"
"import com.thoughtworks.xstream.converters.Converter; import com.thoughtworks.xstream.converters.MarshallingContext; import com.thoughtworks.xstream.converters.UnmarshallingContext; import com.thoughtworks.xstream.io.HierarchicalStreamReader; import com.thoughtworks.xstream.io.HierarchicalStreamWriter;  public class UserConverter implements Converter {      @Override     public boolean canConvert(Class clazz) {         return clazz.equals(User.class);     }      @Override     public void marshal(Object value, HierarchicalStreamWriter writer,             MarshallingContext context)      {      }      @Override     public Object unmarshal(HierarchicalStreamReader reader,             UnmarshallingContext context)      {         User user = new User();          reader.moveDown();         if (""fullName"".equals(reader.getNodeName()))         {             String[] name = reader.getValue().split(""\\s"");             user.setFirstName(name[0]);             user.setLastName(name[1]);         }         reader.moveUp();          return user;     } }"
"import com.thoughtworks.xstream.XStream; import com.thoughtworks.xstream.annotations.XStreamAlias; import com.thoughtworks.xstream.converters.Converter; import com.thoughtworks.xstream.converters.MarshallingContext; import com.thoughtworks.xstream.converters.UnmarshallingContext; import com.thoughtworks.xstream.io.HierarchicalStreamReader; import com.thoughtworks.xstream.io.HierarchicalStreamWriter;  public final class ConverterTest {     public static void main(String[] args) {         XStream xstream = new XStream();         xstream.autodetectAnnotations(true);         xstream.registerConverter(new PositionConverter());          final Position position = new Position();         position.setTitle(""The Title"");         position.setStartDate(""The Start Date"");         position.setEndDate(""The End Date"");          final String xml = xstream.toXML(position);         System.out.println(""Generated XML:"");         System.out.println(xml);          final Position genPosition = (Position) xstream.fromXML(xml);         System.out.println(""Generated Position:"");         System.out.println(""\tTitle: "" + genPosition.getTitle());         System.out.println(""\tStart Date: "" + genPosition.getStartDate());         System.out.println(""\tEnd Date: "" + genPosition.getEndDate());     }      @XStreamAlias(""Position"")     private static class Position {         public String getEndDate() {             return endDate;         }          public void setEndDate(String endDate) {             this.endDate = endDate;         }          public String getStartDate() {             return startDate;         }          public void setStartDate(String startDate) {             this.startDate = startDate;         }          public String getTitle() {             return title;         }          public void setTitle(String title) {             this.title = title;         }          private String title;         private String startDate;         private String endDate;     }      private static class PositionConverter implements Converter {         public boolean canConvert(Class clazz) {             return Position.class == clazz;         }          public void marshal(Object value, HierarchicalStreamWriter writer, MarshallingContext context) {             Position position = (Position)value;             writer.startNode(""PositionBorder"");              writer.startNode(""Title"");             writer.setValue(position.getTitle());             writer.endNode();              writer.startNode(""StartDate"");             writer.setValue(position.getStartDate());             writer.endNode();              writer.startNode(""EndDate"");             writer.setValue(position.getEndDate());             writer.endNode();              writer.endNode();         }          public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {             Position position = new Position();             // move it to &lt;PositionBorder&gt; tag.             reader.moveDown();             // now move it to &lt;Title&gt; tag.             reader.moveDown();             String title = reader.getValue();             position.setTitle(title);             reader.moveUp(); // moves back to &lt;PositionBorder&gt;              reader.moveDown(); // should move down to &lt;StartDate&gt; tag             String startDate = reader.getValue();             position.setStartDate(startDate);             reader.moveUp(); // move back to &lt;PositionBorder&gt;              reader.moveDown(); // should move down to &lt;EndDate&gt; tag             String endDate = reader.getValue();             position.setEndDate(endDate);             reader.moveUp(); // move back to &lt;PositionBorder&gt;               return position;         }     } }"
"import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.mapreduce.InputFormat; import org.apache.hadoop.mapreduce.RecordReader; import org.apache.hadoop.mapreduce.TaskAttemptContext; import org.apache.hadoop.mapreduce.TaskAttemptID; import org.apache.hadoop.mapreduce.lib.input.FileSplit; import org.apache.hadoop.mapreduce.task.TaskAttemptContextImpl; import org.apache.hadoop.util.ReflectionUtils; import java.io.File;  Configuration conf = new Configuration(false); conf.set(""fs.default.name"", ""file:///"");  File testFile = new File(""path/to/file""); Path path = new Path(testFile.getAbsoluteFile().toURI()); FileSplit split = new FileSplit(path, 0, testFile.length(), null);  InputFormat inputFormat = ReflectionUtils.newInstance(MyInputFormat.class, conf); TaskAttemptContext context = new TaskAttemptContextImpl(conf, new TaskAttemptID()); RecordReader reader = inputFormat.createRecordReader(split, context);  reader.initialize(split, context);"
"import com.sun.jna.Native; import com.sun.jna.Pointer; import com.sun.jna.platform.win32.WinDef.HWND; import com.sun.jna.platform.win32.WinUser; import com.sun.jna.platform.win32.WinUser.WNDENUMPROC; import com.sun.jna.win32.StdCallLibrary;  public class TryWithHWND {    public interface User32 extends StdCallLibrary {       User32 INSTANCE = (User32) Native.loadLibrary(""user32"", User32.class);       boolean EnumWindows(WinUser.WNDENUMPROC lpEnumFunc, Pointer arg);       int GetWindowTextA(HWND hWnd, byte[] lpString, int nMaxCount);    }     public static void main(String[] args) {       final User32 user32 = User32.INSTANCE;       user32.EnumWindows(new WNDENUMPROC() {          int count = 0;          @Override          public boolean callback(HWND hWnd, Pointer arg1) {             byte[] windowText = new byte[512];             user32.GetWindowTextA(hWnd, windowText, 512);             String wText = Native.toString(windowText);              // get rid of this if block if you want all windows regardless of whether             // or not they have text             if (wText.isEmpty()) {                return true;             }              System.out.println(""Found window with text "" + hWnd + "", total "" + ++count                   + "" Text: "" + wText);             return true;          }       }, null);    } }"
"package models; import com.avaje.ebean.config.ServerConfig;      import com.avaje.ebean.event.ServerConfigStartup;      import com.avaje.ebean.config.EncryptKey;        import com.avaje.ebean.config.EncryptKeyManager;   public class CustomServerConfigStartup implements ServerConfigStartup {       @Override      public void onStart(ServerConfig serverConfig) {                serverConfig.setEncryptKeyManager(new BasicEncryptKeyManager());          }      }   class BasicEncryptKeyManager implements EncryptKeyManager{    @Override   public EncryptKey getEncryptKey(String tableName, String columnName) {             return new CustomEncryptKey(tableName, columnName);       }    @Override   public void initialise() {       //Do nothing (yet)  }   }   class CustomEncryptKey implements EncryptKey{      private String tableName;     private String columnName;     public CustomEncryptKey(String tableName, String columnName){       this.tableName = tableName;       this.columnName = columnName;    }   @Override   public String getStringValue() {              return play.Configuration.root().getString(""application.secret"") + ""::"" + this.tableName + ""::"" + this.columnName;        }      }"
"import com.sun.jna.Native; import com.sun.jna.Pointer; import com.sun.jna.Structure; import com.sun.jna.WString; import com.sun.jna.platform.win32.Shell32; import com.sun.jna.platform.win32.WinDef.HINSTANCE; import com.sun.jna.platform.win32.WinDef.HWND; import com.sun.jna.platform.win32.WinNT.HANDLE; import com.sun.jna.platform.win32.WinReg.HKEY; import com.sun.jna.win32.W32APIOptions;  public interface Shell32X extends Shell32 {     Shell32X INSTANCE = (Shell32X)Native.loadLibrary(""shell32"", Shell32X.class, W32APIOptions.UNICODE_OPTIONS);      int SW_HIDE = 0;     int SW_MAXIMIZE = 3;     int SW_MINIMIZE = 6;     int SW_RESTORE = 9;     int SW_SHOW = 5;     int SW_SHOWDEFAULT = 10;     int SW_SHOWMAXIMIZED = 3;     int SW_SHOWMINIMIZED = 2;     int SW_SHOWMINNOACTIVE = 7;     int SW_SHOWNA = 8;     int SW_SHOWNOACTIVATE = 4;     int SW_SHOWNORMAL = 1;      /** File not found. */     int SE_ERR_FNF = 2;      /** Path not found. */     int SE_ERR_PNF = 3;      /** Access denied. */     int SE_ERR_ACCESSDENIED = 5;      /** Out of memory. */     int SE_ERR_OOM = 8;      /** DLL not found. */     int SE_ERR_DLLNOTFOUND = 32;      /** Cannot share an open file. */     int SE_ERR_SHARE = 26;        int SEE_MASK_NOCLOSEPROCESS = 0x00000040;       int ShellExecute(int i, String lpVerb, String lpFile, String lpParameters, String lpDirectory, int nShow);     boolean ShellExecuteEx(SHELLEXECUTEINFO lpExecInfo);        public static class SHELLEXECUTEINFO extends Structure     {         /*   DWORD     cbSize;   ULONG     fMask;   HWND      hwnd;   LPCTSTR   lpVerb;   LPCTSTR   lpFile;   LPCTSTR   lpParameters;   LPCTSTR   lpDirectory;   int       nShow;   HINSTANCE hInstApp;   LPVOID    lpIDList;   LPCTSTR   lpClass;   HKEY      hkeyClass;   DWORD     dwHotKey;   union {     HANDLE hIcon;     HANDLE hMonitor;   } DUMMYUNIONNAME;   HANDLE    hProcess;          */          public int cbSize = size();         public int fMask;         public HWND hwnd;         public WString lpVerb;         public WString lpFile;         public WString lpParameters;         public WString lpDirectory;         public int nShow;         public HINSTANCE hInstApp;         public Pointer lpIDList;         public WString lpClass;         public HKEY hKeyClass;         public int dwHotKey;          /*          * Actually:          * union {          *  HANDLE hIcon;          *  HANDLE hMonitor;          * } DUMMYUNIONNAME;          */         public HANDLE hMonitor;         public HANDLE hProcess;          protected List getFieldOrder() {             return Arrays.asList(new String[] {                 ""cbSize"", ""fMask"", ""hwnd"", ""lpVerb"", ""lpFile"", ""lpParameters"",                 ""lpDirectory"", ""nShow"", ""hInstApp"", ""lpIDList"", ""lpClass"",                 ""hKeyClass"", ""dwHotKey"", ""hMonitor"", ""hProcess"",             });         }     }  }"
"public static List&lt;Product&gt; getCartList() {      JSONObject responseDetailsJson = new JSONObject();     JSONArray jsonArray = new JSONArray();      List&lt;Product&gt; cartList = new Vector&lt;Product&gt;(cartMap.keySet().size());     for(Product p : cartMap.keySet()) {         cartList.add(p);         JSONObject formDetailsJson = new JSONObject();         formDetailsJson.put(""id"", ""1"");         formDetailsJson.put(""name"", ""name1"");        jsonArray.add(formDetailsJson);     }     responseDetailsJson.put(""forms"", jsonArray);//Here you can see the data in json format      return cartList;  }"
"Connection con;     String url=""jdbc:mysql://localhost/mydb"";     Class.forName(""com.mysql.jdbc.Driver"").newInstance();     con=(Connection) DriverManager.getConnection(url,""root"","""");     JasperReport jasperReport = JasperCompileManager.compileReport(fileName);     JasperPrint print = JasperFillManager.fillReport(jasperReport, parameter, con);     print.setPageHeight(100);     print.setPageWidth(80);     print.setOrientation(jasperReport.getOrientationValue().LANDSCAPE);     JasperPrintManager.printReport(print,false);"
"import org.newdawn.slick.util.pathfinding.AStarPathFinder; import org.newdawn.slick.util.pathfinding.Mover; import org.newdawn.slick.util.pathfinding.Path; import org.newdawn.slick.util.pathfinding.PathFindingContext; import org.newdawn.slick.util.pathfinding.TileBasedMap;   public class AStarTest {      private static final int MAX_PATH_LENGTH = 100;      private static final int START_X = 1;     private static final int START_Y = 1;      private static final int GOAL_X = 1;     private static final int GOAL_Y = 6;      public static void main(String[] args) {          SimpleMap map = new SimpleMap();          AStarPathFinder pathFinder = new AStarPathFinder(map, MAX_PATH_LENGTH, false);         Path path = pathFinder.findPath(null, START_X, START_Y, GOAL_X, GOAL_Y);          int length = path.getLength();         System.out.println(""Found path of length: "" + length + ""."");          for(int i = 0; i &lt; length; i++) {             System.out.println(""Move to: "" + path.getX(i) + "","" + path.getY(i) + ""."");         }      }  }  class SimpleMap implements TileBasedMap {     private static final int WIDTH = 10;     private static final int HEIGHT = 10;      private static final int[][] MAP = {         {1,1,1,1,1,1,1,1,1,1},         {1,0,0,0,0,0,1,1,1,1},         {1,0,1,1,1,0,1,1,1,1},         {1,0,1,1,1,0,0,0,1,1},         {1,0,0,0,1,1,1,0,1,1},         {1,1,1,0,1,1,1,0,0,0},         {1,0,1,0,0,0,0,0,1,0},         {1,0,1,1,1,1,1,1,1,0},         {1,0,0,0,0,0,0,0,0,0},         {1,1,1,1,1,1,1,1,1,0}     };      @Override     public boolean blocked(PathFindingContext ctx, int x, int y) {         return MAP[y][x] != 0;     }      @Override     public float getCost(PathFindingContext ctx, int x, int y) {         return 1.0f;     }      @Override     public int getHeightInTiles() {         return HEIGHT;     }      @Override     public int getWidthInTiles() {         return WIDTH;     }      @Override     public void pathFinderVisited(int x, int y) {}  }"
"import org.apache.commons.net.io.Util; import org.apache.commons.net.io.CopyStreamListener;  private void copy(FileObject sourceFile, FileObject destinationFile, CopyStreamListener progressMonitor) throws IOException {     InputStream sourceFileIn = sourceFile.getContent().getInputStream();     try {         OutputStream destinationFileOut = destinationFile.getContent().getOutputStream();         try {             Util.copyStream(sourceFileIn, destinationFileOut, Util.DEFAULT_COPY_BUFFER_SIZE, sourceFile.getContent().getSize(), progressMonitor);         } finally {             destinationFileOut.close();         }     } finally {         sourceFileIn.close();     } }"
"package org.hibernate.envers.test.integration.basic;  import org.hibernate.Session; import org.hibernate.action.spi.AfterTransactionCompletionProcess; import org.hibernate.action.spi.BeforeTransactionCompletionProcess; import org.hibernate.engine.spi.SessionImplementor; import org.hibernate.envers.internal.tools.MutableInteger; import org.hibernate.envers.test.BaseEnversFunctionalTestCase; import org.hibernate.envers.test.entities.StrTestEntity; import org.hibernate.event.service.spi.EventListenerRegistry; import org.hibernate.event.spi.EventType; import org.hibernate.event.spi.PostInsertEvent; import org.hibernate.event.spi.PostInsertEventListener; import org.hibernate.persister.entity.EntityPersister;  import org.junit.Assert; import org.junit.Test;  import org.hibernate.testing.TestForIssue;  /**  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)  */ public class RegisterUserEventListenersTest extends BaseEnversFunctionalTestCase {     @Override     protected Class&lt;?&gt;[] getAnnotatedClasses() {         return new Class&lt;?&gt;[] {StrTestEntity.class};     }      @Test     @TestForIssue(jiraKey = ""HHH-7478"")     public void testTransactionProcessSynchronization() {         final EventListenerRegistry registry = sessionFactory().getServiceRegistry()                 .getService( EventListenerRegistry.class );         final CountingPostInsertTransactionBoundaryListener listener = new CountingPostInsertTransactionBoundaryListener();          registry.getEventListenerGroup( EventType.POST_INSERT ).appendListener( listener );          Session session = openSession();         session.getTransaction().begin();         StrTestEntity entity = new StrTestEntity( ""str1"" );         session.save( entity );         session.getTransaction().commit();         session.close();          // Post insert listener invoked three times - before/after insertion of original data,         // revision entity and audit row.         Assert.assertEquals( 3, listener.getBeforeCount() );         Assert.assertEquals( 3, listener.getAfterCount() );     }      private static class CountingPostInsertTransactionBoundaryListener implements PostInsertEventListener {         private final MutableInteger beforeCounter = new MutableInteger();         private final MutableInteger afterCounter = new MutableInteger();          @Override         public void onPostInsert(PostInsertEvent event) {             event.getSession().getActionQueue().registerProcess(                     new BeforeTransactionCompletionProcess() {                         @Override                         public void doBeforeTransactionCompletion(SessionImplementor session) {                             beforeCounter.increase();                         }                     }             );             event.getSession().getActionQueue().registerProcess(                     new AfterTransactionCompletionProcess() {                         @Override                         public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {                             afterCounter.increase();                         }                     }             );         }          @Override         public boolean requiresPostCommitHanding(EntityPersister persister) {             return true;         }          public int getBeforeCount() {             return beforeCounter.get();         }          public int getAfterCount() {             return afterCounter.get();         }     } }"
"import play.GlobalSettings; import play.mvc.Action; import play.mvc.Http; import play.mvc.Result;  import java.lang.reflect.Method;  public class Global extends GlobalSettings {      @Override     public Action onRequest(final Http.Request request, Method method) {         if (""GET"".equals(request.method()) &amp;&amp; ""www.example.com"".equals(request.host())) {             return new Action.Simple() {                 public Result call(Http.Context ctx) throws Throwable {                     return movedPermanently(""http://example.com"" + request.path());                 }             };         }         return super.onRequest(request, method);     } }"
"import org.opencv.core.Core; import org.opencv.core.CvType; import org.opencv.core.Mat; import org.opencv.core.Rect; import org.opencv.core.Scalar; import org.opencv.highgui.Highgui; import org.opencv.imgproc.Imgproc;  /**  * Example how to use grabCut algorithm in OpenCV using GC_INIT_WITH_MASK.  *  */ public class ImageSegmentByMask {      public static void main(String[] args) {         System.loadLibrary(Core.NATIVE_LIBRARY_NAME);          // will read image         Mat image = Highgui.imread(""lena.png"");         Mat mask = Highgui.imread(""lena_mask.png"", Highgui.CV_LOAD_IMAGE_GRAYSCALE);          Rect rectangle = new Rect(10, 10, image.cols() - 20, image.rows() - 20);          Mat bgdModel = new Mat(); // extracted features for background         Mat fgdModel = new Mat(); // extracted features for foreground         Mat source = new Mat(1, 1, CvType.CV_8U, new Scalar(0));          convertToOpencvValues(mask); // from human readable values to OpenCV values           int iterCount = 1;         Imgproc.grabCut(image, mask, rectangle, bgdModel, fgdModel, iterCount, Imgproc.GC_INIT_WITH_MASK);           convertToHumanValues(mask); // back to human readable values         Imgproc.threshold(mask,mask,128,255,Imgproc.THRESH_TOZERO);          Mat foreground = new Mat(image.size(), CvType.CV_8UC1, new Scalar(0, 0, 0));         image.copyTo(foreground, mask);          Highgui.imwrite(""sandbox/sucess1.jpg"", foreground);     }      private static void convertToHumanValues(Mat mask) {         byte[] buffer = new byte[3];         for (int x = 0; x &lt; mask.rows(); x++) {             for (int y = 0; y &lt; mask.cols(); y++) {                 mask.get(x, y, buffer);                 int value = buffer[0];                 if (value == Imgproc.GC_BGD) {                     buffer[0] = 0; // for sure background                 } else if (value == Imgproc.GC_PR_BGD) {                     buffer[0] = 85; // probably background                 } else if (value == Imgproc.GC_PR_FGD) {                     buffer[0] = (byte) 170; // probably foreground                 } else {                     buffer[0] = (byte) 255; // for sure foreground                  }                 mask.put(x, y, buffer);             }         }     }      /**      * Converts level of grayscale into OpenCV values. White - foreground, Black      * - background.      *       * @param mask      */     private static void convertToOpencvValues(Mat mask) {         byte[] buffer = new byte[3];         for (int x = 0; x &lt; mask.rows(); x++) {             for (int y = 0; y &lt; mask.cols(); y++) {                 mask.get(x, y, buffer);                 int value = buffer[0];                 if (value &gt;= 0 &amp;&amp; value &lt; 64) {                     buffer[0] = Imgproc.GC_BGD; // for sure background                 } else if (value &gt;= 64 &amp;&amp; value &lt; 128) {                     buffer[0] = Imgproc.GC_PR_BGD; // probably background                 } else if (value &gt;= 128 &amp;&amp; value &lt; 192) {                     buffer[0] = Imgproc.GC_PR_FGD; // probably foreground                 } else {                     buffer[0] = Imgproc.GC_FGD; // for sure foreground                  }                 mask.put(x, y, buffer);             }         }      }  }"
"class MyFileDownloadAction extends ActionSupport{       private String fileName;      // getter and setter      public String fileDownload() throws exception{       // file download logic       fileName =""abc""  // can set name dynamic from DB    }  }  &lt;action name=""download"" class=""action.DownloadAction""&gt;         &lt;result name=""success"" type=""stream""&gt;             &lt;param name=""contentType""&gt;application/octet-stream&lt;/param&gt;             &lt;param name=""inputName""&gt;fileInputStream&lt;/param&gt;             &lt;param name=""contentDisposition""&gt;attachment;filename=""${filename}""&lt;/param&gt;             &lt;param name=""bufferSize""&gt;1024&lt;/param&gt;         &lt;/result&gt;         &lt;result name=""error""&gt;/live/useradminerror.jsp&lt;/result&gt;     &lt;/action&gt;"
"package com.mycompany;  import com.sun.jersey.api.model.AbstractMethod; import com.sun.jersey.api.model.AbstractResource; import com.sun.jersey.api.model.AbstractResourceMethod; import com.sun.jersey.api.model.Parameter; import com.sun.jersey.server.wadl.WadlGenerator; import com.sun.research.ws.wadl.Application; import com.sun.research.ws.wadl.Method; import com.sun.research.ws.wadl.ObjectFactory; import com.sun.research.ws.wadl.Option; import com.sun.research.ws.wadl.Param; import com.sun.research.ws.wadl.RepresentationType; import com.sun.research.ws.wadl.Request; import com.sun.research.ws.wadl.Resource; import com.sun.research.ws.wadl.Resources; import com.sun.research.ws.wadl.Response;  import javax.ws.rs.core.MediaType;  public class OptionsWadlGenerator implements WadlGenerator {      private WadlGenerator _delegate;      private ObjectFactory objectFactory = new ObjectFactory();      @Override     public Param createParam(AbstractResource r, AbstractMethod m, Parameter p) {         Param param = _delegate.createParam(r, m, p);         if(((Parameter)p).getParameterClass().isEnum()){             Object[] values = p.getParameterClass().getEnumConstants();             for(Object enumItem:values){                 Option option = objectFactory.createOption();                 option.setValue(((Enum)enumItem).name());                 param.getOption().add(option);             }         }         return param;     }      @Override     public void setWadlGeneratorDelegate(WadlGenerator delegate) {         this._delegate = delegate;     }      @Override     public Application createApplication() {         return _delegate.createApplication();     }      ... all other methods also simply call the _delegate equivalent method     }"
"package com.jaspersoft.alliances.mdahlman; import com.google.zxing.BarcodeFormat; import com.google.zxing.WriterException; import com.google.zxing.common.BitMatrix; import com.google.zxing.qrcode.QRCodeWriter; import com.google.zxing.client.j2se.MatrixToImageWriter; import net.sf.jasperreports.engine.JRDefaultScriptlet; import net.sf.jasperreports.engine.JRScriptletException;  public class QRCodeScriptlet extends JRDefaultScriptlet {     public void afterDetailEval() throws JRScriptletException {         QRCodeWriter writer = new QRCodeWriter();         BitMatrix matrix = null;         try {             matrix = writer.encode(getFieldValue(""barcode_text"").toString(), BarcodeFormat.QR_CODE, 256, 256);             this.setVariableValue(""BarCodeImage"", MatrixToImageWriter.toBufferedImage(matrix) );         } catch (WriterException e) {             e.printStackTrace();         }     } }"
"private class InfoSerializer implements JsonSerializer&lt;Info&gt; {     @Override     public JsonElement serialize(Info src, Type typeOfSrc,             JsonSerializationContext context)     {          JsonObject obj = new JsonObject();          obj.addProperty(""details"", src.getDetails());          obj.addProperty(""hostId"", src.getHostId());          obj.addProperty(""dateCreated"", src.getDateCreated().toString());          obj.addProperty(""expiryDate"", src.getExpiryDate().toString());          obj.add(""alternativeInfo"", getGsonInstance().toJsonTree(src.getAlternativeInfo()));          obj.add(""alternativeTimes"", getGsonInstance().toJsonTree(src.getAlternativeTimes()));          return obj;     }    }"
"NotificationCompat.Builder b = new NotificationCompat.Builder(c);        b.setNumber(g_push.Counter)         .setLargeIcon(BitmapFactory.decodeResource(c.getResources(), R.drawable.list_avatar))         .setSmallIcon(R.drawable.ic_stat_example)         .setAutoCancel(true)         .setContentTitle(pushCount &gt; 1 ? c.getString(R.string.stat_messages_title) + pushCount : title)         .setContentText(pushCount &gt; 1 ? push.ProfileID : mess)         .setWhen(g_push.Timestamp)         .setContentIntent(PendingIntent.getActivity(c, 0, it, PendingIntent.FLAG_UPDATE_CURRENT))         .setDeleteIntent(PendingIntent.getBroadcast(c, 0, new Intent(ACTION_CLEAR_NOTIFICATION), PendingIntent.FLAG_CANCEL_CURRENT))         .setDefaults(Notification.DEFAULT_LIGHTS | Notification.DEFAULT_VIBRATE)         .setSound(Uri.parse(prefs.getString(                 SharedPreferencesID.PREFERENCE_ID_PUSH_SOUND_URI,                 ""android.resource://ru.mail.mailapp/raw/new_message_bells"")));"
protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);      map = ((SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map)).getMap();      // Add this line     map.setMyLocationEnabled(true);      locManager = (LocationManager)getSystemService(LOCATION_SERVICE);     providersList = locManager.getAllProviders();     provider =locManager.getProvider(providersList.get(0));     precision = provider.getAccuracy();     req = new Criteria();     req.setAccuracy(Criteria.ACCURACY_FINE);             inside = false;      //map.getUiSettings().setMyLocationButtonEnabled(true);      buildPolygon();     drawPolygon();     startLocalization(); }
"import com.sun.jna.Native; import com.sun.jna.Pointer; import com.sun.jna.platform.win32.BaseTSD.LONG_PTR; import com.sun.jna.platform.win32.WinDef.HWND; import com.sun.jna.platform.win32.WinDef.RECT; import com.sun.jna.win32.StdCallLibrary;  /**  * JNA interface with Window's user32.dll  *   * @author Pete S  *   */ public interface User32 extends StdCallLibrary {    User32 INSTANCE = (User32) Native.loadLibrary(""user32"", User32.class);     interface WNDENUMPROC extends StdCallCallback {       boolean callback(Pointer hWnd, Pointer arg);    }     public static final int GW_OWNER = 4; // used with GetWindow to get win owner    public static final int GW_HWNDNEXT = 2; // used with GetNextWindow    public static final int GA_ROOT = 2; // used with GetAncestor    public static final int GWL_EXSTYLE = -20; // used with GetWindowLong    public static final long WS_EX_APPWINDOW = 0x00040000L;    public static final Pointer HWND_TOP = new Pointer(0L); // used with                                                            // SetWindowPos     boolean EnumWindows(WNDENUMPROC lpEnumFunc, Pointer userData);     int GetWindowTextA(Pointer hWnd, byte[] lpString, int nMaxCount);     int SetForegroundWindow(Pointer hWnd);     Pointer GetForegroundWindow();     boolean GetWindowRect(Pointer hWnd, RECT rect);     boolean SetWindowPos(Pointer hWnd, Pointer hWndInsertAfter, int x, int y,          int cx, int cy, int uFlags);     boolean MoveWindow(Pointer hWnd, int x, int y, int nWidth, int nHeight, boolean bRepaint);     boolean IsWindow(Pointer hWnd);     Pointer GetWindow(Pointer hWnd, int uCmd);     LONG_PTR GetWindowLongPtr(HWND hWnd, int nIndex);     Pointer GetParent(Pointer hWnd);     Pointer GetAncestor(Pointer hWnd, int gaFlags);     boolean IsWindowVisible(Pointer hWnd); }"
"import java.lang.reflect.Constructor;  import org.joda.time.DateTime;  import com.thoughtworks.xstream.converters.Converter; import com.thoughtworks.xstream.converters.MarshallingContext; import com.thoughtworks.xstream.converters.UnmarshallingContext; import com.thoughtworks.xstream.io.HierarchicalStreamReader; import com.thoughtworks.xstream.io.HierarchicalStreamWriter;   public final class JodaTimeConverter implements Converter {      @Override     @SuppressWarnings(""unchecked"")     public boolean canConvert(final Class type) {             return (type != null) &amp;&amp; DateTime.class.getPackage().equals(type.getPackage());     }      @Override     public void marshal(final Object source, final HierarchicalStreamWriter writer,             final MarshallingContext context) {             writer.setValue(source.toString());     }      @Override     @SuppressWarnings(""unchecked"")     public Object unmarshal(final HierarchicalStreamReader reader,             final UnmarshallingContext context) {             try {                     final Class requiredType = context.getRequiredType();                     final Constructor constructor = requiredType.getConstructor(Object.class);                     return constructor.newInstance(reader.getValue());             } catch (final Exception e) {                 throw new RuntimeException(String.format(                  ""Exception while deserializing a Joda Time object: %s"", context.getRequiredType().getSimpleName()), e);             }     }  }"
