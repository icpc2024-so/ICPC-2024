code
"import java.io.File; import java.io.FileReader; import java.io.IOException; import java.security.KeyPair; import java.security.Security; import java.security.Signature; import java.util.Arrays;  import org.bouncycastle.jce.provider.BouncyCastleProvider; import org.bouncycastle.openssl.PEMReader; import org.bouncycastle.openssl.PasswordFinder; import org.bouncycastle.util.encoders.Hex;  public class SignatureExample {      public static void main(String [] args) throws Exception {         Security.addProvider(new BouncyCastleProvider());          String message = ""hello world"";         File privateKey = new File(""private.pem"");         KeyPair keyPair = readKeyPair(privateKey, ""password"".toCharArray());          Signature signature = Signature.getInstance(""SHA256WithRSAEncryption"");         signature.initSign(keyPair.getPrivate());         signature.update(message.getBytes());         byte [] signatureBytes = signature.sign();         System.out.println(new String(Hex.encode(signatureBytes)));          Signature verifier = Signature.getInstance(""SHA256WithRSAEncryption"");         verifier.initVerify(keyPair.getPublic());         verifier.update(message.getBytes());         if (verifier.verify(signatureBytes)) {             System.out.println(""Signature is valid"");         } else {             System.out.println(""Signature is invalid"");         }     }      private static KeyPair readKeyPair(File privateKey, char [] keyPassword) throws IOException {         FileReader fileReader = new FileReader(privateKey);         PEMReader r = new PEMReader(fileReader, new DefaultPasswordFinder(keyPassword));         try {             return (KeyPair) r.readObject();         } catch (IOException ex) {             throw new IOException(""The private key could not be decrypted"", ex);         } finally {             r.close();             fileReader.close();         }     }      private static class DefaultPasswordFinder implements PasswordFinder {          private final char [] password;          private DefaultPasswordFinder(char [] password) {             this.password = password;         }          @Override         public char[] getPassword() {             return Arrays.copyOf(password, password.length);         }     }  }"
"String url = ""http://www.theGateWayurl.com""; // Generates the connection to the amf gateway. AMFConnection amfConnection = new AMFConnection();  // Must register the class that this library will use to load the // AMF object information. // The library will read AMF object variables and use setters from // the java bean stated in this line. AMFConnection.registerAlias("""", new LabelData().getClass().getName());  try {     // Do the connection.     amfConnection.connect(url);      // This page requires a certain headers to function.     // The Content-type is used to sniff with Charles Web Proxy.     amfConnection.addHttpRequestHeader(""Content-type"", ""application/x-amf"");     // The Referer is used by the webpage to allow gathering information.     amfConnection.addHttpRequestHeader(""Referer"", ""http://orlandoinfo.com/ws/b2c/sitesearch/customtags/comSearch.swf"");      // The rest of the HTTP POST sent by this library is wrapped     // inside a RemotingMessage.     // Prepare the msg to send.     RemotingMessage msg = new RemotingMessage();      // The method called in the server.     msg.setOperation(""getLocations"");      // Where the request came from. Similar to referer.     msg.setSource(""ws.b2c.sitesearch.components.myService"");      // The destination is a needed parameter.     msg.setDestination(""ColdFusion"");      // Create the body with the parameters needed to call the     // operation set with setOperation()     msg.setBody(new Object[] {""consumer"", ""attractions""});      // This is needed but not used.     msg.setMessageId(""xxxxxxxxxx"");      // Send the msg.     AcknowledgeMessage reply = (AcknowledgeMessage) amfConnection.call(""null"", msg);      // Parse the reply from the server.     ArrayCollection body = (ArrayCollection) reply.getBody();     for (Object obj : body) {         LabelData location = (LabelData) obj;         // Do something with the info.     }  } catch (ClientStatusException cse) {     // Do something with the exception.  } catch (ServerStatusException sse) {     // Do something with the exception. } finally {     amfConnection.close(); }"
"%typemap(jni) std::string *INOUT, std::string &amp;INOUT %{jobjectArray%} %typemap(jtype) std::string *INOUT, std::string &amp;INOUT ""java.lang.String[]"" %typemap(jstype) std::string *INOUT, std::string &amp;INOUT ""java.lang.String[]"" %typemap(javain) std::string *INOUT, std::string &amp;INOUT ""$javainput""  %typemap(in) std::string *INOUT (std::string strTemp ), std::string &amp;INOUT (std::string strTemp ) {   if (!$input) {     SWIG_JavaThrowException(jenv, SWIG_JavaNullPointerException, ""array null"");     return $null;   }   if (JCALL1(GetArrayLength, jenv, $input) == 0) {     SWIG_JavaThrowException(jenv, SWIG_JavaIndexOutOfBoundsException, ""Array must contain at least 1 element"");     return $null;   }    jobject oInput = JCALL2(GetObjectArrayElement, jenv, $input, 0);    if ( NULL != oInput ) {     jstring sInput = static_cast&lt;jstring&gt;( oInput );      const char * $1_pstr = (const char *)jenv-&gt;GetStringUTFChars(sInput, 0);      if (!$1_pstr) return $null;     strTemp.assign( $1_pstr );     jenv-&gt;ReleaseStringUTFChars( sInput, $1_pstr);     }    $1 = &amp;strTemp; }  %typemap(freearg) std::string *INOUT, std::string &amp;INOUT """"  %typemap(argout) std::string *INOUT, std::string &amp;INOUT {    jstring jStrTemp = jenv-&gt;NewStringUTF( strTemp$argnum.c_str() );   JCALL3(SetObjectArrayElement, jenv, $input, 0, jStrTemp );  }"
"import java.util.regex.*;  public class Test {      public static String foo(String str) {         return ""&lt;b&gt;"" + str + ""&lt;/b&gt;"";     }      public static void main(String[] args) {         String content = ""Some Text"";         Pattern pattern = Pattern.compile(""[A-Z]"");         Matcher m = pattern.matcher(content);          StringBuffer sb = new StringBuffer();          while (m.find())             m.appendReplacement(sb, foo(m.group()));          m.appendTail(sb);          System.out.println(sb);     } }"
"import java.util.Arrays; import java.util.Collections;  public class MyArray {      public static void name() {                     String hello = ""hello, world"";         char[] hello_array = hello.toCharArray();         // copy to wrapper array         Character[] hello_array1 = new Character[hello_array.length];         for (int i = 0; i &lt; hello_array.length; i++) {            hello_array1[i] = hello_array[i];         }         // sort the wrapper array instead of primitives         Arrays.sort(hello_array1, Collections.reverseOrder());                                 } }"
"import java.io.BufferedReader; import java.io.File; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.IOException; import java.util.Map; import java.util.HashMap;  public class CountKeywords {      public static void main(String args[]) {          String[] theKeywords = { ""abstract"", ""assert"", ""boolean"", ""break"", ""byte"", ""case"", ""catch"", ""char"", ""class"", ""const"", ""continue"", ""default"", ""do"", ""double"", ""else"", ""enum"", ""extends"", ""false"", ""final"", ""finally"", ""float"", ""for"", ""goto"", ""if"", ""implements"", ""import"", ""instanceof"", ""int"", ""interface"", ""long"", ""native"", ""new"", ""null"", ""package"", ""private"", ""protected"", ""public"", ""return"", ""short"", ""static"", ""strictfp"", ""super"", ""switch"", ""synchronized"", ""this"", ""throw"", ""throws"", ""transient"", ""true"", ""try"", ""void"", ""volatile"", ""while"" };          // put each keyword in the map with value 0          Map&lt;String, Integer&gt; theKeywordCount = new HashMap&lt;String, Integer&gt;();         for (String str : theKeywords) {             theKeywordCount.put(str, 0);         }          FileReader fr;         BufferedReader br;         File file = new File(args[0]); // the filename is passed in as a String          // attempt to open and read file         try {             fr = new FileReader(file);             br = new BufferedReader(fr);              String sLine;              // read lines until reaching the end of the file             while ((sLine = br.readLine()) != null) {                  // if an empty line was read                 if (sLine.length() != 0) {                      // extract the words from the current line in the file                     if (theKeywordCount.containsKey(sLine)) {                         theKeywordCount.put(sLine, theKeywordCount.get(sLine) + 1);                     }                 }             }          } catch (FileNotFoundException exception) {             // Unable to find file.             exception.printStackTrace();         } catch (IOException exception) {             // Unable to read line.             exception.printStackTrace();         } finally {                 br.close();             }          // count how many times each keyword was encontered         int occurrences = 0;         for (Integer i : theKeywordCount.values()) {             occurrences += i;         }          System.out.println(""\n\nTotal occurences in file: "" + occurrences);     } }"
"import static java.util.Arrays.asList;  import java.util.Comparator; import java.util.Iterator; import java.util.List; import java.util.PriorityQueue;  public class MergingIterator&lt;T&gt; implements Iterator&lt;T&gt; {      public static class InputIter&lt;T&gt; {         final Iterator&lt;T&gt; source;         T data;          public InputIter(Iterable&lt;T&gt; list) {             source = list.iterator();             read();         }          public void read() {             if (source.hasNext()) {                 data = source.next();             } else {                 data = null;             }         }     }      final PriorityQueue&lt;InputIter&lt;T&gt;&gt; queue;      public MergingIterator(final Comparator&lt;? super T&gt; cmp, Iterable&lt;T&gt;... lists) {         queue = new PriorityQueue&lt;InputIter&lt;T&gt;&gt;(lists.length, new Comparator&lt;InputIter&lt;T&gt;&gt;() {             @Override             public int compare(InputIter&lt;T&gt; o1, InputIter&lt;T&gt; o2) {                 return cmp.compare(o1.data, o2.data);             }         });         for (Iterable&lt;T&gt; list : lists) {             InputIter&lt;T&gt; ii = new InputIter&lt;T&gt;(list);             if (ii.data != null) {                 queue.add(ii);             }         }     }      @Override     public boolean hasNext() {         return !queue.isEmpty();     }      @Override     public T next() {         InputIter&lt;T&gt; ii = queue.poll();         T next = ii.data;         ii.read();         if (ii.data != null) {             queue.add(ii);         }         return next;     }      @Override     public void remove() {         throw new UnsupportedOperationException();     } }"
"import java.lang.reflect.*; import java.util.*;  class A&lt;T1, T2&gt; {   Class&lt;T2&gt; clazz;    A()   {     Type sc = getClass().getGenericSuperclass();     Map&lt;TypeVariable&lt;?&gt;, Class&lt;?&gt;&gt; map = new HashMap&lt;TypeVariable&lt;?&gt;, Class&lt;?&gt;&gt;();     while (sc != null)     {       if (sc instanceof ParameterizedType)       {         ParameterizedType pt = (ParameterizedType) sc;         Type[] ata = pt.getActualTypeArguments();         TypeVariable[] tps = ((Class) pt.getRawType())             .getTypeParameters();         for (int i = 0; i &lt; tps.length; i++)         {           Class&lt;?&gt; value;           if (ata[i] instanceof TypeVariable)           {             value = map.get(ata[i]);           }           else           {             value = (Class) ata[i];           }           map.put(tps[i], value);         }         if (pt.getRawType() == A.class)         {           break;         }         if (ata.length &gt;= 1)         {           sc = ((Class) pt.getRawType()).getGenericSuperclass();         }       }       else       {         sc = ((Class) sc).getGenericSuperclass();       }     }      TypeVariable&lt;?&gt; myVar = A.class.getTypeParameters()[1];     clazz = map.containsKey(myVar) ? (Class&lt;T2&gt;) map.get(myVar) : null;   } }  class Bar&lt;T&gt; extends A&lt;T, String&gt; {} class Baz extends Bar&lt;Integer&gt; {}  class A2&lt;T3, T1, T2&gt; extends A&lt;T1, T2&gt; { } class B&lt;T&gt; extends A2&lt;Long, String, T&gt; { } class C extends B&lt;Integer&gt; { } class D extends C { }  class Plain&lt;T1, T2&gt; extends A&lt;T1, T2&gt; {}  public class Test {   public static void main(String[] args)   {     new D();     new Baz();     new A&lt;String, Integer&gt;();     new Plain&lt;String, Integer&gt;();   } }"
"import java.security.*; import java.security.cert.*; import java.security.interfaces.*; import java.security.spec.*; import javax.crypto.*; import javax.crypto.interfaces.*; import javax.crypto.spec.*; import java.io.*; /**  *  AES  */ public class SymmetricAES {      public SymmetricAES() {     }      public static void main(String args[]){         BufferedReader ch = new BufferedReader(new InputStreamReader(System.in));         char[] toCode;         byte[] toCode2;         byte[] Coded;         char[] Coded2;         byte[] decoded;         char[] deco2;          try{             System.out.print(""Text to Encrypt : "");             String toMake = ch.readLine();              /** Arxikopoihsh antikeimenou KeyGenerator gia AES              *  kai dhmhourgia Kleidioy */             KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");             SecretKey aesKey = keyGen.generateKey();              /* Arxikopoihsh aesCipher gia AES */             Cipher aesCipher = Cipher.getInstance(""AES"");              /* Orismos aesCipher se ENCRYPT_MODE me to aesKey */             aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);             System.out.println(""The Key : "" + aesKey.getEncoded());              /* Metatroph antikeimenou String se pinaka Char              * kai o ka8e xarakthras gineta Cast se Byte kai eisagwgh              * se pinaka Byte isou mege8ous me ton prwto pinaka */             toCode = toMake.toCharArray();             toCode2 = new byte[toCode.length];             Coded = new byte[toCode.length];             for(int i=0;i&lt;toCode.length;i++)                 toCode2[i] = (byte)toCode[i];              /* Teliko stadio Kryptografhshs */             Coded = aesCipher.doFinal(toCode2);              /* byte[] --&gt; char[] kai ektypwsh*/             Coded2 = new char[Coded.length];             for(int i=0;i&lt;Coded.length;i++)                 Coded2[i] = (char)Coded[i];             System.out.println(""Test Encrypt: "" + new String(Coded2));               Cipher aesCipher2 = Cipher.getInstance(""AES"");              /* Orismos aesCipher2 se DECRYPT_MODE me to aesKey */             aesCipher2.init(Cipher.DECRYPT_MODE, aesKey);              decoded = aesCipher2.doFinal(Coded);              /* byte[] --&gt; char[] kai ektypwsh*/             deco2 = new char[decoded.length];             for(int i=0;i&lt;decoded.length;i++)                 deco2[i] = (char)decoded[i];             System.out.println(""Test Decrypt: "" + new String(deco2));         }         catch(Exception e){             System.out.println(e);         }        } }"
"case class JListWrapper[A](val underlying : java.util.List[A]) extends mutable.Buffer[A] {     def length = underlying.size     override def isEmpty = underlying.isEmpty     override def iterator : Iterator[A] = underlying.iterator     def apply(i : Int) = underlying.get(i)     def update(i : Int, elem : A) = underlying.set(i, elem)     def +=:(elem : A) = { underlying.subList(0, 0).add(elem) ; this }      def +=(elem : A): this.type = { underlying.add(elem); this }     def insertAll(i : Int, elems : Traversable[A]) = { val ins = underlying.subList(0, i) ;  elems.seq.foreach(ins.add(_)) }     def remove(i : Int) = underlying.remove(i)     def clear = underlying.clear     def result = this }"
"package com.me;  import java.io.IOException; import java.io.PrintWriter; import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public class EmpServlet extends HttpServlet {     @Override     protected void doPost(HttpServletRequest request, HttpServletResponse response)             throws ServletException, IOException {          PrintWriter pw=response.getWriter();          Emp emp=(Emp)request.getAttribute(""emp"");          pw.print(emp);     } }"
"JNIEnv* create_vm(JavaVM ** jvm) {      JNIEnv *env;     JavaVMInitArgs vm_args;     JavaVMOption options[2];     options[0].optionString = CLASSPATH; //""-Djava.class.path=/scratch/workareas/JTest/Java/""     options[1].optionString = ""-DXcheck:jni:pedantic"";     vm_args.version = JNI_VERSION_1_6; //JDK version. This indicates version 1.6     vm_args.nOptions = 2;     vm_args.options = options;     vm_args.ignoreUnrecognized = JNI_TRUE; //drop unrecognized options      int ret = JNI_CreateJavaVM(jvm, (void**) &amp;env, &amp;vm_args);     if (ret &lt; 0) printf(""\n&lt;&lt;&lt;&lt;&lt; Unable to Launch JVM &gt;&gt;&gt;&gt;&gt;\n"");     return env; }"
"package com.mkyong;  import java.io.IOException; import java.io.PrintWriter; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public class ServletDemo1 extends HttpServlet{  public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException{     PrintWriter out = response.getWriter();     out.println(""&lt;html&gt;"");     out.println(""&lt;body&gt;"");     out.println(""&lt;h1&gt;Hello Servlet Get&lt;/h1&gt;"");     out.println(""&lt;/body&gt;"");     out.println(""&lt;/html&gt;"");       }  }"
"package com.bitplan.resthelper; import java.lang.reflect.Field;  /**  * Reflection help  * @author wf  *  */ public class FieldHelper {      /**      * get a Field including superclasses      *       * @param c      * @param fieldName      * @return      */     public Field getField(Class&lt;?&gt; c, String fieldName) {         Field result = null;         try {             result = c.getDeclaredField(fieldName);         } catch (NoSuchFieldException nsfe) {             Class&lt;?&gt; sc = c.getSuperclass();             result = getField(sc, fieldName);         }         return result;     }      /**      * set a field Value by name      *       * @param fieldName      * @param Value      * @throws Exception      */     public void setFieldValue(Object target,String fieldName, Object value) throws Exception {         Class&lt;? extends Object&gt; c = target.getClass();         Field field = getField(c, fieldName);         field.setAccessible(true);         // beware of ...         // http://docs.oracle.com/javase/tutorial/reflect/member/fieldTrouble.html         field.set(this, value);     }      /**      * get a field Value by name      *       * @param fieldName      * @return      * @throws Exception      */     public Object getFieldValue(Object target,String fieldName) throws Exception {         Class&lt;? extends Object&gt; c = target.getClass();         Field field = getField(c, fieldName);         field.setAccessible(true);         Object result = field.get(target);         return result;     }  }"
"import java.math.BigDecimal; import javax.faces.component.UIComponent; import javax.faces.context.FacesContext; import javax.faces.convert.Converter; import javax.faces.convert.FacesConverter;  /**  * Use via e.g.:  * &lt;pre&gt;  * &amp;lt;h:outputText value=""#{EL}""&amp;gt;  *  &amp;lt;f:converter id=""com.edsi.jsf.RoundHalfUp""/&amp;gt;  *  &amp;lt;f:attribute name=""decimalPlaces"" value=""2""/&amp;gt;  * &amp;lt;/h:outputText&amp;gt;  * &lt;pre&gt;  * @author Esmond Pitt  */ @FacesConverter(value=""com.edsi.jsf.RoundHalfUp"") public class RoundHalfUpConverter implements Converter {      @Override     public Object getAsObject(FacesContext context, UIComponent component, String value)     {         throw new UnsupportedOperationException(""Not supported yet."");     }      @Override     public String getAsString(FacesContext context, UIComponent component, Object value)     {         BigDecimal  bd = (BigDecimal)value;         int decimalPlaces;         try         {             decimalPlaces = Integer.parseInt((String)component.getAttributes().get(""decimalPlaces""));         }         catch (Exception exc)         {             decimalPlaces = 2;  // or whatever         }         return bd.setScale(decimalPlaces, BigDecimal.ROUND_HALF_UP).toString();     }  }"
"import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors;  public class Main {     public static class Worker implements Runnable {         private final String line;          public Worker(String line) {             this.line = line;         }          @Override         public void run() {             // Process line here.             System.out.println(""Processing line: "" + line);         }     }      public static void main(String[] args) throws IOException {         // Create worker thread pool.         ExecutorService service = Executors.newFixedThreadPool(4);          BufferedReader buffer = new BufferedReader(new InputStreamReader(System.in));         String line;          // Read each line and hand it off to a worker thread for processing.         while ((line = buffer.readLine()) != null) {             service.execute(new Worker(line));         }     } }"
"import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader;  public class Test {      public static void main(String[] args){         Test t = new Test();          t.start();     }      private void start(){         String command = //Command to invoke the program          ProcessBuilder pb = new ProcessBuilder(command);          try{             Process p = pb.start();              InputStream stdout = p.getInputStream();             InputStream stderr = p.getErrorStream();              StreamListener stdoutReader = new StreamListener(stdout);             StreamListener stderrReader = new StreamListener(stderr);              Thread t_stdoutReader = new Thread(stdoutReader);             Thread t_stderrReader = new Thread(stderrReader);              t_stdoutReader.start();             t_stderrReader.start();         }catch(IOException n){             System.err.println(""I/O Exception: "" + n.getLocalizedMessage());         }     }      private class StreamListener implements Runnable{         private BufferedReader Reader;         private boolean Run;          public StreamListener(InputStream s){             Reader = new BufferedReader(new InputStreamReader(s));             Run = true;         }          public void run(){             String line;              try{                 while(Run &amp;&amp; (line = Reader.readLine()) != null){                     //At this point, a line of the output from the external process has been grabbed. Process it however you want.                     System.out.println(""External Process: "" + line);                 }             }catch(IOException n){                 System.err.println(""StreamListener I/O Exception!"");             }         }     } }"
"import java.util.*;  public class DeepToArray {  public static void main(String[] args) {      int row, col;     row = 2;     col = 3;     String[][] in = new String[row][col];      for (int i = 0; i &lt; row; i++) {         for (int j = 0; j &lt; col; j++) {             in[i][j] = i + "" "" + j;         }     }     String str = Arrays.deepToString(in);      System.out.println(str);      String[][] out = stringToDeep(str);      for (String s2[] : out) {         for (String s3 : s2) {             System.out.print(s3 + ""  "");         }         System.out.println();     } }  private static String[][] stringToDeep(String str) {     int row = 0;     int col = 0;     for (int i = 0; i &lt; str.length(); i++) {         if (str.charAt(i) == '[') {             row++;         }     }     row--;     for (int i = 0;; i++) {         if (str.charAt(i) == ',') {             col++;         }         if (str.charAt(i) == ']') {             break;         }     }     col++;      String[][] out = new String[row][col];      str = str.replaceAll(""\\["", """").replaceAll(""\\]"", """");      String[] s1 = str.split("", "");      int j = -1;     for (int i = 0; i &lt; s1.length; i++) {         if (i % col == 0) {             j++;         }         out[j][i % col] = s1[i];         //System.out.println(s1[i] + ""\t"" + j + ""\t"" + i % col);     }     return out; } }"
"import java.io.BufferedWriter; import java.io.File; import java.io.FileInputStream; import java.io.FileWriter; import java.io.IOException;  public class BinToHex {     private final static String[] hexSymbols = { ""0"", ""1"", ""2"", ""3"", ""4"", ""5"", ""6"", ""7"", ""8"", ""9"", ""a"", ""b"", ""c"", ""d"", ""e"", ""f"" };      public final static int BITS_PER_HEX_DIGIT = 4;      public static String toHexFromByte(final byte b)     {         byte leftSymbol = (byte)((b &gt;&gt;&gt; BITS_PER_HEX_DIGIT) &amp; 0x0f);         byte rightSymbol = (byte)(b &amp; 0x0f);          return (hexSymbols[leftSymbol] + hexSymbols[rightSymbol]);     }      public static String toHexFromBytes(final byte[] bytes)     {         if(bytes == null || bytes.length == 0)         {             return ("""");         }          // there are 2 hex digits per byte         StringBuilder hexBuffer = new StringBuilder(bytes.length * 2);          // for each byte, convert it to hex and append it to the buffer         for(int i = 0; i &lt; bytes.length; i++)         {             hexBuffer.append(toHexFromByte(bytes[i]));         }          return (hexBuffer.toString());     }      public static void main(final String[] args) throws IOException     {         try         {             FileInputStream fis = new FileInputStream(new File(args[0]));             BufferedWriter fos = new BufferedWriter(new FileWriter(new File(args[1])));              byte[] bytes = new byte[800];             int value = 0;             do             {                 value = fis.read(bytes);                 fos.write(toHexFromBytes(bytes));              }while(value != -1);              fos.flush();             fos.close();         }         catch(Exception e)         {             e.printStackTrace();         }     } }"
"package mypackage;  import java.io.IOException;  import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public class RunLongProcessServlet extends HttpServlet {      protected void doGet(HttpServletRequest request, HttpServletResponse response)         throws ServletException, IOException     {         if (""XMLHttpRequest"".equals(request.getHeader(""x-requested-with""))) {             LongProcess longProcess = (LongProcess) request.getSession().getAttribute(""longProcess"");             response.setContentType(""application/json"");             response.getWriter().write(String.valueOf(longProcess.getProgress()));         } else {             request.getRequestDispatcher(""runLongProcess.jsp"").forward(request, response);         }     }      protected void doPost(HttpServletRequest request, HttpServletResponse response)         throws ServletException, IOException     {         LongProcess longProcess = new LongProcess();         longProcess.setDaemon(true);         longProcess.start();         request.getSession().setAttribute(""longProcess"", longProcess);         request.getRequestDispatcher(""runLongProcess.jsp"").forward(request, response);     }  }  class LongProcess extends Thread {      private int progress;      public void run() {         while (progress &lt; 100) {             try { sleep(1000); } catch (InterruptedException ignore) {}             progress++;         }     }      public int getProgress() {         return progress;     }  }"
"import java.lang.reflect.*;  public class NewInstance {    static void print(String label, Object[] arr) {       System.out.println(label);       for (Object o : arr) {          System.out.println(o);       }       System.out.println(""---"");    }     static Object newInstance(Object o) {       Class&lt;?&gt; c = o.getClass();       System.out.println(""Class is "" + c);       print(""FIELDS:"", c.getDeclaredFields());       print(""METHODS:"", c.getDeclaredMethods());       print(""CONSTRUCTORS:"", c.getDeclaredConstructors());        try {          Constructor&lt;?&gt; cc = c.getDeclaredConstructor(c);          o = cc.newInstance(o);       } catch (NoSuchMethodException e) {          System.out.println(""No copy constructor found!"");       } catch (IllegalAccessException e) {          System.out.println(""Copy constructor inaccessible!"");       } catch (InstantiationException e) {          System.out.println(""Instantiation failed!"");       } catch (InvocationTargetException e) {          System.out.println(""Copy constructor threw "" + e.getCause());       }       return o;    }     public static void main(String args[]) {       Object o1 = ""hello"";       Object o2 = newInstance(o1);       boolean success = (o1 != o2) &amp;&amp; (o1.equals(o2));       System.out.println(""Attempt "" + (success ? ""succeeded!"" : ""failed :(""));    } }"
"import java.io.IOException; import java.io.OutputStream;  import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import jxl.Workbook; import jxl.write.Label; import jxl.write.WritableSheet; import jxl.write.WritableWorkbook;  public class Sample extends HttpServlet {  public void doGet(HttpServletRequest request, HttpServletResponse response)  throws ServletException, IOException  {   OutputStream out = null;   try   {    response.setContentType(""application/vnd.ms-excel"");    response.setHeader(""Content-Disposition"", ""attachment; filename=sampleName.xls"");    WritableWorkbook w = Workbook.createWorkbook(response.getOutputStream());    WritableSheet s = w.createSheet(""Demo"", 0);    s.addCell(new Label(0, 0, ""Hello World""));    w.write();    w.close();   } catch (Exception e)   {    throw new ServletException(""Exception in Excel Sample Servlet"", e);   } finally   {    if (out != null)     out.close();   }  } }"
"import java.io.StringWriter; import java.util.*; public class SortedProperties extends Properties {     @Override public Set&lt;Object&gt; keySet() {         return Collections.unmodifiableSet(new TreeSet&lt;Object&gt;(super.keySet()));     }     @Override public synchronized Enumeration&lt;Object&gt; keys() {         return Collections.enumeration(new TreeSet&lt;Object&gt;(super.keySet()));     }     public static void main(String[] args) throws Exception {         Properties properties = new SortedProperties() {             {                 for (int c = 18; c &gt;= 0; c--) {                     String name = ""Button"" + (c &lt; 10 ? ""0"" : """") + c;                     put(name, name);                 }             }         };         StringWriter stringWriter = new StringWriter();         properties.store(stringWriter, ""foo"");         System.err.println(stringWriter.toString());     }     private static final long serialVersionUID = 1L; }"
"import java.nio.ByteBuffer; import java.nio.ByteOrder; import java.nio.IntBuffer;  public class Test {     static final int bytes_per_datum = 4;      public static void main(String args[]) {         main2(""Native Endian"", ByteOrder.nativeOrder());         main2(""Big Endian"", ByteOrder.BIG_ENDIAN);         main2(""Little Endian"", ByteOrder.LITTLE_ENDIAN);     }      static void main2(String comment, ByteOrder endian) {         int[] data = { 1, 0xF, 0xFF, 0xFFF, 0xFFFF, 0xFFFFF, 0xFFFFFF, 0xFFFFFFF, 0xFFFFFFFF };         ByteBuffer bb = ByteBuffer.allocateDirect(data.length * bytes_per_datum);         bb.order(endian); // endian must be set before putting ints into the buffer         put_ints(bb, data);          System.out.println(comment + "": "");         print(bb);     }      static void put_ints(ByteBuffer bb, int[] data) {         IntBuffer b = bb.asIntBuffer(); // created IntBuffer starts only from the ByteBuffer's relative position                                         // if you plan to reuse this IntBuffer, be mindful of its position         b.put(data); // position of this IntBuffer changes by +data.length;     } // this IntBuffer goes out of scope      static void print(ByteBuffer bb) { // prints from start to limit         ByteBuffer bb_2 = bb.duplicate(); // shares backing content, but has its own capacity/limit/position/mark (equivalent to original buffer at initialization)         bb_2.rewind();         for (int x = 0, xx = bb_2.limit(); x &lt; xx; ++x) {             System.out.print((bb_2.get() &amp; 0xFF) + "" ""); // 0xFF for display, since java bytes are signed             if ((x + 1) % bytes_per_datum == 0) {                 System.out.print(System.lineSeparator());             }         }     } }"
"private boolean _jspx_meth_c_005fwhen_005f0(javax.servlet.jsp.tagext.JspTag _jspx_th_c_005fchoose_005f0, javax.servlet.jsp.PageContext _jspx_page_context)       throws java.lang.Throwable { javax.servlet.jsp.PageContext pageContext = _jspx_page_context; javax.servlet.jsp.JspWriter out = _jspx_page_context.getOut(); //  c:when org.apache.taglibs.standard.tag.rt.core.WhenTag _jspx_th_c_005fwhen_005f0 = (org.apache.taglibs.standard.tag.rt.core.WhenTag) _005fjspx_005ftagPool_005fc_005fwhen_0026_005ftest.get(org.apache.taglibs.standard.tag.rt.core.WhenTag.class); _jspx_th_c_005fwhen_005f0.setPageContext(_jspx_page_context); _jspx_th_c_005fwhen_005f0.setParent((javax.servlet.jsp.tagext.Tag) _jspx_th_c_005fchoose_005f0); // /index1.jsp(4,2) name = test type = boolean reqTime = true required = true fragment = false deferredValue = false expectedTypeName = null deferredMethod = false methodSignature = null _jspx_th_c_005fwhen_005f0.setTest(((java.lang.Boolean) org.apache.jasper.runtime.PageContextImpl.proprietaryEvaluate(""${true}"", java.lang.Boolean.class, (javax.servlet.jsp.PageContext)_jspx_page_context, null, false)).booleanValue()); int _jspx_eval_c_005fwhen_005f0 = _jspx_th_c_005fwhen_005f0.doStartTag(); if (_jspx_eval_c_005fwhen_005f0 != javax.servlet.jsp.tagext.Tag.SKIP_BODY) {   do {     out.write(""\r\n"");     out.write(""  "");     int evalDoAfterBody = _jspx_th_c_005fwhen_005f0.doAfterBody();     if (evalDoAfterBody != javax.servlet.jsp.tagext.BodyTag.EVAL_BODY_AGAIN)       break;   } while (true); } if (_jspx_th_c_005fwhen_005f0.doEndTag() == javax.servlet.jsp.tagext.Tag.SKIP_PAGE) {   _005fjspx_005ftagPool_005fc_005fwhen_0026_005ftest.reuse(_jspx_th_c_005fwhen_005f0);   return true; } _005fjspx_005ftagPool_005fc_005fwhen_0026_005ftest.reuse(_jspx_th_c_005fwhen_005f0); return false; }"
"import java.util.ArrayList; import java.util.List;  import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject;  public class JsonReference {     Object data;      public JsonReference(String buildFromString){         try {             data = new JSONObject(buildFromString);         } catch (JSONException e) {             e.printStackTrace();         }          if(data == null){             try {                 data = new JSONArray(buildFromString);             } catch (JSONException e) {                 e.printStackTrace();             }         }     }      public Object getAbstractJsonObject(){         return data;     }      public List&lt;String&gt; parseForData(String data,boolean removeDuplicates){         Traverser valFinder = new Traverser(0);         valFinder.setValues(data, removeDuplicates);         valFinder.traverseForStringValue(this.data);         return valFinder.foundInstances;     }      class Traverser{         List&lt;String&gt; foundInstances = new ArrayList&lt;String&gt;();         String value;         boolean removeDuplicates;          public Traverser(int type){          }          public void setValues(String value,boolean removeDuplicates){             this.value = value;             this.removeDuplicates = removeDuplicates;         }          public void traverseForStringValue(Object root){              if(root == null){                 return;             }             else if(root instanceof JSONObject){                 JSONObject self = (JSONObject)root;                  //if the key exists in this object.. save it!                 if(self.has(value)){                     try {                         if(!removeDuplicates || notRepeat(self.getString(value)))                             foundInstances.add(self.getString(value));                     } catch (JSONException e) {                         e.printStackTrace();                     }                     return;                 }                  //otherwise, see if you can dive deeper..                 JSONArray names = self.names();                 for(int i=0;i&lt;names.length();i++){                     String temp = null;                     try{                         temp = names.getString(i);                     }                     catch(JSONException e){                         e.printStackTrace();                     }                     if(temp != null){                         try {                             if(self.get(temp) instanceof JSONObject || self.get(temp) instanceof JSONArray)                                 traverseForStringValue(self.get(temp));                             else if(self.get(temp) instanceof String){                                 if(!removeDuplicates || notRepeat(self.getString(value)))                                     foundInstances.add(self.getString(value));                             }                         } catch (JSONException e) {                             e.printStackTrace();                         }                     }                 }              }             else if(root instanceof JSONArray){                 JSONArray self = (JSONArray)root;                  //iterate through the array..                 for(int i=0;i&lt;self.length();i++){                     Object temp = null;                     try {                         temp = self.get(i);                     } catch (JSONException e) {                         e.printStackTrace();                     }                      if(temp != null &amp;&amp; temp != JSONObject.NULL){                          if(temp instanceof JSONObject || temp instanceof JSONArray)                             traverseForStringValue(temp);                         else if(temp instanceof String &amp;&amp; ((String)temp).contains(value)){                             try {                                 if(!removeDuplicates || notRepeat(self.getString(i)))                                     foundInstances.add(self.getString(i));                             } catch (JSONException e) {                                 e.printStackTrace();                             }                         }                      }                 }             }         }          private boolean notRepeat(String s){             for(String item : foundInstances){                 if(item.equals(s))                     return false;             }             return true;         }     } }"
"import java.io.BufferedReader; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.io.PrintWriter; import java.util.Scanner;  public class TrialAutoIt3a {     // ***** of course your path to program will be different    private static final String AUTOIT_PATH = ""C:/Users/Pete/Documents/Programming/AutoIt/Experiment/"";    private static final String AUTOIT_EXEC = ""TestWithJava.exe"";    protected static final CharSequence EXIT = ""exit"";    private static Process proc = null;     public static void main(String[] args) {       Runtime rt = Runtime.getRuntime();       System.out.println(""Type \""exit\"" to exit program"");        try {          proc = rt.exec(AUTOIT_PATH + AUTOIT_EXEC);       } catch (IOException e1) {          e1.printStackTrace();          System.exit(-1);       }       InputStream iStream = proc.getInputStream();       InputStreamReader isr = new InputStreamReader(iStream);       final BufferedReader bufReader = new BufferedReader(isr);        OutputStream oStream = proc.getOutputStream();       final PrintWriter pw = new PrintWriter(oStream, true);        Runnable bufReaderRunnable = new Runnable() {          public void run() {             String output;             try {                while ((output = bufReader.readLine()) != null) {                   System.out.println(output);                   if (output.toLowerCase().contains(EXIT)) {                      proc.destroy();                      System.exit(0);                   }                }             } catch (IOException e) {                e.printStackTrace();             } finally {                if (bufReader != null) {                   try {                      bufReader.close();                   } catch (IOException e) {                      e.printStackTrace();                   }                }             }          }       };       new Thread(bufReaderRunnable).start();        Runnable myRun = new Runnable() {          public void run() {             Scanner scan = new Scanner(System.in);             while (scan.hasNextLine()) {                String line = scan.nextLine();                pw.println(line);             }             scan.close();          }       };       new Thread(myRun).start();     } }"
"import java.util.ArrayList; import java.util.Arrays; import java.util.Collections; import java.util.HashSet; import java.util.List; import java.util.Set;  // Solution for Lesson 9, ""CountNonDivisible"" // of http://codility.com/demo/train/ public class Solution {     public static void main(String[] args)     {         int A[] = new int[5];         A[0] = 3;         A[1] = 1;         A[2] = 2;         A[3] = 3;         A[4] = 6;          Solution s = new Solution();         int B[] = s.solution(A);         System.out.println(""Input  : ""+Arrays.toString(A));         System.out.println(""Result : ""+Arrays.toString(B));     }      public int[] solution(int[] A)     {         Set&lt;Integer&gt; setA = asSet(A);         List&lt;Set&lt;Integer&gt;&gt; divisors = computeDivisors(A.length * 2);         int occurrences[] = computeOccurrences(A);         int nonDivisors[] = new int[A.length];         for (int i=0; i&lt;A.length; i++)         {             int value = A[i];             Set&lt;Integer&gt; d = divisors.get(value);             int totalOccurances = 0;             for (Integer divisor : d)             {                 if (setA.contains(divisor))                 {                     totalOccurances += occurrences[divisor];                 }             }             nonDivisors[i] = A.length-totalOccurances;         }         return nonDivisors;     }       /**      * Returns a set containing all elements of the given array      *       * Space: O(N)      * Time: O(N)      *       * @param A The input array      * @return The set      */     private static Set&lt;Integer&gt; asSet(int A[])     {         Set&lt;Integer&gt; result = new HashSet&lt;Integer&gt;();         for (int value : A)         {             result.add(value);         }         return result;     }       /**      * Computes a list that contains for each i in [0...maxValue+1] a set      * with all divisors of i. This is basically an ""Eratosthenes Sieve"".       * But in addition to setting the entries of a list to 'false'       * (indicating that the respective numbers are non-prime), this       * methods inserts the divisors into the corresponding set.      *        * Space: O(N) (?)      * Time: O(N*logN) (?)      *       * @param maxValue The maximum value      * @return The list       */     private static List&lt;Set&lt;Integer&gt;&gt; computeDivisors(int maxValue)     {         List&lt;Boolean&gt; prime = new ArrayList&lt;Boolean&gt;();         prime.addAll(Collections.nCopies(maxValue+1, Boolean.TRUE));         List&lt;Set&lt;Integer&gt;&gt; divisors = new ArrayList&lt;Set&lt;Integer&gt;&gt;();         for (int i = 0; i &lt; maxValue + 1; i++)         {             Set&lt;Integer&gt; d = new HashSet&lt;Integer&gt;();             d.add(1);             d.add(i);             divisors.add(d);         }         for (int i = 2; i &lt;= maxValue; i++)         {             int next = i + i;             while (next &lt;= maxValue)             {                 divisors.get(next).addAll(divisors.get(i));                 prime.set(next, Boolean.FALSE);                 next += i;             }         }         return divisors;     }      /**      * Computes an array of length 2*A.length+1, where each entry i contains      * the number of occurrences of value i in array A      *       * Space: O(N)      * Time: O(N)      *       * @param A The input array      * @return The occurrences array      */     private static int[] computeOccurrences(int A[])     {         int occurances[] = new int[A.length * 2 + 1];         for (int i=0; i&lt;A.length; i++)         {             int value = A[i];             occurances[value]++;         }         return occurances;     } }"
"import java.util.Arrays; import java.util.HashMap; import java.util.Map.Entry;  public class Draft {  public static class SomeClass{      final private String val;      public SomeClass(String val) {         this.val = val;     } }  public void someFun(String str, SomeClass ... classes) {     System.out.println(""someFun"" + str + Arrays.toString(classes)); }  public static void main(String[] args) {     HashMap&lt;String, String&gt; keyToParam = new HashMap&lt;&gt;();     keyToParam.put(""a"", ""b"");     keyToParam.put(""c"", ""d"");     String strArg = null;     SomeClass[] classes = new SomeClass[keyToParam.size()];     int pointer = 0;     for(Entry&lt;String, String&gt; entry: keyToParam.entrySet()) {         strArg += entry.getKey() + "":#"";         classes[pointer++] = new SomeClass(entry.getValue());     }     new Draft().someFun(strArg, classes); }  }"
"package cz.literak.demo;  import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.io.InputStream; import java.io.PrintWriter;  public class JarServlet extends HttpServlet {      @Override     protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {         String path = request.getPathInfo();         setContentType(path, response);          InputStream streamIn = null;         try {             streamIn = getClass().getResourceAsStream(path);             PrintWriter writer = response.getWriter();             int c;             while ((c = streamIn.read()) != -1) {                 writer.write(c);             }         } catch (IOException e) {             streamIn.close();         }     }      private void setContentType(String path, HttpServletResponse response) {         if (path.toLowerCase().endsWith("".css"")) {             response.setContentType(""text/css"");         }         // TODO other mime types     } }"
