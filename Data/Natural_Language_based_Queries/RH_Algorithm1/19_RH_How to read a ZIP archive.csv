code
"import java.io.File;  import org.apache.commons.io.FileUtils; import org.apache.hadoop.conf.Configured; import org.apache.hadoop.fs.Path; import org.apache.hadoop.io.LongWritable; import org.apache.hadoop.io.Text; import org.apache.hadoop.mapreduce.Job; import org.apache.hadoop.mapreduce.Mapper; import org.apache.hadoop.mapreduce.lib.input.FileInputFormat; import org.apache.hadoop.mapreduce.lib.output.FileOutputFormat; import org.apache.hadoop.util.Tool; import org.apache.hadoop.util.ToolRunner;  public class MapReduceExample extends Configured implements Tool {      static class MyMapper extends Mapper&lt;LongWritable, Text, LongWritable, Text&gt; {         public MyMapper(){          }          protected void map(                 LongWritable key,                 Text value,                 org.apache.hadoop.mapreduce.Mapper&lt;LongWritable, Text, LongWritable, Text&gt;.Context context)                 throws java.io.IOException, InterruptedException {             context.getCounter(""mygroup"", ""jeff"").increment(1);             context.write(key, value);         };     }      @Override     public int run(String[] args) throws Exception {         Job job = new Job();         job.setMapperClass(MyMapper.class);         FileInputFormat.setInputPaths(job, new Path(args[0]));         FileOutputFormat.setOutputPath(job, new Path(args[1]));          job.waitForCompletion(true);         return 0;     }      public static void main(String[] args) throws Exception {         FileUtils.deleteDirectory(new File(""data/output""));         args = new String[] { ""data/input"", ""data/output"" };         ToolRunner.run(new MapReduceExample(), args);     } }"
"ZipOutputStream out = new ZipOutputStream(response.getOutputStream()); byte[] buf = new byte[1024];  File file; InputStream in; // Loop through entities for (TitleProductAccountApproval tpAccountApproval : tpAccountApprovals) {     // Generate the file         file = xmlManager.getXML(         tpAccountApproval.getTitleProduct().getTitleProductId(),          tpAccountApproval.getAccount().getAccountId(),          username);      // Write to zip file     in = new FileInputStream(file);     out.putNextEntry(new ZipEntry(file.getName()));      int len;     while ((len = in.read(buf)) &gt; 0) {         out.write(buf, 0, len);     }      out.closeEntry();     in.close(); }  out.close();"
import org.codehaus.groovy.grails.web.servlet.GrailsApplicationAttributes import org.codehaus.groovy.grails.web.context.ServletContextHolder import org.springframework.context.ApplicationContext  public class SpringUtils {      static getSpringBean(String name) {         getApplicationContext().getBean(name);     }      static ApplicationContext getApplicationContext() {         return ServletContextHolder.getServletContext().getAttribute(GrailsApplicationAttributes.APPLICATION_CONTEXT);     }     }
"public class FormInfo {    string Domain;    string Name;    string Category;    // etc...    public FormInfo(string domain, string name, string category)   {      Domain = domain;      Name = name;      Category = category;      // etc...   } }   // Somewhere in your initialization code public static FormInfo Info1 = new FormInfo(""myDomain1"", ""myName1"", ""myCategory1""); public static FormInfo Info2 = new FormInfo(""myDomain2"", ""myName2"", ""myCategory2"");  You can still update one of your common merchants if you need to do something one-off:  // In your test case: Info1.Category = ""blah""; FormPage.FillForm(Info1);"
"for(int i=0; i&lt;length; i++) {     try {         String srcFile = ""file:///store/home/user/sample/www"" + resourseFileNames[i];         FileConnection srcConn = (FileConnection) Connector.open(srcFile, Connector.READ);         InputStream in = srcConn.openInputStream();          String dstFile = ""file:///SDCard/myAppName/www"" + resourseFileNames[i];         FileConnection dstConn = (FileConnection)Connector.open(dstFile, Connector.WRITE);         OutputStream out = dstConn.openOutputStream();          // Copy the bits from instream to outstream         byte[] buf = new byte[1024];         int len;         while ((len = in.read(buf)) &gt; 0) {            out.write(buf, 0, len);         }          in.close();         srcConn.close();          out.close();         dstConn.close();     } catch (IOException e) {         e.printStackTrace();     } }"
"import java.awt.image.BufferedImage; import java.io.File; import java.io.FilenameFilter; import java.io.IOException; import javax.imageio.ImageIO;  public class Test {      // File representing the folder that you select using a FileChooser     static final File dir = new File(""PATH_TO_YOUR_DIRECTORY"");      // array of supported extensions (use a List if you prefer)     static final String[] EXTENSIONS = new String[]{         ""gif"", ""png"", ""bmp"" // and other formats you need     };     // filter to identify images based on their extensions     static final FilenameFilter IMAGE_FILTER = new FilenameFilter() {          @Override         public boolean accept(final File dir, final String name) {             for (final String ext : EXTENSIONS) {                 if (name.endsWith(""."" + ext)) {                     return (true);                 }             }             return (false);         }     };      public static void main(String[] args) {          if (dir.isDirectory()) { // make sure it's a directory             for (final File f : dir.listFiles(IMAGE_FILTER)) {                 BufferedImage img = null;                  try {                     img = ImageIO.read(f);                      // you probably want something more involved here                     // to display in your UI                     System.out.println(""image: "" + f.getName());                     System.out.println("" width : "" + img.getWidth());                     System.out.println("" height: "" + img.getHeight());                     System.out.println("" size  : "" + f.length());                 } catch (final IOException e) {                     // handle errors here                 }             }         }     } }"
"public void commitData(){      Bundle bundle = new Bundle();     bundle.putString(""key"", txtBuildingName.getText().toString()); //Gets the TEXT that the TEXTVIEW was holding converts it to a String and adds to the Extras bundle     bundle.putString(""key1"", txtDescription.getText().toString()); // Same again     bundle.putString(""key2"", type.getItemAtPosition(type.getSelectedItemPosition()).toString());     bundle.putString(""key3"", project.getItemAtPosition(project.getSelectedItemPosition()).toString());"
"final URL url = new URL(""http://localhost:8080/SearchPerson.aspx/PersonSearch""); final URLConnection urlConnection = url.openConnection(); urlConnection.setDoOutput(true); urlConnection.setRequestProperty(""Content-Type"", ""application/json; charset=utf-8""); urlConnection.connect(); final OutputStream outputStream = urlConnection.getOutputStream(); outputStream.write((""{\""fNamn\"": \"""" + stringData + ""\""}"").getBytes(""UTF-8"")); outputStream.flush(); final InputStream inputStream = urlConnection.getInputStream();"
"Dyld maintains a current stack of paths called the run path list.   When @rpath is encountered it is substituted with each path in the   run path list until a loadable dylib if found. The run path stack   is built from the LC_RPATH load commands in the depencency chain   that lead to the current dylib load. You can add an LC_RPATH load   command to an image with the -rpath option to ld(1). You can even add   a LC_RPATH load command path that starts with @loader_path/, and it   will push a path on the run path stack that relative to the image   containing the LC_RPATH. The use of @rpath is most useful when you   have a complex directory structure of programs and dylibs which can be   installed anywhere, but keep their relative positions. This scenario   could be implemented using @loader_path, but every client of a dylib   could need a different load path because its relative position in the   file system is different. The use of @rpath introduces a level of   indirection that simplies things. You pick a location in your directory   structure as an anchor point. Each dylib then gets an install path that   starts with @rpath and is the path to the dylib relative to the anchor   point. Each main executable is linked with -rpath @loader_path/zzz,   where zzz is the path from the executable to the anchor point. At runtime   dyld sets it run path to be the anchor point, then each dylib is found   relative to the anchor point."
"final String url = ""http://www.amazon.com/gp/rss/movers-and-shakers/appliances/ref=zg_bsms_appliances_rsslink"";     Document doc = Jsoup.connect(url).get();       for( Element item : doc.select(""item"") ) // Select all items     {         final String title = item.select(""title"").first().text(); // select the 'title' of the item         final String link = item.select(""link"").first().nextSibling().toString().trim(); // select 'link' (-1-)          final Document descr = Jsoup.parse(StringEscapeUtils.unescapeHtml4(item.select(""description"").first().toString()));         final String price = descr.select(""span.price"").first().text(); // select 'price' (-2-)          // Output - Example         System.out.println(title);         System.out.println(link);         System.out.println(price);         System.out.println();     }"
"public class Xattrj {      /**      * Write the extended attribute to the given file      * @param file      * @param attrKey      * @param attrValue      */     public void writeAttribute(File file, String attrKey, String attrValue){         writeAttribute(file.getAbsolutePath(), attrKey, attrValue);     }      /**      * Read the extended attribute from the given file      * @param file      * @param attrKey      * @return      */     public String readAttribute(File file, String attrKey){         return readAttribute(file.getAbsolutePath(), attrKey);     }      /**      * Write the extended attribute to the given file      * @param file      * @param attrKey      * @param attrValue      */     private native void writeAttribute(String file, String attrKey, String attrValue);      /**      * Read the extended attribute from the given file      * @param file      * @param attrKey      * @return      */     private native String readAttribute(String file, String attrKey);       static {         try {             System.out.println(""loading xattrj..."");             LibraryLoader.loadLibrary(""xattrj"");             System.out.println(""loaded!"");         } catch (Exception e) {             e.printStackTrace();         }     } }"
"try {     OutputStream servletOutputStream = httpServletResponse.getOutputStream(); // retrieve OutputStream from HttpServletResponse     ZipOutputStream zos = new ZipOutputStream(servletOutputStream); // create a ZipOutputStream from servletOutputStream      List&lt;String[]&gt; csvFileContents  = getContentToZIP(); // get the list of csv contents. I am assuming the CSV content is generated programmatically     int count = 0;     for (String[] entries : csvFileContents) {         String filename = ""file-"" + ++count  + "".csv"";         ZipEntry entry = new ZipEntry(filename); // create a zip entry and add it to ZipOutputStream         zos.putNextEntry(entry);          CSVWriter writer = new CSVWriter(new OutputStreamWriter(zos));  // There is no need for staging the CSV on filesystem or reading bytes into memory. Directly write bytes to the output stream.         writer.writeNext(entries);  // write the contents         writer.flush(); // flush the writer. Very important!         zos.closeEntry(); // close the entry. Note : we are not closing the zos just yet as we need to add more files to our ZIP     }      zos.close(); // finally closing the ZipOutputStream to mark completion of ZIP file } catch (Exception e) {     log.error(e); // handle error }"
"public class Services implements DisposableBean {      ClassPathXmlApplicationContext ctx;     private MyAService myAService;     private MyBService myBService;      public Services() {        this.ctx = new ClassPathXmlApplicationContext(""services-context.xml"");         // these are configured in the services-context.xml        this.myAService = ctx.getBean(""myAService"");        this.myBService = ctx.getBean(""myBService"");     }      // Add getters for your services      @Override     public void destroy() throws Exception {        this.myAService = null;        this.myBService = null;        this.ctx.destroy();        this.ctx = null;     } }"
"package your.package;  public class CORSFilter implements ContainerResponseFilter {      @Override     public ContainerResponse filter(ContainerRequest creq, ContainerResponse cresp) {          cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Origin"", ""*"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Credentials"", ""true"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Methods"", ""GET, POST, DELETE, PUT, OPTIONS, HEAD"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Headers"", ""Content-Type, Accept, X-Requested-With"");          return cresp;     } }"
"public interface InetAddr extends StdCallLibrary {     InetAddr INSTANCE = (InetAddr)              Native.loadLibrary(""wsock32.dll"", InetAddr.class);      ULONG inet_addr(String cp);                     //in_addr creator. Creates the in_addr C struct used below }  public interface IcmpEcho extends StdCallLibrary {     IcmpEcho INSTANCE = (IcmpEcho)             Native.loadLibrary(""iphlpapi.dll"", IcmpEcho.class);      int IcmpSendEcho(             HANDLE IcmpHandle,                      //Handle to the ICMP             ULONG DestinationAddress,               //Destination address, in the form of an in_addr C Struct defaulted to ULONG             Pointer RequestData,                    //Pointer to the buffer where my Message to be sent is             short RequestSize,                      //size of the above buffer. sizeof(Message)             byte[] RequestOptions,                  //OPTIONAL!! Can set this to NULL             Pointer ReplyBuffer,                    //Pointer to the buffer where the replied echo is written to             int ReplySize,                          //size of the above buffer. Normally its set to the sizeof(ICMP_ECHO_REPLY), but arbitrarily set it to 256 bytes             int Timeout);                           //time, as int, for timeout      HANDLE IcmpCreateFile();                        //win32 ICMP Handle creator      boolean IcmpCloseHandle(HANDLE IcmpHandle);     //win32 ICMP Handle destroyer }"
"Gate.init(); DataStore ds = Factory.openDataStore(""gate.creole.annic.SearchableDataStore"", ""file:/path/to/datastore""); List docIds = ds.getLrIds(""gate.corpora.DocumentImpl""); for(Object id : docIds) {   Document d = (Document)Factory.createResource(""gate.corpora.DocumentImpl"",             gate.Utils.featureMap(DataStore.DATASTORE_FEATURE_NAME, ds,                                   DataStore.LR_ID_FEATURE_NAME, id));   try {     File outputFile = new File(...); // based on doc name, sequential number, etc.     DocumentStaxUtils.writeDocument(d, outputFile);   } finally {     Factory.deleteResource(d);   } }"
"private static final String SERVER_UPLOAD_LOCATION_FOLDER = ""/somepath/tmp/uploaded_files/"";  @POST @Consumes(MediaType.MULTIPART_FORM_DATA) @Produces(MediaType.TEXT_PLAIN) @Path(""/upload"") public String uploadFunction(@Context UriInfo uriInfo,         @FormDataParam(""upload"") final InputStream inputStream,         @FormDataParam(""upload"") final FormDataContentDisposition fileDetail) {          String filePath = SERVER_UPLOAD_LOCATION_FOLDER + fileDetail.getFileName();         // save the file to the server         saveFile(inputStream, filePath);         String output = ""File saved to server location : "" + filePath;         return Response.status(200).entity(output).build();   }  private void saveFile(InputStream uploadedInputStream, String serverLocation) {     try {         OutputStream outputStream = new FileOutputStream(new File(serverLocation));         int read = 0;         byte[] bytes = new byte[1024];         outputStream = new FileOutputStream(new File(serverLocation));         while ((read = uploadedInputStream.read(bytes)) != -1) {             outputStream.write(bytes, 0, read);         }         outputStream.flush();         outputStream.close();     } catch (IOException e) {         e.printStackTrace();     } }"
"DrawPageElement drawPageElement = slide.getOdfElement(); DrawFrameElement drawFrame = OdfElement.findFirstChildNode(DrawFrameElement.class, drawPageElement); DrawImageElement image = drawFrame.newDrawImageElement(); OdfPackage mOdfPackage = odp.getPackage(); String imageRef = ""/some/path/to/chart.png"";  String packagePath = odp.getDocumentPath() + OdfPackage.OdfFile.IMAGE_DIRECTORY.getPath() + ""/"" + someMethodToCreateRandomString();  mOdfPackage.insert(new URI(imageRef), packagePath, OdfFileEntry.getMediaTypeString(imageRef)); packagePath = packagePath.replaceFirst(odp.getDocumentPath(), """"); URI uri = new URI(AnyURI.encodePath(packagePath).toString()); image.setXlinkHrefAttribute(AnyURI.decodePath(uri.toString())); image.setXlinkActuateAttribute(""onLoad""); image.setXlinkShowAttribute(""embed""); image.setXlinkTypeAttribute(""simple"");"
package org.camunda.bpm;  import org.camunda.bpm.engine.HistoryService; import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.history.HistoricProcessInstance; import org.camunda.bpm.engine.repository.ProcessDefinition; import java.util.List;  public class AllFinishedProcessInstances {    public List&lt;HistoricProcessInstance&gt; getAllFinishedProcessInstances(String processDefinitionName) {     ProcessEngine processEngine = BpmPlatform.getDefaultProcessEngine();     HistoryService historyService = processEngine.getHistoryService();;     RepositoryService repositoryService = processEngine.getRepositoryService();      ProcessDefinition myProcessDefinition =         repositoryService.createProcessDefinitionQuery()             .processDefinitionName(processDefinitionName)             .latestVersion() // we are only interested in the latest version             .singleResult();      List&lt;HistoricProcessInstance&gt; processInstances =         historyService.createHistoricProcessInstanceQuery()             .processDefinitionId(myProcessDefinition.getId())             .finished() // we only want the finished process instances             .list();      return processInstances;   }  }
"String inCommonMDFile = ""/data/org/opensaml/saml2/metadata/InCommon-metadata.xml"";  // Initialize the library DefaultBootstrap.bootstrap();   // Get parser pool manager BasicParserPool ppMgr = new BasicParserPool(); ppMgr.setNamespaceAware(true);  // Parse metadata file InputStream in = MetadataTest.class.getResourceAsStream(inCommonMDFile); Document inCommonMDDoc = ppMgr.parse(in); Element metadataRoot = inCommonMDDoc.getDocumentElement();  // Get apropriate unmarshaller UnmarshallerFactory unmarshallerFactory = Configuration.getUnmarshallerFactory(); Unmarshaller unmarshaller = unmarshallerFactory.getUnmarshaller(metadataRoot);  // Unmarshall using the document root element, an EntitiesDescriptor in this case EntitiesDescriptor inCommonMD = (EntitiesDescriptor) unmarshaller.unmarshall(metadataRoot);"
"ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();      // This URL for a directory will be searched *recursively*     URL classes =         new URL( ""file:///D:/code/myCustomClassesAreUnderThisFolder/"" );      ClassLoader custom =          new URLClassLoader( new URL[] { classes }, systemClassLoader );      // this class should be loaded from your directory     Class&lt; ? &gt; clazz = custom.loadClass( ""my.custom.class.Name"" );      // this class will be loaded as well, because you specified the system      // class loader as the parent     Class&lt; ? &gt; clazzString = custom.loadClass( ""java.lang.String"" );"
"public static Spanned removeImageSpanObjects(String inStr) {     SpannableStringBuilder spannedStr = (SpannableStringBuilder) Html             .fromHtml(inStr.trim());     Object[] spannedObjects = spannedStr.getSpans(0, spannedStr.length(),             Object.class);     for (int i = 0; i &lt; spannedObjects.length; i++) {         if (spannedObjects[i] instanceof ImageSpan) {             ImageSpan imageSpan = (ImageSpan) spannedObjects[i];             spannedStr.replace(spannedStr.getSpanStart(imageSpan),                     spannedStr.getSpanEnd(imageSpan), """");         }     }     return spannedStr; }"
"Path file = ...; BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);  System.out.println(""creationTime: "" + attr.creationTime()); System.out.println(""lastAccessTime: "" + attr.lastAccessTime()); System.out.println(""lastModifiedTime: "" + attr.lastModifiedTime());  System.out.println(""isDirectory: "" + attr.isDirectory()); System.out.println(""isOther: "" + attr.isOther()); System.out.println(""isRegularFile: "" + attr.isRegularFile()); System.out.println(""isSymbolicLink: "" + attr.isSymbolicLink()); System.out.println(""size: "" + attr.size());"
"public abstract class OpenFileAction extends AbstractAction {     JFrame frame;     JFileChooser chooser;      public OpenFileAction(JFrame frame, JFileChooser chooser) {         super(""Open..."");         this.chooser = chooser;         this.frame = frame;     }      public void actionPerformed(ActionEvent evt) {         int option = chooser.showOpenDialog(this.frame);         if (option == JFileChooser.APPROVE_OPTION) {             File selectedFile = chooser.getSelectedFile();             doWithSelectedFile(selectedFile)         }     }      /**      * Method to override, which gets called with the selected file.      */     protected abstract doWithSelectedFile(File file); }  ...  OpenFileAction action = new OpenFileAction(frame, new JFileChooser(new File("".""))) {     @Override     protected void doWithSelectedFile(File file) {         // do what you want here     } }; JButton button = new JButton(action);"
"public class RenderSceneServlet extends HttpServlet {     protected void doGet(HttServletRequest request, HttpServletResponse response) {         String outputFile = ""/path/to/output-file"";          // execute command to render a frame from scene.blend         Runtime runtime = Runtime.getRuntime();         Process exec = runtime.exec(""blender -b scene.blend -o "" + outputFile + "" -F JPEG -x 1 -f 1"");          // wait for blender to finish         exec.waitFor();          // serve the rendered file         File file = new File(outputFile);         byte[] bytes = FileUtils.readFileToByteArray(file);         response.setContentLength(bytes.length);         response.setContentType(""image/jpeg"");         response.getOutputStream().write(bytes);     } }"
"package opencv;  import org.opencv.core.Core; import org.opencv.core.Core.MinMaxLocResult; import org.opencv.core.CvType; import org.opencv.core.Mat; import org.opencv.core.Point; import org.opencv.core.Scalar; import org.opencv.highgui.Highgui; import org.opencv.imgproc.Imgproc;  class MatchingDemo {     public void run(String inFile, String templateFile, String outFile, int match_method) {         System.out.println(""\nRunning Template Matching"");          Mat img = Highgui.imread(inFile);         Mat templ = Highgui.imread(templateFile);          // / Create the result matrix         int result_cols = img.cols() - templ.cols() + 1;         int result_rows = img.rows() - templ.rows() + 1;         Mat result = new Mat(result_rows, result_cols, CvType.CV_32FC1);          // / Do the Matching and Normalize         Imgproc.matchTemplate(img, templ, result, match_method);         Core.normalize(result, result, 0, 1, Core.NORM_MINMAX, -1, new Mat());          // / Localizing the best match with minMaxLoc         MinMaxLocResult mmr = Core.minMaxLoc(result);          Point matchLoc;         if (match_method == Imgproc.TM_SQDIFF || match_method == Imgproc.TM_SQDIFF_NORMED) {             matchLoc = mmr.minLoc;         } else {             matchLoc = mmr.maxLoc;         }          // / Show me what you got         Core.rectangle(img, matchLoc, new Point(matchLoc.x + templ.cols(),                 matchLoc.y + templ.rows()), new Scalar(0, 255, 0));          // Save the visualized detection.         System.out.println(""Writing ""+ outFile);         Highgui.imwrite(outFile, img);      } }  public class TemplateMatching {     public static void main(String[] args) {         System.loadLibrary(""opencv_java246"");         new MatchingDemo().run(args[0], args[1], args[2], Imgproc.TM_CCOEFF);     } }"
"public interface ProductTrader&lt;P, S&gt; {    public P create(S specification);  }  public interface ImageCreator {    public boolean canProcess(File file);    public Image createImage(File file);  }  public class PNGImageCreator implements ImageCreator {    public boolean canProcess(File file) {     return (file.isFile() &amp;&amp; file.canRead() &amp;&amp; file.getName().endsWith("".png""));   }    public Image createImag(File file) {     //Image I/O code goes here   }  }  public class FileToImageProductTrader implements ProductTrader&lt;Image, File&gt; {    private List&lt;ImageCreator&gt; imageCreators = new ArrayList&lt;ImageCreator&gt;();    public void registerCreator(ImageCreator creator) {     imageCreators.add(creator);   }    public Image create(File specification) {     for(ImageCreator creator : imageCreators) {       if(creator.canProcess(specification)) {         return creator.createImage(specification);       }     }     //No creator for given file     return null;   }  }  public class Main {    public static void main(String [] args) {     FileToImageProductTrader trader = new FileToImageProductTrader();     PNGCreator pngCreator = new PNGCreator();     trader.registerCreator(pngCreator);     File imageFile = new File(""/tmp/foo.png"");     Image image = trader.create(imageFile);   }  }"
"FormBodyPart customBodyPart = new FormBodyPart(""file"", body) {             @Override             protected void generateContentDisp(final ContentBody body) {                 StringBuilder buffer = new StringBuilder();                 buffer.append(""form-data; name=\"""");                 buffer.append(getName());                 buffer.append(""\"""");                 buffer.append(""; filename=\""-\"""");                 addField(MIME.CONTENT_DISPOSITION, buffer.toString());             }     };     entity.addPart(customBodyPart);"
"public class DownloadImages {      //The url of the website. This is just an example     private static final String webSiteURL = ""http://www.supercars.net/gallery/119513/2841/5.html"";      //The path of the folder that you want to save the images to     private static final String folderPath = ""&lt;FOLDER PATH&gt;"";      public static void main(String[] args) {          try {              //Connect to the website and get the html             Document doc = Jsoup.connect(webSiteURL).get();              //Get all elements with img tag ,             Elements img = doc.getElementsByTag(""img"");              for (Element el : img) {                  //for each element get the srs url                 String src = el.absUrl(""src"");                  System.out.println(""Image Found!"");                 System.out.println(""src attribute is : ""+src);                  getImages(src);              }          } catch (IOException ex) {             System.err.println(""There was an error"");             Logger.getLogger(DownloadImages.class.getName()).log(Level.SEVERE, null, ex);         }     }      private static void getImages(String src) throws IOException {          String folder = null;          //Exctract the name of the image from the src attribute         int indexname = src.lastIndexOf(""/"");          if (indexname == src.length()) {             src = src.substring(1, indexname);         }          indexname = src.lastIndexOf(""/"");         String name = src.substring(indexname, src.length());          System.out.println(name);          //Open a URL Stream         URL url = new URL(src);         InputStream in = url.openStream();          OutputStream out = new BufferedOutputStream(new FileOutputStream( folderPath+ name));          for (int b; (b = in.read()) != -1;) {             out.write(b);         }         out.close();         in.close();      }"
"public class Toto {      public Toto(){         // this writes ""Toto"" in the console if the class is well instanciated         System.out.println(""Toto"");     }      public static void main(String[] args) {         try {             File subfolder = new File(""bin"");             URL classUrl = subfolder.toURI().toURL();             URL[] classUrls = { classUrl };             URLClassLoader ucl = new URLClassLoader(classUrls);              for (File f : subfolder.listFiles()) {                 String fileName= f.getName();                 int suffix = fileName.lastIndexOf('.');                 if(f.isDirectory() || suffix==-1){                     continue;                 }                 String name = fileName.substring(0, suffix);                 try {                     Class.forName(name, true, ucl).newInstance();                  } catch (ClassNotFoundException e) {                     e.printStackTrace();                 }             }             ucl.close();         } catch (MalformedURLException e) {         } catch (InstantiationException e) {             e.printStackTrace();         } catch (IllegalAccessException e) {             e.printStackTrace();         } catch (IOException e) {             e.printStackTrace();         }     } }"
