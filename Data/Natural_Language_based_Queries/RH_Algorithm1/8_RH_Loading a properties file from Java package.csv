code
"import java.io.IOException; import javax.tools.DiagnosticCollector; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.StandardJavaFileManager; import javax.tools.ToolProvider; import javax.tools.JavaCompiler.CompilationTask; import com.sun.source.tree.CompilationUnitTree; import com.sun.source.tree.LineMap; import com.sun.source.tree.MethodTree; import com.sun.source.util.JavacTask; import com.sun.source.util.SourcePositions; import com.sun.source.util.TreeScanner; import com.sun.source.util.Trees;  public class MethodFinder {      public static void main(String[] args) {         JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();         DiagnosticCollector&lt;JavaFileObject&gt; diagnosticsCollector = new DiagnosticCollector&lt;JavaFileObject&gt;();         StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnosticsCollector, null, null);         Iterable&lt;? extends JavaFileObject&gt; fileObjects = fileManager.getJavaFileObjects(""path/to/Source.java"");         CompilationTask task = compiler.getTask(null, fileManager, diagnosticsCollector, null, null, fileObjects);          // Here we switch to Sun-specific APIs         JavacTask javacTask = (JavacTask) task;         SourcePositions sourcePositions = Trees.instance(javacTask).getSourcePositions();         Iterable&lt;? extends CompilationUnitTree&gt; parseResult = null;         try {             parseResult = javacTask.parse();         } catch (IOException e) {              // Parsing failed             e.printStackTrace();             System.exit(0);         }         for (CompilationUnitTree compilationUnitTree : parseResult) {             compilationUnitTree.accept(new MethodLineLogger(compilationUnitTree, sourcePositions), null);         }     }      private static class MethodLineLogger extends TreeScanner&lt;Void, Void&gt; {         private final CompilationUnitTree compilationUnitTree;         private final SourcePositions sourcePositions;         private final LineMap lineMap;          private MethodLineLogger(CompilationUnitTree compilationUnitTree, SourcePositions sourcePositions) {             this.compilationUnitTree = compilationUnitTree;             this.sourcePositions = sourcePositions;             this.lineMap = compilationUnitTree.getLineMap();         }          @Override         public Void visitMethod(MethodTree arg0, Void arg1) {             long startPosition = sourcePositions.getStartPosition(compilationUnitTree, arg0);             long startLine = lineMap.getLineNumber(startPosition);             long endPosition = sourcePositions.getEndPosition(compilationUnitTree, arg0);             long endLine = lineMap.getLineNumber(endPosition);              // Voila!             System.out.println(""Found method "" + arg0.getName() + "" from line "" + startLine + "" to line ""  + endLine + ""."");              return super.visitMethod(arg0, arg1);         }     } }"
"package com.example;  import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.IOException; import java.io.InputStream; import java.util.zip.ZipEntry; import java.util.zip.ZipOutputStream;  import javax.servlet.ServletException; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public class ZipFileServlet extends HttpServlet {      private static final int DEFAULT_BUFFER_SIZE = 10240; // 10KB.     private YourFileDAO yourFileDAO = YourDAOFactory.getYourFileDAO();      @Override     protected void doPost(HttpServletRequest request, HttpServletResponse response)         throws ServletException, IOException     {         String[] fileIds = request.getParameterValues(""fileId"");         response.setContentType(""application/zip"");         response.setHeader(""Content-Disposition"", ""attachment; filename=\""allfiles.zip\"""");         ZipOutputStream output = null;         byte[] buffer = new byte[DEFAULT_BUFFER_SIZE];          try {             output = new ZipOutputStream(new BufferedOutputStream(response.getOutputStream(), DEFAULT_BUFFER_SIZE));              for (String fileId : fileIds) {                 YourFileItem item = yourFileDAO.find(fileId);                 if (item == null) continue; // Handle yourself. The fileId may be wrong/spoofed.                 InputStream input = null;                  try {                     input = new BufferedInputStream(item.getInputStream(), DEFAULT_BUFFER_SIZE);                     output.putNextEntry(new ZipEntry(item.getName()));                     for (int length = 0; (length = input.read(buffer)) &gt; 0;) {                         output.write(buffer, 0, length);                     }                     output.closeEntry();                 } finally {                     if (input != null) try { input.close(); } catch (IOException logOrIgnore) { /**/ }                 }             }         } finally {             if (output != null) try { output.close(); } catch (IOException logOrIgnore) { /**/ }         }     }  }"
"package mypackage;  import org.opencms.file.*; import org.opencms.main.*; import org.opencms.scheduler.I_CmsScheduledJob; import java.text.SimpleDateFormat; import java.util.*;   public class BuildTagCloud implements I_CmsScheduledJob {    private final String indexaddress = ""address/of/your/index/folder""; // something like ../webapps/opencms/WEB-INF/index/nameOfIndex   private final String tagsFile = ""address""; // part of my template; it's where I store the tag cloud   private final int numTerms = 10; // number of terms in the tag cloud                                                                        public String launch(CmsObject object, java.util.Map parameters) throws java.lang.Exception {       Cloud cloud = new Cloud(indexaddress, numTerms);        Calendar cal = Calendar.getInstance();       SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");       String data;       data = ""&lt;div style=\""border-top: 3px solid #000099; padding-top: 6px; margin-top: 17px;\""&gt;&lt;span style=\""font-weight: bold; font-size: 11px; color: #000099;\""&gt;Tag cloud&lt;/span&gt;&lt;br /&gt;"";       data += sdf.format(cal.getTime()) + ""&lt;br /&gt;"";        try {           List&lt;TermInfo&gt; list = cloud.getCloud();            for(int i = 0; i&lt;list.size(); i++) {               data += ""&lt;br /&gt;"" + i + "". "" + list.get(i).term.text() + "" ... "" + list.get(i).docFreq; // list.get(i).docFreq           }        } catch (Exception e) {            data += e.getMessage();           data += ""&lt;br /&gt;"";        } finally {            data+=""&lt;/div&gt;"";       }        writeAndPublishResource(object, tagsFile, data);        return ""OK"";   }    private void writeAndPublishResource(CmsObject object, String resouce, String data) throws java.lang.Exception {       object.loginUser(""administrator's user name"", ""and his password"");        CmsRequestContext cmsContext = object.getRequestContext();       CmsProject curProject = cmsContext.currentProject();        if(curProject.isOnlineProject()){             CmsProject offlineProject = object.readProject(""Name of the project"");             cmsContext.setCurrentProject(offlineProject);       }       CmsResource res = object.readResource(resouce);       object.lockResource(resouce);       CmsFile file = object.readFile(res);       file.setContents(data.getBytes());       object.writeFile(file);       OpenCms.getPublishManager().publishResource(object, resouce);       object.unlockResource(resouce);     }  }"
"import java.io.IOException; import java.io.InputStream; import java.lang.annotation.Annotation; import java.lang.reflect.Type; import java.net.URL;  import javax.ws.rs.Consumes; import javax.ws.rs.WebApplicationException; import javax.ws.rs.core.Context; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.MultivaluedMap; import javax.ws.rs.ext.ContextResolver; import javax.ws.rs.ext.MessageBodyReader; import javax.ws.rs.ext.Provider; import javax.ws.rs.ext.Providers; import javax.xml.XMLConstants; import javax.xml.bind.JAXBContext; import javax.xml.bind.JAXBException; import javax.xml.bind.Unmarshaller; import javax.xml.validation.Schema; import javax.xml.validation.SchemaFactory;  @Provider @Consumes(""application/xml"") public class ValidatingReader implements MessageBodyReader&lt;Customer&gt; {      @Context     protected Providers providers;      private Schema schema;      public ValidatingReader() {         try {             SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);             URL schemaURL = null;             schema = sf.newSchema(schemaURL);         } catch(Exception e) {             throw new RuntimeException(e);         }     }      public boolean isReadable(Class&lt;?&gt; arg0, Type arg1, Annotation[] arg2, MediaType arg3) {         return arg0 == Customer.class;     }      public Customer readFrom(Class&lt;Customer&gt; arg0, Type arg1, Annotation[] arg2, MediaType arg3, MultivaluedMap&lt;String, String&gt; arg4, InputStream arg5)             throws IOException, WebApplicationException {         try {             JAXBContext jaxbContext = null;             ContextResolver&lt;JAXBContext&gt; resolver = providers.getContextResolver(JAXBContext.class, arg3);             if(null != resolver) {                 jaxbContext = resolver.getContext(arg0);             }             if(null == jaxbContext) {                 jaxbContext = JAXBContext.newInstance(arg0);             }             Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();             unmarshaller.setSchema(schema);             return (Customer) unmarshaller.unmarshal(arg5);         } catch(JAXBException e) {             throw new RuntimeException(e);         }     }  }"
"import org.icepdf.ri.common.SwingController; import org.icepdf.ri.common.SwingViewBuilder;  import javax.swing.*;  /**  * The &lt;code&gt;ViewerComponentExample&lt;/code&gt; class is an example of how to use  * &lt;code&gt;SwingController&lt;/code&gt; and &lt;code&gt;SwingViewBuilder&lt;/code&gt;  * to build a PDF viewer component.  A file specified at the command line is  * opened in a JFrame which contains the viewer component.  *  * @since 2.0  */ public class ViewerComponentExample {     public static void main(String[] args) {         // Get a file from the command line to open         String filePath = args[0];          // build a component controller         SwingController controller = new SwingController();          SwingViewBuilder factory = new SwingViewBuilder(controller);          JPanel viewerComponentPanel = factory.buildViewerPanel();          // add interactive mouse link annotation support via callback         controller.getDocumentViewController().setAnnotationCallback(                 new org.icepdf.ri.common.MyAnnotationCallback(                         controller.getDocumentViewController()));          JFrame applicationFrame = new JFrame();         applicationFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         applicationFrame.getContentPane().add(viewerComponentPanel);          // Now that the GUI is all in place, we can try openning a PDF         controller.openDocument(filePath);          // show the component         applicationFrame.pack();         applicationFrame.setVisible(true);     } }"
"import java.io.IOException; import java.io.PrintWriter; import java.io.StringWriter; import java.lang.reflect.InvocationTargetException; import java.net.URI; import java.util.Arrays;  import javax.tools.Diagnostic; import javax.tools.DiagnosticCollector; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.SimpleJavaFileObject; import javax.tools.ToolProvider; import javax.tools.JavaCompiler.CompilationTask; import javax.tools.JavaFileObject.Kind;  public class CompileSourceInMemory {   public static void main(String args[]) throws IOException {     JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();     DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();      StringWriter writer = new StringWriter();     PrintWriter out = new PrintWriter(writer);     out.println(""public class HelloWorld {"");     out.println(""  public static void main(String args[]) {"");     out.println(""    System.out.println(\""This is in another java file\"");"");         out.println(""  }"");     out.println(""}"");     out.close();     JavaFileObject file = new JavaSourceFromString(""HelloWorld"", writer.toString());      Iterable&lt;? extends JavaFileObject&gt; compilationUnits = Arrays.asList(file);     CompilationTask task = compiler.getTask(null, null, diagnostics, null, null, compilationUnits);      boolean success = task.call();     for (Diagnostic diagnostic : diagnostics.getDiagnostics()) {       System.out.println(diagnostic.getCode());       System.out.println(diagnostic.getKind());       System.out.println(diagnostic.getPosition());       System.out.println(diagnostic.getStartPosition());       System.out.println(diagnostic.getEndPosition());       System.out.println(diagnostic.getSource());       System.out.println(diagnostic.getMessage(null));      }     System.out.println(""Success: "" + success);      if (success) {       try {         Class.forName(""HelloWorld"").getDeclaredMethod(""main"", new Class[] { String[].class })             .invoke(null, new Object[] { null });       } catch (ClassNotFoundException e) {         System.err.println(""Class not found: "" + e);       } catch (NoSuchMethodException e) {         System.err.println(""No such method: "" + e);       } catch (IllegalAccessException e) {         System.err.println(""Illegal access: "" + e);       } catch (InvocationTargetException e) {         System.err.println(""Invocation target: "" + e);       }     }   } }  class JavaSourceFromString extends SimpleJavaFileObject {   final String code;    JavaSourceFromString(String name, String code) {     super(URI.create(""string:///"" + name.replace('.','/') + Kind.SOURCE.extension),Kind.SOURCE);     this.code = code;   }    @Override   public CharSequence getCharContent(boolean ignoreEncodingErrors) {     return code;   } }"
"package com.primavera.ws.jaxws.provider;  import javax.annotation.Resource; import javax.xml.ws.BindingType; import javax.xml.ws.Provider; import javax.xml.ws.Service; import javax.xml.ws.ServiceMode; import javax.xml.ws.WebServiceContext; import javax.xml.ws.WebServiceProvider;  @WebServiceProvider(portName=""MyPort"", serviceName=""MyService"", targetNamespace=""http://mytargetlocation"", wsdlLocation=""WEB-INF/wsdl/My.wsdl"") @ServiceMode(value = Service.Mode.MESSAGE) @BindingType(HTTPBinding.HTTP_BINDING)  public class MyProvider implements Provider&lt;Source&gt; {      @Resource     private WebServiceContext context;       public MyProvider()     {     }      @Override     public Source invoke(Source request)     {         MessageContext mc = context.getMessageContext();         HttpSession session =    ((javax.servlet.http.HttpServletRequest)mc.get(MessageContext.SERVLET_REQUEST)).getSession();         if (session == null)             throw new WebServiceException(""No HTTP Session found"");          System.out.println(""SessionID: "" + session.getId());          return request;     } }"
"import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.BufferedReader; import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.net.URI; import java.util.Deque; import java.util.Enumeration; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.Map; import java.util.UUID; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; import java.util.zip.ZipOutputStream;  import javax.faces.context.ExternalContext; import javax.faces.context.FacesContext; import javax.servlet.http.HttpServletResponse;  public class DocxManipulator {      private static final String MAIN_DOCUMENT_PATH = ""word/document.xml"";     private static final String TEMPLATE_DIRECTORY_ROOT = ""TEMPLATES_DIRECTORY/"";       /*    PUBLIC METHODS    */      /**      * Generates .docx document from given template and the substitution data      *       * @param templateName      *            Template data      * @param substitutionData      *            Hash map with the set of key-value pairs that represent      *            substitution data      * @return      */     public static Boolean generateAndSendDocx(String templateName, Map&lt;String,String&gt; substitutionData) {          String templateLocation = TEMPLATE_DIRECTORY_ROOT + templateName;          String userTempDir = UUID.randomUUID().toString();         userTempDir = TEMPLATE_DIRECTORY_ROOT + userTempDir + ""/"";          try {              // Unzip .docx file             unzip(new File(templateLocation), new File(userTempDir));                     // Change data             changeData(new File(userTempDir + MAIN_DOCUMENT_PATH), substitutionData);              // Rezip .docx file             zip(new File(userTempDir), new File(userTempDir + templateName));              // Send HTTP response             sendDOCXResponse(new File(userTempDir + templateName), templateName);              // Clean temp data             deleteTempData(new File(userTempDir));         }          catch (IOException ioe) {             System.out.println(ioe.getMessage());             return false;         }          return true;     }       /*    PRIVATE METHODS    */      /**      * Unzipps specified ZIP file to specified directory      *       * @param zipfile      *            Source ZIP file      * @param directory      *            Destination directory      * @throws IOException      */     private static void unzip(File zipfile, File directory) throws IOException {          ZipFile zfile = new ZipFile(zipfile);         Enumeration&lt;? extends ZipEntry&gt; entries = zfile.entries();          while (entries.hasMoreElements()) {           ZipEntry entry = entries.nextElement();           File file = new File(directory, entry.getName());           if (entry.isDirectory()) {             file.mkdirs();           }            else {             file.getParentFile().mkdirs();             InputStream in = zfile.getInputStream(entry);             try {               copy(in, file);             }              finally {               in.close();             }           }         }       }       /**      * Substitutes keys found in target file with corresponding data      *       * @param targetFile      *            Target file      * @param substitutionData      *            Map of key-value pairs of data      * @throws IOException      */     @SuppressWarnings({ ""unchecked"", ""rawtypes"" })     private static void changeData(File targetFile, Map&lt;String,String&gt; substitutionData) throws IOException{          BufferedReader br = null;         String docxTemplate = """";         try {             br = new BufferedReader(new InputStreamReader(new FileInputStream(targetFile), ""UTF-8""));             String temp;             while( (temp = br.readLine()) != null)                 docxTemplate = docxTemplate + temp;              br.close();             targetFile.delete();         }          catch (IOException e) {             br.close();             throw e;         }          Iterator substitutionDataIterator = substitutionData.entrySet().iterator();         while(substitutionDataIterator.hasNext()){             Map.Entry&lt;String,String&gt; pair = (Map.Entry&lt;String,String&gt;)substitutionDataIterator.next();             if(docxTemplate.contains(pair.getKey())){                 if(pair.getValue() != null)                     docxTemplate = docxTemplate.replace(pair.getKey(), pair.getValue());                 else                     docxTemplate = docxTemplate.replace(pair.getKey(), ""NEDOSTAJE"");             }         }          FileOutputStream fos = null;         try{             fos = new FileOutputStream(targetFile);             fos.write(docxTemplate.getBytes(""UTF-8""));             fos.close();         }         catch (IOException e) {             fos.close();             throw e;         }     }      /**      * Zipps specified directory and all its subdirectories      *       * @param directory      *            Specified directory      * @param zipfile      *            Output ZIP file name      * @throws IOException      */     private static void zip(File directory, File zipfile) throws IOException {          URI base = directory.toURI();         Deque&lt;File&gt; queue = new LinkedList&lt;File&gt;();         queue.push(directory);         OutputStream out = new FileOutputStream(zipfile);         Closeable res = out;          try {           ZipOutputStream zout = new ZipOutputStream(out);           res = zout;           while (!queue.isEmpty()) {             directory = queue.pop();             for (File kid : directory.listFiles()) {               String name = base.relativize(kid.toURI()).getPath();               if (kid.isDirectory()) {                 queue.push(kid);                 name = name.endsWith(""/"") ? name : name + ""/"";                 zout.putNextEntry(new ZipEntry(name));               }                else {                 if(kid.getName().contains("".docx""))                     continue;                   zout.putNextEntry(new ZipEntry(name));                 copy(kid, zout);                 zout.closeEntry();               }             }           }         }          finally {           res.close();         }       }      /**      * Sends HTTP Response containing .docx file to Client      *       * @param generatedFile      *            Path to generated .docx file      * @param fileName      *            File name of generated file that is being presented to user      * @throws IOException      */     private static void sendDOCXResponse(File generatedFile, String fileName) throws IOException {          FacesContext facesContext = FacesContext.getCurrentInstance();         ExternalContext externalContext = facesContext.getExternalContext();         HttpServletResponse response = (HttpServletResponse) externalContext                 .getResponse();          BufferedInputStream input = null;         BufferedOutputStream output = null;          response.reset();         response.setHeader(""Content-Type"", ""application/msword"");         response.setHeader(""Content-Disposition"", ""attachment; filename=\"""" + fileName + ""\"""");         response.setHeader(""Content-Length"",String.valueOf(generatedFile.length()));          input = new BufferedInputStream(new FileInputStream(generatedFile), 10240);         output = new BufferedOutputStream(response.getOutputStream(), 10240);          byte[] buffer = new byte[10240];         for (int length; (length = input.read(buffer)) &gt; 0;) {             output.write(buffer, 0, length);         }          output.flush();         input.close();         output.close();          // Inform JSF not to proceed with rest of life cycle         facesContext.responseComplete();     }       /**      * Deletes directory and all its subdirectories      *       * @param file      *            Specified directory      * @throws IOException      */     public static void deleteTempData(File file) throws IOException {          if (file.isDirectory()) {              // directory is empty, then delete it             if (file.list().length == 0)                 file.delete();             else {                 // list all the directory contents                 String files[] = file.list();                  for (String temp : files) {                     // construct the file structure                     File fileDelete = new File(file, temp);                     // recursive delete                     deleteTempData(fileDelete);                 }                  // check the directory again, if empty then delete it                 if (file.list().length == 0)                     file.delete();             }         } else {             // if file, then delete it             file.delete();         }     }      private static void copy(InputStream in, OutputStream out) throws IOException {          byte[] buffer = new byte[1024];         while (true) {           int readCount = in.read(buffer);           if (readCount &lt; 0) {             break;           }           out.write(buffer, 0, readCount);         }       }        private static void copy(File file, OutputStream out) throws IOException {         InputStream in = new FileInputStream(file);         try {           copy(in, out);         } finally {           in.close();         }       }        private static void copy(InputStream in, File file) throws IOException {         OutputStream out = new FileOutputStream(file);         try {           copy(in, out);         } finally {           out.close();         }      }  }"
"package acme.annotation.processing;  import java.util.HashSet; import java.util.Set;  import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.lang.model.element.TypeElement;  import acme.annotation.FooEntity;  @SupportedAnnotationTypes(""*"") public class FooEntityExtendedProcessor extends AbstractProcessor {      private void log(String msg) {         System.out.println(msg);     }      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         log(""Initially I was asked to process:"" + annotations.toString());          Set&lt;TypeElement&gt; fooAnnotations = new HashSet&lt;&gt;();         for (TypeElement elem : annotations) {             if (isFoo(elem)) fooAnnotations.add(elem);         }          if (fooAnnotations.size() &gt; 0) {             log(""... but I am now going to process:"" + fooAnnotations.toString());             processInternal(fooAnnotations, roundEnv);         } else {             log(""... but none of those was my business!"");         }          // always return false so that other processors get a chance to process the annotations not consumed here         return false;     }      private void processInternal(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         // TODO: do your foo processing here     }      private boolean isFoo(TypeElement elem) {         if (elem.getQualifiedName().toString().equals(""acme.annotation.FooEntity"")                 || elem.getAnnotation(FooEntity.class) != null) {             return true;                     } else {             return false;         }     }  }"
"import java.util.Iterator; import javax.xml.XMLConstants; import javax.xml.namespace.NamespaceContext; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathConstants; import javax.xml.xpath.XPathExpression; import javax.xml.xpath.XPathFactory; import org.w3c.dom.Document;  public class Demo  {     public static void main(String[] args)      {         DocumentBuilderFactory domFactory = DocumentBuilderFactory.newInstance();         domFactory.setNamespaceAware(true);         try          {             DocumentBuilder builder = domFactory.newDocumentBuilder();             Document dDoc = builder.parse(""c:\\path\\to\\xml\\file.xml"");             XPath xPath = XPathFactory.newInstance().newXPath();             xPath.setNamespaceContext(new UniversalNamespaceResolver(dDoc));             String query = ""//rss/channel/yweather:location/@city"";             XPathExpression expr = xPath.compile(query);             Object result = expr.evaluate(dDoc, XPathConstants.STRING);             System.out.println(result);         }          catch (Exception e)          {             e.printStackTrace();         }     }      public static class UniversalNamespaceResolver implements NamespaceContext      {         private Document sourceDocument;          public UniversalNamespaceResolver(Document document)          {             sourceDocument = document;         }          public String getNamespaceURI(String prefix)          {             if (prefix.equals(XMLConstants.DEFAULT_NS_PREFIX))                 return sourceDocument.lookupNamespaceURI(null);             else                 return sourceDocument.lookupNamespaceURI(prefix);         }          public String getPrefix(String namespaceURI)          {             return sourceDocument.lookupPrefix(namespaceURI);         }          public Iterator getPrefixes(String namespaceURI)          {             return null;         }     }    }"
"import java.util.Random; import java.util.concurrent.Executor; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory;  import javafx.application.Application; import javafx.concurrent.Task; import javafx.scene.Scene; import javafx.scene.control.ProgressIndicator ; import javafx.scene.control.TableColumn; import javafx.scene.control.TableView; import javafx.scene.control.cell.ProgressBarTableCell; import javafx.scene.control.cell.PropertyValueFactory; import javafx.scene.layout.BorderPane; import javafx.stage.Stage;  public class ProgressBarTableCellTest extends Application {    @Override   public void start(Stage primaryStage) {     TableView&lt;TestTask&gt; table = new TableView&lt;TestTask&gt;();     Random rng = new Random();     for (int i = 0; i &lt; 20; i++) {       table.getItems().add(           new TestTask(rng.nextInt(3000) + 2000, rng.nextInt(30) + 20));     }      TableColumn&lt;TestTask, String&gt; statusCol = new TableColumn(""Status"");     statusCol.setCellValueFactory(new PropertyValueFactory&lt;TestTask, String&gt;(         ""message""));     statusCol.setPrefWidth(75);      TableColumn&lt;TestTask, Double&gt; progressCol = new TableColumn(""Progress"");     progressCol.setCellValueFactory(new PropertyValueFactory&lt;TestTask, Double&gt;(         ""progress""));     progressCol         .setCellFactory(ProgressBarTableCell.&lt;TestTask&gt; forTableColumn());      table.getColumns().addAll(statusCol, progressCol);      BorderPane root = new BorderPane();     root.setCenter(table);     primaryStage.setScene(new Scene(root));     primaryStage.show();      ExecutorService executor = Executors.newFixedThreadPool(table.getItems().size(), new ThreadFactory() {       @Override       public Thread newThread(Runnable r) {         Thread t = new Thread(r);         t.setDaemon(true);         return t;       }     });       for (TestTask task : table.getItems()) {       executor.execute(task);     }   }    public static void main(String[] args) {     launch(args);   }    static class TestTask extends Task&lt;Void&gt; {      private final int waitTime; // milliseconds     private final int pauseTime; // milliseconds      public static final int NUM_ITERATIONS = 100;      TestTask(int waitTime, int pauseTime) {       this.waitTime = waitTime;       this.pauseTime = pauseTime;     }      @Override     protected Void call() throws Exception {       this.updateProgress(ProgressIndicator.INDETERMINATE_PROGRESS, 1);       this.updateMessage(""Waiting..."");       Thread.sleep(waitTime);       this.updateMessage(""Running..."");       for (int i = 0; i &lt; NUM_ITERATIONS; i++) {         updateProgress((1.0 * i) / NUM_ITERATIONS, 1);         Thread.sleep(pauseTime);       }       this.updateMessage(""Done"");       this.updateProgress(1, 1);       return null;     }    } }"
"import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.TypeElement;  @SupportedSourceVersion(SourceVersion.RELEASE_7) @SupportedAnnotationTypes(""*"") public class Processor extends AbstractProcessor {      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         ImportScanner scanner = new ImportScanner();         scanner.scan(roundEnv.getRootElements(), null);          Set&lt;String&gt; importedTypes = scanner.getImportedTypes();         // do something with the types          return false;     }  }"
"enter code here /*  * Ext GWT - Ext for GWT  * Copyright(c) 2007, 2008, Ext JS, LLC.  * licensing@extjs.com  *   * http://extjs.com/license  */ package com.extjs.gxt.ui.client.data; import java.io.Serializable; import java.util.Collection; import java.util.Date;  import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set;  /**  * RpcMap is used to workaround a part of GWT RPC system.  *   * &lt;p /&gt; The GWT RPC rebinder generates field serializers for every type that is  * assignable to any type in the RPC interfaces.  *   * &lt;p /&gt; If BaseModel was to use ""Map&amp;lt;String, Serializable&gt; map"" this would trigger  * the RPC system to generate field serializers for EVERY Serializable type in  * your GWT Module's class path.  *   * &lt;p /&gt; Therefore BaseModel uses ""Map&amp;lt;String, RpcField&gt; map"" and relies on type  * erasure (cast to Map&amp;lt;Object,Object&gt;) to work around this.  *   * &lt;p /&gt; The only drawback is that if you have to ensure that field serializers are  * generated for any type you add to this map  *   * &lt;p /&gt; RpcMap ensures that the following types are supported Byte, Short, Integer,  * Long, Float, Double, Date, Boolean, and arrays of these types. As well as  * List, Set and Map  */ @SuppressWarnings(""unused"") public class RpcMap implements Serializable{ /**      *       */     private static final long serialVersionUID = 1L; private Byte _byte;   private Short _short;   private Integer _integer;   private Long _long;    private Float _float;   private Double _double; private Date _date;   private Boolean _boolean;   private Byte[] _bytes;   private Short[] _shorts;   private Integer[] _integers;   private Long[] _longs;   private Float[] _floats;   private Double[] _doubles;   private Date[] _dates; private Boolean[] _booleans;  private List&lt;String&gt; _list;   private Set&lt;String&gt; _set;   private Map&lt;String, String&gt; _map;  private transient Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;();   public Map&lt;String, Object&gt; getTransientMap() {    return map;   }   public void clear() {    map.clear();   }   public boolean containsKey(Object key) {    return map.containsKey(key);   }   public boolean containsValue(Object value) {    return map.containsValue(value);   }   public Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet() {    return map.entrySet();   }   public boolean equals(Object o) {    if(o instanceof RpcMap){      return map.equals(((RpcMap)o). map);    }    return false;   }   public Object get(Object key) {    return map.get(key);   }   public int hashCode() {    return map.hashCode();   }   public boolean isEmpty() {    return map.isEmpty();   }   public Set&lt;String&gt; keySet() {    return map.keySet();   }   public Object put(String key, Object value) {    return map.put(key, value);   }   public void putAll(Map&lt;? extends String, ? extends Object&gt; m) {    map.putAll(m);   }   public Object remove(Object key) {    return map.remove(key);   }   public int size() {    return map.size();   }   public Collection&lt;Object&gt; values() {    return map.values();   }   @Override   public String toString() {    return map.toString();   }  }"
"import java.io.ByteArrayInputStream; import java.io.FileInputStream; import java.io.FilterInputStream; import java.io.IOException; import java.io.InputStream; import java.io.SequenceInputStream; import java.util.Enumeration; import java.util.zip.CRC32; import java.util.zip.Deflater; import java.util.zip.DeflaterInputStream; import java.util.zip.DeflaterOutputStream;  /**  * @author mwyraz  * Wraps an input stream and compresses it's contents. Similiar to DeflateInputStream but adds GZIP-header and trailer  * See GzipOutputStream for details.  * LICENSE: Free to use. Contains some lines from GzipOutputStream, so oracle's license might apply as well!  */ public class GzipCompressingInputStream extends SequenceInputStream {     public GzipCompressingInputStream(InputStream in) throws IOException     {         this(in,512);     }     public GzipCompressingInputStream(InputStream in, int bufferSize) throws IOException     {         super(new StatefullGzipStreamEnumerator(in,bufferSize));     }      static enum StreamState     {         HEADER,         CONTENT,         TRAILER     }      protected static class StatefullGzipStreamEnumerator implements Enumeration&lt;InputStream&gt;     {          protected final InputStream in;         protected final int bufferSize;         protected StreamState state;          public StatefullGzipStreamEnumerator(InputStream in, int bufferSize)         {             this.in=in;             this.bufferSize=bufferSize;             state=StreamState.HEADER;         }          public boolean hasMoreElements()         {             return state!=null;         }         public InputStream nextElement()         {             switch (state)             {                 case HEADER:                     state=StreamState.CONTENT;                     return createHeaderStream();                 case CONTENT:                     state=StreamState.TRAILER;                     return createContentStream();                 case TRAILER:                     state=null;                     return createTrailerStream();             }             return null;         }          static final int GZIP_MAGIC = 0x8b1f;         static final byte[] GZIP_HEADER=new byte[] {                 (byte) GZIP_MAGIC,        // Magic number (short)                 (byte)(GZIP_MAGIC &gt;&gt; 8),  // Magic number (short)                 Deflater.DEFLATED,        // Compression method (CM)                 0,                        // Flags (FLG)                 0,                        // Modification time MTIME (int)                 0,                        // Modification time MTIME (int)                 0,                        // Modification time MTIME (int)                 0,                        // Modification time MTIME (int)                 0,                        // Extra flags (XFLG)                 0                         // Operating system (OS)         };         protected InputStream createHeaderStream()         {             return new ByteArrayInputStream(GZIP_HEADER);         }         protected InternalGzipCompressingInputStream contentStream;         protected InputStream createContentStream()         {             contentStream=new InternalGzipCompressingInputStream(new CRC32InputStream(in), bufferSize);             return contentStream;         }         protected InputStream createTrailerStream()         {             return new ByteArrayInputStream(contentStream.createTrailer());         }     }      /**      * Internal stream without header/trailer        */     protected static class CRC32InputStream extends FilterInputStream     {         protected CRC32 crc = new CRC32();         protected long byteCount;         public CRC32InputStream(InputStream in)         {             super(in);         }          @Override         public int read() throws IOException         {             int val=super.read();             if (val&gt;=0)             {                 crc.update(val);                 byteCount++;             }             return val;         }         @Override         public int read(byte[] b, int off, int len) throws IOException         {             len=super.read(b, off, len);             if (len&gt;=0)             {                 crc.update(b,off,len);                 byteCount+=len;             }             return len;         }         public long getCrcValue()         {             return crc.getValue();         }         public long getByteCount()         {             return byteCount;         }     }      /**      * Internal stream without header/trailer        */     protected static class InternalGzipCompressingInputStream extends DeflaterInputStream     {         protected final CRC32InputStream crcIn;         public InternalGzipCompressingInputStream(CRC32InputStream in, int bufferSize)         {             super(in, new Deflater(Deflater.DEFAULT_COMPRESSION, true),bufferSize);             crcIn=in;         }         public void close() throws IOException         {             if (in != null)             {                 try                 {                     def.end();                     in.close();                 }                 finally                 {                     in = null;                 }             }         }          protected final static int TRAILER_SIZE = 8;          public byte[] createTrailer()         {             byte[] trailer= new byte[TRAILER_SIZE];             writeTrailer(trailer, 0);             return trailer;         }          /*          * Writes GZIP member trailer to a byte array, starting at a given          * offset.          */         private void writeTrailer(byte[] buf, int offset)         {             writeInt((int)crcIn.getCrcValue(), buf, offset); // CRC-32 of uncompr. data             writeInt((int)crcIn.getByteCount(), buf, offset + 4); // Number of uncompr. bytes         }          /*          * Writes integer in Intel byte order to a byte array, starting at a          * given offset.          */         private void writeInt(int i, byte[] buf, int offset)         {             writeShort(i &amp; 0xffff, buf, offset);             writeShort((i &gt;&gt; 16) &amp; 0xffff, buf, offset + 2);         }          /*          * Writes short integer in Intel byte order to a byte array, starting          * at a given offset          */         private void writeShort(int s, byte[] buf, int offset)         {             buf[offset] = (byte)(s &amp; 0xff);             buf[offset + 1] = (byte)((s &gt;&gt; 8) &amp; 0xff);         }     }  }"
"package wsdlvalidation;   import java.io.File; import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import java.util.StringTokenizer; import java.util.Map.Entry;  import javax.wsdl.Definition; import javax.wsdl.Fault; import javax.wsdl.Message; import javax.wsdl.Operation; import javax.wsdl.Part; import javax.wsdl.PortType; import javax.wsdl.WSDLException; import javax.wsdl.factory.WSDLFactory; import javax.wsdl.xml.WSDLReader; import javax.xml.namespace.QName;  import org.apache.tools.ant.BuildException; import org.apache.tools.ant.taskdefs.MatchingTask; import org.apache.tools.ant.types.FileSet;  /**  * Ant Task to validate a WDSL for an Axis1 bug.  * */ public class WSDLValidationTask extends MatchingTask {     private FileSet configuredWsdl;      public void execute() throws BuildException     {         super.execute();          try {             WSDLFactory wsdlFactory = WSDLFactory.newInstance();             WSDLReader reader = wsdlFactory.newWSDLReader();              Iterator it = getWSDLFileNamesList().iterator();             while (it.hasNext()) {                 String wsdl = (String) it.next();                  Definition theWSDL = reader.readWSDL(wsdl);                   // This is a Bag of all Messages in the WSDL that are used in some &lt;wsdl:fault&gt; of any Operation of any PortType                 Set faultMessages = new HashSet();                 Map allPortTypes = theWSDL.getPortTypes();                 Iterator portTypeIt = allPortTypes.entrySet().iterator();                 while (portTypeIt.hasNext()) {                     Map.Entry entry = (Entry) portTypeIt.next();                     PortType portType = (PortType) entry.getValue();                     List allOperations = portType.getOperations();                     Iterator listIt = allOperations.iterator();                     while (listIt.hasNext()) {                         Operation operation = (Operation)listIt.next();                         Iterator faultIt = operation.getFaults().values().iterator();                         while (faultIt.hasNext()) {                             Fault fault = (Fault) faultIt.next();                                 faultMessages.add(fault.getMessage());                                             }                     }                 }                  Map allMessages = theWSDL.getMessages();                 Iterator messageIt = allMessages.entrySet().iterator();                 while (messageIt.hasNext()) {                     Map.Entry entry = (Entry) messageIt.next();                     QName messageNameQName = (QName) entry.getKey();                     String messageName = messageNameQName.getLocalPart();                      Message message = (Message) entry.getValue();                     Map parts = message.getParts();                     validate(parts.size() == 1, wsdl,                             ""wsdl:message has more than one part: "" + messageNameQName.toString());                     Part messagePart = (Part) parts.values().iterator().next();                     validate(messagePart.getTypeName() == null, wsdl, ""wsdl:part should not have a 'type' attribute: "" + messagePart.getName());                      // Only for Messages that are used in Fault:                     if (faultMessages.contains(message)) {                         validate(!messagePart.getElementName().getLocalPart().equals(messageName), wsdl,                                 ""Due to an Axis1 bug, please do NOT use the same name for &lt;wsdl:message name=\"""" + messageName + ""\""&gt; and &lt;xsd:element name=\"""" + messagePart.getElementName().getLocalPart()+""\""&gt;"");                     }                 }              }         } catch (WSDLException e) {             throw new BuildException(e);         }     }      private void validate(boolean condition, String wsdlFilename, String failureMessage) throws BuildException {         if (!condition) {             throw new BuildException(wsdlFilename + "": "" + failureMessage);         }     }      // TODO Doesn't code like this already exist in ant??     private List getWSDLFileNamesList() {         List/*&lt;String&gt;*/ wsdlList = new ArrayList/*&lt;String&gt;*/();         File dir = configuredWsdl.getDir(configuredWsdl.getProject());         StringTokenizer tokenizer = new StringTokenizer(configuredWsdl.toString(), "";"");         while (tokenizer.hasMoreTokens()) {             String token = tokenizer.nextToken();             wsdlList.add(new File(dir, token).toString());         }         return wsdlList;     }      public void addConfiguredWsdl(FileSet fileSet) {         configuredWsdl = fileSet;     } }"
"package gui;  import java.awt.BorderLayout; import java.awt.EventQueue; import java.awt.event.ActionEvent; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import javax.swing.AbstractAction; import javax.swing.JButton; import javax.swing.JFrame; import javax.swing.JLabel;  /**  * @see http://stackoverflow.com/a/20116944/230513  */ public class PrevNext {      private final List&lt;String&gt; list = new ArrayList&lt;&gt;(         Arrays.asList(""Alpher"", ""Bethe"", ""Gamow"", ""Dirac"", ""Einstein""));     private int index = list.indexOf(""Einstein"");     private final JLabel label = new JLabel(list.get(index), JLabel.CENTER);      private void display() {         JFrame f = new JFrame(""PrevNext"");         f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         f.add(new JButton(new AbstractAction(""&lt;Prev"") {              @Override             public void actionPerformed(ActionEvent e) {                 if (--index &lt; 0) {                     index = list.size() - 1;                 }                 update();             }         }), BorderLayout.LINE_START);         f.add(label);         f.add(new JButton(new AbstractAction(""Next&gt;"") {              @Override             public void actionPerformed(ActionEvent e) {                 if (++index == list.size()) {                     index = 0;                 }                 update();             }         }), BorderLayout.LINE_END);         f.pack();         f.setLocationRelativeTo(null);         f.setVisible(true);     }      private void update() {         label.setText(list.get(index));     }      public static void main(String[] args) {         EventQueue.invokeLater(new Runnable() {              @Override             public void run() {                 new PrevNext().display();             }         });     } }"
"import java.io.BufferedReader; import java.io.DataOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.util.Date; import java.util.Map; import java.util.Set;  import org.json.simple.JSONObject; import org.json.simple.parser.JSONParser; import org.json.simple.parser.ParseException;   try{                 URL url = new URL(basicPayPalPath+""/v1/oauth2/token"");                 HttpURLConnection uc = (HttpURLConnection) url.openConnection();                 uc.setRequestMethod(""POST"");                 uc.setDoOutput(true);                 String userpass = clientID + "":"" + clientSecret;                 String basicAuth = ""Basic "" + javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());                  uc.setRequestProperty(""Accept"", ""application/json"");                 uc.setRequestProperty(""Authorization"", basicAuth);                 uc.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded"");                 DataOutputStream wr = new DataOutputStream (uc.getOutputStream ());                 wr.writeBytes (""grant_type=client_credentials"");                 wr.flush ();                 wr.close ();                  InputStream is = uc.getInputStream();                 BufferedReader rd = new BufferedReader(new InputStreamReader(is));                 String line;                 StringBuffer response = new StringBuffer();                  while((line = rd.readLine()) != null) {                     response.append(line);                     response.append('\r');                 }                 rd.close();                 JSONParser jsonParser = new JSONParser();                 System.out.println(response.toString());                 JSONObject jsonObject = (JSONObject) jsonParser.parse(response.toString());                 Set&lt;Map.Entry&lt;String, String&gt;&gt; map = jsonObject.entrySet();                 for(Map.Entry&lt;String, String&gt; entry : map){                     System.out.println(entry.toString());                 }             }catch (IOException | ParseException e){                 e.printStackTrace();             }"
"import org.ccil.cowan.tagsoup.Parser; import org.w3c.dom.DOMImplementation; import org.w3c.dom.Document; import org.xml.sax.*;  import javax.xml.parsers.DocumentBuilder; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMResult; import javax.xml.transform.sax.SAXSource; import java.io.IOException;  public class MyDocumentBuilder extends DocumentBuilder {      @Override     public Document parse(InputSource inputSource) throws SAXException, IOException {          XMLReader xmlReader = new Parser();         xmlReader.setFeature(Parser.namespacesFeature, false);         xmlReader.setFeature(Parser.namespacePrefixesFeature, false);          try{             Transformer transformer = TransformerFactory.newInstance().newTransformer();             DOMResult domResult = new DOMResult();             transformer.transform(new SAXSource(xmlReader, inputSource), domResult);             return (Document) domResult.getNode();         }         catch(Exception exp){             throw new RuntimeException(""Error parsing with Tagsoup"");         }     }      @Override     public void setErrorHandler(ErrorHandler errorHandler) {      }      @Override     public Document newDocument() {         return null;     }      @Override     public void setEntityResolver(EntityResolver entityResolver) {      }      @Override     public boolean isValidating() {         return false;     }      @Override     public DOMImplementation getDOMImplementation() {         return null;     }      @Override     public boolean isNamespaceAware() {         return false;     } }"
"package org.camunda.bpm;  import java.util.HashMap; import java.util.List; import java.util.Map; import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.RuntimeService; import org.camunda.bpm.engine.runtime.ProcessInstance; import org.camunda.bpm.model.bpmn.BpmnModelInstance; import org.camunda.bpm.model.xml.instance.ModelElementInstance;  public class AllActiveActivities {    public Map&lt;String, String&gt; getAllActiveActivities(String processInstanceId) {     // get engine services     ProcessEngine processEngine = BpmPlatform.getDefaultProcessEngine()     RuntimeService runtimeService = processEngine.getRuntimeService();     RepositoryService repositoryService = processEngine.getRepositoryService();      // get the process instance     ProcessInstance processInstance =         runtimeService.createProcessInstanceQuery()             .processInstanceId(processInstanceId)             .singleResult();      HashMap&lt;String, String&gt; activityNameByActivityId = new HashMap&lt;String, String&gt;();      // get all active activities of the process instance     List&lt;String&gt; activeActivityIds =         runtimeService.getActiveActivityIds(processInstance.getId());      // get bpmn model of the process instance     BpmnModelInstance bpmnModelInstance =         repositoryService.getBpmnModelInstance(processInstance.getProcessDefinitionId());      for (String activeActivityId : activeActivityIds) {       // get the speaking name of each activity in the diagram       ModelElementInstance modelElementById =           bpmnModelInstance.getModelElementById(activeActivityId);       String activityName = modelElementById.getAttributeValue(""name"");        activityNameByActivityId.put(activeActivityId, activityName);     }      // map contains now all active activities     return activityNameByActivityId;   }  }"
"package com.displaytag.export.views;   import java.io.IOException; import java.io.OutputStream; import java.util.Iterator; import javax.servlet.jsp.JspException; import org.apache.commons.lang.ObjectUtils; import org.apache.commons.lang.StringUtils; import org.displaytag.export.BinaryExportView; import org.displaytag.model.Column; import org.displaytag.model.ColumnIterator; import org.displaytag.model.HeaderCell; import org.displaytag.model.RowIterator; import org.displaytag.model.TableModel; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.CellStyle; import org.apache.poi.ss.usermodel.IndexedColors; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.util.CellRangeAddress; import org.apache.poi.xssf.usermodel.XSSFFont; import org.apache.poi.xssf.usermodel.XSSFSheet; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import com.lowagie.text.BadElementException;  public class myExcel2007ExportView implements BinaryExportView{   //private static Log log = LogFactory.getLog(myExcel2007ExportView.class); private TableModel model; private boolean exportFull; private boolean header; private boolean decorated; private XSSFWorkbook workbook; private XSSFSheet sheet; private int rowCount=0; private CellStyle normalstyle=null; private CellStyle headerstyle=null; private CellStyle captionstyle=null;  private XSSFFont defaultFont; private XSSFFont headerFont; private XSSFFont captionFont;  public String getMimeType() {      return &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;; }  public void setParameters(TableModel tableModel, boolean exportFullList, boolean includeHeader,        boolean decorateValues) {    this.model = tableModel;    this.exportFull = true;    this.header = includeHeader;    this.decorated = decorateValues; }  public boolean outputPage() {     return false; }  protected void initTable() throws BadElementException {     //Blank workbook     workbook = new XSSFWorkbook();           //Create a blank sheet     sheet = workbook.createSheet(&quot;Server Management System&quot;);               defaultFont= workbook.createFont();     defaultFont.setFontHeightInPoints((short)10);     defaultFont.setFontName(&quot;Arial&quot;);     defaultFont.setColor(IndexedColors.BLACK.getIndex());     defaultFont.setBold(false);     defaultFont.setItalic(false);      headerFont= workbook.createFont();     headerFont.setFontHeightInPoints((short)10);     headerFont.setFontName(&quot;Arial&quot;);     headerFont.setColor(IndexedColors.WHITE.getIndex());     headerFont.setBold(true);     headerFont.setItalic(false);          captionFont= workbook.createFont();     captionFont.setFontHeightInPoints((short)15);     captionFont.setFontName(&quot;Arial&quot;);     captionFont.setColor(IndexedColors.BLACK.getIndex());     captionFont.setBold(true);     captionFont.setItalic(false);               normalstyle= workbook.createCellStyle();      normalstyle.setFillBackgroundColor(IndexedColors.WHITE.getIndex());     normalstyle.setFillPattern(CellStyle.BIG_SPOTS);     normalstyle.setAlignment(CellStyle.ALIGN_CENTER);     normalstyle.setFont(defaultFont);          headerstyle= workbook.createCellStyle();      headerstyle.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());     headerstyle.setFillPattern(CellStyle.BIG_SPOTS);     headerstyle.setAlignment(CellStyle.ALIGN_CENTER);     headerstyle.setFont(headerFont);          captionstyle= workbook.createCellStyle();      captionstyle.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());     captionstyle.setFillPattern(CellStyle.BIG_SPOTS);     captionstyle.setAlignment(CellStyle.ALIGN_CENTER);     captionstyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER);     captionstyle.setFont(captionFont);      }  protected void generateXLSXTable() throws JspException, BadElementException {     //adding caption     if(this.model.getCaption()!=null &amp;&amp; this.model.getCaption()!=&quot;&quot;)     {      Row blankrow = sheet.createRow(rowCount++);      Row row = sheet.createRow(rowCount++);            row.setHeight((short)5000);      int columnCount=0;      Cell captionCell = row.createCell(columnCount++);      captionCell.setCellValue(this.model.getCaption());      captionCell.setCellStyle(captionstyle);      sheet.addMergedRegion(new CellRangeAddress(              rowCount-1, //first row (0-based)              rowCount-1, //last row  (0-based)              columnCount-1, //first column (0-based)              columnCount+5  //last column  (0-based)      ));      Row blankrow2 = sheet.createRow(rowCount++);     }          if (this.header)     {         generateHeaders();     }          generateRows();          //adding footer     if(this.model.getFooter()!=null &amp;&amp; this.model.getFooter()!=&quot;&quot;)     {      Row blankrow = sheet.createRow(rowCount++);      Row blankrow2 = sheet.createRow(rowCount++);      Row row = sheet.createRow(rowCount++);            row.setHeight((short)1000);      int columnCount=0;      Cell captionCell = row.createCell(columnCount++);      captionCell.setCellValue(this.model.getFooter());      captionCell.setCellStyle(captionstyle);      sheet.addMergedRegion(new CellRangeAddress(              rowCount-1, //first row (0-based)              rowCount-1, //last row  (0-based)              columnCount-1, //first column (0-based)              columnCount+5  //last column  (0-based)      ));     } }  protected void generateHeaders() throws BadElementException {     Iterator&lt;HeaderCell&gt; iterator = this.model.getHeaderCellList().iterator();     Row row = sheet.createRow(rowCount++);          int columnCount=0;     while (iterator.hasNext())     {         sheet.autoSizeColumn(columnCount);         HeaderCell headerCell = iterator.next();          String columnHeader = headerCell.getTitle();          if (columnHeader == null)         {             columnHeader = StringUtils.capitalize(headerCell.getBeanPropertyName());         }          Cell hdrCell = row.createCell(columnCount++);         hdrCell.setCellValue(columnHeader);         hdrCell.setCellStyle(headerstyle);     } }  protected void generateRows() throws JspException, BadElementException {     // get the correct iterator (full or partial list according to the exportFull field)     RowIterator rowIterator = this.model.getRowIterator(this.exportFull);     // iterator on rows     while (rowIterator.hasNext())     {         Row newrow = sheet.createRow(rowCount++);         org.displaytag.model.Row row = rowIterator.next();         // iterator on columns         ColumnIterator columnIterator = row.getColumnIterator(this.model.getHeaderCellList());         int columnCount=0;         while (columnIterator.hasNext())         {             Column column = columnIterator.nextColumn();              // Get the value to be displayed for the column             Object value = column.getValue(this.decorated);              Cell Cell = newrow.createCell(columnCount++);             Cell.setCellValue(ObjectUtils.toString(value));         }     }      }  @Override public void doExport(OutputStream out) throws IOException, JspException {          try {         // Initialize the table with the appropriate number of columns         initTable();                  generateXLSXTable();              } catch (BadElementException e) {         // TODO Auto-generated catch block         e.printStackTrace();     }                 workbook.write(out);     out.close(); } }"
"import com.sun.jndi.ldap.LdapCtxFactory; import java.util.ArrayList; import java.util.Hashtable; import java.util.List; import java.util.Iterator; import javax.naming.Context; import javax.naming.AuthenticationException; import javax.naming.NamingEnumeration; import javax.naming.NamingException; import javax.naming.directory.Attribute; import javax.naming.directory.Attributes; import javax.naming.directory.DirContext; import javax.naming.directory.SearchControls; import javax.naming.directory.SearchResult; import static javax.naming.directory.SearchControls.SUBTREE_SCOPE;  class App2 {      public static void main(String[] args) {          if (args.length != 4 &amp;&amp; args.length != 2) {             System.out.println(""Purpose: authenticate user against Active Directory and list group membership."");             System.out.println(""Usage: App2 &lt;username&gt; &lt;password&gt; &lt;domain&gt; &lt;server&gt;"");             System.out.println(""Short usage: App2 &lt;username&gt; &lt;password&gt;"");             System.out.println(""(short usage assumes 'xyz.tld' as domain and 'abc' as server)"");             System.exit(1);         }          String domainName;         String serverName;          if (args.length == 4) {             domainName = args[2];             serverName = args[3];         } else {             domainName = ""xyz.tld"";             serverName = ""abc"";         }          String username = args[0];         String password = args[1];          System.out                 .println(""Authenticating "" + username + ""@"" + domainName + "" through "" + serverName + ""."" + domainName);          // bind by using the specified username/password         Hashtable props = new Hashtable();         String principalName = username + ""@"" + domainName;         props.put(Context.SECURITY_PRINCIPAL, principalName);         props.put(Context.SECURITY_CREDENTIALS, password);         DirContext context;          try {             context = LdapCtxFactory.getLdapCtxInstance(""ldap://"" + serverName + ""."" + domainName + '/', props);             System.out.println(""Authentication succeeded!"");              // locate this user's record             SearchControls controls = new SearchControls();             controls.setSearchScope(SUBTREE_SCOPE);             NamingEnumeration&lt;SearchResult&gt; renum = context.search(toDC(domainName),                     ""(&amp; (userPrincipalName="" + principalName + "")(objectClass=user))"", controls);             if (!renum.hasMore()) {                 System.out.println(""Cannot locate user information for "" + username);                 System.exit(1);             }             SearchResult result = renum.next();              List&lt;String&gt; groups = new ArrayList&lt;String&gt;();             Attribute memberOf = result.getAttributes().get(""memberOf"");             if (memberOf != null) {// null if this user belongs to no group at all                 for (int i = 0; i &lt; memberOf.size(); i++) {                     Attributes atts = context.getAttributes(memberOf.get(i).toString(), new String[] { ""CN"" });                     Attribute att = atts.get(""CN"");                     groups.add(att.get().toString());                 }             }              context.close();              System.out.println();             System.out.println(""User belongs to: "");             Iterator ig = groups.iterator();             while (ig.hasNext()) {                 System.out.println(""   "" + ig.next());             }          } catch (AuthenticationException a) {             System.out.println(""Authentication failed: "" + a);             System.exit(1);         } catch (NamingException e) {             System.out.println(""Failed to bind to LDAP / get account information: "" + e);             System.exit(1);         }     }      private static String toDC(String domainName) {         StringBuilder buf = new StringBuilder();         for (String token : domainName.split(""\\."")) {             if (token.length() == 0)                 continue; // defensive check             if (buf.length() &gt; 0)                 buf.append("","");             buf.append(""DC="").append(token);         }         return buf.toString();     }  }"
import java.util.ArrayList; import java.util.List;  import javax.xml.bind.annotation.XmlAccessType; import javax.xml.bind.annotation.XmlAccessorType; import javax.xml.bind.annotation.XmlAttribute; import javax.xml.bind.annotation.XmlElementRef; import javax.xml.bind.annotation.XmlRootElement;  @XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) public class Project {      @XmlAttribute     private String name;      @XmlElementRef     private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;();  }
"package com.example;  import java.io.IOException; import java.io.PrintWriter; import java.util.ArrayList; import java.util.Enumeration; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.regex.Pattern;  import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse;  /**  * Applies search and replace patterns. To initialize this filter, the  * param-names should be ""search1"", ""replace1"", ""search2"", ""replace2"", etc.  */ public final class RegexFilter implements Filter {     private List&lt;Pattern&gt; searchPatterns;     private List&lt;String&gt; replaceStrings;      /**      * Finds the search and replace strings in the configuration file. Looks for      * matching searchX and replaceX parameters.      */     public void init(FilterConfig filterConfig) {         Map&lt;String, String&gt; patternMap = new HashMap&lt;String, String&gt;();          // Walk through the parameters to find those whose names start with         // search         Enumeration&lt;String&gt; names = (Enumeration&lt;String&gt;) filterConfig.getInitParameterNames();         while (names.hasMoreElements()) {             String name = names.nextElement();             if (name.startsWith(""search"")) {                 patternMap.put(name.substring(6), filterConfig.getInitParameter(name));             }         }         this.searchPatterns = new ArrayList&lt;Pattern&gt;(patternMap.size());         this.replaceStrings = new ArrayList&lt;String&gt;(patternMap.size());          // Walk through the parameters again to find the matching replace params         names = (Enumeration&lt;String&gt;) filterConfig.getInitParameterNames();         while (names.hasMoreElements()) {             String name = names.nextElement();             if (name.startsWith(""replace"")) {                 String searchString = patternMap.get(name.substring(7));                 if (searchString != null) {                     this.searchPatterns.add(Pattern.compile(searchString));                     this.replaceStrings.add(filterConfig.getInitParameter(name));                 }             }         }     }      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {         // Wrap the response in a wrapper so we can get at the text after calling the next filter         PrintWriter out = response.getWriter();         CharResponseWrapper wrapper = new CharResponseWrapper((HttpServletResponse) response);         chain.doFilter(request, wrapper);          // Extract the text from the completed servlet and apply the regexes         String modifiedHtml = wrapper.toString();         for (int i = 0; i &lt; this.searchPatterns.size(); i++) {             modifiedHtml = this.searchPatterns.get(i).matcher(modifiedHtml).replaceAll(this.replaceStrings.get(i));         }          // Write our modified text to the real response         response.setContentLength(modifiedHtml.getBytes().length);         out.write(modifiedHtml);         out.close();     }      public void destroy() {         this.searchPatterns = null;         this.replaceStrings = null;     } }"
"package net.pms.plugin.webservice.filesystem;  import java.io.File; import java.io.FileNotFoundException; import java.util.ArrayList; import java.util.List;  import javax.jws.WebMethod; import javax.jws.WebParam; import javax.jws.WebService;  import net.pms.plugin.webservice.ServiceBase;  @WebService(serviceName = ""FileSystem"", targetNamespace = ""http://ps3mediaserver.org/filesystem"") public class FileSystemWebService extends ServiceBase {      @WebMethod()     public List&lt;String&gt; getRoots() {         List&lt;String&gt; roots = new ArrayList&lt;String&gt;();         for(File child : File.listRoots()) {             roots.add(child.getAbsolutePath());         }         return roots;     }      @WebMethod()     public List&lt;String&gt; getChildFolders(@WebParam(name=""folderPath"") String folderPath) throws FileNotFoundException {         List&lt;String&gt; children = new ArrayList&lt;String&gt;();         File d = new File(folderPath);         if(d.isDirectory()) {             for(File child : d.listFiles()) {                 if(child.isDirectory() &amp;&amp; !child.isHidden()) {                     children.add(child.getAbsolutePath());                 }             }         } else {             throw new FileNotFoundException();         }         return children;     } }"
"import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.FileInputStream; import java.io.InputStream; import java.io.OutputStreamWriter; import java.io.Writer;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node;  public class XmlTest {      public static void main(String[] args) throws Exception     {         InputStream is = new FileInputStream(""test.xml"");         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();         DocumentBuilder builder = factory.newDocumentBuilder();          Document oldDoc = builder.parse(is);         Node oldRoot = oldDoc.getDocumentElement();         Document newDoc = builder.newDocument();         Element newRoot = newDoc.createElement(""newroot"");         newDoc.appendChild(newRoot);         newRoot.appendChild(newDoc.importNode(oldRoot, true));          ByteArrayOutputStream out = new ByteArrayOutputStream();         DOMSource domSource = new DOMSource(newDoc);         Writer writer = new OutputStreamWriter(out);         StreamResult result = new StreamResult(writer);         TransformerFactory tf = TransformerFactory.newInstance();         Transformer transformer = tf.newTransformer();         transformer.transform(domSource, result);         writer.flush();          InputStream isNewXML = new ByteArrayInputStream(out.toByteArray());      }  }"
"import java.awt.Toolkit; import java.awt.datatransfer.Clipboard; import java.awt.datatransfer.ClipboardOwner; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.StringSelection; import java.awt.datatransfer.Transferable;  import com.sun.jna.Native; import com.sun.jna.platform.win32.User32; import com.sun.jna.platform.win32.WinDef.HWND; import com.sun.jna.win32.StdCallLibrary;  public class Foo implements ClipboardOwner {     public interface CustomUser32 extends StdCallLibrary {         CustomUser32 INSTANCE = (CustomUser32) Native.loadLibrary(""user32"", CustomUser32.class);         HWND GetForegroundWindow();         void keybd_event(byte bVk, byte bScan, int dwFlags, int dwExtraInfo);     }      public void lostOwnership(Clipboard clipboard, Transferable contents) {         // dummy: needed for `ClipboardOwner`     }      void controlC(CustomUser32 customUser32) {         customUser32.keybd_event((byte) 0x11 /* VK_CONTROL*/, (byte) 0, 0, 0);         customUser32.keybd_event((byte) 0x43 /* 'C' */, (byte) 0, 0, 0);         customUser32.keybd_event((byte) 0x43 /* 'C' */, (byte) 0, 2 /* KEYEVENTF_KEYUP */, 0);         customUser32.keybd_event((byte) 0x11 /* VK_CONTROL*/, (byte) 0, 2 /* KEYEVENTF_KEYUP */, 0);// 'Left Control Up     }      String getClipboardText() throws Exception {         return (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);     }      void setClipboardText(String data) throws Exception {         Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(data), this);     }      String getSelectedText(User32 user32, CustomUser32 customUser32) throws Exception {         HWND hwnd = customUser32.GetForegroundWindow();         char[] windowText = new char[512];         user32.GetWindowText(hwnd, windowText, 512);         String windowTitle = Native.toString(windowText);         System.out.println(""Will take selected text from the following window: ["" + windowTitle + ""]"");         String before = getClipboardText();         controlC(customUser32); // emulate Ctrl C         Thread.sleep(100); // give it some time         String text = getClipboardText();         System.out.println(""Currently in clipboard: "" + text);         // restore what was previously in the clipboard         setClipboardText(before);         return text;     }      public static void main(String[] args) throws Exception {         Foo foo = new Foo();         Thread.sleep(2000); // take some time for you to select something anywhere         System.out.println(foo.getSelectedText(User32.INSTANCE, CustomUser32.INSTANCE));     } }"
"import java.io.BufferedReader; import java.io.ByteArrayInputStream; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.lang.annotation.Annotation; import java.lang.reflect.Type;  import javax.servlet.ServletContext; import javax.ws.rs.Consumes; import javax.ws.rs.WebApplicationException; import javax.ws.rs.core.Context; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.MultivaluedMap; import javax.ws.rs.ext.MessageBodyReader; import javax.ws.rs.ext.Provider;  import org.codehaus.jackson.map.ObjectMapper;  import at.fhj.ase.dao.data.Address; import at.fhj.ase.xmlvalidation.msbreader.MessageBodyReaderValidationException;  import com.fasterxml.jackson.databind.JsonNode; import com.github.fge.jackson.JsonLoader; import com.github.fge.jsonschema.exceptions.ProcessingException; import com.github.fge.jsonschema.main.JsonSchemaFactory; import com.github.fge.jsonschema.main.JsonValidator; import com.github.fge.jsonschema.report.ProcessingReport;  @Provider @Consumes(MediaType.APPLICATION_JSON) public class AddressJsonValidationReader implements MessageBodyReader&lt;Address&gt; {      private final String jsonSchemaFileAsString;      public AddressJsonValidationReader(@Context ServletContext servletContext) {         this.jsonSchemaFileAsString = servletContext                 .getRealPath(""/json/Address.json"");     }      @Override     public boolean isReadable(Class&lt;?&gt; type, Type genericType,             Annotation[] annotations, MediaType mediaType) {         if (type == Address.class) {             return true;         }         return false;     }      @Override     public Address readFrom(Class&lt;Address&gt; type, Type genericType,             Annotation[] annotations, MediaType mediaType,             MultivaluedMap&lt;String, String&gt; httpHeaders, InputStream entityStream)             throws IOException, WebApplicationException {          final String jsonData = getStringFromInputStream(entityStream);         System.out.println(jsonData);          InputStream isSchema = new FileInputStream(jsonSchemaFileAsString);         String jsonSchema = getStringFromInputStream(isSchema);          /*          * Perform JSON data validation against schema          */         validateJsonData(jsonSchema, jsonData);          /*          * Convert stream to data entity          */         ObjectMapper m = new ObjectMapper();         Address addr = m.readValue(stringToStream(jsonData), Address.class);          return addr;     }      /**      * Validate the given JSON data against the given JSON schema      *       * @param jsonSchema      *            as String      * @param jsonData      *            as String      * @throws MessageBodyReaderValidationException      *             in case of an error during validation process      */     private void validateJsonData(final String jsonSchema, final String jsonData)             throws MessageBodyReaderValidationException {         try {             final JsonNode d = JsonLoader.fromString(jsonData);             final JsonNode s = JsonLoader.fromString(jsonSchema);              final JsonSchemaFactory factory = JsonSchemaFactory.byDefault();             JsonValidator v = factory.getValidator();              ProcessingReport report = v.validate(s, d);             System.out.println(report);             if (!report.toString().contains(""success"")) {                 throw new MessageBodyReaderValidationException(                         report.toString());             }          } catch (IOException e) {             throw new MessageBodyReaderValidationException(                     ""Failed to validate json data"", e);         } catch (ProcessingException e) {             throw new MessageBodyReaderValidationException(                     ""Failed to validate json data"", e);         }     }      /**      * Taken from &lt;a href=      * ""http://www.mkyong.com/java/how-to-convert-inputstream-to-string-in-java/""      * &gt;www.mkyong.com&lt;/a&gt;      *       * @param is      *            {@link InputStream}      * @return Stream content as String      */     private String getStringFromInputStream(InputStream is) {         BufferedReader br = null;         StringBuilder sb = new StringBuilder();          String line;         try {              br = new BufferedReader(new InputStreamReader(is));             while ((line = br.readLine()) != null) {                 sb.append(line);             }          } catch (IOException e) {             e.printStackTrace();         } finally {             if (br != null) {                 try {                     br.close();                 } catch (IOException e) {                     e.printStackTrace();                 }             }         }          return sb.toString();     }      private InputStream stringToStream(final String str) throws UnsupportedEncodingException {         return new ByteArrayInputStream(str.getBytes(""UTF-8""));     }  }"
"import java.io.IOException; import java.util.EnumSet;  import javax.servlet.DispatcherType; import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  import org.eclipse.jetty.server.Server; import org.eclipse.jetty.servlet.ServletHandler;  public class JettyFilter {    public static void main(final String[] args) throws Exception {     Server server = new Server(8080);      ServletHandler handler = new ServletHandler();     server.setHandler(handler);      handler.addServletWithMapping(HelloServlet.class, ""/*"");     handler.addFilterWithMapping(HelloPrintingFilter.class, ""/*"",         EnumSet.of(DispatcherType.REQUEST));      server.start();     server.join();   }    public static class HelloServlet extends HttpServlet {     private static final long serialVersionUID = 1L;      @Override     protected void doGet(HttpServletRequest request, HttpServletResponse response)         throws ServletException, IOException {       response.setContentType(""text/html"");       response.setStatus(HttpServletResponse.SC_OK);       response.getWriter().println(""&lt;h1&gt;Hello SimpleServlet&lt;/h1&gt;"");     }   }    public static class HelloPrintingFilter implements Filter {     @Override     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)         throws IOException, ServletException {       System.out.print(""hello from filter"");     }      @Override     public void init(FilterConfig arg0) throws ServletException {      }      @Override     public void destroy() {}   } }"
"package inlinecompiler;  import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; import java.net.URL; import java.net.URLClassLoader; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import javax.tools.Diagnostic; import javax.tools.DiagnosticCollector; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.StandardJavaFileManager; import javax.tools.ToolProvider;  public class InlineCompiler {      public static void main(String[] args) {         StringBuilder sb = new StringBuilder(64);         sb.append(""package testcompile;\n"");         sb.append(""public class HelloWorld implements inlinecompiler.InlineCompiler.DoStuff {\n"");         sb.append(""    public void doStuff() {\n"");         sb.append(""        System.out.println(\""Hello world\"");\n"");         sb.append(""    }\n"");         sb.append(""}\n"");          File helloWorldJava = new File(""testcompile/HelloWorld.java"");         if (helloWorldJava.getParentFile().exists() || helloWorldJava.getParentFile().mkdirs()) {              try {                 Writer writer = null;                 try {                     writer = new FileWriter(helloWorldJava);                     writer.write(sb.toString());                     writer.flush();                 } finally {                     try {                         writer.close();                     } catch (Exception e) {                     }                 }                  /** Compilation Requirements *********************************************************************************************/                 DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();                 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();                 StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);                  // This sets up the class path that the compiler will use.                 // I've added the .jar file that contains the DoStuff interface within in it...                 List&lt;String&gt; optionList = new ArrayList&lt;String&gt;();                 optionList.add(""-classpath"");                 optionList.add(System.getProperty(""java.class.path"") + File.pathSeparator + ""dist/InlineCompiler.jar"");                  Iterable&lt;? extends JavaFileObject&gt; compilationUnit                         = fileManager.getJavaFileObjectsFromFiles(Arrays.asList(helloWorldJava));                 JavaCompiler.CompilationTask task = compiler.getTask(                     null,                      fileManager,                      diagnostics,                      optionList,                      null,                      compilationUnit);                 /********************************************************************************************* Compilation Requirements **/                 if (task.call()) {                     /** Load and execute *************************************************************************************************/                     System.out.println(""Yipe"");                     // Create a new custom class loader, pointing to the directory that contains the compiled                     // classes, this should point to the top of the package structure!                     URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(""./"").toURI().toURL()});                     // Load the class from the classloader by name....                     Class&lt;?&gt; loadedClass = classLoader.loadClass(""testcompile.HelloWorld"");                     // Create a new instance...                     Object obj = loadedClass.newInstance();                     // Santity check                     if (obj instanceof DoStuff) {                         // Cast to the DoStuff interface                         DoStuff stuffToDo = (DoStuff)obj;                         // Run it baby                         stuffToDo.doStuff();                     }                     /************************************************************************************************* Load and execute **/                 } else {                     for (Diagnostic&lt;? extends JavaFileObject&gt; diagnostic : diagnostics.getDiagnostics()) {                         System.out.format(""Error on line %d in %s%n"",                                 diagnostic.getLineNumber(),                                 diagnostic.getSource().toUri());                     }                 }                 fileManager.close();             } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException exp) {                 exp.printStackTrace();             }         }     }      public static interface DoStuff {          public void doStuff();     }  }"
"import java.util.List; import java.util.Set;  import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.Element; import javax.lang.model.element.ElementKind; import javax.lang.model.element.TypeElement; import javax.tools.Diagnostic.Kind;  @SupportedSourceVersion(SourceVersion.RELEASE_7) @SupportedAnnotationTypes(""*"") public class Test extends AbstractProcessor {     public int shit;     public int foo;      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         Set&lt;? extends Element&gt; rootElements = roundEnv.getRootElements();          for (Element element : rootElements) {             if (element.getKind() == ElementKind.CLASS) {                 List&lt;? extends Element&gt; classElements = element.getEnclosedElements();                  for (Element classElement : classElements) {                     if (classElement.getKind() == ElementKind.FIELD) {                         if (classElement.getSimpleName().contentEquals(""shit"")) {                             processingEnv.getMessager().printMessage(                                 Kind.WARNING,                                 ""How dare you to swear in the source code?!"",                                 classElement                             );                         }                     }                 }             }         }          return false;     }      public static void main(String[] args) {         //     } }"
