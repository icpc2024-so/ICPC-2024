code
ProcessBuilder processbuilder try  {     processbuilder.directory(file);     processbuilder.redirectErrorStream(true);      process = processbuilder.start();      String readLine;     BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));     // include this too:      // BufferedReader output = new BufferedReader(new InputStreamReader(process.getErrorStream()));     while((readLine = output.readLine()) != null)     {         m_Logger.info(readLine);     }      process.waitFor(); }
pointcut navigation(AutoHandling handling) : execution(* navigation(..))                                               &amp;&amp; @annotation(handling);  // Collect whatever other context you need pointcut processAutoHandleCall() : execution(* *.processAutoHandling());  pointcut wormhole(AutoHandling handling) : processAutoHandleCall()                                             &amp;&amp; cflow(navigation(handling));  after(AutoHandling handling) : wormhole(hanlding) {    ... you advice code    ... access the slot using handling.slot() }
"public void doGet(HttpServletRequest request, HttpServletResponse response)     throws ServletException, IOException {      // fetch the username that was sent in the request     String username = request.getParameter(""username"");      // TODO: verify if the username is taken in the database      // based on the results set the value     request.setAttribute(""isUsernameTaken"", ""true"");      RequestDispatcher dispatcher = getServletContext().getRequestDispatcher(""/register.jsp"");      dispatcher.forward(request, response);       }"
Runnable SendThread = new Runnable() {     public void run() {         try {             GetAndConvertImagesToPdf();             mProgStatus = 30;             mProgress.setProgress(mProgStatus);             title.setText(R.string.sendingTitle);         }          catch (DocumentException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }          catch (IOException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }     } };
"Statement stm = con.createStatement(); BufferedReader reader = new BufferedReader(new FileReader(new File(...))); while (true) {     String line = reader.readLine();     if (line == null) {         break;     }     // this is the trick -- you need to pass different SQL to different methods     if (line.startsWith(""SELECT"")) {         stm.executeQuery(line);     } else if (line.startsWith(""UPDATE"") || line.startsWith(""INSERT"")         || line.startsWith(""DELETE"")) {         stm.executeUpdate(line);     } else {         stm.execute(line);     } } stm.close();"
"KeyStore trustStore  = KeyStore.getInstance( &quot;BKS&quot; /*KeyStore.getDefaultType()*/ ); FileInputStream instream = new FileInputStream(new File(&quot;/mnt/sdcard/keystore.bks&quot;)); try {     trustStore.load(instream, &quot;222222&quot;.toCharArray()); } catch (NoSuchAlgorithmException e) {     e.printStackTrace(); } catch (CertificateException e) {     e.printStackTrace(); } catch (IOException e) {     e.printStackTrace(); } finally {     try { instream.close(); } catch (Exception ignore) {} }  // Create socket factory with given keystore. SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore);  SSLSocketFactory socketFactory = new SSLSocketFactory(trustStore); Scheme sch = new Scheme(&quot;https&quot;, socketFactory, 443); httpclient.getConnectionManager().getSchemeRegistry().register(sch);  HttpGet httpget = new HttpGet(&quot;https://10.2.20.20/fido/EzPay/login.php&quot;);  System.out.println(&quot;executing request &quot; + httpget.getRequestLine());  HttpResponse response = httpclient.execute(httpget); HttpEntity entity = response.getEntity();  System.out.println(&quot;----------------------------------------&quot;); System.out.println(response.getStatusLine()); if (entity != null) {     System.out.println(&quot;Response content length:  &quot; + entity.getContentLength()); }              // Print html. BufferedReader in = new BufferedReader(new InputStreamReader(response.getEntity().getContent())); String line = &quot;&quot;; while ((line = in.readLine()) != null) {      System.out.println(line); } in.close();"
"try{    Class.forName(""com.mysql.jdbc.Driver"").newInstance();    Connection con=DriverManager.getConnection(""jdbc:mysql://localhost:8888/atmlivedetails"",""root"",""root"");               Statement st=con.createStatement();             ResultSet rs=st.executeQuery(""select atmbrno, atmbrname  from location_stat where act_brname='""+br_id+""'"");             int i=0;             JSONArray jArray = new JSONArray();             while(rs.next()){          String s = rs.getString(""atmbrno"");         String t = rs.getString(""atmbrname"");          JSONObject arrayObj = new JSONObject();          arrayObj.put(""atmbrno"",s);         arrayObj.put(""atmbrname"",t);          jArray.add(i,arrayObj);         i++;         }         rs.close ();         st.close ();         out.print(jArray);     }"
"public static void outputXML(Document dom) throws TransformerException {     Transformer transformer = TransformerFactory.newInstance().newTransformer();     transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");      //initialize StreamResult with File object to save to file     StreamResult result = new StreamResult(new StringWriter());     DOMSource source = new DOMSource(dom);     transformer.transform(source, result);      String xmlString = result.getWriter().toString();     System.out.println(xmlString); }"
"JComponent dropTargetComponent = ...; new DropTarget(dropTargetComponent , DnDConstants.ACTION_COPY,     new DropTargetListener() {          public void drop(DropTargetDropEvent dtde) {             Transferable tr = dtde.getTransferable();             if(tr.isDataFlavorSupported(java.awt.datatransfer.DataFlavor.imageFlavor)) {                  Image image = (Image) tr.getTransferData(java.awt.datatransfer.DataFlavor.imageFlavor);                  // Do something with image             }          }           ...    }"
"Dyld maintains a current stack of paths called the run path list.   When @rpath is encountered it is substituted with each path in the   run path list until a loadable dylib if found. The run path stack   is built from the LC_RPATH load commands in the depencency chain   that lead to the current dylib load. You can add an LC_RPATH load   command to an image with the -rpath option to ld(1). You can even add   a LC_RPATH load command path that starts with @loader_path/, and it   will push a path on the run path stack that relative to the image   containing the LC_RPATH. The use of @rpath is most useful when you   have a complex directory structure of programs and dylibs which can be   installed anywhere, but keep their relative positions. This scenario   could be implemented using @loader_path, but every client of a dylib   could need a different load path because its relative position in the   file system is different. The use of @rpath introduces a level of   indirection that simplies things. You pick a location in your directory   structure as an anchor point. Each dylib then gets an install path that   starts with @rpath and is the path to the dylib relative to the anchor   point. Each main executable is linked with -rpath @loader_path/zzz,   where zzz is the path from the executable to the anchor point. At runtime   dyld sets it run path to be the anchor point, then each dylib is found   relative to the anchor point."
"DefaultTableModel rs = MyDB.DataTable(""SELECT `Activity` FROM `transactions` WHERE `Group` = '"" + Gname.getText()+ ""' OR `Group` = 'ALL'""); int columnCount = rs.getColumnCount(); int rowCount = rs.getRowCount();  List &lt;Object&gt; values = new ArrayList&lt;Object&gt;(); for (int rowIndex = 0; rowIndex &lt; rowCount; rowIndex ++){     for(int columnIndex = 0; columnIndex &lt; columnCount; columnIndex++){          Object value = rs.getValueAt(rowIndex , columnIndex );          values.add(value);     } } DefaultComboBoxModel dmc = new DefaultComboBoxModel(values.toArray());"
for (Iterator entries = logEntries.iterator(); entries.hasNext();) {                 SVNLogEntry logEntry = (SVNLogEntry) entries.next();                  if (logEntry.getChangedPaths().size() &gt; 0) {                     Set&lt;String&gt; changedPathsSet = logEntry.getChangedPaths().keySet();                      for (Iterator&lt;String&gt; changedPaths = changedPathsSet.iterator(); changedPaths                             .hasNext();) {                         SVNLogEntryPath entryPath = (SVNLogEntryPath) logEntry                                 .getChangedPaths().get(changedPaths.next());                         String path = entryPath.getPath();                         if (!path.startsWith(updatePath)) {                             continue;                         }
"jSlider.addChangeListener(new ChangeListener() {              @Override             public void stateChanged(ChangeEvent e) {                 // TODO Auto-generated method stub                 JSlider source = (JSlider)e.getSource();                 if(!source.getValueIsAdjusting())                 {                     //textField.setText(String.valueOf(source.getValue()));                     int gain = source.getValue();                     //System.out.println(""***** GAIN ***** ""+gain);                     GetGain g = new GetGain(gain);                 }             }         });"
while (cursor.moveToNext()) {         ProductCategoryDatabaseRetrieve prodCatDB = new ProductCategoryDatabaseRetrieve();//Instantiate here with each iteration.         prodCatDB.set_tid(cursor.getInt(cursor.getColumnIndex(DatabaseHandler._TID)));         prodCatDB.setTid(String.valueOf(cursor.getInt(cursor                 .getColumnIndex(DatabaseHandler.TID))));         prodCatDB.setProductCategoryName(cursor.getString(cursor                 .getColumnIndex(DatabaseHandler.PRODUCT_CATEGORY_NAME)));         prodCatDB.setProductCategoryImage(cursor.getBlob(cursor                 .getColumnIndex(DatabaseHandler.PRODUCT_CATEGORY_IMAGE)));         productCategoryDatabaseRetrieve.add(prodCatDB); }
"Connection conn = ...;   Statement stmt = conn.createStatement();   ResultSet rs = stmt.executeQuery     (&quot;select account_id, name from customers&quot;);   Iterator rows = (new ResultSetDynaClass(rs)).iterator();   while (rows.hasNext()) {     DynaBean row = (DynaBean) rows.next();     System.out.println(&quot;Account number is &quot; +                        row.get(&quot;account_id&quot;) +                        &quot; and name is &quot; + row.get(&quot;name&quot;));   }   rs.close();   stmt.close();"
"UserService userService = UserServiceFactory.getUserService(); String thisURL = request.getRequestURI(); if (request.getUserPrincipal() != null) {     response.getWriter().println(""&lt;p&gt;Hello, "" +                                 request.getUserPrincipal().getName() +                                 ""!  You can &lt;a href=\"""" +                                 userService.createLogoutURL(thisURL) +                                 ""\""&gt;sign out&lt;/a&gt;.&lt;/p&gt;"");     Properties props = new Properties();     Session mailSession = Session.getDefaultInstance(props, null);         Message msg = new MimeMessage(mailSession);     String email = userService.getCurrentUser().getEmail();     //Or     //String email = ""my_admin_account@gmail.com"";     msg.setFrom(new InternetAddress(email));     msg.addRecipient(Message.RecipientType.TO,                      new InternetAddress(""jesse.sightler@gmail.com""));     msg.setSubject(""Test Email"");     msg.setText(""Nobody"");     Transport.send(msg);     response.getWriter().println(""&lt;p&gt;Sent email!&lt;/p&gt;""); } else {     response.getWriter().println(""&lt;p&gt;Please &lt;a href=\"""" +                                 userService.createLoginURL(thisURL) +                                 ""\""&gt;sign in&lt;/a&gt;.&lt;/p&gt;""); }"
"em.getTransaciton().begin(); try {   Query query = em.createNativeQuery(""DELETE FROM table1 WHERE theId = 10;"");   query.executeUpdate(); //not yet executed until transaction is commited.    //continue do something...    em.getTransaction().commit(); //the query above is executed here finally } catch (ex RuntimeException) {   em.getTransaction().rollback(); } finally {   // you probably also want something here to check the status of the transaction and rollback if you exited the try block somehow }"
"Socket socket = ...; // Create and connect the socket DataOutputStream dOut = new DataOutputStream(socket.getOutputStream());  // Send first message dOut.writeByte(1); dOut.writeUTF(""This is the first type of message.""); dOut.flush(); // Send off the data  // Send the second message dOut.writeByte(2); dOut.writeUTF(""This is the second type of message.""); dOut.flush(); // Send off the data  // Send the third message dOut.writeByte(3); dOut.writeUTF(""This is the third type of message (Part 1).""); dOut.writeUTF(""This is the third type of message (Part 2).""); dOut.flush(); // Send off the data  // Send the exit message dOut.writeByte(-1); dOut.flush();  dOut.close();"
"InputStream stream = new FileInputStream(""C:\\Thumbs.db""); POIFSFileSystem fs = new POIFSFileSystem(stream); DirectoryEntry root = fs.getRoot(); Entry entry = root.getEntry(""2""); DocumentInputStream is = fs.createDocumentInputStream(entry.getName());  //Added to read the header lines and fix the ImageFormatException int header_len = is.read(); for (int i = 1; i &lt; header_len; i++) {         is.read(); }  JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(is); JPEGDecodeParam param = JPEGCodec.getDefaultJPEGEncodeParam(4,JPEGDecodeParam.COLOR_ID_RGBA); decoder.setJPEGDecodeParam(param); BufferedImage originalBufferedImage = decoder.decodeAsBufferedImage();"
"public Multimap&lt;String, Map&lt;String, String&gt;&gt; listMysqlBackups(int howManyDays) {     // ... }  public Map&lt;String, Collection&lt;Map&lt;String, String&gt;&gt;&gt; getListMysqlBackupsAsMap() {     return listMysqlBackups(this.numberOfDays).asMap(); }   &lt;c:forEach var=""backup"" items=""${bean.listMysqlBackupsAsMap}""&gt;     &lt;c:set var=""dateISO"" value=""${backup.key}/&gt;     &lt;c:set var=""backupJobs"" value=""${backup.value}/&gt; &lt;!-- a Collection&lt;Map&lt;String,String&gt;&gt; --&gt;     &lt;c:forEach var=""backupJob"" items=""${backupJobs}""&gt;         &lt;!-- do something with each backup job (Map&lt;String, String&gt;) for the current date --&gt;     &lt;/c:forEach&gt; &lt;/c:forEach&gt;"
"JsonArray jArray = new JsonArray(); while (result.next()) {     String  type_json=result.getString(""type"");     String name_json=result.getString(""name"");     String id_json=result.getString(""demo"");     JsonObject jObj = new JsonObject();     jobj.put(""id"", id_json);     jobj.put(""type"", type_json);     jobj.put(""name"", name_json);     jArray.put(jObj); }  JsonObject jObjDevice = new JsonObject(); jObjDevice.put(""device"", jArray); JsonObject jObjDeviceList = new JsonObject(); jObjDevice.put(""devicelist"", jObjDevice );"
"ProcessBuilder pb = new ProcessBuilder(""ssh"",                                         ""user@127.0.0.1"",                                         ""export MYVAR=this/dir/is/cool; /run/my/script/myScript; echo $MYVAR""); pb.redirectErrorStream(); //redirect stderr to stdout Process process = pb.start(); InputStream inputStream = process.getInputStream(); BufferedReader reader = new BufferedReader(new InputStreamReader(inputStream)); String line = null; while((line = reader.readLine())!= null) {     System.out.println(line); } process.waitFor();"
"DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance(); DocumentBuilder db = dbf.newDocumentBuilder(); Document dom = db.parse(is); NodeList contacts = dom.getElementsByTagName(""Contact""); for(int i = 0; i &lt; contacts.getLength(); i++) {     Element contact = (Element) contacts.item(i);     String contactNumber = contact.getAttribute(""Number"");     if(contactNumber.equals(somenumber)) {         Element newMessage = dom.createElement(""Message"");         // Configure the message element         contact.appendChild(newMessage);     } }"
Document retDoc; byte[] c14nOutputbytes; DocumentBuilderFactory factory; DocumentBuilder parser;  // CANONICALIZE THE ORIGINAL DOM c14nOutputbytes = Canonicalizer.getInstance(Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS).canonicalizeSubtree(inXMLDoc.getDocumentElement());  // PARSE THE CANONICALIZED BYTES (IF YOU WANT ANOTHER DOM) OR JUST USE THE BYTES factory = DocumentBuilderFactory.newInstance(); factory.set ... // SETUP THE FACTORY parser = factory.newDocumentBuilder(); // REPARSE TO GET ANOTHER DOM WITH THE ATTRIBUTES IN ALPHA ORDER ByteArrayInputStream bais = new ByteArrayInputStream(c14nOutputbytes); retDoc = parser.parse(bais);
"try {     List&lt;ActivityManager.RunningAppProcessInfo&gt; tasks = am.getRunningAppProcesses();     int numOfTasks = tasks.size();     for(int i = 0; i &lt; numOfTasks; i++)     {         ActivityManager.RunningAppProcessInfo task = tasks.get(i);         try         {             PackageInfo myPInfo = getPackageManager().getPackageInfo(task.processName, 0);             //System.out.println(task.processName);         }         catch (PackageManager.NameNotFoundException ne)         {          ne.printStackTrace();         }     } } catch (SecurityException se) {  se.printStackTrace(); }"
"ParcelFileDescriptor fileDescriptor = this.getContentResolver().openFileDescriptor(uri, &quot;r&quot;);             InputStream in = this.getContentResolver().openInputStream(uri);              CountingInputStreamEntity entity = new CountingInputStreamEntity(in, fileDescriptor.getStatSize());             entity.setUploadListener(this);             entity.setContentType(&quot;binary/octet-stream&quot;);             entity.setChunked(true);                       BufferedHttpEntity myEntity = null;             try {                 myEntity = new BufferedHttpEntity(entity);             } catch (IOException e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }                          put.setEntity(myEntity);"
"public static String findXPathInXMLString(int index, String string) throws XPathExpressionException, SAXException, ParserConfigurationException, IOException {     String xpath;      //Step 1. Insert temporary tag in insert location     StringBuilder stringBuilder = new StringBuilder(string);     stringBuilder.insert(index, ""&lt;findXPathInXMLStringTemporaryTag /&gt;"");      Document document = DocumentBuilderFactory.newInstance().newDocumentBuilder().parse(         new ByteArrayInputStream(stringBuilder.toString().getBytes())       );      //Step 2. Convert string document to DOM document &amp; Find XPath of temporary tag in DOM document     xpath = getXPath(document, ""findXPathInXMLStringTemporaryTag"");      //Step 3. Cut off last part of the XPath     xpath = xpath.replace(""/findXPathInXMLStringTemporaryTag"", """");      //Step 4. Return the XPath     return xpath; }  private static String getXPath(Document root, String elementName) throws XPathExpressionException  {   XPathExpression expr = XPathFactory.newInstance().newXPath().compile(""//""+elementName);   Node node = (Node)expr.evaluate(root, XPathConstants.NODE);     if(node != null) {       return getXPath(node);   }    return null; }  private static String getXPath(Node node) throws XPathExpressionException {     if(node == null || node.getNodeType() != Node.ELEMENT_NODE) {         return """";     }      return getXPath(node.getParentNode()) + ""/"" + node.getNodeName() + getIndex(node); }  private static String getIndex(Node node) throws XPathExpressionException {     XPathExpression expr = XPathFactory.newInstance().newXPath().compile(""count(preceding-sibling::*[local-name() = '"" + node.getNodeName() + ""'])"");     int result = (int)(double)(Double)expr.evaluate(node, XPathConstants.NUMBER);      if(result == 0){         return """";     }     else {         return ""["" + (result + 1) + ""]"";     } }"
"public void parse(String json)  {        JsonFactory factory = new JsonFactory();         ObjectMapper mapper = new ObjectMapper(factory);        JsonNode rootNode = mapper.readTree(json);           Iterator&lt;Map.Entry&lt;String,JsonNode&gt;&gt; fieldsIterator = rootNode.fields();        while (fieldsIterator.hasNext()) {             Map.Entry&lt;String,JsonNode&gt; field = fieldsIterator.next();            System.out.println(""Key: "" + field.getKey() + ""\tValue:"" + field.getValue());        } }"
"task copyDependenciesToTarget(type: Copy) {     println 'Copying dependencies to target...'      configurations.compile.collect().each { compileDependency -&gt;         copy {             with from (compileDependency.getPath()) {                 include '*'             }             into 'target/libs/libs'         }     } }  build.dependsOn(copyDependenciesToTarget)   jar {     manifest.attributes(             ""Main-Class"": ""Main"",             ""Class-Path"": configurations.compile.collect { 'libs/' + it.getName()}.join(' ')     ) }"
package org.camunda.bpm;  import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.RuntimeService; import org.camunda.bpm.engine.repository.ProcessDefinition; import org.camunda.bpm.engine.runtime.ProcessInstance; import java.util.List;  public class AllRunningProcessInstances {    public List&lt;ProcessInstance&gt; getAllRunningProcessInstances(String processDefinitionName) {     // get process engine and services     ProcessEngine processEngine = BpmPlatform.getDefaultProcessEngine();     RuntimeService runtimeService = processEngine.getRuntimeService();     RepositoryService repositoryService = processEngine.getRepositoryService();      // query for latest process definition with given name     ProcessDefinition myProcessDefinition =         repositoryService.createProcessDefinitionQuery()             .processDefinitionName(processDefinitionName)             .latestVersion()             .singleResult();      // list all running/unsuspended instances of the process     List&lt;ProcessInstance&gt; processInstances =         runtimeService.createProcessInstanceQuery()             .processDefinitionId(myProcessDefinition.getId())             .active() // we only want the unsuspended process instances             .list();      return processInstances;   }  }
