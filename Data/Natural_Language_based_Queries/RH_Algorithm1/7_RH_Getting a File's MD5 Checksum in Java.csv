code
"import java.io.ByteArrayOutputStream; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory;  import org.junit.Test; import org.w3c.dom.DOMImplementation; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.ls.DOMImplementationLS; import org.w3c.dom.ls.LSOutput; import org.w3c.dom.ls.LSSerializer;  public class DomLsTest {      @Test     public void testDomLs() throws Exception {         DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();         DocumentBuilder db = dbf.newDocumentBuilder();         DOMImplementation di = db.getDOMImplementation();         Document d = di.createDocument("""", ""foo"", null);         Element e = d.createElement(""bar"");         d.getDocumentElement().appendChild(e);         DOMImplementationLS ls = (DOMImplementationLS) di;         LSOutput lso = ls.createLSOutput();         ByteArrayOutputStream baos = new ByteArrayOutputStream();         lso.setByteStream(baos);         LSSerializer lss = ls.createLSSerializer();         lss.write(d, lso);         System.out.println(baos.toString());     }  }"
"package mypackage;  import org.opencms.file.*; import org.opencms.main.*; import org.opencms.scheduler.I_CmsScheduledJob; import java.text.SimpleDateFormat; import java.util.*;   public class BuildTagCloud implements I_CmsScheduledJob {    private final String indexaddress = ""address/of/your/index/folder""; // something like ../webapps/opencms/WEB-INF/index/nameOfIndex   private final String tagsFile = ""address""; // part of my template; it's where I store the tag cloud   private final int numTerms = 10; // number of terms in the tag cloud                                                                        public String launch(CmsObject object, java.util.Map parameters) throws java.lang.Exception {       Cloud cloud = new Cloud(indexaddress, numTerms);        Calendar cal = Calendar.getInstance();       SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");       String data;       data = ""&lt;div style=\""border-top: 3px solid #000099; padding-top: 6px; margin-top: 17px;\""&gt;&lt;span style=\""font-weight: bold; font-size: 11px; color: #000099;\""&gt;Tag cloud&lt;/span&gt;&lt;br /&gt;"";       data += sdf.format(cal.getTime()) + ""&lt;br /&gt;"";        try {           List&lt;TermInfo&gt; list = cloud.getCloud();            for(int i = 0; i&lt;list.size(); i++) {               data += ""&lt;br /&gt;"" + i + "". "" + list.get(i).term.text() + "" ... "" + list.get(i).docFreq; // list.get(i).docFreq           }        } catch (Exception e) {            data += e.getMessage();           data += ""&lt;br /&gt;"";        } finally {            data+=""&lt;/div&gt;"";       }        writeAndPublishResource(object, tagsFile, data);        return ""OK"";   }    private void writeAndPublishResource(CmsObject object, String resouce, String data) throws java.lang.Exception {       object.loginUser(""administrator's user name"", ""and his password"");        CmsRequestContext cmsContext = object.getRequestContext();       CmsProject curProject = cmsContext.currentProject();        if(curProject.isOnlineProject()){             CmsProject offlineProject = object.readProject(""Name of the project"");             cmsContext.setCurrentProject(offlineProject);       }       CmsResource res = object.readResource(resouce);       object.lockResource(resouce);       CmsFile file = object.readFile(res);       file.setContents(data.getBytes());       object.writeFile(file);       OpenCms.getPublishManager().publishResource(object, resouce);       object.unlockResource(resouce);     }  }"
"package persistence;  import java.sql.Connection; import java.sql.Driver; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.List; import java.util.Map;  public class DatabaseUtils {     private static final String URL = ""jdbc:mysql://localhost:3306/contacts"";     private static final String USERNAME = ""contacts"";     private static final String PASSWORD = ""contacts"";      public static final String SELECT_SQL = ""select customer_id, name, street, city, state, zip, phone, url from customer order by customer_id"";     public static final String INSERT_SQL = ""insert into customer(name, street, city, state, zip, phone, url) values(?,?,?,?,?,?,?)"";      public static void main(String[] args)     {         Connection connection = null;          try         {             connection = getConnection(URL, USERNAME, PASSWORD);             List&lt;Map&gt; rows = findAllCustomers(connection);              for (Map row : rows)             {                 System.out.println(row);                                 }         }         catch (SQLException e)         {             e.printStackTrace();         }         finally         {             close(connection);         }     }      public static List&lt;Map&gt; findAllCustomers(Connection connection) throws SQLException     {         List&lt;Map&gt; rows = new ArrayList&lt;Map&gt;();         PreparedStatement st = null;         ResultSet rs = null;          try         {             st = connection.prepareStatement(SELECT_SQL);             rs = st.executeQuery();             while (rs.next())             {                 rows.add(map(rs));                             }         }         finally         {             close(rs);             close(st);         }          return rows;     }      private static Map&lt;String, Object&gt; map(ResultSet rs) throws SQLException     {         Map&lt;String, Object&gt; row = new LinkedHashMap&lt;String, Object&gt;();          ResultSetMetaData meta = rs.getMetaData();          int numColumns = meta.getColumnCount();         for (int i = 1; i &lt;= numColumns; ++i)         {             String column = meta.getColumnName(i);             Object value = rs.getObject(i);             row.put(column, value);         }          return row;     }      public static Connection getConnection(String url, String username, String password) throws SQLException     {         Driver driver = DriverManager.getDriver(url);          DriverManager.registerDriver(driver);          return DriverManager.getConnection(url, username, password);     }      public static void close(Connection connection)     {         try         {             if (connection != null)             {                 connection.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public static void close(Statement st)     {         try         {             if (st != null)             {                 st.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public static void close(ResultSet rs)     {         try         {             if (rs != null)             {                 rs.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public void rollback(Connection connection)     {         try         {             if (connection != null)             {                 connection.rollback();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     } }"
"package com.vsd.server.hibernate;  import java.sql.Connection; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Properties;  import org.apache.commons.lang.StringUtils; import org.hibernate.HibernateException; import org.hibernate.connection.C3P0ConnectionProvider;  public class FailoverConnectionProvider extends C3P0ConnectionProvider {      String password;     String username;     String connectionString;     String failover_connstring;      @Override     public Connection getConnection() throws SQLException {          Connection conn = null;          try {             conn = DriverManager.getConnection(connectionString, username, password);         } catch (Exception ex) {             conn = DriverManager.getConnection(failover_connstring, username, password);         }          if(conn == null){             throw new IllegalStateException(""Database connection was not initialized"");         }          return conn;      }      @Override     public void configure(Properties properties) throws HibernateException {         failover_connstring = properties.getProperty(""hibernate.connection.failover.url"");          if (StringUtils.isBlank(connectionString)                 &amp;&amp; StringUtils.isBlank(failover_connstring)                 &amp;&amp; StringUtils.isBlank(username)                 &amp;&amp; StringUtils.isBlank(password)) {             throw new IllegalStateException(""Unable to initialize connection provider for hibernate"");         }     } }"
"package hibernatehelper;  import java.io.Serializable; import java.lang.reflect.Method; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Properties; import org.hibernate.HibernateException; import org.hibernate.type.AbstractSingleColumnStandardBasicType; import org.hibernate.type.TypeResolver; import org.hibernate.usertype.ParameterizedType; import org.hibernate.usertype.UserType;   public class GenericEnumUserType implements UserType, ParameterizedType {      private Class &lt;? extends Enum&gt; enumClass;      private Class &lt;?&gt; identifierType;      private Method identifierMethod;      private Method valueOfMethod;      private static final String defaultIdentifierMethodName = ""getId"";      private static final String defaultValueOfMethodName = ""parseId"";      private AbstractSingleColumnStandardBasicType type;      private int[] sqlTypes;      @Override     public void setParameterValues(Properties parameters) {         String enumClassName = parameters.getProperty(""enumClass"");         try {             enumClass = Class.forName(enumClassName).asSubclass(Enum.class);         } catch (ClassNotFoundException exception) {             throw new HibernateException(""Enum class not found"", exception);         }          String identifierMethodName =                 parameters.getProperty(""identifierMethod"",                         defaultIdentifierMethodName);          try {             identifierMethod =                     enumClass.getMethod(identifierMethodName, new Class[0]);             identifierType = identifierMethod.getReturnType();         } catch (Exception exception) {             throw new HibernateException(""Failed to optain identifier method"",                     exception);         }          TypeResolver tr = new TypeResolver();         type =                 (AbstractSingleColumnStandardBasicType) tr.basic(identifierType                         .getName());         if (type == null) {             throw new HibernateException(""Unsupported identifier type ""                     + identifierType.getName());         }         sqlTypes = new int[] {type.sqlType()};          String valueOfMethodName = parameters.getProperty(""valueOfMethod"",                 defaultValueOfMethodName);         try {             valueOfMethod = enumClass.getMethod(valueOfMethodName,                             new Class[] {identifierType});         } catch (Exception exception) {             throw new HibernateException(""Failed to optain valueOf method"",                     exception);         }     }      @Override     public Class returnedClass() {         return enumClass;     }      @Override     public Object nullSafeGet(ResultSet rs, String[] names, Object owner)             throws HibernateException, SQLException {         Object identifier = type.get(rs, names[0]);         if (identifier == null) {             return null;         }          if (valueOfMethod == null) {          }          try {             return valueOfMethod.invoke(enumClass, new Object[] {identifier});         } catch (Exception exception) {             throw new HibernateException(                     ""Exception while invoking valueOfMethod of enumeration class: "",                     exception);         }     }      public void nullSafeSet(PreparedStatement st, Object value, int index)             throws HibernateException, SQLException {         try {             Object identifier =                     value != null ? identifierMethod.invoke(value,                             new Object[0]) : null;             st.setObject(index, identifier);         } catch (Exception exception) {             throw new HibernateException(                     ""Exception while invoking identifierMethod of enumeration class: "",                     exception);          }     }      @Override     public int[] sqlTypes() {         return sqlTypes;     }      @Override     public Object assemble(Serializable cached, Object owner)             throws HibernateException {         return cached;     }      @Override     public Object deepCopy(Object value) throws HibernateException {         return value;     }      @Override     public Serializable disassemble(Object value) throws HibernateException {         return (Serializable) value;     }      @Override     public boolean equals(Object x, Object y) throws HibernateException {         return x == y;     }      @Override     public int hashCode(Object x) throws HibernateException {         return x.hashCode();     }      public boolean isMutable() {         return false;     }      public Object replace(Object original, Object target, Object owner)             throws HibernateException {         return original;     } }"
"import java.io.FileReader; import java.sql.Connection; import java.sql.DriverManager;  import org.postgresql.copy.CopyManager; import org.postgresql.core.BaseConnection;  public class PgSqlJdbcCopyStreamsExample {      public static void main(String[] args) throws Exception {          if(args.length!=4) {             System.out.println(""Please specify database URL, user, password and file on the command line."");             System.out.println(""Like this: jdbc:postgresql://localhost:5432/test test password file"");         } else {              System.err.println(""Loading driver"");             Class.forName(""org.postgresql.Driver"");              System.err.println(""Connecting to "" + args[0]);             Connection con = DriverManager.getConnection(args[0],args[1],args[2]);              System.err.println(""Copying text data rows from stdin"");              CopyManager copyManager = new CopyManager((BaseConnection) con);              FileReader fileReader = new FileReader(args[3]);             copyManager.copyIn(""COPY t FROM STDIN"", fileReader );              System.err.println(""Done."");         }     } }"
"import java.security.*; import java.security.cert.*; import java.security.interfaces.*; import java.security.spec.*; import javax.crypto.*; import javax.crypto.interfaces.*; import javax.crypto.spec.*; import java.io.*; /**  *  AES  */ public class SymmetricAES {      public SymmetricAES() {     }      public static void main(String args[]){         BufferedReader ch = new BufferedReader(new InputStreamReader(System.in));         char[] toCode;         byte[] toCode2;         byte[] Coded;         char[] Coded2;         byte[] decoded;         char[] deco2;          try{             System.out.print(""Text to Encrypt : "");             String toMake = ch.readLine();              /** Arxikopoihsh antikeimenou KeyGenerator gia AES              *  kai dhmhourgia Kleidioy */             KeyGenerator keyGen = KeyGenerator.getInstance(""AES"");             SecretKey aesKey = keyGen.generateKey();              /* Arxikopoihsh aesCipher gia AES */             Cipher aesCipher = Cipher.getInstance(""AES"");              /* Orismos aesCipher se ENCRYPT_MODE me to aesKey */             aesCipher.init(Cipher.ENCRYPT_MODE, aesKey);             System.out.println(""The Key : "" + aesKey.getEncoded());              /* Metatroph antikeimenou String se pinaka Char              * kai o ka8e xarakthras gineta Cast se Byte kai eisagwgh              * se pinaka Byte isou mege8ous me ton prwto pinaka */             toCode = toMake.toCharArray();             toCode2 = new byte[toCode.length];             Coded = new byte[toCode.length];             for(int i=0;i&lt;toCode.length;i++)                 toCode2[i] = (byte)toCode[i];              /* Teliko stadio Kryptografhshs */             Coded = aesCipher.doFinal(toCode2);              /* byte[] --&gt; char[] kai ektypwsh*/             Coded2 = new char[Coded.length];             for(int i=0;i&lt;Coded.length;i++)                 Coded2[i] = (char)Coded[i];             System.out.println(""Test Encrypt: "" + new String(Coded2));               Cipher aesCipher2 = Cipher.getInstance(""AES"");              /* Orismos aesCipher2 se DECRYPT_MODE me to aesKey */             aesCipher2.init(Cipher.DECRYPT_MODE, aesKey);              decoded = aesCipher2.doFinal(Coded);              /* byte[] --&gt; char[] kai ektypwsh*/             deco2 = new char[decoded.length];             for(int i=0;i&lt;decoded.length;i++)                 deco2[i] = (char)decoded[i];             System.out.println(""Test Decrypt: "" + new String(deco2));         }         catch(Exception e){             System.out.println(e);         }        } }"
"Connection conn; try {     String[] tableNames = {""tableA"", ""tableB""};     String[] createTableStmts = ... // read the CREATE TABLE SQL statements from a file into this String array. First statement is for the tableA, and so on.     conn = DriverManager.getConnection(""jdbc:derby:sampleDB;create=true"");     for(int ctr =0 ; ctr &lt; tableNames.length; ctr++)     {         PreparedStatement pStmt = conn.prepareStatement(""SELECT t.tablename FROM sys.systables t WHERE t.tablename = ?"");         pStmt.setString(1, tableNames[ctr]);         ResultSet rs = pStmt.executeQuery();         if(!rs.next())         {             // Create the table             Statement stmt = conn.createStatement();             stmt.executeUpdate(createTableStmts[ctr]);             stmt.close();         }         rs.close();         pStmt.close();     } } catch (SQLException e) {     throw new RuntimeException(""Problem starting the app..."", e); }"
"import java.sql.Driver; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Enumeration;  import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.sql.DataSource;  import org.apache.tomcat.jdbc.pool.DataSourceProxy;  public class JdbcPoolListener implements ServletContextListener {      @Override     public void contextInitialized(ServletContextEvent myServletContextEvent) {          // initialize jdbc-pool datasource to start out with pooled connections          try {             Context myContext = (Context) new InitialContext().lookup(""java:comp/env"");             DataSource myDataSource = (DataSource) myContext.lookup(""jdbc/cf"");             myServletContextEvent.getServletContext().setAttribute(""JdbcPool"", myDataSource);         } catch (NamingException e) {             System.out.println(""Error initializing jdbc-pool datasource"");             e.printStackTrace();         }     }      @Override     public void contextDestroyed(ServletContextEvent myServletContextEvent) {      // close datasource from proxy?     ServletContext myServletContext = myServletContextEvent.getServletContext();         DataSourceProxy myDataSource = (DataSourceProxy) myServletContext.getAttribute(""JdbcPool"");         myDataSource.close();                myServletContext.removeAttribute(""JdbcPool"");          // deregister JDBC driver to prevent Tomcat 7 from complaining about memory leaks         Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();         while (drivers.hasMoreElements()) {             Driver driver = drivers.nextElement();             try {                 DriverManager.deregisterDriver(driver);                 System.out.println(String.format(""Deregistering jdbc driver: %s"", driver));             } catch (SQLException e) {                 System.out.println(String.format(""Error deregistering driver %s"", driver));                 e.printStackTrace();             }         }     } }"
"package org.stackoverflowusers.file;  import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.text.ParseException;  /**  * Represents a Windows shortcut (typically visible to Java only as a '.lnk' file).  *  * Retrieved 2011-09-23 from http://stackoverflow.com/questions/309495/windows-shortcut-lnk-parser-in-java/672775#672775  * Originally called LnkParser  *  * Written by: (the stack overflow users, obviously!)  *   Apache Commons VFS dependency removed by crysxd (why were we using that!?) https://github.com/crysxd  *   Headerified, refactored and commented by Code Bling http://stackoverflow.com/users/675721/code-bling  *   Network file support added by Stefan Cordes http://stackoverflow.com/users/81330/stefan-cordes  *   Adapted by Sam Brightman http://stackoverflow.com/users/2492/sam-brightman  *   Based on information in 'The Windows Shortcut File Format' by Jesse Hager &amp;lt;jessehager@iname.com&amp;gt;  *   And somewhat based on code from the book 'Swing Hacks: Tips and Tools for Killer GUIs'  *     by Joshua Marinacci and Chris Adamson  *     ISBN: 0-596-00907-0  *     http://www.oreilly.com/catalog/swinghks/  */ public class WindowsShortcut {     private boolean isDirectory;     private boolean isLocal;     private String real_file;      /**      * Provides a quick test to see if this could be a valid link !      * If you try to instantiate a new WindowShortcut and the link is not valid,      * Exceptions may be thrown and Exceptions are extremely slow to generate,      * therefore any code needing to loop through several files should first check this.      *      * @param file the potential link      * @return true if may be a link, false otherwise      * @throws IOException if an IOException is thrown while reading from the file      */     public static boolean isPotentialValidLink(File file) throws IOException {         final int minimum_length = 0x64;         InputStream fis = new FileInputStream(file);         boolean isPotentiallyValid = false;         try {             isPotentiallyValid = file.isFile()                 &amp;&amp; file.getName().toLowerCase().endsWith("".lnk"")                 &amp;&amp; fis.available() &gt;= minimum_length                 &amp;&amp; isMagicPresent(getBytes(fis, 32));         } finally {             fis.close();         }         return isPotentiallyValid;     }      public WindowsShortcut(File file) throws IOException, ParseException {         InputStream in = new FileInputStream(file);         try {             parseLink(getBytes(in));         } finally {             in.close();         }     }      /**      * @return the name of the filesystem object pointed to by this shortcut      */     public String getRealFilename() {         return real_file;     }      /**      * Tests if the shortcut points to a local resource.      * @return true if the 'local' bit is set in this shortcut, false otherwise      */     public boolean isLocal() {         return isLocal;     }      /**      * Tests if the shortcut points to a directory.      * @return true if the 'directory' bit is set in this shortcut, false otherwise      */     public boolean isDirectory() {         return isDirectory;     }      /**      * Gets all the bytes from an InputStream      * @param in the InputStream from which to read bytes      * @return array of all the bytes contained in 'in'      * @throws IOException if an IOException is encountered while reading the data from the InputStream      */     private static byte[] getBytes(InputStream in) throws IOException {         return getBytes(in, null);     }      /**      * Gets up to max bytes from an InputStream      * @param in the InputStream from which to read bytes      * @param max maximum number of bytes to read      * @return array of all the bytes contained in 'in'      * @throws IOException if an IOException is encountered while reading the data from the InputStream      */     private static byte[] getBytes(InputStream in, Integer max) throws IOException {         // read the entire file into a byte buffer         ByteArrayOutputStream bout = new ByteArrayOutputStream();         byte[] buff = new byte[256];         while (max == null || max &gt; 0) {             int n = in.read(buff);             if (n == -1) {                 break;             }             bout.write(buff, 0, n);             if (max != null)                 max -= n;         }         in.close();         return bout.toByteArray();     }      private static boolean isMagicPresent(byte[] link) {         final int magic = 0x0000004C;         final int magic_offset = 0x00;         return link.length &gt;= 32 &amp;&amp; bytesToDword(link, magic_offset) == magic;     }      /**      * Gobbles up link data by parsing it and storing info in member fields      * @param link all the bytes from the .lnk file      */     private void parseLink(byte[] link) throws ParseException {         try {             if (!isMagicPresent(link))                 throw new ParseException(""Invalid shortcut; magic is missing"", 0);              // get the flags byte             byte flags = link[0x14];              // get the file attributes byte             final int file_atts_offset = 0x18;             byte file_atts = link[file_atts_offset];             byte is_dir_mask = (byte)0x10;             if ((file_atts &amp; is_dir_mask) &gt; 0) {                 isDirectory = true;             } else {                 isDirectory = false;             }              // if the shell settings are present, skip them             final int shell_offset = 0x4c;             final byte has_shell_mask = (byte)0x01;             int shell_len = 0;             if ((flags &amp; has_shell_mask) &gt; 0) {                 // the plus 2 accounts for the length marker itself                 shell_len = bytesToWord(link, shell_offset) + 2;             }              // get to the file settings             int file_start = 0x4c + shell_len;              final int file_location_info_flag_offset_offset = 0x08;             int file_location_info_flag = link[file_start + file_location_info_flag_offset_offset];             isLocal = (file_location_info_flag &amp; 2) == 0;             // get the local volume and local system values             //final int localVolumeTable_offset_offset = 0x0C;             final int basename_offset_offset = 0x10;             final int networkVolumeTable_offset_offset = 0x14;             final int finalname_offset_offset = 0x18;             int finalname_offset = link[file_start + finalname_offset_offset] + file_start;             String finalname = getNullDelimitedString(link, finalname_offset);             if (isLocal) {                 int basename_offset = link[file_start + basename_offset_offset] + file_start;                 String basename = getNullDelimitedString(link, basename_offset);                 real_file = basename + finalname;             } else {                 int networkVolumeTable_offset = link[file_start + networkVolumeTable_offset_offset] + file_start;                 int shareName_offset_offset = 0x08;                 int shareName_offset = link[networkVolumeTable_offset + shareName_offset_offset]                     + networkVolumeTable_offset;                 String shareName = getNullDelimitedString(link, shareName_offset);                 real_file = shareName + ""\\"" + finalname;             }         } catch (ArrayIndexOutOfBoundsException e) {             throw new ParseException(""Could not be parsed, probably not a valid WindowsShortcut"", 0);         }     }      private static String getNullDelimitedString(byte[] bytes, int off) {         int len = 0;         // count bytes until the null character (0)         while (true) {             if (bytes[off + len] == 0) {                 break;             }             len++;         }         return new String(bytes, off, len);     }      /*      * convert two bytes into a short note, this is little endian because it's      * for an Intel only OS.      */     private static int bytesToWord(byte[] bytes, int off) {         return ((bytes[off + 1] &amp; 0xff) &lt;&lt; 8) | (bytes[off] &amp; 0xff);     }      private static int bytesToDword(byte[] bytes, int off) {         return (bytesToWord(bytes, off + 2) &lt;&lt; 16) | bytesToWord(bytes, off);     }  }"
"import java.io.Serializable; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException;  import org.hibernate.HibernateException; import org.hibernate.engine.spi.SessionImplementor; import org.hibernate.id.IdentifierGenerator;  public class StringKeyGenerator implements IdentifierGenerator {      @Override     public Serializable generate(SessionImplementor session, Object collection) throws HibernateException {         Connection connection = session.connection();         PreparedStatement ps = null;         String result = """";          try {             // Oracle-specific code to query a sequence             ps = connection.prepareStatement(""SELECT TABLE_SEQ.nextval AS TABLE_PK FROM dual"");             ResultSet rs = ps.executeQuery();              if (rs.next()) {                 int pk = rs.getInt(""TABLE_PK"");                  // Convert to a String                 result = Integer.toString(pk);             }         } catch (SQLException e) {             throw new HibernateException(""Unable to generate Primary Key"");         } finally {             if (ps != null) {                 try {                     ps.close();                 } catch (SQLException e) {                     throw new HibernateException(""Unable to close prepared statement."");                 }             }         }          return result;     } }"
"import java.io.IOException; import java.io.OutputStream; import java.io.PrintStream; import org.apache.log4j.Logger;  public class RecursiveLogging {   /**    * log4j.properties file:    *     * log4j.rootLogger=DEBUG, A1    * log4j.appender.A1=org.apache.log4j.ConsoleAppender    * log4j.appender.A1.layout=org.apache.log4j.PatternLayout    * log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n    *     */   public static void main(String[] args) {     // Logger.getLogger(RecursiveLogging.class).info(""This initializes log4j!"");     System.setOut(new PrintStream(new CustomOutputStream()));     System.out.println(""This message causes a stack overflow exception!"");   } }  class CustomOutputStream extends OutputStream {   @Override   public final void write(int b) throws IOException {     // the correct way of doing this would be using a buffer     // to store characters until a newline is encountered,     // this implementation is for illustration only     Logger.getLogger(CustomOutputStream.class).info((char) b);   } }"
"import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.util.Vector; import java.util.concurrent.ExecutionException; import java.util.logging.Level; import java.util.logging.Logger; import javax.swing.JTable; import javax.swing.SwingWorker; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableModel; import sun.applet.Main;  public class DataLoadWorker extends SwingWorker&lt;TableModel, TableModel&gt; {      private final JTable table;      public DataLoadWorker(JTable table) {         this.table = table;     }      @Override     protected TableModel doInBackground() throws Exception {         Vector data = new Vector();         Vector columns = new Vector();         PreparedStatement ps = null;         ResultSet rs = null;         try {             String stmt = ""SELECT * FROM APP.DATAVAULT"";             ps = Main.getPreparedStatement(stmt);             rs = ps.executeQuery();             ResultSetMetaData md = rs.getMetaData();             int columnCount = md.getColumnCount();             //store column names               for (int i = 1; i &lt;= columnCount; i++) {                 columns.add(md.getColumnName(i));             }              columns.ensureCapacity(columnCount);              Vector row;             while (rs.next()) {                  row = new Vector(columnCount);                 for (int i = 1; i &lt;= columnCount; i++) {                     row.add(rs.getString(i));                 }                 data.add(row);                  //Debugging                             }              // List.setModel(tableModel);          } finally {             try {                 ps.close();             } catch (Exception e) {             }             try {                 rs.close();             } catch (Exception e) {             }         }          DefaultTableModel tableModel = new DefaultTableModel(data, columns);         return tableModel;     }      @Override     protected void done() {         try {             TableModel model = get();             table.setModel(model);         } catch (InterruptedException | ExecutionException ex) {             ex.printStackTrace();         }     } }"
"import java.math.BigDecimal; import java.sql.Array; import java.sql.CallableStatement; import java.sql.Connection; import java.sql.SQLException; import java.util.ArrayList; import java.util.List;  import javax.sql.DataSource;  import oracle.jdbc.OracleTypes; import oracle.sql.ARRAY; import oracle.sql.ArrayDescriptor; import oracle.sql.STRUCT;  import org.apache.log4j.Logger; import org.springframework.jdbc.core.SqlOutParameter; import org.springframework.jdbc.core.SqlParameter; import org.springframework.jdbc.object.StoredProcedure;  import com.****.****.****.ExcelListenerBean; import com.****.****.****.RevAppViewBean;  public class RevPrdBrkDwnSP extends StoredProcedure{      private final Logger log = Logger.getLogger(this.getClass().getName());      private  Connection con = null;     private DataSource ds = null;      public RevPrdBrkDwnSP(DataSource dataSource, String storeProcName) throws SQLException {          // Run the Parent         super(dataSource, storeProcName);          con = dataSource.getConnection();         ds = dataSource;          if (log.isInfoEnabled()) {             log.info(""Stored Procedure Name : ""+ storeProcName);         }         // Declare the Parameter Details         declareParameter(new SqlParameter(""IN_ARRAY"", OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY""));         declareParameter(new SqlOutParameter(""OUT_ARRAY"", OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY""));          // Compile the SP         compile();     }       public List&lt;ExcelListenerBean&gt; execute(final RevAppViewBean appViewBean$Session, DataSource dataSource) throws Exception {         dataSource = ds;         List&lt;ExcelListenerBean&gt; beans = new ArrayList&lt;ExcelListenerBean&gt;();          log.info(""Setting up the Store Procedure Params"");          String getDBUSERByUserIdSql = ""{call ****.PRCS_PROD_PRCT_BRKDWN_ENTRIES(?,?)}"";         CallableStatement cs = con.prepareCall(getDBUSERByUserIdSql);          ArrayDescriptor des = ArrayDescriptor.createDescriptor(""PBAREV.PROD_PRCT_BRKDWN_TYPE_ARRAY"", con);         ARRAY a = new ARRAY(des, con, appViewBean$Session.getExcelRecLst().toArray());         cs.setObject(1, (Object)a);          cs.registerOutParameter(2, OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY"");          if (log.isDebugEnabled()) {             log.debug(""Executing the PBAREV Store Procedure "");         }          cs.execute();         log.info(""Executed ****.PRCS_PROD_PRCT_BRKDWN_ENTRIES... Processing values to beans"");           Array arr = cs.getArray(2);          Object[] objArr = (Object[]) arr.getArray();         for(int i=0; i&lt;objArr.length;i++){             STRUCT st = (STRUCT)objArr[i];             ExcelListenerBean bean = new ExcelListenerBean();             Object[] obj = st.getAttributes();             bean.setPrntGdwIdN(((BigDecimal)obj[1]).longValue());             bean.setChldGdwIdN(((BigDecimal)obj[2]).longValue());             bean.setChldAsetPrcntN(Double.valueOf(String.valueOf(obj[4])));             bean.setStatus(String.valueOf(obj[8]));             bean.setStatusMessage(String.valueOf(obj[9]));             beans.add(bean);         }          if (log.isDebugEnabled()) {             log.info(""Finised processing SP output values to ExcelListenerBeans"");         }          return beans;     } }"
"import javax.imageio.ImageIO; import javax.imageio.ImageReader; import javax.imageio.event.IIOReadProgressListener; import javax.imageio.stream.ImageInputStream; import java.io.File; import java.util.Iterator; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.atomic.AtomicInteger;  class MultipleJPEGDecoding {     private static int threads = Runtime.getRuntime().availableProcessors();     private static ExecutorService executorService = Executors.newFixedThreadPool(threads * 4);      public static void main(final String[] args) throws InterruptedException {         for (int i = 0; i &lt; 100; i++) {             final int index = i;              executorService.submit(new Runnable() {                 public void run() {                     try {                         ImageInputStream stream = ImageIO.createImageInputStream(new File(args[index % args.length]));                         try {                             Iterator&lt;ImageReader&gt; readers = ImageIO.getImageReaders(stream);                             if (!readers.hasNext()) {                                 System.err.println(&quot;No reader!&quot;);                                 return;                             }                              ImageReader reader = readers.next();                             reader.setInput(stream);                             reader.addIIOReadProgressListener(new ProgressListener(index));                              try {                                 reader.read(0);                             }                             finally {                                 reader.dispose();                             }                         }                         finally {                             stream.close();                         }                     }                     catch (Exception e) {                         System.err.printf(&quot;Error reading %d\n&quot;, index);                         e.printStackTrace();                     }                 }             });         }          executorService.shutdown();     }      static class ProgressListener implements IIOReadProgressListener {         final static AtomicInteger simultaneous = new AtomicInteger(0);          final int index;         int nextProgress = 25;          public ProgressListener(int index) {             this.index = index;         }          public void imageStarted(ImageReader source, int imageIndex) {             int inProgress = simultaneous.incrementAndGet();             System.err.printf(&quot;Started reading image %d (now decoding %d images simultaneous)...\n&quot;, index, inProgress);         }          public void imageComplete(ImageReader source) {             int inProgress = simultaneous.decrementAndGet();             System.err.printf(&quot;Done reading image %d%s.\n&quot;, index, inProgress &gt; 0 ? String.format(&quot; (still decoding %d other images)&quot;, inProgress) : &quot;&quot;);         }          public void imageProgress(ImageReader source, float percentageDone) {             if (percentageDone &gt; nextProgress) {                 int inProgress = simultaneous.get();                 System.err.printf(&quot;Progress on image %d (now decoding %d images simultaneous)...\n&quot;, index, inProgress);                 nextProgress += 25;             }         }          public void sequenceStarted(ImageReader source, int minIndex) {         }          public void sequenceComplete(ImageReader source) {         }          public void thumbnailStarted(ImageReader source, int imageIndex, int thumbnailIndex) {         }          public void thumbnailProgress(ImageReader source, float percentageDone) {         }          public void thumbnailComplete(ImageReader source) {         }          public void readAborted(ImageReader source) {         }     } }"
"import java.awt.image.BufferedImage; import java.io.ByteArrayInputStream; import java.io.ByteArrayOutputStream; import java.io.File; import java.io.IOException; import java.sql.Blob; import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import javax.imageio.ImageIO; import javax.swing.ImageIcon; import javax.swing.JLabel; import javax.swing.JOptionPane; import javax.swing.JScrollPane;  public class TestImageDatbase {      private Connection con;      public static void main(String[] args) {         new TestImageDatbase();     }      public TestImageDatbase() {         try {             clearDatabase();             saveImage();             loadImage();         } catch (ClassNotFoundException | SQLException | IOException exp) {             exp.printStackTrace();         }     }      protected Connection getConnection() throws ClassNotFoundException, SQLException {         Class.forName(""org.h2.Driver"");         return DriverManager.getConnection(""jdbc:h2:d:\\Image"", ""sa"", """");     }      protected void clearDatabase() throws IOException, ClassNotFoundException, SQLException {          Connection con = null;         PreparedStatement stmt = null;          try {              con = getConnection();             System.out.println(""Cleaning database"");             stmt = con.prepareStatement(""delete from images"");             int updated = stmt.executeUpdate();             System.out.println(""Updated "" + updated + "" rows"");          } finally {             try {                 stmt.close();             } catch (Exception e) {             }             try {                 con.close();             } catch (Exception e) {             }         }      }      protected void saveImage() throws IOException, ClassNotFoundException, SQLException {          Connection con = null;         PreparedStatement stmt = null;         ByteArrayOutputStream baos = null;         ByteArrayInputStream bais = null;          try {              baos = new ByteArrayOutputStream();              File source = new File(""/path/to/file"");             System.out.println(""Source size = "" + source.length());             BufferedImage img = ImageIO.read(source);             ImageIO.write(img, ""png"", baos);              baos.close();              bais = new ByteArrayInputStream(baos.toByteArray());              con = getConnection();             stmt = con.prepareStatement(""insert into images (image) values (?)"");             stmt.setBinaryStream(1, bais);             int updated = stmt.executeUpdate();             System.out.println(""Updated "" + updated + "" rows"");          } finally {             try {                 bais.close();             } catch (Exception e) {             }             try {                 baos.close();             } catch (Exception e) {             }             try {                 stmt.close();             } catch (Exception e) {             }             try {                 con.close();             } catch (Exception e) {             }         }      }      protected void loadImage() throws IOException, ClassNotFoundException, SQLException {          Connection con = null;         PreparedStatement stmt = null;         ResultSet rs = null;          try {              con = getConnection();             stmt = con.prepareStatement(""select image from images"");             rs = stmt.executeQuery();              while (rs.next()) {                  System.out.println(""Getting blob"");                 Blob blob = rs.getBlob(1);                 System.out.println(""Reading image"");                 BufferedImage img = ImageIO.read(blob.getBinaryStream());                 System.out.println(""img = "" + img);                 JOptionPane.showMessageDialog(null, new JScrollPane(new JLabel(new ImageIcon(img))));              }          } finally {             try {                 rs.close();             } catch (Exception e) {             }             try {                 stmt.close();             } catch (Exception e) {             }             try {                 con.close();             } catch (Exception e) {             }         }      }  }"
"import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; /**  * Creates a JSONARRAY from an java.sql.ResultSet.  * @author Aries  *  */ public class SQL2JSON  {      public static JSONArray convert(ResultSet rs) throws SQLException, JSONException           {             JSONArray json = new JSONArray();             ResultSetMetaData rsmd = rs.getMetaData();             rs.beforeFirst();             while(rs.next()) {                   int numColumns = rsmd.getColumnCount();                   JSONObject obj = new JSONObject();                    for(int i=1; i&lt;numColumns+1; i++) {                      String column_name = rsmd.getColumnLabel(i);  //Bugfix , works better than getColumnName() /Aries                       switch( rsmd.getColumnType( i ) ) {                       case java.sql.Types.ARRAY:                         obj.put(column_name, rs.getArray(column_name));     break;                       case java.sql.Types.BIGINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.BOOLEAN:                         obj.put(column_name, rs.getBoolean(column_name));   break;                       case java.sql.Types.BLOB:                         obj.put(column_name, rs.getBlob(column_name));      break;                       case java.sql.Types.DOUBLE:                         obj.put(column_name, rs.getDouble(column_name));    break;                       case java.sql.Types.FLOAT:                         obj.put(column_name, rs.getFloat(column_name));     break;                       case java.sql.Types.INTEGER:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.NVARCHAR:                         obj.put(column_name, rs.getNString(column_name));   break;                       case java.sql.Types.VARCHAR:                         obj.put(column_name, rs.getString(column_name));    break;                       case java.sql.Types.TINYINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.SMALLINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.DATE:                         obj.put(column_name, SQL2JSON.convertDateToString(rs.getDate(column_name)));      break;                       case java.sql.Types.TIMESTAMP:                         obj.put(column_name, SQL2JSON.convertDateToString(rs.getTimestamp(column_name))); break;                       default:                         obj.put(column_name, rs.getObject(column_name));    break;                     }                   }                    json.put(obj);                 }              return json;           } }"
"JNIEnv * env; jclass loadedJavaClass; jmethodID loadedJavaMethod;  //assume JVM, class, and method are already loaded at this point.  //Get c string from std::string object pointer const char * c_string = ((std::string*) pPin-&gt;GetUserData())-&gt;c_str();  //Create jstring from string jstring stuff = env-&gt;NewStringUTF( c_string );  //pass jstring to Java function env-&gt;CallStaticVoidMethod( loadedJavaClass, loadedJavaMethod, stuff );  //remove local reference to jstring JavaEnvironment::getEnvironment()-&gt;DeleteLocalRef(stuff);"
"import java.sql.Connection; import java.sql.ResultSet; import javafx.application.Application; import javafx.beans.property.SimpleStringProperty; import javafx.beans.value.ObservableValue; import javafx.collections.FXCollections; import javafx.collections.ObservableList; import javafx.scene.Scene; import javafx.scene.control.TableColumn; import javafx.scene.control.TableColumn.CellDataFeatures; import javafx.scene.control.TableView; import javafx.stage.Stage; import javafx.util.Callback;  /**  *   * @author Narayan  */  public class DynamicTable extends Application{      //TABLE VIEW AND DATA     private ObservableList&lt;ObservableList&gt; data;     private TableView tableview;      //MAIN EXECUTOR     public static void main(String[] args) {         launch(args);     }      //CONNECTION DATABASE     public void buildData(){           Connection c ;           data = FXCollections.observableArrayList();           try{             c = DBConnect.connect();             //SQL FOR SELECTING ALL OF CUSTOMER             String SQL = ""SELECT * from CUSTOMer"";             //ResultSet             ResultSet rs = c.createStatement().executeQuery(SQL);              /**********************************              * TABLE COLUMN ADDED DYNAMICALLY *              **********************************/             for(int i=0 ; i&lt;rs.getMetaData().getColumnCount(); i++){                 //We are using non property style for making dynamic table                 final int j = i;                                 TableColumn col = new TableColumn(rs.getMetaData().getColumnName(i+1));                 col.setCellValueFactory(new Callback&lt;CellDataFeatures&lt;ObservableList,String&gt;,ObservableValue&lt;String&gt;&gt;(){                                         public ObservableValue&lt;String&gt; call(CellDataFeatures&lt;ObservableList, String&gt; param) {                                                                                                                       return new SimpleStringProperty(param.getValue().get(j).toString());                                             }                                     });                  tableview.getColumns().addAll(col);                  System.out.println(""Column [""+i+""] "");             }              /********************************              * Data added to ObservableList *              ********************************/             while(rs.next()){                 //Iterate Row                 ObservableList&lt;String&gt; row = FXCollections.observableArrayList();                 for(int i=1 ; i&lt;=rs.getMetaData().getColumnCount(); i++){                     //Iterate Column                     row.add(rs.getString(i));                 }                 System.out.println(""Row [1] added ""+row );                 data.add(row);              }              //FINALLY ADDED TO TableView             tableview.setItems(data);           }catch(Exception e){               e.printStackTrace();               System.out.println(""Error on Building Data"");                        }       }         @Override       public void start(Stage stage) throws Exception {         //TableView         tableview = new TableView();         buildData();          //Main Scene         Scene scene = new Scene(tableview);                  stage.setScene(scene);         stage.show();       } }"
"import javax.swing.*; import javax.swing.table.*; import java.awt.*; import java.util.*;  public class TextAreaRenderer extends JTextArea implements TableCellRenderer {      private final DefaultTableCellRenderer adaptee = new DefaultTableCellRenderer();     /** map from table to map of rows to map of column heights */     private final Map cellSizes = new HashMap();       public TextAreaRenderer() {         setLineWrap(true);         setWrapStyleWord(true);     }      public Component getTableCellRendererComponent(             JTable table, Object obj, boolean isSelected,             boolean hasFocus, int row, int column) {          // set the colours, etc. using the standard for that platform         adaptee.getTableCellRendererComponent(table, obj,                 isSelected, hasFocus, row, column);         setForeground(adaptee.getForeground());         setBackground(adaptee.getBackground());         setBorder(adaptee.getBorder());         setFont(adaptee.getFont());         setText(adaptee.getText());           // This line was very important to get it working with JDK1.4         TableColumnModel columnModel = table.getColumnModel();         setSize(columnModel.getColumn(column).getWidth(), 100000);         int height_wanted = (int) getPreferredSize().getHeight();         addSize(table, row, column, height_wanted);         height_wanted = findTotalMaximumRowSize(table, row);         if (height_wanted != table.getRowHeight(row)) {             table.setRowHeight(row, height_wanted);         }         return this;     }      @SuppressWarnings(""unchecked"")     private void addSize(JTable table, int row, int column, int height) {         Map rows = (Map) cellSizes.get(table);         if (rows == null) {             cellSizes.put(table, rows = new HashMap());         }         Map rowheights = (Map) rows.get(new Integer(row));         if (rowheights == null) {             rows.put(new Integer(row), rowheights = new HashMap());         }         rowheights.put(new Integer(column), new Integer(height));     }      /**      * Look through all columns and get the renderer.  If it is      * also a TextAreaRenderer, we look at the maximum height in      * its hash table for this row.      */     private int findTotalMaximumRowSize(JTable table, int row) {         int maximum_height = 0;         Enumeration columns = table.getColumnModel().getColumns();         while (columns.hasMoreElements()) {             TableColumn tc = (TableColumn) columns.nextElement();             TableCellRenderer cellRenderer = tc.getCellRenderer();             if (cellRenderer instanceof TextAreaRenderer) {                 TextAreaRenderer tar = (TextAreaRenderer) cellRenderer;                 maximum_height = Math.max(maximum_height,                         tar.findMaximumRowSize(table, row));             }         }         return maximum_height;     }      private int findMaximumRowSize(JTable table, int row) {         Map rows = (Map) cellSizes.get(table);         if (rows == null) {             return 0;         }         Map rowheights = (Map) rows.get(new Integer(row));         if (rowheights == null) {             return 0;         }         int maximum_height = 0;         for (Iterator it = rowheights.entrySet().iterator();                 it.hasNext();) {             Map.Entry entry = (Map.Entry) it.next();             int cellHeight = ((Integer) entry.getValue()).intValue();             maximum_height = Math.max(maximum_height, cellHeight);         }         return maximum_height;     } }"
"import java.util.Hashtable; import java.util.Set; import java.util.concurrent.CopyOnWriteArrayList;  public class Threadexample {      // Hashtable and Keylist     private Hashtable&lt;String, Integer&gt; table;     private CopyOnWriteArrayList&lt;String&gt; keys;      // Konstruktor     public Threadexample() {         table = new Hashtable&lt;String, Integer&gt;();         keys = new CopyOnWriteArrayList&lt;String&gt;();     }      // Adds an Item to the Table and prints the table     public synchronized void addItem(String key, int value, String threadname) {         // Adding         table.put(key, value);         if (!isAlreadyAdded(key)) {             keys.add(key);         }else{         return;         }         System.out.println(threadname + ""-&gt; Added! Key: "" + key + "" Value: "" + value);         // Showing         showItems(threadname);     }      // Bewares of doublicate keys in the keylist     private boolean isAlreadyAdded(String key) {         int size = keys.size();         for (int i = 0; i &lt; size; i++) {             if (keys.get(i).equals(key)) {                 return true;             }         }         return false;     }      // Prints out all Integer with their keys     private void showItems(String threadname) {         Set&lt;String&gt; keys = table.keySet();         for (String key : keys) {             System.out.println(threadname + ""-&gt; Key: "" + key + ""   Value: "" + table.get(key));         }         System.out.print(System.getProperty(""line.separator""));     }      // Mainmethod     public static void main(String[] args) {         final Threadexample tex = new Threadexample();         final String[] keyarray = new String[] { ""Zero"", ""One"", ""Two"" };          // starts 3 Threads which are adding and showing the Objects         for (int i = 0; i &lt; 3; i++) {             final int value = i;              new Thread() {                 public void run() {                     setName(""Thread: "" + (value + 1));                     tex.addItem(keyarray[value], value, getName());                 }             }.start();              try {                 // Leave every Thread enough time to work                 Thread.sleep(10);             } catch (InterruptedException e) {             }         }      } }"
"import com.sun.javafx.scene.control.skin.TableViewSkin; import javafx.scene.control.Skin; import javafx.scene.control.TableColumn; import javafx.scene.control.TableView; import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method;  public class GUIUtils {     private static Method columnToFitMethod;      static {         try {             columnToFitMethod = TableViewSkin.class.getDeclaredMethod(""resizeColumnToFitContent"", TableColumn.class, int.class);             columnToFitMethod.setAccessible(true);         } catch (NoSuchMethodException e) {             e.printStackTrace();         }     }      public static void autoFitTable(TableView tableView) {         tableView.getItems().addListener(new ListChangeListener&lt;Object&gt;() {             @Override             public void onChanged(Change&lt;?&gt; c) {                 for (Object column : tableView.getColumns()) {                     try {                         columnToFitMethod.invoke(tableView.getSkin(), column, -1);                     } catch (IllegalAccessException | InvocationTargetException e) {                         e.printStackTrace();                     }                 }             }         });     } }"
"import java.io.File; import java.io.FileInputStream; import java.math.BigDecimal; import java.net.URI; import java.util.Date; import java.util.List;  import org.codehaus.jackson.JsonNode; import org.codehaus.jackson.annotate.JsonAutoDetect.Visibility; import org.codehaus.jackson.annotate.JsonProperty; import org.codehaus.jackson.map.MapperConfig; import org.codehaus.jackson.map.ObjectMapper; import org.codehaus.jackson.map.PropertyNamingStrategy; import org.codehaus.jackson.map.introspect.AnnotatedField; import org.codehaus.jackson.map.introspect.AnnotatedMethod;  public class Foo {   public static void main(String[] args) throws Exception   {     ObjectMapper mapper = new ObjectMapper();     mapper.setPropertyNamingStrategy(new CamelCaseToLowerCaseWithUnderscoresNamingStrategy());     mapper.setVisibilityChecker(mapper.getVisibilityChecker().withFieldVisibility(Visibility.ANY));      Response response = mapper.readValue(new File(""input.json""), Response.class);     String json = mapper.writeValueAsString(response);     System.out.println(json);      // Check for correctness     JsonNode originalInput = mapper.readTree(new FileInputStream(""input.json"")); // next release of Jackson will have readTree that just takes a File object reference     JsonNode generatedOutput = mapper.readTree(json);     System.out.println(""Are they the same?"");     System.out.println(originalInput.equals(generatedOutput) ? ""yes"" : ""no"");   } }  class Response {   @JsonProperty(""NOTICE"")   String notice;   List&lt;Link&gt; links;   int nlinksAvail;   BigDecimal nlinksEstTotal;   BigDecimal toRank10; }  class Link {   boolean anchorHasImg;   String anchorText;   boolean exclude;   boolean follow;   BigDecimal fromHostRank10;   String fromIp;   Geo fromIpGeo;   Date fromPubdate;   BigDecimal fromRank10;   String fromTitle;   URI fromUrl;   int toHttpStatus;   BigDecimal toRank10;   URI toRedir;   String toTitle;   URI toUrl; }  class Geo {   String city;   String countryCode;   String ispOrg;   String latitude;   String longitude;   State state;   String zip; }  enum State {   MA, MN, NJ }  class CamelCaseToLowerCaseWithUnderscoresNamingStrategy extends PropertyNamingStrategy {   @Override     public String nameForGetterMethod(MapperConfig&lt;?&gt; config,         AnnotatedMethod method, String defaultName)     {       return translate(defaultName);     }      @Override     public String nameForSetterMethod(MapperConfig&lt;?&gt; config,         AnnotatedMethod method, String defaultName)     {       return translate(defaultName);     }      @Override     public String nameForField(MapperConfig&lt;?&gt; config,         AnnotatedField field, String defaultName)     {       return translate(defaultName);     }      private String translate(String defaultName)     {       char[] nameChars = defaultName.toCharArray();       StringBuilder nameTranslated =           new StringBuilder(nameChars.length * 2);       for (char c : nameChars)       {         if (Character.isUpperCase(c))         {           nameTranslated.append(""_"");           c = Character.toLowerCase(c);         }         nameTranslated.append(c);       }       return nameTranslated.toString();     } }"
"char *concatenated; const jbyte *sx; jstring retval;  /* Get the UTF-8 characters that represent our java string */ sx = (*env)-&gt;GetStringUTFChars(env, s, NULL);  /* Concatenate the two strings. */ concatenated = malloc(strlen(""asd "") + strlen(sx) + 1); strcpy(concatenated, ""asd ""); strcat(concatenated, sx);  /* Create java string from our concatenated C string */ retval = (*env)-&gt;NewStringUTF(env, concatenated);  /* Free the memory in sx */ (*env)-&gt;ReleaseStringUTFChars(env, s, sx);  /* Free the memory in concatenated */ free(concatenated);  return retval;"
"import java.io.*; import java.util.*; import java.text.*; import java.lang.*;   import org.hyperic.sigar.Mem; import org.hyperic.sigar.Sigar; import org.hyperic.sigar.SigarException;  public class MemExample {      private static Sigar sigar = new Sigar();      public static void getInformationsAboutMemory() {         System.out.println(""**************************************"");         System.out.println(""*** Informations about the Memory: ***"");         System.out.println(""**************************************\n"");          Mem mem = null;         try {             mem = sigar.getMem();         } catch (SigarException se) {             se.printStackTrace();         }          System.out.println(""Actual total free system memory: ""                 + mem.getActualFree() / 1024 / 1024+ "" MB"");         System.out.println(""Actual total used system memory: ""                 + mem.getActualUsed() / 1024 / 1024 + "" MB"");         System.out.println(""Total free system memory ......: "" + mem.getFree()                 / 1024 / 1024+ "" MB"");         System.out.println(""System Random Access Memory....: "" + mem.getRam()                 + "" MB"");         System.out.println(""Total system memory............: "" + mem.getTotal()                 / 1024 / 1024+ "" MB"");         System.out.println(""Total used system memory.......: "" + mem.getUsed()                 / 1024 / 1024+ "" MB"");          System.out.println(""\n**************************************\n"");       }      public static void main(String[] args) throws Exception{                  getInformationsAboutMemory();                  }  }"
"import java.io.*; import java.sql.*;  public class CountRows{     public static void main(String[] args) {         System.out.println(""Count number of rows in a specific table!"");         Connection con = null;         int count = 0;         try {             Class.forName(""com.mysql.jdbc.Driver"");             con = DriverManager.getConnection(""jdbc:mysql://localhost:3306/jdbctutorial"",""root"",""root"");             try {                 Statement st = con.createStatement();                 BufferedReader bf = new BufferedReader(new InputStreamReader(System.in));                 System.out.println(""Enter table name:"");                 String table = bf.readLine();                 ResultSet res = st.executeQuery(""SELECT COUNT(*) FROM ""+table);                 while (res.next()){                     count = res.getInt(1);                 }                 System.out.println(""Number of row:""+count);             }             catch (SQLException s){                 System.out.println(""SQL statement is not executed!"");             }         }         catch (Exception e){             e.printStackTrace();         }     } }"
"import java.awt.Toolkit; import java.awt.datatransfer.Clipboard; import java.awt.datatransfer.ClipboardOwner; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.StringSelection; import java.awt.datatransfer.Transferable;  import com.sun.jna.Native; import com.sun.jna.platform.win32.User32; import com.sun.jna.platform.win32.WinDef.HWND; import com.sun.jna.win32.StdCallLibrary;  public class Foo implements ClipboardOwner {     public interface CustomUser32 extends StdCallLibrary {         CustomUser32 INSTANCE = (CustomUser32) Native.loadLibrary(""user32"", CustomUser32.class);         HWND GetForegroundWindow();         void keybd_event(byte bVk, byte bScan, int dwFlags, int dwExtraInfo);     }      public void lostOwnership(Clipboard clipboard, Transferable contents) {         // dummy: needed for `ClipboardOwner`     }      void controlC(CustomUser32 customUser32) {         customUser32.keybd_event((byte) 0x11 /* VK_CONTROL*/, (byte) 0, 0, 0);         customUser32.keybd_event((byte) 0x43 /* 'C' */, (byte) 0, 0, 0);         customUser32.keybd_event((byte) 0x43 /* 'C' */, (byte) 0, 2 /* KEYEVENTF_KEYUP */, 0);         customUser32.keybd_event((byte) 0x11 /* VK_CONTROL*/, (byte) 0, 2 /* KEYEVENTF_KEYUP */, 0);// 'Left Control Up     }      String getClipboardText() throws Exception {         return (String) Toolkit.getDefaultToolkit().getSystemClipboard().getData(DataFlavor.stringFlavor);     }      void setClipboardText(String data) throws Exception {         Toolkit.getDefaultToolkit().getSystemClipboard().setContents(new StringSelection(data), this);     }      String getSelectedText(User32 user32, CustomUser32 customUser32) throws Exception {         HWND hwnd = customUser32.GetForegroundWindow();         char[] windowText = new char[512];         user32.GetWindowText(hwnd, windowText, 512);         String windowTitle = Native.toString(windowText);         System.out.println(""Will take selected text from the following window: ["" + windowTitle + ""]"");         String before = getClipboardText();         controlC(customUser32); // emulate Ctrl C         Thread.sleep(100); // give it some time         String text = getClipboardText();         System.out.println(""Currently in clipboard: "" + text);         // restore what was previously in the clipboard         setClipboardText(before);         return text;     }      public static void main(String[] args) throws Exception {         Foo foo = new Foo();         Thread.sleep(2000); // take some time for you to select something anywhere         System.out.println(foo.getSelectedText(User32.INSTANCE, CustomUser32.INSTANCE));     } }"
"create or replace type stringArray is table of varchar2(4000); / CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED Parser AS import java.sql.Connection; import oracle.jdbc.OracleDriver; import oracle.jdbc.OracleConnection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Array;  public class Parser {      public static Array parseToArray(String str, String delim) throws SQLException {         OracleDriver ora = new oracle.jdbc.OracleDriver();         Connection conn = ora.defaultConnection();         OracleConnection oraConn = (OracleConnection)conn;         Array arr = oraConn.createARRAY(""STRINGARRAY"", str.split(delim));         return arr;     } } / CREATE OR REPLACE FUNCTION PARSETOARRAY (str IN VARCHAR2, delim IN VARCHAR2)  RETURN STRINGARRAY AS LANGUAGE JAVA NAME 'Parser.parseToArray (java.lang.String, java.lang.String) return java.sql.Array'; / DECLARE v_array STRINGARRAY; BEGIN   FOR testing IN (SELECT record FROM interfacelog) LOOP     v_array := PARSETOARRAY(testing.record, '|');    END LOOP; END;"
"import com.sun.jna.Library; import com.sun.jna.Native; import com.sun.jna.NativeLong; import com.sun.jna.Platform; import com.sun.jna.Structure;  /** Simple example of JNA interface mapping and usage. */ public class HelloJNAWorld {      // This is the standard, stable way of mapping, which supports extensive     // customization and mapping of Java to native types.      public interface CLibrary extends Library {         CLibrary INSTANCE = (CLibrary)         Native.loadLibrary((Platform.isWindows() ? ""msvcrt"" : ""c""),CLibrary.class);           void printf(String format, Object... args);       }      public interface IPCLibrary extends Library {         IPCLibrary INSTANCE = (IPCLibrary)                    Native.loadLibrary(""c"",IPCLibrary.class);            class WaitQueue extends Structure{          }           // mapping msqid_ds structure         class MsqidDs extends Structure{             long msg_stime;       /* last msgsnd time */             long msg_rtime;       /* last msgrcv time */             long msg_ctime;       /* last change time */             short msg_cbytes;             short msg_qnum;             short msg_qbytes;      /* max number of bytes on queue */             short msg_lspid;       /* pid of last msgsnd */             short msg_lrpid;       /* last receive pid */         }          // END mapping msqid_ds structure          class MsgBuf extends Structure{             NativeLong mtype; /* type of message */             byte mtext[] = new byte[1];         }           class MyMsgBuf extends MsgBuf{             public NativeLong messageKind;             public byte[] contenido = new byte[1024];         }          // Initialize queue, or if it exists, get it                     int msgget(NativeLong key, int msgflg);         // Send messages to queue         // int msgsnd(int msqid, struct msgbuf *ptrkey, int length, int flag);         int msgsnd(int msqid, MsgBuf ptrkey, int msgsz, int msgflg);         // Receive messages from queue         // int msgrcv(int msqid, struct msgbuf *ptrkey, int length, long msgtype, int flag);         int msgrcv(int msqid, MsgBuf ptrkey, int length, long msgtype, int flag);                  }      public static void main(String[] args) {          int idCola = IPCLibrary.INSTANCE.msgget(new NativeLong(12500), 0);                      if(idCola&lt;0){             System.out.println(""The queue can't be created. IdCola:""+idCola);                        System.out.println(""Error msgget: "" + Native.getLastError());         }else{             System.out.println(""Queue with id:"" + idCola + ""has been recovered"");                        // Send message             IPCLibrary.MyMsgBuf mensaje = new IPCLibrary.MyMsgBuf();             mensaje.tipoMensaje = new NativeLong(1);             mensaje.contenido = ""Sending message"".getBytes();             int devSend = IPCLibrary.INSTANCE.msgsnd(idCola, mensaje, mensaje.contenido.length, 1);             if(devSend != 0){                 System.out.println(""Send response: ""+devSend);                 System.out.println(""Error value: "" + Native.getLastError());             }         }          // Receiving message         IPCLibrary.MyMsgBuf mensajeRecibido =  new IPCLibrary.MyMsgBuf();                 int bytesRecibidos = IPCLibrary.INSTANCE.msgrcv(idCola, mensajeRecibido, mensajeRecibido.contenido.length, 1234, 0);         if(bytesRecibidos &gt; 0){             System.out.println(""C message has been received: "" + new String(mensajeRecibido.contenido));         }else{             System.out.println(""msgrcv error: "" + Native.getLastError());         }           // Send closing message         IPCLibrary.MyMsgBuf mensajeCierre = new IPCLibrary.MyMsgBuf();         mensajeCierre.tipoMensaje = new NativeLong(2);         mensajeCierre.contenido = ""Closing queue"".getBytes();         int devSend = IPCLibrary.INSTANCE.msgsnd(idCola, mensajeCierre, mensajeCierre.contenido.length, 1);         if(devSend != 0){             System.out.println(""Send response: ""+devSend);             System.out.println(""Error value: "" + Native.getLastError());         }                  } }"
"import java.io.File; import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList; import java.util.Iterator;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.apache.poi.hssf.usermodel.HSSFCell; import org.apache.poi.hssf.usermodel.HSSFRichTextString; import org.apache.poi.hssf.usermodel.HSSFRow; import org.apache.poi.hssf.usermodel.HSSFSheet; import org.apache.poi.hssf.usermodel.HSSFWorkbook; import org.apache.poi.poifs.filesystem.POIFSFileSystem; import org.w3c.dom.Document; import org.w3c.dom.Element;  public class POIExcelReader {  public POIExcelReader (){ }  public void displayFromExcel (String xlsPath) {     InputStream inputStream = null;      try     {         inputStream = new FileInputStream (xlsPath);     }     catch (FileNotFoundException e)     {         System.out.println (""File not found in the specified path."");         e.printStackTrace ();     }      POIFSFileSystem fileSystem = null;      try {         //Initializing the XML document         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();         DocumentBuilder builder = factory.newDocumentBuilder();         Document document = builder.newDocument();         Element rootElement = document.createElement(""products"");         document.appendChild(rootElement);           fileSystem = new POIFSFileSystem (inputStream);         HSSFWorkbook      workBook = new HSSFWorkbook (fileSystem);         HSSFSheet         sheet    = workBook.getSheetAt (0);          Iterator&lt;?&gt; rows     = sheet.rowIterator ();          ArrayList&lt;ArrayList&lt;String&gt;&gt; data = new ArrayList&lt;ArrayList&lt;String&gt;&gt;();         while (rows.hasNext ())          {             HSSFRow row = (HSSFRow) rows.next();               int rowNumber = row.getRowNum ();             // display row number             System.out.println (""Row No.: "" + rowNumber);              // get a row, iterate through cells.             Iterator&lt;?&gt; cells = row.cellIterator ();               ArrayList&lt;String&gt; rowData = new ArrayList&lt;String&gt;();             while (cells.hasNext ())             {                 HSSFCell cell = (HSSFCell) cells.next ();                 //System.out.println (""Cell : "" + cell.getCellNum ());                 switch (cell.getCellType ())                 {                 case HSSFCell.CELL_TYPE_NUMERIC :                 {                     // NUMERIC CELL TYPE                     System.out.println (""Numeric: "" + cell.getNumericCellValue ());                     rowData.add(cell.getNumericCellValue () + """");                     break;                 }                 case HSSFCell.CELL_TYPE_STRING :                  {                     // STRING CELL TYPE                     HSSFRichTextString richTextString = cell.getRichStringCellValue ();                      System.out.println (""String: "" + richTextString.getString ());                     rowData.add(richTextString.getString ());                     break;                 }                 default:                 {                     // types other than String and Numeric.                     System.out.println (""Type not supported."");                     break;                 }                 } // end switch              } // end while             data.add(rowData);           } //end while          int numOfProduct = data.size();          for (int i = 1; i &lt; numOfProduct; i++){             Element productElement = document.createElement(""product"");             rootElement.appendChild(productElement);              int index = 0;             for(String s: data.get(i)) {                 String headerString = data.get(0).get(index);                 if( data.get(0).get(index).equals(""image link"") ){                     headerString = ""image_link"";                 }                  if( data.get(0).get(index).equals(""product type"") ){                     headerString = ""product_type"";                 }                  Element headerElement = document.createElement(headerString);                 productElement.appendChild(headerElement);                 headerElement.appendChild(document.createTextNode(s));                 index++;             }         }          TransformerFactory tFactory = TransformerFactory.newInstance();          Transformer transformer = tFactory.newTransformer();         //Add indentation to output         transformer.setOutputProperty         (OutputKeys.INDENT, ""yes"");         transformer.setOutputProperty(                 ""{http://xml.apache.org/xslt}indent-amount"", ""2"");          DOMSource source = new DOMSource(document);         StreamResult result = new StreamResult(new File(""products.xml""));         //StreamResult result = new StreamResult(System.out);         transformer.transform(source, result);      }     catch(IOException e)     {         System.out.println(""IOException "" + e.getMessage());     } catch (ParserConfigurationException e) {         System.out.println(""ParserConfigurationException "" + e.getMessage());     } catch (TransformerConfigurationException e) {         System.out.println(""TransformerConfigurationException ""+ e.getMessage());     } catch (TransformerException e) {         System.out.println(""TransformerException "" + e.getMessage());     } }   public static void main (String[] args) {     POIExcelReader poiExample = new POIExcelReader ();     String xlsPath =""products.xls"";     poiExample.displayFromExcel (xlsPath); } }"
