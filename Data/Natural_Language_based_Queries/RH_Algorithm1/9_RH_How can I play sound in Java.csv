code
"private static final Pattern COMMA_PATTERN = Pattern.compile(""\\s*,\\s*"");  public List&lt;Integer&gt; getIntegerList() {     // Assumes scanner is positioned at first integer in list.     List&lt;Integer&gt; integers = new ArrayList&lt;Integer&gt;();     for (;;) {         integers.add(scanner.nextInt());         if (scanner.hasNext(COMMA_PATTERN)) {             // Read and discard comma token, and continue parsing list.             scanner.next();         } else {             // Number is not followed by comma, stop parsing.             break;         }     }     return integers; }"
"Map map = new HashMap();         map.put(""1"",new Integer(1));         map.put(""2"",new Integer(2));         map.put(""3"",new Integer(3));         FileOutputStream fos = new FileOutputStream(""map.ser"");         ObjectOutputStream oos = new ObjectOutputStream(fos);         oos.writeObject(map);         oos.close();          FileInputStream fis = new FileInputStream(""map.ser"");         ObjectInputStream ois = new ObjectInputStream(fis);         Map anotherMap = (Map) ois.readObject();         ois.close();          System.out.println(anotherMap);"
package egPriv;  import java.io.FileReader; import java.io.IOException; import java.io.Reader; import java.security.AccessController; import java.security.PrivilegedActionException; import java.security.PrivilegedExceptionAction;  public class PrivCat {     /** Cat a file with no privileges */     public void cat(String file) throws IOException {         cat(new FileReader(file));     }      private void cat(Reader r) throws IOException {         int c;         while( (c = r.read()) != -1 ) {             System.out.print((char) c);         }         r.close();     }      /** Cat a file WITH privileges */     public void catPriv(final String file) throws IOException {         Reader r;         try {             r = AccessController.doPrivileged(new PrivilegedExceptionAction&lt;Reader&gt;() {                 public Reader run() throws IOException {                     return new FileReader(file);                 }             });         } catch (PrivilegedActionException e) {             throw (IOException) e.getCause();         }         cat(r);     } }
theSize++;             AnyType[] newItems = new AnyType[theSize];             for(int i = 0; i &lt; theSize-1; i++)                 if(items[i].compareTo(x) &gt; 0)                 {                     newItems[i] = x;                     newItems[i + 1] = items[i];                     for(int j = i + 2; j &lt; theSize; j++)                         newItems[j] = items[j-1];                     items = newItems;                     return true;                 }                 else                     newItems[i] = items[i];             newItems[theSize-1] = x;             items = newItems;             return true;
"Have state-setting operations on Subject call Notify after they change the  subject's state. The advantage of this approach is that clients don't have  to remember to call Notify on the subject. The disadvantage is that several consecutive operations will cause several consecutive updates, which may be inefficient.  Make clients responsible for calling Notify at the right time. The advantage  here is that the client can wait to trigger the update until after a series  of state changes has been made, thereby avoiding needless intermediate updates. The disadvantage is that clients have an added responsibility to trigger the  update. That makes errors more likely, since clients might forget to call Notify."
static boolean check(int n)    {            if(n&lt;30)            {               return n==2 || n==3 || n==5 || n==7 || ...            }             for(int i = 30; i * i &lt;= n; i += 30)            {               if (n % (i + 1))==0 return false;               if (n % (i + 7))==0 return false;               if (n % (i + 11))==0 return false;               if (n % (i + 13))==0 return false;               if (n % (i + 17))==0 return false;               if (n % (i + 19))==0 return false;               if (n % (i + 23))==0 return false;               if (n % (i + 29))==0 return false;            }            return true;    }
"private final Object[] objects = new Object[5]; private final boolean[] referenced = new boolean[objects.length]; private int clock = 0;  public Object getOrCache(Object obj) {     for (int i = 0, objectsLength = objects.length; i &lt; objectsLength; i++) {         Object o = objects[i];         if (obj.equals(o)) {             referenced[i] = true;             return obj;         }     }     while(referenced[clock]) {         referenced[clock] = false;         incrClock();     }     objects[clock] = obj;     incrClock();     return obj; }  private void incrClock() {     if (++clock &gt;= objects.length)         clock = 0; }"
"public Boolean readFile (){ //Fix tomorrow     while( input.hasNext () ) {        char x =           input.next().charAt(0); // get the char        System.out.println(""char obtained: ""+x);         String line =      input.nextLine().trim();        Scanner stat =     new Scanner(line).useDelimiter(""\\s*:\\s*"")         while ( stat.hasNext() ) {           if (stat.hasNext("""")||stat.hasNext(Pattern.compile(""/.*""))) continue;           // above line is equivalent to:           // if( token.length()== 0 || token.charAt(0) == '/' ) continue;           // but is better because does not consume a token           switch ( x ) {               case 'c' :                   int a =         stat.nextInt(); // 20002                   String b =      stat.next(); // ""The Dragon""                   System.out.println(""b obtained: ""+b);                   // some options here:                   // - add a line for each expected var like:                   String b2 =      stat.next(); // ""Dreama""                   String i =      stat.nextInt(); // 10000                   String j =      stat.nextInt(); // 1                   // ...                    // OR: - iterate through the remaining tokens and do something                   // while (stat.hasNext()) { System.out.println(stat.next()); }                    // OR: - get an array of the remaining tokens using split():                   // String[] restOfLine = stat.nextLine().split(""\\s*:\\s*"");                   break;               case 't' :                   //..."
"public static final int DATE_PICKER = 1;             public static final int TIME_PICKER = 2;             public static final int DIALOG = 3;              Context mContext;             String mMessage;             boolean finishActivity;             // private Fragment mCurrentFragment;             Activity mActivity;              /**              *  this constructor is used for datepicker &amp; Timepicker              */             public CustomDialogFragment (Fragment fragment ) {             //        mCurrentFragment = fragment;             }              public CustomDialogFragment (Activity mActivity ) {                 this.mActivity = mActivity;         }              /**              *  this constructor is used for simple dialog fragment              */             public CustomDialogFragment(Context context, String message, final boolean finishActivity) {                 mContext = context;                 mMessage = message;                 this.finishActivity = finishActivity;             }                public Dialog onCreateDialog(Bundle savedInstanceState) {                 Bundle bundle = new Bundle();                 bundle = getArguments();                 int id = bundle.getInt(""dialog_id"");                 switch (id) {                 case DATE_PICKER:                     return new DatePickerDialog(getActivity(),                             (OnDateSetListener)mActivity, bundle.getInt(""year""),                             bundle.getInt(""month""), bundle.getInt(""day""));                 case TIME_PICKER:                     return new TimePickerDialog(getActivity(),                             (OnTimeSetListener)mActivity,bundle.getInt(""hour""),                             bundle.getInt(""minute""), true);                 case DIALOG:                    AlertDialog.Builder alertDialogBuilder = new AlertDialog.Builder(mContext);                    alertDialogBuilder.setTitle(R.string.app_name);                    alertDialogBuilder.setMessage(mMessage);                    alertDialogBuilder.setIcon(R.drawable.ic_launcher);                    alertDialogBuilder.setCancelable(false);                    alertDialogBuilder.setPositiveButton(                             getResources().getString(R.string.ok), new DialogInterface.OnClickListener() {                         @Override                        public void onClick(DialogInterface dialog, int arg1) {                             dialog.dismiss();                            if (finishActivity == true) {                                Activity act = (Activity) mContext;                                act.finish();                            }                         }                    });                    alertDialogBuilder.setNegativeButton(getResources().getString(R.string.cancel_btn_title), new DialogInterface.OnClickListener() {                         @Override                        public void onClick(DialogInterface dialog, int which) {                            CustomDialogFragment.this.dismiss();                        }                    });                      return alertDialogBuilder.create();                  }                 //Define your custom dialog or alert dialog here and return it.                return new Dialog(getActivity());             }         }"
"package register_file_pkg is     type register_file_type is array (0 to 31) of integer range 0 to 255;     signal register_file: register_file_type;     alias pc is register_file(31); end; -------------------------------------------------------------------------------- use work.register_file_pkg.all;  entity alu is     port (         clock: in bit;         zero_flag: out boolean;         last_pc_flag: out boolean     ); end;  architecture rtl of alu is begin     zero_flag &lt;= (register_file(0) = 0);     last_pc_flag &lt;= (pc = 255);      process (clock) begin         if clock'event and clock = '1' then             register_file(0) &lt;= pc / 4;         end if;     end process; end; -------------------------------------------------------------------------------- library ieee; use ieee.numeric_bit.all; use work.register_file_pkg.all;  entity cpu is     port (         clock: in bit;         address_bus: out integer;         zero_flag: out boolean;         last_pc_flag: out boolean     ); end;  architecture rtl of cpu is begin     address_bus &lt;= pc;      process (clock) begin         if clock'event and clock = '1' then             pc &lt;= pc + 1;         end if;     end process;      cpu_alu: entity work.alu         port map(             clock =&gt; clock,             zero_flag =&gt; zero_flag,             last_pc_flag =&gt; last_pc_flag         ); end;"
"BufferedImage jpg = ImageIO.read(new File(""myjpg.jpg""));      //Convert the image to a byte array      DataBufferUShort buff = (DataBufferUShort) jpg.getData().getDataBuffer();     short[] data = buff.getData();     ByteBuffer byteBuf = ByteBuffer.allocate(2*data.length);     int i = 0;     while (data.length &gt; i) {         byteBuf.putShort(data[i]);         i++;     }      //Copy a header      DicomInputStream dis = new DicomInputStream(new File(""fileToCopyheaderFrom.dcm""));     Attributes meta = dis.readFileMetaInformation();     Attributes attribs = dis.readDataset(-1, Tag.PixelData);     dis.close();      //Change the rows and columns     attribs.setInt(Tag.Rows, VR.US, jpg.getHeight());     attribs.setInt(Tag.Columns, VR.US, jpg.getWidth());     System.out.println(byteBuf.array().length);     //Attributes attribs = new Attributes();      //Write the file     attribs.setBytes(Tag.PixelData, VR.OW, byteBuf.array());     DicomOutputStream dcmo = new DicomOutputStream(new File(""myDicom.dcm""));     dcmo.writeFileMetaInformation(meta);     attribs.writeTo(dcmo);     dcmo.close();"
"package kieTest;  import java.util.Scanner;  import org.drools.compiler.kproject.ReleaseIdImpl; import org.kie.api.KieServices; import org.kie.api.builder.KieScanner; import org.kie.api.runtime.KieContainer; import org.kie.api.runtime.StatelessKieSession;  public class MainKieTest {      public static void main(String[] args) {          // works even without -SNAPSHOT versions         String url = ""http://localhost:8080/kie-drools/maven2/de/test/Test/1.2.3/Test-1.2.3.jar"";          // make sure you use ""LATEST"" here!         ReleaseIdImpl releaseId = new ReleaseIdImpl(""de.test"", ""Test"", ""LATEST"");          KieServices ks = KieServices.Factory.get();          ks.getResources().newUrlResource(url);          KieContainer kieContainer = ks.newKieContainer(releaseId);          // check every 5 seconds if there is a new version at the URL         KieScanner kieScanner = ks.newKieScanner(kieContainer);         kieScanner.start(5000L);         // alternatively:         // kieScanner.scanNow();          Scanner scanner = new Scanner(System.in);         while (true) {             runRule(kieContainer);             System.out.println(""Press enter in order to run the test again...."");             scanner.nextLine();         }     }      private static void runRule(KieContainer kieKontainer) {         StatelessKieSession kSession = kieKontainer.newStatelessKieSession(""testSession"");         kSession.setGlobal(""out"", System.out);         kSession.execute(""testRuleAgain"");     } }"
"private static final Map&lt;String, Character&gt; codonsMap; static {     codonsMap = new HashMap&lt;String, Character&gt;();     codonsMap.put(""UUU"", 'F');     codonsMap.put(""UUC"", 'F');     codonsMap.put(""UUA"", 'L');     //and so on for all codons }  //be sure that length of temp is a multiple of 3 and that every 3 characters correspond to a valid codon public String translation(String temp) {     //Use StringBuilder for adding Characters, it is by far faster than adding chars to a mutable String     StringBuilder finalreturn = new StringBuilder();     String codon;            for (int i = 0; i &lt; temp.length() - 2; i++) {         codon = temp.substring(i, i+3);         finalreturn.append(codonsMap.get(codon));     }     return finalreturn.toString(); }"
"import org.jboss.seam.contexts.Lifecycle;  @Service public class MyService extends DefaultTimedService implements TimedObject, DefaultServiceInterface {     @Timeout     public void ejbTimeout(Timer timer) {         Lifecycle.beginCall();          MyInterface loader = (MyInterface) Component.getInstance(MyInterface.SEAM_NAME, true);         // will not throw no context!         // also the Component.getInstance(MyInterface.SEAM_NAME, true,true); call         // is another way you could inject that component.           Lifecycle.endCall();     } }"
"DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance(); DocumentBuilder builder = documentBuilderFactory.newDocumentBuilder();  Document tournament = builder.parse(new File(""b.xml"")); Document tournaments = builder.parse(new File(""a.xml""));  Node tournamentElement = tournament.getFirstChild(); Node ndetournament = tournaments.getDocumentElement(); Node firstDocImportedNode = tournaments.adoptNode(tournamentElement); ndetournament.appendChild(firstDocImportedNode);  TransformerFactory transformerFactory = TransformerFactory.newInstance(); Transformer transformer = transformerFactory.newTransformer(); transformer.setOutputProperty(OutputKeys.INDENT, ""yes""); transformer.transform(new DOMSource(tournaments), new StreamResult(System.out));"
"PrintStream psFile = /* Open file */;  final int blockSize = 4;  psFile.println(""%!PS-Adobe-3.0 EPSF-3.0""); psFile.println(""%%BoundingBox: 0 0 "" + bitMatrix.getWidth() * blockSize + "" "" + bitMatrix.getHeight() * blockSize);  psFile.print(""/bits [""); for(int y = 0; y &lt; bitMatrix.getHeight(); ++y) {     for(int x = 0; x &lt; bitMatrix.getWidth(); ++x) {         psFile.print(bitMatrix.get(x, y) ? ""1 "" : ""0 "");     }            } psFile.println(""] def"");  psFile.println(""/width "" + bitMatrix.getWidth() + "" def""); psFile.println(""/height "" + bitMatrix.getHeight() + "" def"");  psFile.println(         ""/y 0 def\n"" +          blockSize + "" "" + blockSize + "" scale\n"" +          ""height {\n"" +         ""   /x 0 def\n"" +         ""   width {\n"" +         ""      bits y width mul x add get 1 eq {\n"" +         ""         newpath\n"" +         ""         x y moveto\n"" +         ""         0 1 rlineto\n"" +         ""         1 0 rlineto\n"" +         ""         0 -1 rlineto\n"" +         ""         closepath\n"" +         ""         fill\n"" +         ""      } if\n"" +         ""      /x x 1 add def\n"" +         ""   } repeat\n"" +         ""   /y y 1 add def\n"" +         ""} repeat\n""); psFile.close();"
"Pattern singleLinecommentsPattern = Pattern.compile(""\\/\\/.*""); Matcher matcher = singleLinecommentsPattern.matcher(content);  while (matcher.find()) {     document.setCharacterAttributes(matcher.start(),        matcher.end() - matcher.start(), textPane.getStyle(""red""), true); }  Pattern multipleLinecommentsPattern = Pattern.compile(""\\/\\*.*?\\*\\/"",                         Pattern.DOTALL); matcher = multipleLinecommentsPattern.matcher(content);  while (matcher.find()) {     document.setCharacterAttributes(matcher.start(),        matcher.end() - matcher.start(), textPane.getStyle(""red""), true); }"
"import java.awt.*; import javax.swing.*;  // TODO don't extend JPanel, just create an instance class TestGui extends JPanel {      JTextField arrivalDateTF;     JTextField departureDateTF;     JTextField roomCategoryTF;     JTextField roomQtyTF;     JButton submitB;      TestGui() {         initComponents();     }      private void initComponents() {         setLayout(new BorderLayout());          arrivalDateTF = new JTextField(6);         departureDateTF = new JTextField(6);         roomCategoryTF = new JTextField(8);         roomQtyTF = new JTextField(2);          JTextField[] textFields = { arrivalDateTF, departureDateTF, roomCategoryTF, roomQtyTF };         JLabel[] textLabels = { new JLabel(""1 : ""), new JLabel(""2 : ""),             new JLabel(""3 : ""), new JLabel(""4 : "")         };          JPanel displayPan = new JPanel();         GridBagLayout gridBagLay = new GridBagLayout();         GridBagConstraints gridBagC = new GridBagConstraints();          displayPan.setLayout(gridBagLay); //      SwingUtilities.addTextElementsAsRows(textLabels, textFields, gridBagLay, displayPan);         for (int ii=0; ii&lt;textFields.length; ii++) {             displayPan.add( textLabels[ii] );             displayPan.add( textFields[ii] );         }          gridBagC.gridwidth = GridBagConstraints.REMAINDER;         gridBagC.anchor = GridBagConstraints.EAST;         gridBagC.weightx = 1.0;          displayPan.add(new JLabel("" ""), gridBagC);          submitB = new JButton(""Soumettre"");         displayPan.add(submitB, gridBagC);  //      SwingUtilities.addStdBorder(displayPan, ""Reservation"");         add(displayPan, BorderLayout.CENTER);     }      public static void main(String[] args){         SwingUtilities.invokeLater(new Runnable() {             public void run() {                 JFrame frame1 = new JFrame(""Hotel Reservation App"");                 frame1.getContentPane().add(new TestGui(), BorderLayout.CENTER);                 frame1.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);                  frame1.pack();                 frame1.setVisible(true);             }         });     } }"
"GraphicsDevice gd = GraphicsEnvironment.getLocalGraphicsEnvironment().getDefaultScreenDevice(); Rectangle bounds = gd.getDefaultConfiguration().getBounds(); Insets insets = Toolkit.getDefaultToolkit().getScreenInsets(gd.getDefaultConfiguration());  Rectangle safeBounds = new Rectangle(bounds); safeBounds.x += insets.left; safeBounds.y += insets.top; safeBounds.width -= (insets.left + insets.right); safeBounds.height -= (insets.top + insets.bottom);  System.out.println(""Bounds = "" + bounds); System.out.println(""SafeBounds = "" + safeBounds);  Area area = new Area(bounds); area.subtract(new Area(safeBounds)); System.out.println(""Area = "" + area.getBounds());"
"DecimalFormat three = new DecimalFormat(""#,##0.000""); // will display numbers separated by commas every three digits to the left of the decimal, and will round it to three decimal places. No more, no less.  // the three zeros after the decimal point above specify how many decimal places to be accurate to. // the zero to the left of the decimal place above makes it so that numbers that start with ""0."" will display ""0."" vs just ""."" If you don't want the ""0."", replace that 0 to the left of the decimal point with ""#"""
"reader.beginArray(); while (reader.hasNext()) {     int position;     int a, b, d; // stores your parsed values     String c; // stores your parsed values     reader.beginArray();      // read and parse first four elements, checking hasNext() each time for robustness     for (position = 0; position &lt; 4 &amp;&amp; reader.hasNext(); ++ position) {         if (position == 0) a = reader.nextInt();          else if (position == 1) b = reader.nextInt();         else if (position == 2) c = reader.nextString();         else if (position == 3) d = reader.nextInt();     }      // if position &lt; 4 then there weren't enough values in array.     if (position == 4) { // correctly read          System.out.println(a + "" "" + b + "" "" + c + "" "" + d);     }     // skip rest of array, regardless of number of values     while (reader.hasNext())         reader.skipValue();     reader.endArray(); }  reader.endArray();"
"str1 = read file1 num1 = parse( str1 ) //parse() should be a method that can properly handle a null  str2 = read file2    //and return something appropriate, like -1, when null  num2 = parse( str2 ) //is encountered  while str1 != null || str2 != null      if str2 == null || num1 &lt; num2         write num1         str1 = read file1         num1 = parse( str1 )     else if str1 == null || num1 &gt; num2         write num2         str2 = read file2         num2 = parse( str2 )     else if num1 == num2         write num1         write num2         str1 = read file1         num1 = parse( str1 )         str2 = read file2         num2 = parse( str2 )"
"Object arr1[] = { ""1"", ""2"", ""3"" };     Object arr2[] = { ""One"", ""Two"", ""Three"" };     Object arr3[] = { ""Red"", ""Blue"", ""Yellow"" };     //make an array of arrays     Object allArr[] = { arr1, arr2, arr3 };     //the new array to store values     Object arr4[][] = new Object[3][3];      for (int i = 0; i &lt; 3; i++) {         for (int j = 0, k = 0; j &lt; 3 &amp;&amp; k &lt; 3; j++, k++) {             //take the first array from array of arrays             Object tmp[] = (Object[]) allArr[k];             //take the ith element of each individual array and store in the new array in correct position              arr4[i][j] = tmp[i];          }     }      //print the new array     for (int i = 0; i &lt; 3; i++) {         for (int j = 0; j &lt; 3; j++) {             System.out.print(arr4[i][j] + "" "");         }         System.out.println();     }"
"HashMap&lt;String, Integer&gt; map = new HashMap&lt;String, Integer&gt;(); map.put(""a"", 4); map.put(""c"", 6); map.put(""b"", 2); Object[] a = map.entrySet().toArray(); Arrays.sort(a, new Comparator() {     public int compare(Object o1, Object o2) {         return ((Map.Entry&lt;String, Integer&gt;) o2).getValue()                    .compareTo(((Map.Entry&lt;String, Integer&gt;) o1).getValue());     } }); for (Object e : a) {     System.out.println(((Map.Entry&lt;String, Integer&gt;) e).getKey() + "" : ""             + ((Map.Entry&lt;String, Integer&gt;) e).getValue()); }"
"public interface DocumentParser&lt;K,V&gt; {       Map&lt;K,V&gt; parse(Document document); }   public class ExcelParser implements DocumentParser&lt;String, String&gt; {      @Override     public Map&lt;String, String&gt; parse(Document document) {         // TODO Auto-generated method stub         return new HashMap&lt;String, String&gt;();     }  }  public SomeOtherParser implements DocumentParser&lt;String, Integer&gt; {      @Override     public Map&lt;String, Integer&gt; parse(Document document) {         // TODO Auto-generated method stub         return new HashMap&lt;String, Integer&gt;();     } }"
"PdfReader reader = new PdfReader(src); // We assume that there's a single large picture on the first page PdfDictionary page = reader.getPageN(1); PdfDictionary resources = page.getAsDict(PdfName.RESOURCES); PdfDictionary xobjects = resources.getAsDict(PdfName.XOBJECT); PdfName imgName = xobjects.getKeys().iterator().next(); Image img = Image.getInstance((PRIndirectReference)xobjects.getAsIndirectObject(imgName)); img.setAbsolutePosition(0, 0); img.scaleAbsolute(reader.getPageSize(1)); PdfStamper stamper = new PdfStamper(reader, new FileOutputStream(dest)); stamper.getOverContent(1).addImage(img); stamper.close(); reader.close();"
"public class DataTask extends AsyncTask&lt;Void, Void, Integer&gt; {      Context context;     DataTask(Context context) {         this.context = context; // &lt;-- you already have a context, you don't need to call getApplicationContext();            }     @Override     protected Integer doInBackground(Void... params) {         doSomeWork();         doSomeOtherWork();         doYetSomeMoreWork();         //...     }      @Override     protected void onPostExecute(Integer result) {         doSomethingWithThe(result);     } }"
