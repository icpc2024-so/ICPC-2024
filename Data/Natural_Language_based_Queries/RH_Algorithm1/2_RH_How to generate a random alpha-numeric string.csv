code
"public static void main(String[] args) {         String number1 = ""108"";         String number2 = ""84"";          char[] n1 = number1.toCharArray();         char[] n2 = number2.toCharArray();          int result = 0;          for (int i = 0; i &lt; n1.length; i++) {             for (int j = 0; j &lt; n2.length; j++) {                 result += (n1[i] - '0') * (n2[j] - '0')                         * (int) Math.pow(10, n1.length + n2.length - (i + j + 2));             }         }         System.out.println(result);     }"
"public class sample {      public String code="""";     ArrayList&lt;String&gt; conlst;      ArrayList&lt;String&gt; actlst;     ArrayList&lt;innerObject&gt; prolst;      public String getCode() {         return code;     }     public void setCode(String code) {         this.code = code;     }     public ArrayList&lt;String&gt; getConlst() {         return conlst;     }     public void setConlst(ArrayList&lt;String&gt; conlst) {         this.conlst = conlst;     }     public ArrayList&lt;String&gt; getActlst() {         return actlst;     }     public void setActlst(ArrayList&lt;String&gt; actlst) {         this.actlst = actlst;     }     public ArrayList&lt;innerObject&gt; getProlst() {         return prolst;     }     public void setProlst(ArrayList&lt;innerObject&gt; prolst) {         this.prolst = prolst;     }  }"
public class S {    private List&lt;Integer&gt; Samples = new List&lt;Integer&gt;();      public void addSample(int x){       Samples.Add(new Integer(x));    }     public void Process(IOp[] operations){       for (Op operation : operations){           Process(operation);       }    }    public void Process(ICollection&lt;IOp&gt; operations){       for (Op operation : operations){           Process(operation);       }    }    public void Process(IOp operation){       operation.Compute(this.Samples);    } }
"public class Multiply {     static int temp = 0;     static int sum = 0;      public static void main(String[] args) {         int x = Integer.parseInt(""11"");         int y = Integer.parseInt(""9"");         int ans = multiply(x, y);         System.out.println(ans);     }      public static int multiply(int x, int y) {         if (x == 1) {             System.out.println(x + "" : "" + y);             return sum + y;         }         if (x % 2 == 0) {             System.out.println(x + "" : "" + y);         } else {             System.out.println(x + "" : "" + y);             sum = sum + y;         }         return multiply(x / 2, y * 2);     } }"
"public class BinarySearch {      public static void main(String[] a) {         int[] numArray = {5,6,10,11,19,18,30,25,88,44,55,1,3};         Arrays.sort(numArray);         // performing a binary search - here 100 is the element that you want              // to search in your array         System.out.println(searchElement(numArray, 100));     }      private static int searchElement(int[] sortedArray, int element) {          int first = 0;         int upto  = sortedArray.length;          while (first &lt; upto) {             int mid = (first + upto) / 2;  // Compute mid point.             if (element &lt; sortedArray[mid]) {                 upto = mid;       // repeat search in bottom half.             } else if (element &gt; sortedArray[mid]) {                 first = mid + 1;  // Repeat search in top half.             } else {                 return sortedArray[mid];       // Found it. You can return the position or the element             }         }         return -1;    // The element is not in the array     } }"
"class OuterClass {      String a = ""A"";     String b = ""B"";     String c = ""C"";      class InnerClass{         int x;         public String getA(){             return a; // access the variable a from outer class         }     }      public static class StaticInnerClass{         int x;     }      public String stringConCat(){         return a + b + c;         } }   public class Test{      public static void main(String args[]) {          OuterClass.StaticInnerClass staticClass = new OuterClass.StaticInnerClass();         OuterClass outer = new OuterClass();         OuterClass.InnerClass inner = outer.new InnerClass();          System.out.println(inner.getA()); // This will print ""A""     } }"
"public static double sin(double x, int n) {     double result = x;     double term = x;     for (int i = 3, n2 = n * 2; i &lt;= n2; i += 2) {         term *= -x * x / ((i - 1) * i);         result += term;     }     return result; }  public static void main(String... args) { /*     for (int i = -20; i &lt;= 20; i++) {         double d = i / 10.0;         System.out.println(Math.sin(d) + "" vs "" + sin(d, 14));     } */     double d = -1.5;     double sin = Math.sin(d);     System.out.println(""Searching for sin("" + d + "") = "" + sin);     for (int n = 2; n &lt;= 14; n++) {         System.out.println(n + "": "" + sin + "" vs "" + sin(d, n) + "" err: "" + (sin(d, n) - sin));     } }"
"public class LCS {      public static void main(String[] args) {         String x = StdIn.readString();         String y = StdIn.readString();         int M = x.length();         int N = y.length();          // opt[i][j] = length of LCS of x[i..M] and y[j..N]         int[][] opt = new int[M+1][N+1];          // compute length of LCS and all subproblems via dynamic programming         for (int i = M-1; i &gt;= 0; i--) {             for (int j = N-1; j &gt;= 0; j--) {                 if (x.charAt(i) == y.charAt(j))                     opt[i][j] = opt[i+1][j+1] + 1;                 else                      opt[i][j] = Math.max(opt[i+1][j], opt[i][j+1]);             }         }          // recover LCS itself and print it to standard output         int i = 0, j = 0;         while(i &lt; M &amp;&amp; j &lt; N) {             if (x.charAt(i) == y.charAt(j)) {                 System.out.print(x.charAt(i));                 i++;                 j++;             }             else if (opt[i+1][j] &gt;= opt[i][j+1]) i++;             else                                 j++;         }         System.out.println();      }  }"
"public int compare(String o1, String o2) {             String s1 = o1.substring(0, 3);             String s2 = o2.substring(0, 3);             if(!s1.equals(s2)) {                 return s1.compareTo(s2);             }             String[] fields1 = o1.substring(3).split(""[^0-9]"", 2);             String[] fields2 = o2.substring(3).split(""[^0-9]"", 2);             int i1 = Integer.parseInt(fields1[0]);             int i2 = Integer.parseInt(fields2[0]);             if(i1 != i2) {                 return i1 - i2;             }             String r1 = """";             if(fields1.length &gt; 1) {                 r1 = fields1[1];             }             String r2 = """";             if(fields2.length &gt; 1) {                 r2 = fields2[1];             }             return r1.compareTo(r2);         }"
"class Test {     public Test(final int a, final int b) {         this.a = a;         this.b = b;     }      public int a;     public int b; }  public class Main {      public static void main(String[] args) throws Exception {         List&lt;Test&gt; values = new ArrayList&lt;Test&gt;(2);         values.add(new Test(1, 2));         values.add(new Test(3, 4));          List&lt;Test&gt; readOnly = Collections.unmodifiableList(values);         for (Test t : readOnly) {             t.a = 5;         }          for (Test t : values) {             System.out.println(t.a);         }     }  }"
"private static DecimalFormat oneDecimal = new DecimalFormat(&quot;0.0&quot;);    /**    * Given an integer, return a string that is in an approximate, but human     * readable format.     * It uses the bases 'k', 'm', and 'g' for 1024, 1024**2, and 1024**3.    * @param number the number to format    * @return a human readable form of the integer    */   public static String humanReadableInt(long number) {     long absNumber = Math.abs(number);     double result = number;     String suffix = &quot;&quot;;     if (absNumber &lt; 1024) {       // nothing     } else if (absNumber &lt; 1024 * 1024) {       result = number / 1024.0;       suffix = &quot;k&quot;;     } else if (absNumber &lt; 1024 * 1024 * 1024) {       result = number / (1024.0 * 1024);       suffix = &quot;m&quot;;     } else {       result = number / (1024.0 * 1024 * 1024);       suffix = &quot;g&quot;;     }     return oneDecimal.format(result) + suffix;   }"
"import java.math.BigInteger; public class BaseConvert {     static BigInteger fromString(String s, int base, String symbols) {         BigInteger num = BigInteger.ZERO;         BigInteger biBase = BigInteger.valueOf(base);         for (char ch : s.toCharArray()) {             num = num.multiply(biBase)                      .add(BigInteger.valueOf(symbols.indexOf(ch)));         }         return num;     }     static String toString(BigInteger num, int base, String symbols) {         StringBuilder sb = new StringBuilder();         BigInteger biBase = BigInteger.valueOf(base);         while (!num.equals(BigInteger.ZERO)) {             sb.append(symbols.charAt(num.mod(biBase).intValue()));             num = num.divide(biBase);         }         return sb.reverse().toString();     }     static String span(char from, char to) {         StringBuilder sb = new StringBuilder();         for (char ch = from; ch &lt;= to; ch++) {             sb.append(ch);         }         return sb.toString();     } }"
"import java.util.regex.*;  public class test {     public static void main(String[] args)     {         String s =         ""CREATE UNIQUE INDEX index555 ON\nSOME_TABLE\n(\n    SOME_PK          ASC\n);\nCREATE UNIQUE INDEX index666 ON\nOTHER_TABLE\n(\n    OTHER_PK          ASC\n);\n"";          Pattern p = Pattern.compile(""([^;]*?('.*?')?)*?;\\s*"", Pattern.CASE_INSENSITIVE | Pattern.DOTALL | Pattern.MULTILINE);          Matcher m = p.matcher(s);          while (m.find())         {         System.out.println (""--- Statement ---"");         System.out.println (m.group ());         }     } }"
"class Outer {      ClassA a;     ClassB b;     ClassC c;     Map&lt;MyEnum,Double&gt; results= new EnumMap&lt;MyEnum, Double&gt;(MyEnum.class);     private enum MyEnum{         X{  public void calc(Outer o){ }           },         Y{  public void calc(Outer o){  } },         Z{  public void calc(Outer o){ } };         abstract void calc(Outer o);     }      public void doCalc(){         for(MyEnum item:MyEnum.values()){             item.calc(this);         }     } }   class ClassA {} class ClassB {} class ClassC {}"
"from visual import * import math  def make_grid(unit, n):     nunit = unit * n     f = frame()     for i in xrange(n+1):         if i%5==0:              color = (1,1,1)         else:             color = (0.5, 0.5, 0.5)          curve(pos=[(0,i*unit,0), (nunit, i*unit, 0)],color=color,frame=f)         curve(pos=[(i*unit,0,0), (i*unit, nunit, 0)],color=color,frame=f)     return f  arrow(pos=(0,0,0), axis=(5,0,0), color=(1,0,0), shaftwidth=0.1)     arrow(pos=(0,0,0), axis=(0,5,0), color=(0,1,0), shaftwidth=0.1)     arrow(pos=(0,0,0), axis=(0,0,5), color=(0,0,1), shaftwidth=0.1)     grid_xy = make_grid(0.5, 10) grid_xz = make_grid(0.5, 10) grid_xz.rotate(angle=pi/2, axis=(1,0,0), origin=(0,0,0)) grid_yz = make_grid(0.5, 10) grid_yz.rotate(angle=-pi/2, axis=(0,1,0), origin=(0,0,0)) sphere(radius=0.3)  obj = arrow(pos=(0,0,0), axis=(1,2,3), shaftwidth=0.3) th = 0 while True:     rate(20)     obj.axis = (3*math.cos(th), 3*math.sin(th), 2)     th += 0.04"
"import edu.emory.mathcs.jtransforms.fft.DoubleFFT_1D; import java.util.Arrays;  public class TestFFT {      void print(String msg, double [] x) {         System.out.println(msg);         for (double d : x) System.out.println(d);     }      /**      * This is a ""wrapped"" signal processing-style autocorrelation.       * For ""true"" autocorrelation, the data must be zero padded.        */     public void bruteForceAutoCorrelation(double [] x, double [] ac) {         Arrays.fill(ac, 0);         int n = x.length;         for (int j = 0; j &lt; n; j++) {             for (int i = 0; i &lt; n; i++) {                 ac[j] += x[i] * x[(n + i - j) % n];             }         }     }      private double sqr(double x) {         return x * x;     }      public void fftAutoCorrelation(double [] x, double [] ac) {         int n = x.length;         // Assumes n is even.         DoubleFFT_1D fft = new DoubleFFT_1D(n);         fft.realForward(x);         ac[0] = sqr(x[0]);         // ac[0] = 0;  // For statistical convention, zero out the mean          ac[1] = sqr(x[1]);         for (int i = 2; i &lt; n; i += 2) {             ac[i] = sqr(x[i]) + sqr(x[i+1]);             ac[i+1] = 0;         }         DoubleFFT_1D ifft = new DoubleFFT_1D(n);          ifft.realInverse(ac, true);         // For statistical convention, normalize by dividing through with variance         //for (int i = 1; i &lt; n; i++)         //    ac[i] /= ac[0];         //ac[0] = 1;     }      void test() {         double [] data = { 1, -81, 2, -15, 8, 2, -9, 0};         double [] ac1 = new double [data.length];         double [] ac2 = new double [data.length];         bruteForceAutoCorrelation(data, ac1);         fftAutoCorrelation(data, ac2);         print(""bf"", ac1);         print(""fft"", ac2);         double err = 0;         for (int i = 0; i &lt; ac1.length; i++)             err += sqr(ac1[i] - ac2[i]);         System.out.println(""err = "" + err);     }      public static void main(String[] args) {         new TestFFT().test();     } }"
"public class Test {      public static void main(String[] args) {         int hash = 100000;         String sample = getStringForHashCode(hash);         System.out.println(sample); // ASD^TYQ         System.out.println(sample.hashCode()); // 100000     }      private static final int OFFSET = ""AAAAAAA"".hashCode();      private static String getStringForHashCode(int hash) {         hash -= OFFSET;         // Treat it as an unsigned long, for simplicity.         // This avoids having to worry about negative numbers anywhere.         long longHash = (long) hash &amp; 0xFFFFFFFFL;         System.out.println(longHash);          char[] c = new char[7];         for (int i = 0; i &lt; 7; i++)         {             c[6 - i] = (char) ('A' + (longHash % 31));             longHash /= 31;         }         return new String(c);     } }"
"static final char[] ENCODE = new char[100];  static {     int x = 0;     for (char i = ' ' + 1; i &lt; 256 &amp;&amp; x &lt; 100; i++)         if (!Character.isLowerCase(i) &amp;&amp; !Character.isWhitespace(i))             ENCODE[x++] = i;     assert x == ENCODE.length; }  public static char[] encode(int n) {     assert n &gt;= 0 &amp;&amp; n &lt; 100000000;     char[] ret = new char[4];     for (int i = ret.length - 1; i &gt;= 0; i--) {         ret[i] = ENCODE[n % 100];         n /= 100;     }     return ret; }  public static int decode(char[] chars) {     int n = 0;     for (char ch : chars) {         int x = Arrays.binarySearch(ENCODE, ch);         assert x &gt;= 0;         n = n * 100 + x;     }     return n; }  public static void main(String... args) {     char[] chars = encode(12345678);     System.out.println(""Encoded: "" + new String(chars));     int n = decode(chars);     System.out.println(""Dencoded: "" + n); }"
"public void testHash() {     System.out.println(""A:"" + ((int)'A'));     System.out.println(""B:"" + ((int)'B'));     System.out.println(""a:"" + ((int)'a'));      System.out.println(hash(""Aa"".hashCode()));     System.out.println(hash(""BB"".hashCode()));     System.out.println(hash(""Aa"".hashCode()));     System.out.println(hash(""BB"".hashCode()));       System.out.println(hash(""AaAa"".hashCode()));     System.out.println(hash(""BBBB"".hashCode()));     System.out.println(hash(""AaBB"".hashCode()));     System.out.println(hash(""BBAa"".hashCode()));  }"
"public class Test {   public static void main(String args[]) {     new Test().test();   }    public static class EnumIterator implements Iterator&lt;Enum[]&gt; {     // The enums     private final Enum[][] enums;     // Where we are in each column.     private final int[] is;     // Which column to increment next.     private int i = 0;      // Construct from Enum[]s.     public EnumIterator(Enum[]... enums) {       // Grab the enums.       this.enums = enums;       // Start all ordinals at zero.       is = new int[enums.length];       // Next one to increment is the last one.       i = enums.length - 1;     }      // Construct from classes.     public EnumIterator(Class&lt;? extends Enum&gt;... classes) {       this(enumsFromClasses(classes));     }      // Factory to build the Enum[] array from an array of classes.     private static Enum[][] enumsFromClasses(Class&lt;? extends Enum&gt;[] classes) {       Enum[][] theEnums = new Enum[classes.length][];       for ( int j = 0; j &lt; classes.length; j++ ) {         theEnums[j] = classes[j].getEnumConstants();       }       return theEnums;     }      @Override     public boolean hasNext() {       // We stop when we are about to increment col 0 and we are at its end.       return (i &gt; 0 || is[0] &lt; enums[0].length);     }      @Override     public Enum[] next() {       if (hasNext()) {         // One from each.         Enum[] next = new Enum[enums.length];         for (int j = 0; j &lt; next.length; j++) {           next[j] = enums[j][is[j]];         }         // Step - Kinda like incrementing a number with each digit in a different base.         // Walk back past '9's setting them to 0.         for (i = is.length - 1; i &gt; 0 &amp;&amp; is[i] == enums[i].length - 1; i--) {           // Back one.           is[i] = 0;         }         // Step that one up one.         is[i] += 1;         return next;       } else {         throw new NoSuchElementException();       }     }      @Override     public void remove() {       throw new UnsupportedOperationException(""Not supported."");     }   }    enum ABC {     A, B, C;   }    enum XY {     X, Y;   }    enum IJ {     I, J;   }    private void test() {     // Also works - but constructing from classes is cleaner.     //Iterator&lt;Enum[]&gt; i = new EnumIterator(ABC.values(), XY.values(), IJ.values());     Iterator&lt;Enum[]&gt; i = new EnumIterator(ABC.class, XY.class, IJ.class);     for (Enum[] e : Iterables.in(i)) {       System.out.println(Arrays.toString(e));     }   } }"
"public static String convertColumn(String textF) {       String textAux = """";     String newText = ""["";      int i = 0;      textF = textF.substring(1, textF.length() - 1);      while(i &lt; textF.length())     {         textAux = textF.substring(i, i + 5);         int nrAux = Integer.parseInt(textAux);          i+=7;         int a;         int b;          a = nrAux / 1000;         b = nrAux - a * 1000;          double newNr;         newNr = a + b * 0.001;         newText = newText + newNr + "", "";      }     newText = newText.substring(0, newText.length() - 2);     newText += ""]"";     return newText; }"
"public static void main(String[] args) {         double x = 999999.99; // thats the max size of the double         // I dont know how to code this part         int[] splitD = { 9, 9, 9, 9, 9, 9 }; // the number         int[] splitDec = { 9, 9 }; // the decimal          // convert number to String         String input = x + """";         // split the number         String[] split = input.split(""\\."");          String firstPart = split[0];         char[] charArray1 = firstPart.toCharArray();         // recreate the array with size equals firstPart length         splitD = new int[charArray1.length];         for (int i = 0; i &lt; charArray1.length; i++) {             // convert char to int             splitD[i] = Character.getNumericValue(charArray1[i]);         }          // the decimal part         if (split.length &gt; 1) {             String secondPart = split[1];             char[] charArray2 = secondPart.toCharArray();             splitDec = new int[charArray2.length];             for (int i = 0; i &lt; charArray2.length; i++) {                 // convert char to int                 splitDec[i] = Character.getNumericValue(charArray2[i]);             }         }     }"
"public class SortTest {     public static void main(String[] args) {         String[] test = new String[]{             ""a"",             ""b"",             ""b.a"",             ""b.a.a"",             ""a.a.a"",             ""a.b.a"",             ""a.a"",             ""a.b"",             ""b.a.b"",             ""b.b.a""         };          Arrays.sort(test, new Comparator&lt;String&gt;() {          int compareComplexList(List&lt;String&gt; a, List&lt;String&gt; b, List&lt;int[]&gt; positions, int order ) {            int minimum = a.size() &lt; b.size() ? a.size() - 1 : b.size() - 1;               if (a.get(positions.get(minimum)[order]).compareTo(b.get(positions.get(minimum)[order])) != 0)                 return a.get(positions.get(minimum)[order]).compareTo(b.get(positions.get(minimum)[order]));           else if (order &lt; minimum - 1) return compareComplexList(a,b, positions, ++order);           else return Double.compare(a.size(),b.size());         }          public int compare(String a, String b) {           List&lt;String&gt; partsA = Arrays.asList(a.split(""\\.""));           List&lt;String&gt; partsB = Arrays.asList(b.split(""\\.""));           List&lt;int[]&gt;  orders = new ArrayList&lt;int[]&gt;();            orders.add(new int[] {0});           orders.add(new int[] {0,1});           orders.add(new int[] {0,2,1});            return compareComplexList(partsA, partsB, orders,0);         }         });         System.out.println(""Sorted: ""+Arrays.toString(test));     }  }"
"public static void solve(int[] a, int k, int i, List&lt;List&lt;Integer&gt;&gt; subsets) {     if (i == a.length) {         for (List&lt;Integer&gt; subset : subsets) {             System.out.print(subset);                        }         System.out.println();     } else {         // loop over all subsets and try to put a[i] in         for (int j = 0; j &lt; subsets.size(); j++) {                              if (subsets.get(j).size() &lt; k) {                 // subset j not full                 subsets.get(j).add(a[i]);                 solve(a, k, i+1, subsets); // do recursion                 subsets.get(j).remove((Integer)a[i]);                  if (subsets.get(j).size() == 0) {                      // don't skip empty subsets, so you won't get duplicates                      break;                 }                                 }         }     } }"
public class Test {      public static void main(String[] args) {         System.out.println(format(14.0184849945)); // prints '14.01'         System.out.println(format(13)); // prints '13'         System.out.println(format(3.5)); // prints '3.5'         System.out.println(format(3.138136)); // prints '3.13'     }      public static String format(Number n) {         NumberFormat format = DecimalFormat.getInstance();         format.setRoundingMode(RoundingMode.FLOOR);         format.setMinimumFractionDigits(0);         format.setMaximumFractionDigits(2);         return format.format(n);     }  }
"public final class PointVerificationAdapter extends BaseAdapter {     List&lt;BasicNameValuePair&gt; mObjects;     Context mContext;     LayoutInflater mInflater;     HashMap&lt;Integer, String&gt; mReponsesActuel;     ArrayList&lt;String&gt; myItems = new ArrayList&lt;String&gt;();      public PointVerificationAdapter(             Context context,             List&lt;BasicNameValuePair&gt; listObjets             ) {          this.mInflater = LayoutInflater.from(context);         this.mContext = context;         this.mObjects = listObjets;          for (int i = 0; i &lt; 30; i++) {             myItems.add(Integer.toString(i));         }     }      @Override     public int getCount() {         return mObjects.size();     }      @Override     public BasicNameValuePair getItem(int position) {         return mObjects.get(position);     }      @Override     public long getItemId(int position) {         return position;     }      static class ViewHolder {         EditText yourEditText;     }      @Override     public View getView(int position, View convertView, ViewGroup parent) {          ViewHolder holder = null;          if (convertView == null)         {             holder = new ViewHolder();             convertView = mInflater.inflate(R.layout.intervention_reponses_controle_nombre, parent, false);             convertView.setId(position);             holder.yourEditText = (EditText) convertView.findViewById(R.id.edValeur);              convertView.setTag(holder);         }         else         {             holder = (ViewHolder) convertView.getTag();         }          ((TextView) convertView.findViewById(R.id.tvNom)).setText(Integer.toString(position));          holder.yourEditText.setText(myItems.get(position));         holder.yourEditText.setId(position);         holder.yourEditText.setOnFocusChangeListener(new OnFocusChangeListener() {             public void onFocusChange(View view, boolean hasFocus) {                 if (!hasFocus){                     final int position = view.getId();                     final EditText editText = (EditText) view;                     myItems.set(position, editText.getText().toString());                 }             }         });          return convertView;     }  }"
"import java.math.BigInteger; import java.util.regex.Matcher; import java.util.regex.Pattern;  public class SignatureFromPython {     private static final Pattern PAT = Pattern.compile(""\\[(\\d+)\\]"");      private static byte[] i2osp(final BigInteger i, final int bitSize) {         if (i == null || i.signum() == -1) {             throw new IllegalArgumentException(                     ""input parameter should not be null or negative"");         }          if (bitSize &lt; Byte.SIZE) {             throw new IllegalArgumentException(                     ""bitSize parameter should not be negative and a multiple of 8"");         }          final int byteSize = (bitSize - 1) / Byte.SIZE + 1;         final byte[] signedBigEndian = i.toByteArray();         final int signedBigEndianLength = signedBigEndian.length;         if (signedBigEndianLength == byteSize) {             return signedBigEndian;         }          final byte[] leftPadded = new byte[byteSize];          if (signedBigEndianLength == byteSize + 1) {             System.arraycopy(signedBigEndian, 1, leftPadded, 0, byteSize);         } else if (signedBigEndianLength &lt; byteSize) {             System.arraycopy(signedBigEndian, 0, leftPadded, byteSize                     - signedBigEndianLength, signedBigEndianLength);         } else {             throw new IllegalArgumentException(                     ""Integer i is too large to fit into "" + bitSize + "" bits"");         }         return leftPadded;     }      public static String toHex(final byte[] data) {         final StringBuilder hex = new StringBuilder(data.length * 2);         for (int i = 0; i &lt; data.length; i++) {             hex.append(String.format(""%02X"", data[i]));         }         return hex.toString();     }      public static void main(String[] args) {         String sigString = ""[68830459489863257411523011520104203035626147084548742757940226446079486348431212041096334237130703774949375015187747280487790006116898192460644067270457728626039524097117092304115366780581423597886886987279231850120937691165013216970647150989646220735762034864029622135210042186666476516651349805320771941650]"";         Matcher sigMatcher = PAT.matcher(sigString);         if (!sigMatcher.matches()) {             throw new IllegalArgumentException(""Whatever"");         }         BigInteger sigBI = new BigInteger(sigMatcher.group(1));         // requires bouncy castle libraries         System.out.println(toHex(i2osp(sigBI, 1024)));     } }"
"public class Perms {  /**  * @param args  */ public static int x; public static void main(String[] args) {     // TODO Auto-generated method stub      x = 6;     rec(x, new int[1000], new String[1000], 0); }  public static void rec(int n, int all[], String operator[], int size) {        if (n==0)        {           if (size==1)return;           System.out.print(x + "" ="");           for (int i=0;i&lt;size;i++)           {              System.out.print("" "" + all[i]);              if (i!=size-1)                  System.out.print("" "" + operator[i]);           }           System.out.println();           return;        }        int i=1;        if (size&gt;0)           i = all[size-1]+1;        for ( ;i&lt;=n;i++)        {           operator[size] = ""+"";           all[size] = i;           rec(n-i, all, operator, size+1);        }         i=1;        if (size&gt;0)           i = all[size-1]+1;        for (;i&lt;=n;i++)        {           float r = n/(float)i;           if (r == (int)r)           {              operator[size] = ""*"";              all[size] = i;              rec(n/i, all, operator, size+1);           }        }     } }"
"public class Test {      public static void main(String[] args)      {//create array of 1,000 random numbers       int[] randomNumbers = new int[1000];        for(int i = 0; i &lt; randomNumbers.length; i++)       randomNumbers[i] =1 +(int)(Math.random() * 6);       { //initialize count        int[] counts = countInts(randomNumbers);        displayIntCount(counts);       }      }      public static int[] countInts(int[] ints)         { //creat new array to hold occurence values          int[] counts = new int[6];          for(int i = 1; i &lt;=counts.length; i++)              for(int j=0;j&lt;ints.length;j++)                  if(ints[j] == i)                      counts[i-1]++;            return counts;         }       public static void displayIntCount(int[] counts)       {//display the occurrences          for (int i = 0; i &lt; counts.length; i++)              System.out.println(""The number ""+ (i+1) +"" occurs ""+counts[i]+ "" times"");     }  }"
"public class TestMultipleReturns {              public static String multipleVals() {                  String result = """";                 String separator = ""!@#"";                   int intVal = 5;                 // Code to process intVal                  double doubleVal = 3.14;                 // Code to process doubleVal                  String stringVal = ""hello"";                 // Code to process Int intVal                  result = intVal + separator + doubleVal + separator + stringVal + separator;                 return (result);             }              public static void main(String[] args) {                  String res = multipleVals();                  int intVal = Integer.parseInt(res.split(""!@#"")[0]);                 // Code to process intVal                  double doubleVal = Double.parseDouble(res.split(""!@#"")[1]);                 // Code to process doubleVal                  String stringVal = res.split(""!@#"")[2];                  System.out.println(intVal+""\n""+doubleVal+""\n""+stringVal);             }         }"
