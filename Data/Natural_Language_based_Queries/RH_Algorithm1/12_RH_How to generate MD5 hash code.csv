code
"try {     // Construct data     String data = URLEncoder.encode(""key1"", ""UTF-8"") + ""="" + URLEncoder.encode(""value1"", ""UTF-8"");     data += ""&amp;amp;"" + URLEncoder.encode(""key2"", ""UTF-8"") + ""="" + URLEncoder.encode(""value2"", ""UTF-8"");      // Send data     URL url = new URL(""http://testes.neoscopio.com/myrepo/send.php"");     URLConnection conn = url.openConnection();     conn.setDoOutput(true);     OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());     wr.write(data);     wr.flush();      // Get the response     BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));     String line;     while ((line = rd.readLine()) != null) {         // Process line...     }     wr.close();     rd.close(); } catch (Exception e) { }"
"class NativeMemoryCache{   private Map&lt;Object, ByteBuffer&gt; data = new HashMap&lt;...&gt;();    public void put(Object key, Serializable object){     byte[] bytes = serialize(object);     //allocate native memory to store our object     ByteBuffer buf = ByteBuffer.allocateDirect(bytes.length);     buf.put(bytes);     buf.flip();     data.put(key, buf);   }    public Object get(Object key){     ByteBuffer buf = data.get(key).duplicate();     byte[] bytes = new byte[buf.remaining()];     buf.get(bytes);     return deserialize(bytes);   }    private byte[] serialize(Object obj){ ... }   private Object deserialize(byte[] bytes){ ... } }"
"String sql = ""Select * from Activity""; Statement stmt = connection.createStatement(); ResultSet rs = stmt.executeQuery( sql ); ResultSetMetaData md = rs.getMetaData(); int columns = md.getColumnCount();  //  Get column names  for (int i = 1; i &lt;= columns; i++) {     columnNames.addElement( md.getColumnName(i) ); }  //  Get row data  while (rs.next()) {     Vector row = new Vector(columns);      for (int i = 1; i &lt;= columns; i++)     {         row.addElement( rs.getObject(i) );     }      data.addElement( row ); }"
"import java.security.NoSuchAlgorithmException;  import javax.crypto.Cipher; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec;  public class MCrypt {      private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)     private IvParameterSpec ivspec;     private SecretKeySpec keyspec;     private Cipher cipher;      private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)      public MCrypt()     {         ivspec = new IvParameterSpec(iv.getBytes());          keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");          try {             cipher = Cipher.getInstance(""AES/CBC/NoPadding"");         } catch (NoSuchAlgorithmException e) {             // TODO Auto-generated catch block             e.printStackTrace();         } catch (NoSuchPaddingException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }     }      public byte[] encrypt(String text) throws Exception     {         if(text == null || text.length() == 0)             throw new Exception(""Empty string"");          byte[] encrypted = null;          try {             cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);              encrypted = cipher.doFinal(padString(text).getBytes());         } catch (Exception e)         {                        throw new Exception(""[encrypt] "" + e.getMessage());         }          return encrypted;     }      public byte[] decrypt(String code) throws Exception     {         if(code == null || code.length() == 0)             throw new Exception(""Empty string"");          byte[] decrypted = null;          try {             cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);              decrypted = cipher.doFinal(hexToBytes(code));         } catch (Exception e)         {             throw new Exception(""[decrypt] "" + e.getMessage());         }         return decrypted;     }        public static String bytesToHex(byte[] data)     {         if (data==null)         {             return null;         }          int len = data.length;         String str = """";         for (int i=0; i&lt;len; i++) {             if ((data[i]&amp;0xFF)&lt;16)                 str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);             else                 str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);         }         return str;     }       public static byte[] hexToBytes(String str) {         if (str==null) {             return null;         } else if (str.length() &lt; 2) {             return null;         } else {             int len = str.length() / 2;             byte[] buffer = new byte[len];             for (int i=0; i&lt;len; i++) {                 buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);             }             return buffer;         }     }        private static String padString(String source)     {       char paddingChar = ' ';       int size = 16;       int x = source.length() % size;       int padLength = size - x;        for (int i = 0; i &lt; padLength; i++)       {           source += paddingChar;       }        return source;     } }"
"import java.security.NoSuchAlgorithmException;  import javax.crypto.Cipher; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec;  public class MCrypt {      private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)     private IvParameterSpec ivspec;     private SecretKeySpec keyspec;     private Cipher cipher;      private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)      public MCrypt()     {         ivspec = new IvParameterSpec(iv.getBytes());          keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");          try {             cipher = Cipher.getInstance(""AES/CBC/NoPadding"");         } catch (NoSuchAlgorithmException e) {             // TODO Auto-generated catch block             e.printStackTrace();         } catch (NoSuchPaddingException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }     }      public byte[] encrypt(String text) throws Exception     {         if(text == null || text.length() == 0)             throw new Exception(""Empty string"");          byte[] encrypted = null;          try {             cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);              encrypted = cipher.doFinal(padString(text).getBytes());         } catch (Exception e)         {                        throw new Exception(""[encrypt] "" + e.getMessage());         }          return encrypted;     }      public byte[] decrypt(String code) throws Exception     {         if(code == null || code.length() == 0)             throw new Exception(""Empty string"");          byte[] decrypted = null;          try {             cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);              decrypted = cipher.doFinal(hexToBytes(code));         } catch (Exception e)         {             throw new Exception(""[decrypt] "" + e.getMessage());         }         return decrypted;     }        public static String bytesToHex(byte[] data)     {         if (data==null)         {             return null;         }          int len = data.length;         String str = """";         for (int i=0; i&lt;len; i++) {             if ((data[i]&amp;0xFF)&lt;16)                 str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);             else                 str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);         }         return str;     }       public static byte[] hexToBytes(String str) {         if (str==null) {             return null;         } else if (str.length() &lt; 2) {             return null;         } else {             int len = str.length() / 2;             byte[] buffer = new byte[len];             for (int i=0; i&lt;len; i++) {                 buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);             }             return buffer;         }     }        private static String padString(String source)     {       char paddingChar = ' ';       int size = 16;       int x = source.length() % size;       int padLength = size - x;        for (int i = 0; i &lt; padLength; i++)       {           source += paddingChar;       }        return source;     } }"
"public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {             Component c = super.prepareRenderer(renderer, row, column);              if ((column == 2 || column == 3) &amp;&amp; (Boolean)getValueAt(row, 0)) {                 return c;             }          //    if (column == 0 || column == 1 || (Boolean) getValueAt(row, 0)) {             if (column == 0 || column == 1) {                 return c;             }              return Box.createRigidArea(c.getPreferredSize());         }"
"class Encoder {   public static final int BASE = 40;   StringBuilder chars = new StringBuilder(BASE);   byte[] index = new byte[256];    {     chars.append('\0');     for (char ch = 'a'; ch &lt;= 'z'; ch++) chars.append(ch);     for (char ch = '0'; ch &lt;= '9'; ch++) chars.append(ch);     chars.append(""-:."");     Arrays.fill(index, (byte) -1);     for (byte i = 0; i &lt; chars.length(); i++)       index[chars.charAt(i)] = i;   }    public byte[] encode(String address) {     try {       ByteArrayOutputStream baos = new ByteArrayOutputStream();       DataOutputStream dos = new DataOutputStream(baos);       for (int i = 0; i &lt; address.length(); i += 3) {         switch (Math.min(3, address.length() - i)) {           case 1: // last one.             byte b = index[address.charAt(i)];             dos.writeByte(b);             break;            case 2:             char ch = (char) ((index[address.charAt(i+1)]) * 40 + index[address.charAt(i)]);             dos.writeChar(ch);             break;            case 3:             char ch2 = (char) ((index[address.charAt(i+2)] * 40 + index[address.charAt(i + 1)]) * 40 + index[address.charAt(i)]);             dos.writeChar(ch2);             break;         }       }       return baos.toByteArray();     } catch (IOException e) {       throw new AssertionError(e);     }   }    public static void main(String[] args) {     Encoder encoder = new Encoder();     for (String s : ""twitter.com:2122,123.211.80.4:2122,my-domain.se:2121,www.stackoverflow.com:80"".split("","")) {       System.out.println(s + "" ("" + s.length() + "" chars) encoded is "" + encoder.encode(s).length + "" bytes."");     }   } }"
"public class DBHelper extends SQLiteOpenHelper{  private final static String DB_PATH = ""/data/data/[YOUR PACKAGE HERE]/databases/"";  String dbName; Context context;  File dbFile;  public DBHelper(Context context, String dbName, CursorFactory factory,         int version) {     super(context, dbName, factory, version);     this.context = context;     this.dbName = dbName;     dbFile= new File(DB_PATH + dbName); }  @Override public synchronized SQLiteDatabase getWritableDatabase() {      if(!dbFile.exists()){         SQLiteDatabase db = super.getWritableDatabase();         copyDataBase(db.getPath());     }     return super.getWritableDatabase(); }  @Override public synchronized SQLiteDatabase getReadableDatabase() {     if(!dbFile.exists()){         SQLiteDatabase db = super.getReadableDatabase();         copyDataBase(db.getPath());     }     return super.getReadableDatabase(); }  @Override public void onCreate(SQLiteDatabase db) {}  @Override public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion) {}  private void copyDataBase(String dbPath){     try{         InputStream assestDB = context.getAssets().open(""databases/""+dbName);          OutputStream appDB = new FileOutputStream(dbPath,false);          byte[] buffer = new byte[1024];         int length;         while ((length = assestDB.read(buffer)) &gt; 0) {             appDB.write(buffer, 0, length);         }          appDB.flush();         appDB.close();         assestDB.close();     }catch(IOException e){         e.printStackTrace();     }  }  }"
"log4j.rootLogger=DEBUG, CA, FA   # Console Appender  log4j.appender.CA=org.apache.log4j.ConsoleAppender  log4j.appender.CA.layout=org.apache.log4j.PatternLayout  log4j.appender.CA.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n       # File Appender  log4j.appender.FA=org.apache.log4j.FileAppender  log4j.appender.FA.File=sample.log  log4j.appender.FA.layout=org.apache.log4j.PatternLayout  log4j.appender.FA.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n   # Set the logger level of File Appender to WARN  log4j.appender.FA.Threshold = WARN"
"Connection connection = DriverManager.getConnection(JDBC_URL, JDBC_USERNAME, JDBC_PASSWORD); PreparedStatement statement = connection.prepareStatement(JDBC_SELECT); ResultSet rs = statement.executeQuery(); PrintStream out = System.out;  if (rs != null) {     while (rs.next()) {         ResultSetMetaData rsmd = rs.getMetaData();         for (int i = 1; i &lt;= rsmd.getColumnCount(); i++) {             if (i &gt; 1) {             out.print("","");             }              int type = rsmd.getColumnType(i);             if (type == Types.VARCHAR || type == Types.CHAR) {                 out.print(rs.getString(i));             } else {                 out.print(rs.getLong(i));             }         }          out.println();     } }"
"public class myConnection  {  // JDBC driver name and database URL private static final String JDBC_DRIVER = ""sun.jdbc.odbc.JdbcOdbcDriver""; private static final String DATABASE_URL =""jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=.\\database.accdb"";  // declare Connection for accessing and querying database private Connection connection;   // constructor connects to database public myConnection ()  {      try      {         Class.forName(JDBC_DRIVER);         connection = DriverManager.getConnection(DATABASE_URL);      }       catch (SQLException sqlException)     {         JOptionPane.showMessageDialog(null, sqlException.getMessage(),                 ""Database Error"", JOptionPane.ERROR_MESSAGE);          System.exit(1);     }      catch (ClassNotFoundException classNotFound)     {         JOptionPane.showMessageDialog(null, classNotFound.getMessage(),                 ""Driver Not Found"", JOptionPane.ERROR_MESSAGE);          System.exit(1);     } }  public void closeConnection() {     try      {         connection.close();     }      catch (SQLException sqlException)     {         JOptionPane.showMessageDialog(null, sqlException.getMessage(),                 ""Database Error"", JOptionPane.ERROR_MESSAGE);          System.exit(1);     } }  public Connection getConnection() {     return connection; }"
"class ThreadTask implements Runnable {      private final AtomicInteger id;      ThreadTask(AtomicInteger id) {         this.id = id; //in your main thread: id = new AtomicInteger(minId);     }      @Override     public void run() {         dbConnection = getDBConnection();         preparedStatement = dbConnection.prepareStatement(INSERT_SQL);          preparedStatement.setString(1, String.valueOf(id.getAndIncrement()));         preparedStatement.setString(2, ACCOUNT);          preparedStatement.executeUpdate();     } }"
"public List&lt;Map&lt;String, Object&gt;&gt; getResultSet(String sql) {    // this list will hold all the data returned from resultset    List&lt;Map&lt;String, Object&gt;&gt; rows = new ArrayList&lt;Map&lt;String, Object&gt;&gt;();     try (Connection conn = getConnection();         ResultSet rs = conn.createStatement().executeQuery(sql);) {       while(rs.next()) {          // this map corresponds to each row of the resultset          // key: column-name, value: column-value          Map&lt;String, Object&gt; row = new LinkedHashMap&lt;String, Object&gt;();           // populate each row using resultset's Meta data          ResultSetMetaData meta = rs.getMetaData();          for (int i=1; i&lt;=meta.getColumnCount(); i++)             row.put(meta.getColumnName(i), rs.getObject(i));          rows.add(row);         }    } catch (Exception e) {         e.printStackTrace();    }    return rows; }"
"public class StringConcat{     public static String strcat(String str1, String str2){         //converting string into char array         char[] charArray1 = str1.toCharArray();         char[] charArray2 = str2.toCharArray();          int counter=charArray1.length+charArray2.length;          //stores both char array            char[] charContainer=new char[counter];          //for storing charArray1 into charContainer         int i=0;         for(; i&lt;charArray1.length; i++) {             charContainer[i]=charArray1[i];         }         //for storing charArray2 into charContainer         for(int j=0; i&lt;counter; j++,i++) {             charContainer[i]=charArray2[j];         }         //converting charContainer char array into string         return new String(charContainer);     }     public static void main(String args[]){         String str1 = ""FirstString"";         String str2 = ""SecondString"";         String strContainer = strcat(str1,str2);         System.out.println(""String Container : "" +strContainer);       } }//end of the class"
"class Stuff {      private ByteBuffer data;      public Stuff() {     }      public Stuff(ByteBuffer data) {         super();         this.data = data;     }      public ByteBuffer getData() {         return data;     }      public void setData(ByteBuffer data) {         this.data = data;     }      @JsonProperty(value = ""data"")     public String convertData() {         return new String(data.array());     }      @JsonProperty(""data"")     public void convertData(String s) {         data = ByteBuffer.wrap(s.getBytes());     }  }"
"package security.symmatric;      import javax.crypto.Cipher;     import javax.crypto.spec.SecretKeySpec;      import org.apache.commons.codec.binary.Base64;      public class AES {         public static String symmetricEncrypt(String text, String secretKey) {             byte[] raw;             String encryptedString;             SecretKeySpec skeySpec;             byte[] encryptText = text.getBytes();             Cipher cipher;             try {                 raw = Base64.decodeBase64(secretKey);                 skeySpec = new SecretKeySpec(raw, ""AES"");                 cipher = Cipher.getInstance(""AES"");                 cipher.init(Cipher.ENCRYPT_MODE, skeySpec);                 encryptedString = Base64.encodeBase64String(cipher.doFinal(encryptText));             }              catch (Exception e) {                 e.printStackTrace();                 return ""Error"";             }             return encryptedString;         }          public static String symmetricDecrypt(String text, String secretKey) {             Cipher cipher;             String encryptedString;             byte[] encryptText = null;             byte[] raw;             SecretKeySpec skeySpec;             try {                 raw = Base64.decodeBase64(secretKey);                 skeySpec = new SecretKeySpec(raw, ""AES"");                 encryptText = Base64.decodeBase64(text);                 cipher = Cipher.getInstance(""AES"");                 cipher.init(Cipher.DECRYPT_MODE, skeySpec);                 encryptedString = new String(cipher.doFinal(encryptText));             } catch (Exception e) {                 e.printStackTrace();                 return ""Error"";             }             return encryptedString;         }          public static void main(String[] args) {             String secretKey = ""XMzDdG4D03CKm2IxIWQw7g=="";             String value1= ""ABCD"";             String enctypedValue1= ""3uweh4pzoVyH1uODQmVNJA=="";             String enctypedValue2= ""37PTC20w4DMZYjG3f+GWepSvAbEJUccMXwS/lXilLav1qM/PrCTdontw5/82OdC1zzyhDEsFVRGo rV6gXAQcm+Zai15hliiUQ8l8KRMtUl4="";             String value4= ""20000"";              /**  Ecnryption and decryption of value1 **/             String encryptedValue1= symmetricEncrypt(value1, secretKey);             String decryptedValue1 = symmetricDecrypt(encryptedValue1, secretKey);             System.out.println(decryptedValue1);              /**  Decryption of  enctypedValue1 **/             String decryptedValue2 = symmetricDecrypt(enctypedValue1, secretKey);             System.out.println(decryptedValue2);              /**  Decryption of  enctypedValue2 **/             String decryptedValue3 = symmetricDecrypt(enctypedValue2, secretKey);             System.out.println(decryptedValue3);              /**  Ecnryption and decryption of value4 **/             String encryptedValue4= symmetricEncrypt(value4, secretKey);             String decryptedValue4 = symmetricDecrypt(encryptedValue4, secretKey);             System.out.println(decryptedValue4);         }     }"
[DEBUG]    org.opensaml:opensaml:jar:2.2.3:compile [DEBUG]       commons-collections:commons-collections:jar:3.1:compile [DEBUG]       commons-lang:commons-lang:jar:2.1:compile [DEBUG]       velocity:velocity:jar:1.5:compile [DEBUG]       org.apache.xerces:xml-apis:jar:2.9.1:runtime [DEBUG]       org.apache.xerces:xercesImpl:jar:2.9.1:runtime [DEBUG]       org.apache.xerces:resolver:jar:2.9.1:runtime [DEBUG]       org.apache.xerces:serializer:jar:2.9.1:runtime [DEBUG]       org.apache.xalan:xalan:jar:2.7.1:runtime
"import com.datastax.driver.core.Cluster; import com.datastax.driver.core.Session;  public class App  {     public static void main( String[] args )     {         Cluster cluster = Cluster.builder()                           .addContactPoints(""127.0.0.1"")                           .build();         Session session = cluster.connect();         String cqlStatement = ""CREATE KEYSPACE myfirstcassandradb WITH "" +                                ""replication = {'class':'SimpleStrategy','replication_factor':1}"";                 session.execute(cqlStatement);          String cqlStatement2 = ""CREATE TABLE myfirstcassandradb.users ("" +                                 "" user_name varchar PRIMARY KEY,"" +                                 "" password varchar "" +                                 "");"";         session.execute(cqlStatement2);          System.out.println(""Done"");         System.exit(0);     } }"
"import javax.crypto.Cipher; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec;  import org.apache.commons.codec.binary.Base64;  public class Encryptor {     public static String encrypt(String key, String initVector, String value) {         try {             IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));             SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");              Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");             cipher.init(Cipher.ENCRYPT_MODE, skeySpec, iv);              byte[] encrypted = cipher.doFinal(value.getBytes());             System.out.println(""encrypted string: ""                     + Base64.encodeBase64String(encrypted));              return Base64.encodeBase64String(encrypted);         } catch (Exception ex) {             ex.printStackTrace();         }          return null;     }      public static String decrypt(String key, String initVector, String encrypted) {         try {             IvParameterSpec iv = new IvParameterSpec(initVector.getBytes(""UTF-8""));             SecretKeySpec skeySpec = new SecretKeySpec(key.getBytes(""UTF-8""), ""AES"");              Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5PADDING"");             cipher.init(Cipher.DECRYPT_MODE, skeySpec, iv);              byte[] original = cipher.doFinal(Base64.decodeBase64(encrypted));              return new String(original);         } catch (Exception ex) {             ex.printStackTrace();         }          return null;     }      public static void main(String[] args) {         String key = ""Bar12345Bar12345""; // 128 bit key         String initVector = ""RandomInitVector""; // 16 bytes IV          System.out.println(decrypt(key, initVector,                 encrypt(key, initVector, ""Hello World"")));     } }"
"CriteriaImpl c = (CriteriaImpl)query; SessionImpl s = (SessionImpl)c.getSession(); SessionFactoryImplementor factory = (SessionFactoryImplementor)s.getSessionFactory(); String[] implementors = factory.getImplementors( c.getEntityOrClassName() ); CriteriaLoader loader = new CriteriaLoader((OuterJoinLoadable)factory.getEntityPersister(implementors[0]),     factory, c, implementors[0], s.getEnabledFilters()); Field f = OuterJoinLoader.class.getDeclaredField(""sql""); f.setAccessible(true); String sql = (String)f.get(loader);"
"public String getEnum(String number) {                             String data = number.replaceAll(""[^0-9]"","""");                             StringBuffer sb = new StringBuffer();                             for (int i = data.length()-1; i &gt;= 0; i--)                             {                                     sb.append(data.charAt(i)).append('.');                             }                             sb.append(""e164.arpa."");                             return sb.toString();                     }"
class NDimensionalArray {   private Object[] array; // internal representation of the N-dimensional array   private int[] dimensions; // dimensions of the array   private int[] multipliers; // used to calculate the index in the internal array    NDimensionalArray(int... dimensions) {     int arraySize = 1;      multipliers = new int[dimensions.length];     for (int idx = dimensions.length - 1; idx &gt;= 0; idx--) {       multipliers[idx] = arraySize;       arraySize *= dimensions[idx];     }     array = new Object[arraySize];     this.dimensions = dimensions;   }   ...   public Object get(int... indices) {     assert indices.length == dimensions.length;     int internalIndex = 0;      for (int idx = 0; idx &lt; indices.length; idx++) {       internalIndex += indices[idx] * multipliers[idx];     }     return array[internalIndex];   }   ... }
"try {     // Construct data     String data = URLEncoder.encode(""key1"", ""UTF-8"") + ""="" + URLEncoder.encode(""value1"", ""UTF-8"");     data += ""&amp;"" + URLEncoder.encode(""key2"", ""UTF-8"") + ""="" + URLEncoder.encode(""value2"", ""UTF-8"");      // Send data     URL url = new URL(""http://hostname:80/cgi"");     URLConnection conn = url.openConnection();     conn.setDoOutput(true);     OutputStreamWriter wr = new OutputStreamWriter(conn.getOutputStream());     wr.write(data);     wr.flush();      // Get the response     BufferedReader rd = new BufferedReader(new InputStreamReader(conn.getInputStream()));     String line;     while ((line = rd.readLine()) != null) {         // Process line...     }     wr.close();     rd.close(); } catch (Exception e) { }"
"psmnt = conn.prepareStatement(""INSERT INTO upload_data(user_id,audiofile) ""                             + ""values(?,?)"");              psmnt.setLong(1, userId);              fis = new FileInputStream(audioFile);             psmnt.setBinaryStream(2, (InputStream) fis, (int) (audioFile                     .length()));             /*              * executeUpdate() method execute specified sql query. Here this              * query insert data and image from specified address.              */             int s = psmnt.executeUpdate();"
"Connection db = DriverManager.getConnection( jdbc:mysql://192.168.0.3:3306,&lt;user&gt;,&lt;password&gt;); Statement stmt = db.createStatement(); PreparedStatement psmt = con.prepareStatement(""SELECT * FROM DB""); ResultSet rs = psmt.executeQuery();  // get column names int len = rs.getMetaData().getColumnCount(); Vector cols= new Vector(len); for(int i=1; i&lt;=len; i++) // Note starting at 1     cols.add(rs.getMetaData().getColumnName(i));   // Add Data Vector data = new Vector(); while(rs.next()) {     Vector row; = new Vector(len);     for(int i=1; i&lt;=len; i++)     {         row.add(rs.getString(i));     }     data.add(row); }  // Now create the table JTable table = new JTable(data, cols);"
"CREATE or REPLACE FUNCTION public.iftableexists( varchar) RETURNS pg_catalog.bool AS $BODY$ DECLARE   BEGIN       /* check the table exist in database and is visible*/  perform n.nspname ,c.relname FROM pg_catalog.pg_class c LEFT JOIN pg_catalog.pg_namespace n ON n.oid = c.relnamespace where n.nspname like 'pg_temp_%' AND pg_catalog.pg_table_is_visible(c.oid) AND Upper(relname) = Upper($1);       IF FOUND THEN         RETURN TRUE;      ELSE         RETURN FALSE;      END IF;   END; $BODY$ LANGUAGE 'plpgsql' VOLATILE"
"private  class ParentLastClassLoader extends ClassLoader {      private String[] jarFiles; //Paths to the jar files     private Hashtable classes = new Hashtable(); //used to cache already defined classes      public ParentLastClassLoader(ClassLoader parent, String[] paths)     {         super(parent);         this.jarFiles = paths;     }      @Override     public Class&lt;?&gt; findClass(String name) throws ClassNotFoundException     {         System.out.println(""Trying to find"");         throw new ClassNotFoundException();     }      @Override     protected synchronized Class&lt;?&gt; loadClass(String className, boolean resolve) throws ClassNotFoundException     {         System.out.println(""Trying to load"");         try         {             System.out.println(""Loading class in Child : "" + className);             byte classByte[];             Class result = null;              //checks in cached classes             result = (Class) classes.get(className);             if (result != null) {                 return result;             }              for(String jarFile: jarFiles){                 try {                     JarFile jar = new JarFile(jarFile);                     JarEntry entry = jar.getJarEntry(className.replace(""."",""/"") + "".class"");                     InputStream is = jar.getInputStream(entry);                     ByteArrayOutputStream byteStream = new ByteArrayOutputStream();                     int nextValue = is.read();                     while (-1 != nextValue) {                         byteStream.write(nextValue);                         nextValue = is.read();                     }                      classByte = byteStream.toByteArray();                     result = defineClass(className, classByte, 0, classByte.length, null);                     classes.put(className, result);                 } catch (Exception e) {                     continue;                 }             }              result = (Class) classes.get(className);             if (result != null) {                 return result;             }             else{                 throw new ClassNotFoundException(""Not found ""+ className);             }         }         catch( ClassNotFoundException e ){              System.out.println(""Delegating to parent : "" + className);             // didn't find it, try the parent             return super.loadClass(className, resolve);         }     } }"
"String squery=""select date_demande as {d.date_demande},nom as {c.nom}, prénom as {c.prénom} from Demande d , Candidat c                    where d.id_candidat=c.id_candidat""; SQLQuery query=session.createSQLQuery(squery); query.setResultTransformer(Criteria.ALIAS_TO_ENTITY_MAP); Map&lt;String,Object&gt; row = null; List data = query.list(); for (Object object : data) {      row= (Map&lt;String,Object&gt;)object;      System.out.println(""date_demande: "" + row.get(""date_demande""));      System.out.println(""nom: "" + row.get(""nom""));      System.out.println(""prénom: "" + row.get(""prénom"")); }"
"int number = 7; //just an example, here binary rep: 00111 =&gt; requested output will be 10011     System.out.println(""number = "" + Integer.toBinaryString(number));     int mask3Bit = 4;//binary rep: 0100     System.out.println(""mask3Bit = "" + Integer.toBinaryString(mask3Bit));      int mask5Bit = 16; //binary rep: 10000     System.out.println(""mask5Bit = "" + Integer.toBinaryString(mask5Bit));      // now we'll create a mask that has all the bits on except the 3rd and 5th bit:     int oppositeMask = -1;     oppositeMask ^= mask3Bit;     oppositeMask ^= mask5Bit;     System.out.println(""oppositeMask = "" + Integer.toBinaryString(oppositeMask));      //check if the 3rd bit is on:     mask3Bit = number &amp; mask3Bit;     //shift twice to the right     mask3Bit &lt;&lt;= 2;     System.out.println(""mask3Bit = "" + Integer.toBinaryString(mask3Bit));     //now do the same with the 5th bit     //check if the 5th bit is on:     mask5Bit = number &amp; mask5Bit;     //shift twice to the right     mask5Bit &gt;&gt;= 2;     System.out.println(""mask5Bit = "" + Integer.toBinaryString(mask5Bit));      //now we'll turn off the 3rd and 5th bits in the original number     number &amp;= oppositeMask;     System.out.println(""number = "" + Integer.toBinaryString(number));     //and use the masks to switch the bits     number |= mask3Bit;     number |= mask5Bit;     //let's check it out now:     System.out.println(""new number = "" + Integer.toBinaryString(number));"
"public static void main(String args []){     // your code here..  }    public static void printUp(int[] array){     System.out.print(""Ascending"");     for(int i = 0; i &lt; array.length; i++){            if(array[i] &gt; 0)                 System.out.printf(""%5d\t%5d\n"",i,array[i]);     }  }   public static void printDown(int[] array){      System.out.print(""Descending"");      for(int i = 0; i &lt; array.length; i--){            if(array[i] &gt; 0)                System.out.printf(""%5d\t%5d\n"",i,array[i]);      } }"
"import java.security.NoSuchAlgorithmException;  import javax.crypto.Cipher; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec;  public class MCrypt {      private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)     private IvParameterSpec ivspec;     private SecretKeySpec keyspec;     private Cipher cipher;      private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)      public MCrypt()     {         ivspec = new IvParameterSpec(iv.getBytes());          keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");          try {             cipher = Cipher.getInstance(""AES/CBC/NoPadding"");         } catch (NoSuchAlgorithmException e) {             // TODO Auto-generated catch block             e.printStackTrace();         } catch (NoSuchPaddingException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }     }      public byte[] encrypt(String text) throws Exception     {         if(text == null || text.length() == 0)             throw new Exception(""Empty string"");          byte[] encrypted = null;          try {             cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);              encrypted = cipher.doFinal(padString(text).getBytes());         } catch (Exception e)         {                        throw new Exception(""[encrypt] "" + e.getMessage());         }          return encrypted;     }      public byte[] decrypt(String code) throws Exception     {         if(code == null || code.length() == 0)             throw new Exception(""Empty string"");          byte[] decrypted = null;          try {             cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);              decrypted = cipher.doFinal(hexToBytes(code));         } catch (Exception e)         {             throw new Exception(""[decrypt] "" + e.getMessage());         }         return decrypted;     }        public static String bytesToHex(byte[] data)     {         if (data==null)         {             return null;         }          int len = data.length;         String str = """";         for (int i=0; i&lt;len; i++) {             if ((data[i]&amp;0xFF)&lt;16)                 str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);             else                 str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);         }         return str;     }       public static byte[] hexToBytes(String str) {         if (str==null) {             return null;         } else if (str.length() &lt; 2) {             return null;         } else {             int len = str.length() / 2;             byte[] buffer = new byte[len];             for (int i=0; i&lt;len; i++) {                 buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);             }             return buffer;         }     }        private static String padString(String source)     {       char paddingChar = ' ';       int size = 16;       int x = source.length() % size;       int padLength = size - x;        for (int i = 0; i &lt; padLength; i++)       {           source += paddingChar;       }        return source;     } }"
"import java.security.NoSuchAlgorithmException;  import javax.crypto.Cipher; import javax.crypto.NoSuchPaddingException; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.SecretKeySpec;  public class MCrypt {      private String iv = ""fedcba9876543210"";//Dummy iv (CHANGE IT!)     private IvParameterSpec ivspec;     private SecretKeySpec keyspec;     private Cipher cipher;      private String SecretKey = ""0123456789abcdef"";//Dummy secretKey (CHANGE IT!)      public MCrypt()     {         ivspec = new IvParameterSpec(iv.getBytes());          keyspec = new SecretKeySpec(SecretKey.getBytes(), ""AES"");          try {             cipher = Cipher.getInstance(""AES/CBC/NoPadding"");         } catch (NoSuchAlgorithmException e) {             // TODO Auto-generated catch block             e.printStackTrace();         } catch (NoSuchPaddingException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }     }      public byte[] encrypt(String text) throws Exception     {         if(text == null || text.length() == 0)             throw new Exception(""Empty string"");          byte[] encrypted = null;          try {             cipher.init(Cipher.ENCRYPT_MODE, keyspec, ivspec);              encrypted = cipher.doFinal(padString(text).getBytes());         } catch (Exception e)         {                        throw new Exception(""[encrypt] "" + e.getMessage());         }          return encrypted;     }      public byte[] decrypt(String code) throws Exception     {         if(code == null || code.length() == 0)             throw new Exception(""Empty string"");          byte[] decrypted = null;          try {             cipher.init(Cipher.DECRYPT_MODE, keyspec, ivspec);              decrypted = cipher.doFinal(hexToBytes(code));         } catch (Exception e)         {             throw new Exception(""[decrypt] "" + e.getMessage());         }         return decrypted;     }        public static String bytesToHex(byte[] data)     {         if (data==null)         {             return null;         }          int len = data.length;         String str = """";         for (int i=0; i&lt;len; i++) {             if ((data[i]&amp;0xFF)&lt;16)                 str = str + ""0"" + java.lang.Integer.toHexString(data[i]&amp;0xFF);             else                 str = str + java.lang.Integer.toHexString(data[i]&amp;0xFF);         }         return str;     }       public static byte[] hexToBytes(String str) {         if (str==null) {             return null;         } else if (str.length() &lt; 2) {             return null;         } else {             int len = str.length() / 2;             byte[] buffer = new byte[len];             for (int i=0; i&lt;len; i++) {                 buffer[i] = (byte) Integer.parseInt(str.substring(i*2,i*2+2),16);             }             return buffer;         }     }        private static String padString(String source)     {       char paddingChar = ' ';       int size = 16;       int x = source.length() % size;       int padLength = size - x;        for (int i = 0; i &lt; padLength; i++)       {           source += paddingChar;       }        return source;     } }"
