code
"public class CopyUtil {    public void doTheCopy( List&lt;String&gt; resourceNames ) {      for ( String resource : resourceNames ) {        InputStream is = this.getClass().getClassLoader().getResourceAsStream(resource);       FileOutputStream fos =         new FileOutputStream( new File(System.getProperty(""user.dir""), resource));       byte[] buffer = new byte[1024];       int read = -1;       while( (read = is.read(buffer)) != -1 ) {         fos.write( buffer,0,read);       }       fos.flush();       fos.close();     }   } }"
"public class MyFrame extends JFrame {      public MyFrame() {         super(""My Frame"");          // You can set the content pane of the frame to your custom class.         setContentPane(new DrawPane());         setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         setSize(400, 400);         setVisible(true);     }     // Create a component that you can actually draw on.    class DrawPane extends JPanel {         public void paintComponent(Graphics g) {             g.fillRect(20, 20, 100, 200); // Draw on g here e.g.         }    }     public static void main(String args[]){         new MyFrame();    } }"
"method processWSDL(Document wsdl) {     for each (""/wsdl:definitions/wsdl:types/xsd:schema"" in wsdl) {         call processXSD(""inline_[i].xsd"",""."")     }     for each (""/wsdl:definitions/wsdl:import"" in wsdl) {         Document x = read and parse (""@location"")         if (x is WSDL) call processWSDL(x)         else if (x is XSD) call processXSD(""@location"", x)     } }  method processXSD(String filename, Document xsd) {     write ""xsd"" to a new file ""filename""   // if 'filename' is a URL, take only the part after the last '/'     for each (""/xsd:schema/xsd:import"" or ""/xsd:schema/xsd:include"" in xsd) {         if (""@schemaLocation"" is local reference) {     // no 'http://' prefix             Document x = read and parse (""@schemaLocation"")             call processXSD(""@schemaLocation"", x)         }     } }"
"DocumentBuilder builder = DocumentBuilderFactory.newInstance().newDocumentBuilder();  //build DOMs Document doc1 = builder.parse(new File(""file1.xml"")); Document doc2  = builder.parse(new File(""file2.xml""));  //get all node_ids from doc2 and iterate NodeList list = doc2.getElementsByTagName(""node_id""); for(int i = 0 ; i&lt; list.getLength() ; i++){      Node n = list.item(i);      //extract the id     String id = n.getTextContent();      //now get all node_id elements from doc1     NodeList list2 = doc1.getElementsByTagName(""node_""+id);     for(int j = 0 ; j&lt; list2.getLength() ; j++){          Node m = list2.item(j);          //import them into doc2         Node imp = doc2.importNode(m,true);         n.getParent().appendChild(imp);     } }  //write out the modified document to a new file TransformerFactory tFactory = TransformerFactory.newInstance();  Transformer transformer = tFactory.newTransformer(); Source source = new DOMSource(doc2); Result output = new StreamResult(new File(""merged.xml"")); transformer.transform(source, output);"
"try {   DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();   DocumentBuilder docBuilder = docFactory.newDocumentBuilder();   Document doc = docBuilder.parse(filePath);   Node rootNode = doc.getFirstChild();//for getting the root node    String expersion=""books/author"";//x-path experssion    XPathFactory factory = XPathFactory.newInstance();   XPath xpath = factory.newXPath();   XPathExpression expr = xpath.compile(expersion);   Node updateNode=null;   Object result = expr.evaluate(doc, XPathConstants.NODESET);   NodeList nodes = (NodeList) result;   updateNode=nodes.item(0);   updateNode.appendChild(doc.createCDATASection(""new value""));   TransformerFactory transformerFactory = TransformerFactory.newInstance();   Transformer transformer = transformerFactory.newTransformer();   DOMSource source = new DOMSource(doc);   StreamResult streamResult =  new StreamResult(new File(filePath));   transformer.transform(source, streamResult); } catch (Exception e) {   e.printStackTrace(); }"
"final ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());     final List&lt;Future&lt;String&gt;&gt; results = new LinkedList&lt;Future&lt;String&gt;&gt;();     // now you have all coords in memory     for (int i = 0; i &lt; coords.size(); i++) {         final int index = i;         final Coord c1 = coords.get(index);         results.add(executor.submit(new Callable&lt;String&gt;() {             public String call() {                 final StringBuilder stringBuilder = new StringBuilder();                 for (int j = 0; j &lt; coords.size(); j++) {                     final Coord c2 = coords.get(j);                     final double foo = ((c1.a - c2.a) * (c1.a - c2.a)) * 1;                     final double goo = ((c1.b - c2.b) * (c1.b - c2.b)) * 1;                     final double hoo = ((c1.c - c2.c) * (c1.c - c2.c)) * 2;                     final double joo = ((c1.d - c2.d) * (c1.d - c2.d)) * 2;                     final double koo = ((c1.e - c2.e) * (c1.e - c2.e)) * 4;                     final double loo = ((c1.f - c2.f) * (c1.f - c2.f)) * 4;                     final double zoo = Math.sqrt(foo + goo + hoo + joo + koo + loo);                      final DecimalFormat df = new DecimalFormat(""#.###"");                     stringBuilder.append(index + "" "" + j + "" "" + df.format(zoo));                     System.out.println(index);                 }                 return stringBuilder.toString();             }         }));     }     for (Future&lt;String&gt; result : results) {         pout.print(result.get());     }     pout.flush();     pout.close();     executor.shutdown();"
"public Component prepareRenderer(TableCellRenderer renderer, int row, int column) {             Component c = super.prepareRenderer(renderer, row, column);              if ((column == 2 || column == 3) &amp;&amp; (Boolean)getValueAt(row, 0)) {                 return c;             }          //    if (column == 0 || column == 1 || (Boolean) getValueAt(row, 0)) {             if (column == 0 || column == 1) {                 return c;             }              return Box.createRigidArea(c.getPreferredSize());         }"
"File baseDirectory = applicationContext.getFilesDir(); File file = new File( baseDirectory, ""settings.data"" ); if (file.exists()) {     //We have to convert it to newsettings.Data     byte[] convertedBytes = common.utils.SerializeTools.changePathInSerializedFile(file, ""old.path.data"", ""new.path.data"");      //Write converted file     File newFile = new File( baseDirectory, ""newsettings.data"" );     FileOutputStream fos = new FileOutputStream(newFile);     fos.write(convertedBytes);     fos.close();      //Remove old file     file.delete(); }"
"Git git = ... // you get it through a CloneCommand, InitCommand                // or through the file system  CheckoutCommand coCmd = git.checkout();  // Commands are part of the api module, which include git-like calls coCmd.setName(""master""); coCmd.setCreateBranch(false); // probably not needed, just to make sure coCmd.call(); // switch to ""master"" branch  MergeCommand mgCmd = git.merge(); mgCmd.include(""foo""); // ""foo"" is considered as a Ref to a branch MergeResult res = mgCmd.call(); // actually do the merge  if (res.getMergeStatus().equals(MergeResult.MergeStatus.CONFLICTING)){    System.out.println(res.getConflicts().toString());    // inform the user he has to handle the conflicts }"
"public static void outputXML(Document dom) throws TransformerException {     Transformer transformer = TransformerFactory.newInstance().newTransformer();     transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");      //initialize StreamResult with File object to save to file     StreamResult result = new StreamResult(new StringWriter());     DOMSource source = new DOMSource(dom);     transformer.transform(source, result);      String xmlString = result.getWriter().toString();     System.out.println(xmlString); }"
"DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();     DocumentBuilder builder = f.newDocumentBuilder();      Document d = builder.newDocument();     Element root = d.createElement(""root"");     d.appendChild(root);     root.setTextContent(""this text contains the \u2227 character"");      Transformer t = TransformerFactory.newInstance().newTransformer();     t.setOutputProperty(OutputKeys.ENCODING, ""US-ASCII"");     t.setOutputProperty(OutputKeys.INDENT, ""yes"");     t.transform(new DOMSource(d), new StreamResult(System.out));"
"Dyld maintains a current stack of paths called the run path list.   When @rpath is encountered it is substituted with each path in the   run path list until a loadable dylib if found. The run path stack   is built from the LC_RPATH load commands in the depencency chain   that lead to the current dylib load. You can add an LC_RPATH load   command to an image with the -rpath option to ld(1). You can even add   a LC_RPATH load command path that starts with @loader_path/, and it   will push a path on the run path stack that relative to the image   containing the LC_RPATH. The use of @rpath is most useful when you   have a complex directory structure of programs and dylibs which can be   installed anywhere, but keep their relative positions. This scenario   could be implemented using @loader_path, but every client of a dylib   could need a different load path because its relative position in the   file system is different. The use of @rpath introduces a level of   indirection that simplies things. You pick a location in your directory   structure as an anchor point. Each dylib then gets an install path that   starts with @rpath and is the path to the dylib relative to the anchor   point. Each main executable is linked with -rpath @loader_path/zzz,   where zzz is the path from the executable to the anchor point. At runtime   dyld sets it run path to be the anchor point, then each dylib is found   relative to the anchor point."
"Folder folder = (Folder) getSession().getObjectByPath(""/cmis-demo"");  String timeStamp = new Long(System.currentTimeMillis()).toString(); String filename = ""cmis-demo-doc ("" + timeStamp + "")"";  // Create a doc Map &lt;String, Object&gt; properties = new HashMap&lt;String, Object&gt;(); properties.put(PropertyIds.OBJECT_TYPE_ID, ""cmis:document""); properties.put(PropertyIds.NAME, filename); String docText = ""This is a sample document""; byte[] content = docText.getBytes(); InputStream stream = new ByteArrayInputStream(content); ContentStream contentStream = getSession().getObjectFactory().createContentStream(filename, Long.valueOf(content.length), ""text/plain"", stream);  Document doc = folder.createDocument(            properties,            contentStream,            VersioningState.MAJOR);  System.out.println(""Created: "" + doc.getId()); System.out.println(""Content Length: "" + doc.getContentStreamLength()); System.out.println(""Version label:"" + doc.getVersionLabel());  // Now update it with a new version if (doc.getAllowableActions().getAllowableActions().contains(org.apache.chemistry.opencmis.commons.enums.Action.CAN_CHECK_OUT)) {    doc.refresh();    String testName = doc.getContentStream().getFileName();    ObjectId idOfCheckedOutDocument = doc.checkOut();    Document pwc = (Document) session.getObject(idOfCheckedOutDocument);    docText = ""This is a sample document with an UPDATE"";    content = docText.getBytes();    stream = new ByteArrayInputStream(content);             contentStream = getSession().getObjectFactory().createContentStream(filename, Long.valueOf(content.length), ""text/plain"", stream);              ObjectId objectId = pwc.checkIn(false, null, contentStream, ""just a minor change"");    doc = (Document) session.getObject(objectId);    System.out.println(""Version label is now:"" + doc.getVersionLabel()); }"
"Document document = new Document(PageSize.LETTER);     PdfWriter writer = PdfWriter.getInstance(document, ""C:\sample.pdf"");     //set page event to PdfWriter instance that you use to prepare pdf     writer.setPageEvent(new HeaderAndFooter(name));     .... //Add your content to documne here and close the document at last      /*      * HeaderAndFooter class      */     public class HeaderAndFooter extends PdfPageEventHelper {      private String name = """";       protected Phrase footer;     protected Phrase header;      /*      * Font for header and footer part.      */     private static Font headerFont = new Font(Font.COURIER, 9,             Font.NORMAL,Color.blue);      private static Font footerFont = new Font(Font.TIMES_ROMAN, 9,             Font.BOLD,Color.blue);       /*      * constructor      */     public HeaderAndFooter(String name) {         super();          this.name = name;           header = new Phrase(""***** Header *****"");         footer = new Phrase(""**** Footer ****"");     }       @Override     public void onEndPage(PdfWriter writer, Document document) {          PdfContentByte cb = writer.getDirectContent();          //header content         String headerContent = ""Name: "" +name;          //header content         String footerContent = headerContent;         /*          * Header          */         ColumnText.showTextAligned(cb, Element.ALIGN_LEFT, new Phrase(headerContent,headerFont),                  document.leftMargin() - 1, document.top() + 30, 0);          /*          * Foooter          */         ColumnText.showTextAligned(cb, Element.ALIGN_RIGHT, new Phrase(String.format("" %d "",                  writer.getPageNumber()),footerFont),                  document.right() - 2 , document.bottom() - 20, 0);      }  }"
"try{         WebElement byId = driver.findElement(By.id(""by-id""));          System.out.println(byId.getTagName());          System.out.println(""get the text for web element with id='by-id' "");         System.out.println(""------------------------------------------------------------"");         System.out.println(byId.getText());         System.out.println(""------------------------------------------------------------"");         System.out.println(byId.getAttribute(""id""));         System.out.println(byId.getCssValue(""font-size""));     } }"
"String filename=""path/to/file/whatever.ttf"";//this is for testing normally we would store the font file in our app (knows as an embedded resource), see this for help on that http://stackoverflow.com/questions/13796331/jar-embedded-resources-nullpointerexception/13797070#13797070  Font font = Font.createFont(Font.TRUETYPE_FONT, new File(filename)); font = font.deriveFont(Font.BOLD,28);  GraphicsEnvironment ge = GraphicsEnvironment.getLocalGraphicsEnvironment(); ge.registerFont(font);  JLabel l = new JLabel(""Some Text""); l.setFont(font);"
"if (!window.Clipboard) {    var pasteCatcher = document.createElement(""apDiv1"");    pasteCatcher.setAttribute(""contenteditable"", """");    pasteCatcher.style.opacity = 0;    document.body.appendChild(pasteCatcher);    pasteCatcher.focus();    document.addEventListener(""click"", function() { pasteCatcher.focus(); }); }   window.addEventListener(""paste"", onPasteHandler);  function onPasteHandler(e) {     if(e.clipboardData) {         var items = e.clipboardData.items;         if(!items){             alert(""Image Not found"");         }         for (var i = 0; i &lt; items.length; ++i) {         if (items[i].kind === 'file' &amp;&amp; items[i].type === 'image/png') {             var blob = items[i].getAsFile(),                 source = window.webkitURL.createObjectURL(blob);              pastedImage = new Image();             pastedImage.src = source;              pasteData();             }         }     } }  function pasteData() {     drawCanvas = document.getElementById('drawCanvas1');     ctx = drawCanvas.getContext( '2d' );     ctx.clearRect(0, 0, 640,480);     ctx.drawImage(pastedImage, 0, 0); }"
public interface IArgumentParser {     Configuration Parse(string[] arguments); }  public static class ArgumentParsers {     public static IArgumentParser(string file)     {         return new FileArgumentParser(file);     } }  internal class FileArgumentParser : IArgumentParser {     private readonly string file;      internal FileArgumentParser(string file)     {         this.file = file;     }      public Configuration Parse(string[] arguments)     {         // Presumably use the file somewhere...     } }
"public static void main(String[] args) {             try {          String filePath = ""./foo.txt"";         // Use ""dxdiag /t"" variant to redirect output to a given file         ProcessBuilder pb = new ProcessBuilder(""cmd.exe"",""/c"",""dxdiag"",""/t"",filePath);         System.out.println(""-- Executing dxdiag command --"");         Process p = pb.start();         p.waitFor();          BufferedReader br = new BufferedReader(new FileReader(filePath));         String line;         System.out.println(String.format(""-- Printing %1$1s info --"",filePath));         while((line = br.readLine()) != null){             if(line.trim().startsWith(""Card name:"") || line.trim().startsWith(""Current Mode:"")){                 System.out.println(line.trim());             }         }     } catch (IOException | InterruptedException ex) {         ex.printStackTrace();     }  }"
"public class BuildTermDocumentMatrix { public BuildTermDocumentMatrix(File index, File corpus) throws IOException{     reader = DirectoryReader.open(FSDirectory.open(index));     searcher = new IndexSearcher(reader);     this.corpus = corpus;     termIdMap = computeTermIdMap(reader); }    /** *  Map term to a fix integer so that we can build document matrix later. *  It's used to assign term to specific row in Term-Document matrix */ private Map&lt;String, Integer&gt; computeTermIdMap(IndexReader reader) throws IOException {     Map&lt;String,Integer&gt; termIdMap = new HashMap&lt;String,Integer&gt;();     int id = 0;     Fields fields = MultiFields.getFields(reader);     Terms terms = fields.terms(""contents"");     TermsEnum itr = terms.iterator(null);     BytesRef term = null;     while ((term = itr.next()) != null) {                        String termText = term.utf8ToString();                       if (termIdMap.containsKey(termText))             continue;         //System.out.println(termText);          termIdMap.put(termText, id++);     }      return termIdMap; }  /** *  build term-document matrix for the given directory */ public RealMatrix buildTermDocumentMatrix () throws IOException {     //iterate through directory to work with each doc     int col = 0;     int numDocs = countDocs(corpus);            //get the number of documents here           int numTerms = termIdMap.size();    //total number of terms          RealMatrix tdMatrix = new Array2DRowRealMatrix(numTerms, numDocs);      for (File f : corpus.listFiles()) {         if (!f.isHidden() &amp;&amp; f.canRead()) {             //I build term document matrix for a subset of corpus so             //I need to lookup document by path name.              //If you build for the whole corpus, just iterate through all documents             String path = f.getPath();             BooleanQuery pathQuery = new BooleanQuery();             pathQuery.add(new TermQuery(new Term(""path"", path)), BooleanClause.Occur.SHOULD);             TopDocs hits = searcher.search(pathQuery, 1);              //get term vector             Terms termVector = reader.getTermVector(hits.scoreDocs[0].doc, ""contents"");             TermsEnum itr = termVector.iterator(null);             BytesRef term = null;              //compute term weight             while ((term = itr.next()) != null) {                                String termText = term.utf8ToString();                               int row = termIdMap.get(termText);                 long termFreq = itr.totalTermFreq();                 long docCount = itr.docFreq();                 double weight = computeTfIdfWeight(termFreq, docCount, numDocs);                 tdMatrix.setEntry(row, col, weight);             }             col++;         }     }            return tdMatrix; } }"
"StructDescriptor projectTypeDesc = StructDescriptor.createDescriptor(""MY_TYPE"", connection);  // array holding structs, where each struct is based on an array //   with fields of Project object STRUCT[] projectsAsStructs = new STRUCT[projectList.size()];  // for each Project object, create a STRUCT object containing its fields for (int i = 0; i &lt; projectList.size(); ++i) {   Project project = projectList.get(i);    Object[] projectFields = new Object[] {project.getProjectId(),                                          project.getProjectTitle()};    STRUCT projectStruct = new STRUCT(projectTypeDesc,                                     connection, projectFields);    projectsAsStructs[i] = projectStruct; }  // now you have all your Project objects ready to be saved in one go: ArrayDescriptor projectTypeArrayDesc = ArrayDescriptor.createDescriptor (""MY_ARRAY"", connection);   ARRAY arrayOfProjects = new ARRAY(projectTypeArrayDesc, connection,                                   projectsAsStructs);  callablestatement.setArray(1, arrayOfProjects);"
"JNIEnv * env; jclass loadedJavaClass; jmethodID loadedJavaMethod;  //assume JVM, class, and method are already loaded at this point.  //Get c string from std::string object pointer const char * c_string = ((std::string*) pPin-&gt;GetUserData())-&gt;c_str();  //Create jstring from string jstring stuff = env-&gt;NewStringUTF( c_string );  //pass jstring to Java function env-&gt;CallStaticVoidMethod( loadedJavaClass, loadedJavaMethod, stuff );  //remove local reference to jstring JavaEnvironment::getEnvironment()-&gt;DeleteLocalRef(stuff);"
"import com.itextpdf.text.Document; import com.itextpdf.text.Element; import com.itextpdf.text.Phrase; import com.itextpdf.text.pdf.ColumnText; import com.itextpdf.text.pdf.PdfPageEventHelper; import com.itextpdf.text.pdf.PdfWriter;  public class HeaderFooterPageEvent extends PdfPageEventHelper {      public void onStartPage(PdfWriter writer, Document document) {         ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_CENTER, new Phrase(""Top Left""), 30, 800, 0);         ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_CENTER, new Phrase(""Top Right""), 550, 800, 0);     }      public void onEndPage(PdfWriter writer, Document document) {         ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_CENTER, new Phrase(""http://www.xxxx-your_example.com/""), 110, 30, 0);         ColumnText.showTextAligned(writer.getDirectContent(), Element.ALIGN_CENTER, new Phrase(""page "" + document.getPageNumber()), 550, 30, 0);     }  }"
"import com.sun.codemodel.*; import com.sun.tools.xjc.api.*; import org.xml.sax.InputSource;  // Configure sources &amp; output String schemaPath = ""path/to/schema.xsd""; String outputDirectory = ""schema/output/source/"";  // Setup schema compiler SchemaCompiler sc = XJC.createSchemaCompiler(); sc.forcePackageName(""com.xyz.schema.generated"");  // Setup SAX InputSource File schemaFile = new File(schemaPath); InputSource is = new InputSource(new FileInputStream(schemaFile)); is.setSystemId(schemaFile.getAbsolutePath());  // Parse &amp; build sc.parseSchema(is); S2JJAXBModel model = sc.bind(); JCodeModel jCodeModel = model.generateCode(null, null); jCodeModel.build(new File(outputDirectory));"
"public class References {      // First, initialise all unique keys     public static final UniqueKey&lt;TAuthorRecord&gt; SysPk_14655 =          createUniqueKey(TAuthor.T_AUTHOR, TAuthor.ID);       // Then initialise all foreign keys     public static final Reference&lt;TBookRecord, TAuthorRecord&gt; SysFk_14666 =          createReference(SysPk_14655, TBook.T_BOOK, TBook.AUTHOR_ID);     public static final Reference&lt;TBookRecord, TAuthorRecord&gt; SysFk_14667 =          createReference(SysPk_14655, TBook.T_BOOK, TBook.CO_AUTHOR_ID);       // Factory method for unique keys     protected static &lt;R extends Record&gt; UniqueKey&lt;R&gt;      createUniqueKey(Table&lt;R&gt; table, TableField&lt;R, ?&gt;... fields) {      // Factory method for foreign keys referencing unique keys     protected static &lt;R extends Record, U extends Record&gt; Reference&lt;R, U&gt;      createReference(UniqueKey&lt;U&gt; key, Table&lt;R&gt; table, TableField&lt;R, ?&gt;... fields) {  }"
"Path folder = Paths.get(System.getProperty(&quot;upload.location&quot;)); String filename = FilenameUtils.getBaseName(uploadedFile.getName());  String extension = FilenameUtils.getExtension(uploadedFile.getName()); Path file = Files.createTempFile(folder, filename + &quot;-&quot;, &quot;.&quot; + extension);  try (InputStream input = uploadedFile.getInputStream()) {     Files.copy(input, file, StandardCopyOption.REPLACE_EXISTING); }  String uploadedFileName = file.getFileName().toString(); // Now store it in DB."
"textField = new JTextField();     // set document listener     textField.getDocument().addDocumentListener(new MyListener());     // get the preferences associated with your application     Preferences prefs = Preferences.userRoot().node(""unique_string_representing_your_preferences"");     // load previous value     textField.setText(prefs.get(""your_preference_unique_key"", """"));  class MyListener implements DocumentListener {      @Override     public void changedUpdate(DocumentEvent event) {         final Document document = event.getDocument();         // get the preferences associated with your application         Preferences prefs = Preferences.userRoot().node(""unique_string_representing_your_preferences"");         try {             // save textfield value in the preferences object             prefs.put(""your_preference_unique_key"", document.getText(0, document.getLength()));         } catch (BadLocationException e) {             e.printStackTrace();         }     }      @Override     public void insertUpdate(DocumentEvent arg0) {     }      @Override     public void removeUpdate(DocumentEvent arg0) {     } }"
"Path file = ...; BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);  System.out.println(""creationTime: "" + attr.creationTime()); System.out.println(""lastAccessTime: "" + attr.lastAccessTime()); System.out.println(""lastModifiedTime: "" + attr.lastModifiedTime());  System.out.println(""isDirectory: "" + attr.isDirectory()); System.out.println(""isOther: "" + attr.isOther()); System.out.println(""isRegularFile: "" + attr.isRegularFile()); System.out.println(""isSymbolicLink: "" + attr.isSymbolicLink()); System.out.println(""size: "" + attr.size());"
"public class RenderSceneServlet extends HttpServlet {     protected void doGet(HttServletRequest request, HttpServletResponse response) {         String outputFile = ""/path/to/output-file"";          // execute command to render a frame from scene.blend         Runtime runtime = Runtime.getRuntime();         Process exec = runtime.exec(""blender -b scene.blend -o "" + outputFile + "" -F JPEG -x 1 -f 1"");          // wait for blender to finish         exec.waitFor();          // serve the rendered file         File file = new File(outputFile);         byte[] bytes = FileUtils.readFileToByteArray(file);         response.setContentLength(bytes.length);         response.setContentType(""image/jpeg"");         response.getOutputStream().write(bytes);     } }"
"public String getStringFromDoc(Document doc) throws TransformerException {          DOMSource domSource = new DOMSource(doc);         StringWriter writer = new StringWriter();         StreamResult result = new StreamResult(writer);         TransformerFactory tf = TransformerFactory.newInstance();         Transformer transformer = tf.newTransformer();         transformer.setOutputProperty(OutputKeys.ENCODING, ""UTF-8"");         transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");         transformer.transform(domSource, result);         writer.flush();         return writer.toString();     }"
