code
"package net.pms.plugin.webservice.filesystem;  import java.io.File; import java.io.FileNotFoundException; import java.util.ArrayList; import java.util.List;  import javax.jws.WebMethod; import javax.jws.WebParam; import javax.jws.WebService;  import net.pms.plugin.webservice.ServiceBase;  @WebService(serviceName = ""FileSystem"", targetNamespace = ""http://ps3mediaserver.org/filesystem"") public class FileSystemWebService extends ServiceBase {      @WebMethod()     public List&lt;String&gt; getRoots() {         List&lt;String&gt; roots = new ArrayList&lt;String&gt;();         for(File child : File.listRoots()) {             roots.add(child.getAbsolutePath());         }         return roots;     }      @WebMethod()     public List&lt;String&gt; getChildFolders(@WebParam(name=""folderPath"") String folderPath) throws FileNotFoundException {         List&lt;String&gt; children = new ArrayList&lt;String&gt;();         File d = new File(folderPath);         if(d.isDirectory()) {             for(File child : d.listFiles()) {                 if(child.isDirectory() &amp;&amp; !child.isHidden()) {                     children.add(child.getAbsolutePath());                 }             }         } else {             throw new FileNotFoundException();         }         return children;     } }"
"package inlinecompiler;  import java.io.File; import java.io.FileWriter; import java.io.IOException; import java.io.Writer; import java.net.URL; import java.net.URLClassLoader; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import javax.tools.Diagnostic; import javax.tools.DiagnosticCollector; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.StandardJavaFileManager; import javax.tools.ToolProvider;  public class InlineCompiler {      public static void main(String[] args) {         StringBuilder sb = new StringBuilder(64);         sb.append(""package testcompile;\n"");         sb.append(""public class HelloWorld implements inlinecompiler.InlineCompiler.DoStuff {\n"");         sb.append(""    public void doStuff() {\n"");         sb.append(""        System.out.println(\""Hello world\"");\n"");         sb.append(""    }\n"");         sb.append(""}\n"");          File helloWorldJava = new File(""testcompile/HelloWorld.java"");         if (helloWorldJava.getParentFile().exists() || helloWorldJava.getParentFile().mkdirs()) {              try {                 Writer writer = null;                 try {                     writer = new FileWriter(helloWorldJava);                     writer.write(sb.toString());                     writer.flush();                 } finally {                     try {                         writer.close();                     } catch (Exception e) {                     }                 }                  /** Compilation Requirements *********************************************************************************************/                 DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();                 JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();                 StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnostics, null, null);                  // This sets up the class path that the compiler will use.                 // I've added the .jar file that contains the DoStuff interface within in it...                 List&lt;String&gt; optionList = new ArrayList&lt;String&gt;();                 optionList.add(""-classpath"");                 optionList.add(System.getProperty(""java.class.path"") + File.pathSeparator + ""dist/InlineCompiler.jar"");                  Iterable&lt;? extends JavaFileObject&gt; compilationUnit                         = fileManager.getJavaFileObjectsFromFiles(Arrays.asList(helloWorldJava));                 JavaCompiler.CompilationTask task = compiler.getTask(                     null,                      fileManager,                      diagnostics,                      optionList,                      null,                      compilationUnit);                 /********************************************************************************************* Compilation Requirements **/                 if (task.call()) {                     /** Load and execute *************************************************************************************************/                     System.out.println(""Yipe"");                     // Create a new custom class loader, pointing to the directory that contains the compiled                     // classes, this should point to the top of the package structure!                     URLClassLoader classLoader = new URLClassLoader(new URL[]{new File(""./"").toURI().toURL()});                     // Load the class from the classloader by name....                     Class&lt;?&gt; loadedClass = classLoader.loadClass(""testcompile.HelloWorld"");                     // Create a new instance...                     Object obj = loadedClass.newInstance();                     // Santity check                     if (obj instanceof DoStuff) {                         // Cast to the DoStuff interface                         DoStuff stuffToDo = (DoStuff)obj;                         // Run it baby                         stuffToDo.doStuff();                     }                     /************************************************************************************************* Load and execute **/                 } else {                     for (Diagnostic&lt;? extends JavaFileObject&gt; diagnostic : diagnostics.getDiagnostics()) {                         System.out.format(""Error on line %d in %s%n"",                                 diagnostic.getLineNumber(),                                 diagnostic.getSource().toUri());                     }                 }                 fileManager.close();             } catch (IOException | ClassNotFoundException | InstantiationException | IllegalAccessException exp) {                 exp.printStackTrace();             }         }     }      public static interface DoStuff {          public void doStuff();     }  }"
"import java.util.List; import java.util.Set;  import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.Element; import javax.lang.model.element.ElementKind; import javax.lang.model.element.TypeElement; import javax.tools.Diagnostic.Kind;  @SupportedSourceVersion(SourceVersion.RELEASE_7) @SupportedAnnotationTypes(""*"") public class Test extends AbstractProcessor {     public int shit;     public int foo;      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         Set&lt;? extends Element&gt; rootElements = roundEnv.getRootElements();          for (Element element : rootElements) {             if (element.getKind() == ElementKind.CLASS) {                 List&lt;? extends Element&gt; classElements = element.getEnclosedElements();                  for (Element classElement : classElements) {                     if (classElement.getKind() == ElementKind.FIELD) {                         if (classElement.getSimpleName().contentEquals(""shit"")) {                             processingEnv.getMessager().printMessage(                                 Kind.WARNING,                                 ""How dare you to swear in the source code?!"",                                 classElement                             );                         }                     }                 }             }         }          return false;     }      public static void main(String[] args) {         //     } }"
"import java.io.IOException; import java.io.PrintWriter; import java.io.StringWriter; import java.lang.reflect.InvocationTargetException; import java.net.URI; import java.util.Arrays;  import javax.tools.Diagnostic; import javax.tools.DiagnosticCollector; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.SimpleJavaFileObject; import javax.tools.ToolProvider; import javax.tools.JavaCompiler.CompilationTask; import javax.tools.JavaFileObject.Kind;  public class CompileSourceInMemory {   public static void main(String args[]) throws IOException {     JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();     DiagnosticCollector&lt;JavaFileObject&gt; diagnostics = new DiagnosticCollector&lt;JavaFileObject&gt;();      StringWriter writer = new StringWriter();     PrintWriter out = new PrintWriter(writer);     out.println(""public class HelloWorld {"");     out.println(""  public static void main(String args[]) {"");     out.println(""    System.out.println(\""This is in another java file\"");"");         out.println(""  }"");     out.println(""}"");     out.close();     JavaFileObject file = new JavaSourceFromString(""HelloWorld"", writer.toString());      Iterable&lt;? extends JavaFileObject&gt; compilationUnits = Arrays.asList(file);     CompilationTask task = compiler.getTask(null, null, diagnostics, null, null, compilationUnits);      boolean success = task.call();     for (Diagnostic diagnostic : diagnostics.getDiagnostics()) {       System.out.println(diagnostic.getCode());       System.out.println(diagnostic.getKind());       System.out.println(diagnostic.getPosition());       System.out.println(diagnostic.getStartPosition());       System.out.println(diagnostic.getEndPosition());       System.out.println(diagnostic.getSource());       System.out.println(diagnostic.getMessage(null));      }     System.out.println(""Success: "" + success);      if (success) {       try {         Class.forName(""HelloWorld"").getDeclaredMethod(""main"", new Class[] { String[].class })             .invoke(null, new Object[] { null });       } catch (ClassNotFoundException e) {         System.err.println(""Class not found: "" + e);       } catch (NoSuchMethodException e) {         System.err.println(""No such method: "" + e);       } catch (IllegalAccessException e) {         System.err.println(""Illegal access: "" + e);       } catch (InvocationTargetException e) {         System.err.println(""Invocation target: "" + e);       }     }   } }  class JavaSourceFromString extends SimpleJavaFileObject {   final String code;    JavaSourceFromString(String name, String code) {     super(URI.create(""string:///"" + name.replace('.','/') + Kind.SOURCE.extension),Kind.SOURCE);     this.code = code;   }    @Override   public CharSequence getCharContent(boolean ignoreEncodingErrors) {     return code;   } }"
"import javax.swing.*; import java.awt.*; import java.awt.datatransfer.Clipboard; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.StringSelection; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.awt.event.InputEvent; import java.awt.event.KeyEvent; import java.util.StringTokenizer;     /**  * ExcelAdapter enables Copy-Paste Clipboard functionality on JTables. The clipboard data format used by the adapter is  * compatible with the clipboard format used by Excel. This provides for clipboard interoperability between enabled  * JTables and Excel.  */ public class ExcelAdapter implements ActionListener {       private String rowstring, value;     private Clipboard clipboard;     private StringSelection stsel;     private JTable jTable1;       /**      * The Excel Adapter is constructed with a JTable on which it enables Copy-Paste and acts as a Clipboard listener.      */     public ExcelAdapter(JTable myJTable) {          jTable1 = myJTable;         final KeyStroke copy = KeyStroke.getKeyStroke(KeyEvent.VK_C, InputEvent.CTRL_MASK, false);         // Identifying the copy KeyStroke user can modify this         // to copy on some other Key combination.         final KeyStroke paste = KeyStroke.getKeyStroke(KeyEvent.VK_V, InputEvent.CTRL_MASK, false);         // Identifying the Paste KeyStroke user can modify this         //to copy on some other Key combination.         jTable1.registerKeyboardAction(this, ""Copy"", copy, JComponent.WHEN_FOCUSED);         jTable1.registerKeyboardAction(this, ""Paste"", paste, JComponent.WHEN_FOCUSED);         clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();     }       /**      * Public Accessor methods for the Table on which this adapter acts.      */     public JTable getJTable() {          return jTable1;     }       public void setJTable(JTable jTable1) {          this.jTable1 = jTable1;     }       /**      * This method is activated on the Keystrokes we are listening to in this implementation. Here it listens for Copy      * and Paste ActionCommands. Selections comprising non-adjacent cells result in invalid selection and then copy      * action cannot be performed. Paste is done by aligning the upper left corner of the selection with the 1st element      * in the current selection of the JTable.      */     @Override     public void actionPerformed(ActionEvent e) {          final String actionCommand = e.getActionCommand();          if (actionCommand.equals(""Copy"")) {              StringBuilder sbf = new StringBuilder();             // Check to ensure we have selected only a contiguous block of cells.             final int numcols = jTable1.getSelectedColumnCount();             final int numrows = jTable1.getSelectedRowCount();             final int[] rowsselected = jTable1.getSelectedRows();             final int[] colsselected = jTable1.getSelectedColumns();              if (!((numrows - 1 == rowsselected[rowsselected.length - 1] - rowsselected[0] &amp;&amp;                     numrows == rowsselected.length) &amp;&amp;                     (numcols - 1 == colsselected[colsselected.length - 1] - colsselected[0] &amp;&amp;                             numcols == colsselected.length))) {                 JOptionPane.showMessageDialog(null, ""Invalid Copy Selection"",                                               ""Invalid Copy Selection"",                                               JOptionPane.ERROR_MESSAGE);                 return;             }             for (int i = 0; i &lt; numrows; i++) {                 for (int j = 0; j &lt; numcols; j++) {                     sbf.append(jTable1.getValueAt(rowsselected[i], colsselected[j]));                     if (j &lt; numcols - 1) {                         sbf.append('\t');                     }                 }                 sbf.append('\n');             }             stsel = new StringSelection(sbf.toString());             clipboard = Toolkit.getDefaultToolkit().getSystemClipboard();             clipboard.setContents(stsel, stsel);          } else if (actionCommand.equals(""Paste"")) {              System.out.println(""Trying to Paste"");             final int startRow = (jTable1.getSelectedRows())[0];             final int startCol = (jTable1.getSelectedColumns())[0];             try {                 final String trString = (String) (clipboard.getContents(this).getTransferData(DataFlavor.stringFlavor));                 System.out.println(""String is:"" + trString);                 final StringTokenizer st1 = new StringTokenizer(trString, ""\n"");                 for (int i = 0; st1.hasMoreTokens(); i++) {                     rowstring = st1.nextToken();                     StringTokenizer st2 = new StringTokenizer(rowstring, ""\t"");                     for (int j = 0; st2.hasMoreTokens(); j++) {                         value = (String) st2.nextToken();                         if (startRow + i &lt; jTable1.getRowCount() &amp;&amp;                                 startCol + j &lt; jTable1.getColumnCount()) {                             jTable1.setValueAt(value, startRow + i, startCol + j);                         }                         System.out.println(""Putting "" + value + ""at row = "" + startRow + i + "" column = "" + startCol + j);                     }                 }             } catch (Exception ex) {                 ex.printStackTrace();             }          }      }  }"
"import org.ccil.cowan.tagsoup.Parser; import org.w3c.dom.DOMImplementation; import org.w3c.dom.Document; import org.xml.sax.*;  import javax.xml.parsers.DocumentBuilder; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMResult; import javax.xml.transform.sax.SAXSource; import java.io.IOException;  public class MyDocumentBuilder extends DocumentBuilder {      @Override     public Document parse(InputSource inputSource) throws SAXException, IOException {          XMLReader xmlReader = new Parser();         xmlReader.setFeature(Parser.namespacesFeature, false);         xmlReader.setFeature(Parser.namespacePrefixesFeature, false);          try{             Transformer transformer = TransformerFactory.newInstance().newTransformer();             DOMResult domResult = new DOMResult();             transformer.transform(new SAXSource(xmlReader, inputSource), domResult);             return (Document) domResult.getNode();         }         catch(Exception exp){             throw new RuntimeException(""Error parsing with Tagsoup"");         }     }      @Override     public void setErrorHandler(ErrorHandler errorHandler) {      }      @Override     public Document newDocument() {         return null;     }      @Override     public void setEntityResolver(EntityResolver entityResolver) {      }      @Override     public boolean isValidating() {         return false;     }      @Override     public DOMImplementation getDOMImplementation() {         return null;     }      @Override     public boolean isNamespaceAware() {         return false;     } }"
";-------------------------------- ;Defines    !define JavaRegKey 'HKLM ""Software\JavaSoft\Java Runtime Environment"" """"'  ;-------------------------------- ;Installer Sections Section 'Java Runtime' SecJava    SetOutPath '$TEMP'   SetOverwrite on   File 'c:\&lt;yourdir&gt;\javasetup.exe'   ExecWait '$TEMP\javasetup.exe' $0   DetailPrint '..Java Runtime Setup exit code = $0'   Delete '$TEMP\javasetup.exe'  SectionEnd  ;-------------------------------- ;   Functions Function .onInit    ReadRegStr $R0 ${JavaRegKey}   StrCmp $R0 """" JavaMissing JavaFound    JavaFound:    !insertmacro UnselectSection ${SecJava}   Goto JavaCheckDone    JavaMissing:   !insertmacro SelectSection ${SecJava}    JavaCheckDone:  FunctionEnd"
"import javax.imageio.ImageIO; import javax.imageio.ImageReader; import javax.imageio.event.IIOReadProgressListener; import javax.imageio.stream.ImageInputStream; import java.io.File; import java.util.Iterator; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.atomic.AtomicInteger;  class MultipleJPEGDecoding {     private static int threads = Runtime.getRuntime().availableProcessors();     private static ExecutorService executorService = Executors.newFixedThreadPool(threads * 4);      public static void main(final String[] args) throws InterruptedException {         for (int i = 0; i &lt; 100; i++) {             final int index = i;              executorService.submit(new Runnable() {                 public void run() {                     try {                         ImageInputStream stream = ImageIO.createImageInputStream(new File(args[index % args.length]));                         try {                             Iterator&lt;ImageReader&gt; readers = ImageIO.getImageReaders(stream);                             if (!readers.hasNext()) {                                 System.err.println(&quot;No reader!&quot;);                                 return;                             }                              ImageReader reader = readers.next();                             reader.setInput(stream);                             reader.addIIOReadProgressListener(new ProgressListener(index));                              try {                                 reader.read(0);                             }                             finally {                                 reader.dispose();                             }                         }                         finally {                             stream.close();                         }                     }                     catch (Exception e) {                         System.err.printf(&quot;Error reading %d\n&quot;, index);                         e.printStackTrace();                     }                 }             });         }          executorService.shutdown();     }      static class ProgressListener implements IIOReadProgressListener {         final static AtomicInteger simultaneous = new AtomicInteger(0);          final int index;         int nextProgress = 25;          public ProgressListener(int index) {             this.index = index;         }          public void imageStarted(ImageReader source, int imageIndex) {             int inProgress = simultaneous.incrementAndGet();             System.err.printf(&quot;Started reading image %d (now decoding %d images simultaneous)...\n&quot;, index, inProgress);         }          public void imageComplete(ImageReader source) {             int inProgress = simultaneous.decrementAndGet();             System.err.printf(&quot;Done reading image %d%s.\n&quot;, index, inProgress &gt; 0 ? String.format(&quot; (still decoding %d other images)&quot;, inProgress) : &quot;&quot;);         }          public void imageProgress(ImageReader source, float percentageDone) {             if (percentageDone &gt; nextProgress) {                 int inProgress = simultaneous.get();                 System.err.printf(&quot;Progress on image %d (now decoding %d images simultaneous)...\n&quot;, index, inProgress);                 nextProgress += 25;             }         }          public void sequenceStarted(ImageReader source, int minIndex) {         }          public void sequenceComplete(ImageReader source) {         }          public void thumbnailStarted(ImageReader source, int imageIndex, int thumbnailIndex) {         }          public void thumbnailProgress(ImageReader source, float percentageDone) {         }          public void thumbnailComplete(ImageReader source) {         }          public void readAborted(ImageReader source) {         }     } }"
import java.util.ArrayList; import java.util.List;  import javax.xml.bind.annotation.XmlAccessType; import javax.xml.bind.annotation.XmlAccessorType; import javax.xml.bind.annotation.XmlAttribute; import javax.xml.bind.annotation.XmlElementRef; import javax.xml.bind.annotation.XmlRootElement;  @XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) public class Project {      @XmlAttribute     private String name;      @XmlElementRef     private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;();  }
"import java.io.BufferedReader; import java.io.DataOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL; import java.util.Date; import java.util.Map; import java.util.Set;  import org.json.simple.JSONObject; import org.json.simple.parser.JSONParser; import org.json.simple.parser.ParseException;   try{                 URL url = new URL(basicPayPalPath+""/v1/oauth2/token"");                 HttpURLConnection uc = (HttpURLConnection) url.openConnection();                 uc.setRequestMethod(""POST"");                 uc.setDoOutput(true);                 String userpass = clientID + "":"" + clientSecret;                 String basicAuth = ""Basic "" + javax.xml.bind.DatatypeConverter.printBase64Binary(userpass.getBytes());                  uc.setRequestProperty(""Accept"", ""application/json"");                 uc.setRequestProperty(""Authorization"", basicAuth);                 uc.setRequestProperty(""Content-Type"", ""application/x-www-form-urlencoded"");                 DataOutputStream wr = new DataOutputStream (uc.getOutputStream ());                 wr.writeBytes (""grant_type=client_credentials"");                 wr.flush ();                 wr.close ();                  InputStream is = uc.getInputStream();                 BufferedReader rd = new BufferedReader(new InputStreamReader(is));                 String line;                 StringBuffer response = new StringBuffer();                  while((line = rd.readLine()) != null) {                     response.append(line);                     response.append('\r');                 }                 rd.close();                 JSONParser jsonParser = new JSONParser();                 System.out.println(response.toString());                 JSONObject jsonObject = (JSONObject) jsonParser.parse(response.toString());                 Set&lt;Map.Entry&lt;String, String&gt;&gt; map = jsonObject.entrySet();                 for(Map.Entry&lt;String, String&gt; entry : map){                     System.out.println(entry.toString());                 }             }catch (IOException | ParseException e){                 e.printStackTrace();             }"
"package test;  import java.awt.Color; import java.io.File; import java.io.FileOutputStream; import java.io.InputStream; import java.io.OutputStream;  import org.apache.pdfbox.pdmodel.PDDocument; import org.apache.pdfbox.pdmodel.PDPage; import org.apache.pdfbox.pdmodel.edit.PDPageContentStream; import org.apache.pdfbox.pdmodel.font.PDFont; import org.apache.pdfbox.pdmodel.font.PDTrueTypeFont;  public class Main {     // TODO adapt 1st two constants     private static final String FILE_OUTPUT_PATH = ""yourPath/yourFile.pdf"";      private static final String FONT_PATH = ""test/yourUnicodeFont.ttf"";     private static final String EXAMPLE = ""\u060F"";      public static void main(String[] args) {          // if the following line returns garbage characters,         // make sure you set your project (and console output) to UTF-8         System.out.println(EXAMPLE);         PDDocument document = null;         try {             // generates custom document             document = new PDDocument();             // gets the Arial.ttf font you placed in your src/test folder             InputStream fontStream = Main.class.getClassLoader()                     .getResourceAsStream(FONT_PATH);             // loads it in the doc             PDFont font = PDTrueTypeFont.loadTTF(document, fontStream);              // closes the stream             fontStream.close();             // initializing a new PDF page             PDPage page = new PDPage();             // initializing a page content stream             PDPageContentStream stream = new PDPageContentStream(document,                     page, true, false);             // assigining font to page content stream             stream.setFont(font, 24);             // setting color             stream.setNonStrokingColor(Color.BLACK);             // starts drawing text             stream.beginText();             // draws something in Arabic                 stream.drawString(EXAMPLE);             // stops drawing text             stream.endText();             // closes stream             stream.close();             // imports the page into the doc             document.importPage(page);             // creating file             File file = new File(FILE_OUTPUT_PATH);             file.createNewFile();             // creating output stream             OutputStream outputStream = new FileOutputStream(file);             // saving doc content to stream             document.save(outputStream);             // flushing stream             outputStream.flush();             // closing stream             outputStream.close();         }         // oops! something wrong happened, see stack trace         catch (Throwable t) {             t.printStackTrace();         }         finally {             // closing doc             if (document != null) {                 try {                     document.close();                 }                 // oops!                 catch (Throwable t) {                     t.printStackTrace();                 }             }         }     } }"
"import java.util.ArrayList; import java.util.Enumeration; import java.util.List; import javax.jms.JMSException; import javax.jms.MessageConsumer; import javax.jms.MessageProducer; import javax.jms.Queue; import javax.jms.QueueBrowser; import javax.jms.QueueConnection; import javax.jms.QueueConnectionFactory; import javax.jms.Session; import javax.jms.TextMessage;  import oracle.AQ.AQQueueTable; import oracle.AQ.AQQueueTableProperty; import oracle.jms.AQjmsDestination; import oracle.jms.AQjmsDestinationProperty; import oracle.jms.AQjmsFactory; import oracle.jms.AQjmsSession;  public class OracleAQClient {  public static QueueConnection getConnection() {      String hostname = ""localhost"";     String oracle_sid = ""xe"";     int portno = 1521;     String userName = ""jmsuser"";     String password = ""jmsuser"";     String driver = ""thin"";     QueueConnectionFactory QFac = null;     QueueConnection QCon = null;     try {         // get connection factory , not going through JNDI here         QFac = AQjmsFactory.getQueueConnectionFactory(hostname, oracle_sid, portno, driver);         // create connection         QCon = QFac.createQueueConnection(userName, password);     } catch (Exception e) {         e.printStackTrace();     }     return QCon; }  public static void createQueue(String user, String qTable, String queueName) {     try {         /* Create Queue Tables */         System.out.println(""Creating Queue Table..."");         QueueConnection QCon = getConnection();         Session session = QCon.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);          AQQueueTableProperty qt_prop;         AQQueueTable q_table = null;         AQjmsDestinationProperty dest_prop;         Queue queue = null;         qt_prop = new AQQueueTableProperty(""SYS.AQ$_JMS_TEXT_MESSAGE"");          q_table = ((AQjmsSession) session).createQueueTable(user, qTable, qt_prop);          System.out.println(""Qtable created"");         dest_prop = new AQjmsDestinationProperty();         /* create a queue */         queue = ((AQjmsSession) session).createQueue(q_table, queueName, dest_prop);         System.out.println(""Queue created"");         /* start the queue */         ((AQjmsDestination) queue).start(session, true, true);      } catch (Exception e) {         e.printStackTrace();         return;     } }  public static void sendMessage(String user, String queueName,String message) {      try {         QueueConnection QCon = getConnection();         Session session = QCon.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);         QCon.start();         Queue queue = ((AQjmsSession) session).getQueue(user, queueName);         MessageProducer producer = session.createProducer(queue);         TextMessage tMsg = session.createTextMessage(message);          //set properties to msg since axis2 needs this parameters to find the operation         tMsg.setStringProperty(""SOAPAction"", ""getQuote"");         producer.send(tMsg);         System.out.println(""Sent message = "" + tMsg.getText());          session.close();         producer.close();         QCon.close();      } catch (JMSException e) {         e.printStackTrace();         return;     } }  public static void browseMessage(String user, String queueName) {     Queue queue;     try {         QueueConnection QCon = getConnection();         Session session = QCon.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);          QCon.start();         queue = ((AQjmsSession) session).getQueue(user, queueName);         QueueBrowser browser = session.createBrowser(queue);         Enumeration enu = browser.getEnumeration();         List list = new ArrayList();         while (enu.hasMoreElements()) {             TextMessage message = (TextMessage) enu.nextElement();             list.add(message.getText());         }         for (int i = 0; i &lt; list.size(); i++) {             System.out.println(""Browsed msg "" + list.get(i));         }         browser.close();         session.close();         QCon.close();      } catch (JMSException e) {         e.printStackTrace();     }  }  public static void consumeMessage(String user, String queueName) {     Queue queue;     try {         QueueConnection QCon = getConnection();         Session session = QCon.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);         QCon.start();         queue = ((AQjmsSession) session).getQueue(user, queueName);         MessageConsumer consumer = session.createConsumer(queue);         TextMessage msg = (TextMessage) consumer.receive();         System.out.println(""MESSAGE RECEIVED "" + msg.getText());          consumer.close();         session.close();         QCon.close();     } catch (JMSException e) {         e.printStackTrace();     } }  public static void main(String args[]) {     String userName = ""jmsuser"";     String queue = ""sample_aq"";     String qTable = ""sample_aqtbl"";     //createQueue(userName, qTable, queue);     //sendMessage(userName, queue,""&lt;user&gt;text&lt;/user&gt;"");     //browseMessage(userName, queue);     //consumeMessage(userName, queue); }"
"package com.sdl.ws.integration.profserv.shared.onejar;   import com.simontuffs.onejar.OneJarURLConnection; import org.reflections.vfs.Vfs; import org.reflections.vfs.ZipDir; import org.reflections.vfs.ZipFile;  import java.io.IOException; import java.util.ArrayList; import java.util.Enumeration; import java.util.List; import java.util.jar.JarEntry; import java.util.jar.JarFile;   public class OneJarDir implements Vfs.Dir {      private JarFile oneJarFile = null;     private List&lt;Vfs.File&gt; oneJarClassFiles = new ArrayList&lt;Vfs.File&gt;();      private OneJarURLConnection oneJarConnection;      public OneJarDir(OneJarURLConnection oneJarConnection) {          this.oneJarConnection = oneJarConnection;          try {             this.oneJarConnection.connect();             this.oneJarFile = this.oneJarConnection.getJarFile();             Enumeration&lt;JarEntry&gt; entries = oneJarFile.entries();              while (entries.hasMoreElements()) {                 oneJarClassFiles.add(new ZipFile(new ZipDir(oneJarFile), entries.nextElement()));             }          } catch (IOException e) {             throw new RuntimeException(""Can't create One-Jar VFS directory"", e);         }     }      public String getPath() {         return oneJarConnection.getURL().getPath();     }      public Iterable&lt;Vfs.File&gt; getFiles() {         return oneJarClassFiles;     }      public void close() {         try {             if (oneJarConnection != null)                 oneJarConnection.getInputStream().close();         } catch (IOException e) {             throw new RuntimeException(""Can't close VFS JAR stream"", e);         }     } }"
"import org.icepdf.ri.common.SwingController; import org.icepdf.ri.common.SwingViewBuilder;  import javax.swing.*;  /**  * The &lt;code&gt;ViewerComponentExample&lt;/code&gt; class is an example of how to use  * &lt;code&gt;SwingController&lt;/code&gt; and &lt;code&gt;SwingViewBuilder&lt;/code&gt;  * to build a PDF viewer component.  A file specified at the command line is  * opened in a JFrame which contains the viewer component.  *  * @since 2.0  */ public class ViewerComponentExample {     public static void main(String[] args) {         // Get a file from the command line to open         String filePath = args[0];          // build a component controller         SwingController controller = new SwingController();          SwingViewBuilder factory = new SwingViewBuilder(controller);          JPanel viewerComponentPanel = factory.buildViewerPanel();          // add interactive mouse link annotation support via callback         controller.getDocumentViewController().setAnnotationCallback(                 new org.icepdf.ri.common.MyAnnotationCallback(                         controller.getDocumentViewController()));          JFrame applicationFrame = new JFrame();         applicationFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         applicationFrame.getContentPane().add(viewerComponentPanel);          // Now that the GUI is all in place, we can try openning a PDF         controller.openDocument(filePath);          // show the component         applicationFrame.pack();         applicationFrame.setVisible(true);     } }"
"import java.io.Closeable; import java.io.File; import java.io.FileNotFoundException; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.OutputStream; import java.net.URI; import java.net.URISyntaxException; import java.net.URL; import java.security.CodeSource; import java.security.ProtectionDomain; import java.util.zip.ZipEntry; import java.util.zip.ZipException; import java.util.zip.ZipFile;  public class Main {     public static void main(final String[] args)         throws URISyntaxException,                ZipException,                IOException     {         final URI uri;         final URI exe;          uri = getJarURI();         exe = getFile(uri, ""Main.class"");         System.out.println(exe);     }      private static URI getJarURI()         throws URISyntaxException     {         final ProtectionDomain domain;         final CodeSource       source;         final URL              url;         final URI              uri;          domain = Main.class.getProtectionDomain();         source = domain.getCodeSource();         url    = source.getLocation();         uri    = url.toURI();          return (uri);     }      private static URI getFile(final URI    where,                                final String fileName)         throws ZipException,                IOException     {         final File location;         final URI  fileURI;          location = new File(where);          // not in a JAR, just return the path on disk         if(location.isDirectory())         {             fileURI = URI.create(where.toString() + fileName);         }         else         {             final ZipFile zipFile;              zipFile = new ZipFile(location);              try             {                 fileURI = extract(zipFile, fileName);             }             finally             {                 zipFile.close();             }         }          return (fileURI);     }      private static URI extract(final ZipFile zipFile,                                final String  fileName)         throws IOException     {         final File         tempFile;         final ZipEntry     entry;         final InputStream  zipStream;         OutputStream       fileStream;          tempFile = File.createTempFile(fileName, Long.toString(System.currentTimeMillis()));         tempFile.deleteOnExit();         entry    = zipFile.getEntry(fileName);          if(entry == null)         {             throw new FileNotFoundException(""cannot find file: "" + fileName + "" in archive: "" + zipFile.getName());         }          zipStream  = zipFile.getInputStream(entry);         fileStream = null;          try         {             final byte[] buf;             int          i;              fileStream = new FileOutputStream(tempFile);             buf        = new byte[1024];             i          = 0;              while((i = zipStream.read(buf)) != -1)             {                 fileStream.write(buf, 0, i);             }         }         finally         {             close(zipStream);             close(fileStream);         }          return (tempFile.toURI());     }      private static void close(final Closeable stream)     {         if(stream != null)         {             try             {                 stream.close();             }             catch(final IOException ex)             {                 ex.printStackTrace();             }         }     } }"
"package listviewcellposition;  import java.util.ArrayList; import java.util.List; import javafx.application.Application; import javafx.scene.Scene; import javafx.scene.control.*; import javafx.scene.layout.*; import javafx.scene.paint.Color; import javafx.scene.shape.Line; import javafx.stage.Stage; import javafx.util.Callback;  public class ListViewCellPosition extends Application {      // CustomCellFactory for creating CustomCells     public class CustomCellFactory implements             Callback&lt;ListView&lt;String&gt;, ListCell&lt;String&gt;&gt; {          List&lt;ListCell&lt;String&gt;&gt; allCells = new ArrayList&lt;&gt;();          @Override         public ListCell&lt;String&gt; call(final ListView&lt;String&gt; p) {             final CustomCell cell = new CustomCell();             allCells.add(cell);             return cell;         }          public List&lt;ListCell&lt;String&gt;&gt; getAllCells() {             return allCells;         }     }      // CustomCell is where the exposure occurs. Here, it's based on the     // Cell being selected in the ListView. You could choose a different     // trigger here but you'll need to explore.     public class CustomCell extends ListCell&lt;String&gt; {         // General display stuff         @Override         protected void updateItem(String item, boolean empty) {             super.updateItem(item, empty);             if (empty) {                 setText(null);                 setGraphic(null);             } else {                 setText(item == null ? """" : item);                 setGraphic(null);             }         }     }      @Override     public void start(Stage primaryStage) {         // This pane will contain the lines after they are created.         // I set it into an AnchorPane to avoid having to deal with          // resizing.         Pane linePane = new Pane();         AnchorPane pane = new AnchorPane();         pane.setPrefSize(100, 250);         AnchorPane.setBottomAnchor(linePane, 0.0);         AnchorPane.setLeftAnchor(linePane, 0.0);         AnchorPane.setRightAnchor(linePane, 0.0);         AnchorPane.setTopAnchor(linePane, 0.0);         pane.getChildren().add(linePane);          ListView&lt;String&gt; lView = new ListView&lt;&gt;();         lView.setPrefSize(100, 250);         CustomCellFactory lCellFactory = new CustomCellFactory();         lView.setCellFactory(lCellFactory);          ListView&lt;String&gt; rView = new ListView&lt;&gt;();         rView.setPrefSize(100, 250);         CustomCellFactory rCellFactory = new CustomCellFactory();         rView.setCellFactory(rCellFactory);          lView.getItems().addAll(""Bill"", ""Doctor"", ""Steve"", ""Joanne"");         rView.getItems().addAll(""Seuss"", ""Rowling"", ""King"", ""Shakespeare"");          HBox root = new HBox();         root.getChildren().addAll(lView, pane, rView);          Scene scene = new Scene(root, 300, 250);         primaryStage.setScene(scene);         primaryStage.show();          connectCells(lCellFactory, ""Bill"", rCellFactory, ""Shakespeare"", linePane);         connectCells(lCellFactory, ""Doctor"", rCellFactory, ""Seuss"", linePane);         connectCells(lCellFactory, ""Steve"", rCellFactory, ""King"", linePane);         connectCells(lCellFactory, ""Joanne"", rCellFactory, ""Rowling"", linePane);     }      // Looks up the ListCell&lt;&gt; for each String and creates a Line     // with the coordinates from each Cell. The calculation is very      // contrived because I know that all the components have the same      // x-coordinate. You'll need more complicated calculations if your     // containers are not aligned this way.     private void connectCells(CustomCellFactory lCellFactory, String lVal,             CustomCellFactory rCellFactory, String rVal, Pane linePane) {          List&lt;ListCell&lt;String&gt;&gt; lList = lCellFactory.getAllCells();         ListCell&lt;String&gt; lCell = null;          for (ListCell&lt;String&gt; lc : lList) {             if (lc.getItem() != null &amp;&amp; lc.getItem().equals(lVal)) {                 lCell = lc;                 break;             }         }          List&lt;ListCell&lt;String&gt;&gt; rList = rCellFactory.getAllCells();         ListCell&lt;String&gt; rCell = null;          for (ListCell&lt;String&gt; rc : rList) {             if (rc.getItem() != null &amp;&amp; rc.getItem().equals(rVal)) {                 rCell = rc;                 break;             }         }          if (lCell != null &amp;&amp; rCell != null) {             double startY = lCell.getLayoutY() +                     (lCell.getBoundsInLocal().getHeight() / 2);             double endY = rCell.getLayoutY() +                     (rCell.getBoundsInLocal().getHeight() / 2);              Line line = new Line(0, startY,                      linePane.getBoundsInParent().getWidth(), endY);             line.setStrokeWidth(2);             line.setStroke(Color.BLACK);              linePane.getChildren().add(line);         }     }         public static void main(String[] args) {         launch(args);     } }"
"import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.TypeElement;  @SupportedSourceVersion(SourceVersion.RELEASE_7) @SupportedAnnotationTypes(""*"") public class Processor extends AbstractProcessor {      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         ImportScanner scanner = new ImportScanner();         scanner.scan(roundEnv.getRootElements(), null);          Set&lt;String&gt; importedTypes = scanner.getImportedTypes();         // do something with the types          return false;     }  }"
"import java.util.Random; import java.util.concurrent.Executor; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.ThreadFactory;  import javafx.application.Application; import javafx.concurrent.Task; import javafx.scene.Scene; import javafx.scene.control.ProgressIndicator ; import javafx.scene.control.TableColumn; import javafx.scene.control.TableView; import javafx.scene.control.cell.ProgressBarTableCell; import javafx.scene.control.cell.PropertyValueFactory; import javafx.scene.layout.BorderPane; import javafx.stage.Stage;  public class ProgressBarTableCellTest extends Application {    @Override   public void start(Stage primaryStage) {     TableView&lt;TestTask&gt; table = new TableView&lt;TestTask&gt;();     Random rng = new Random();     for (int i = 0; i &lt; 20; i++) {       table.getItems().add(           new TestTask(rng.nextInt(3000) + 2000, rng.nextInt(30) + 20));     }      TableColumn&lt;TestTask, String&gt; statusCol = new TableColumn(""Status"");     statusCol.setCellValueFactory(new PropertyValueFactory&lt;TestTask, String&gt;(         ""message""));     statusCol.setPrefWidth(75);      TableColumn&lt;TestTask, Double&gt; progressCol = new TableColumn(""Progress"");     progressCol.setCellValueFactory(new PropertyValueFactory&lt;TestTask, Double&gt;(         ""progress""));     progressCol         .setCellFactory(ProgressBarTableCell.&lt;TestTask&gt; forTableColumn());      table.getColumns().addAll(statusCol, progressCol);      BorderPane root = new BorderPane();     root.setCenter(table);     primaryStage.setScene(new Scene(root));     primaryStage.show();      ExecutorService executor = Executors.newFixedThreadPool(table.getItems().size(), new ThreadFactory() {       @Override       public Thread newThread(Runnable r) {         Thread t = new Thread(r);         t.setDaemon(true);         return t;       }     });       for (TestTask task : table.getItems()) {       executor.execute(task);     }   }    public static void main(String[] args) {     launch(args);   }    static class TestTask extends Task&lt;Void&gt; {      private final int waitTime; // milliseconds     private final int pauseTime; // milliseconds      public static final int NUM_ITERATIONS = 100;      TestTask(int waitTime, int pauseTime) {       this.waitTime = waitTime;       this.pauseTime = pauseTime;     }      @Override     protected Void call() throws Exception {       this.updateProgress(ProgressIndicator.INDETERMINATE_PROGRESS, 1);       this.updateMessage(""Waiting..."");       Thread.sleep(waitTime);       this.updateMessage(""Running..."");       for (int i = 0; i &lt; NUM_ITERATIONS; i++) {         updateProgress((1.0 * i) / NUM_ITERATIONS, 1);         Thread.sleep(pauseTime);       }       this.updateMessage(""Done"");       this.updateProgress(1, 1);       return null;     }    } }"
"package org.lig.hadas.services.mapper;  import javax.ws.rs.Produces; import javax.ws.rs.core.MediaType; import javax.ws.rs.ext.ContextResolver; import javax.ws.rs.ext.Provider;  import org.codehaus.jackson.map.DeserializationConfig; import org.codehaus.jackson.map.ObjectMapper;  @Produces(MediaType.APPLICATION_JSON) @Provider public class ObjectMapperProvider implements ContextResolver&lt;ObjectMapper&gt; {    ObjectMapper mapper;     public ObjectMapperProvider(){        mapper = new ObjectMapper();        mapper.configure(DeserializationConfig.Feature.ACCEPT_SINGLE_VALUE_AS_ARRAY, true);    }    @Override    public ObjectMapper getContext(Class&lt;?&gt; type) {        return mapper;    } }"
"import java.io.ByteArrayInputStream; import java.io.FileInputStream; import java.io.FilterInputStream; import java.io.IOException; import java.io.InputStream; import java.io.SequenceInputStream; import java.util.Enumeration; import java.util.zip.CRC32; import java.util.zip.Deflater; import java.util.zip.DeflaterInputStream; import java.util.zip.DeflaterOutputStream;  /**  * @author mwyraz  * Wraps an input stream and compresses it's contents. Similiar to DeflateInputStream but adds GZIP-header and trailer  * See GzipOutputStream for details.  * LICENSE: Free to use. Contains some lines from GzipOutputStream, so oracle's license might apply as well!  */ public class GzipCompressingInputStream extends SequenceInputStream {     public GzipCompressingInputStream(InputStream in) throws IOException     {         this(in,512);     }     public GzipCompressingInputStream(InputStream in, int bufferSize) throws IOException     {         super(new StatefullGzipStreamEnumerator(in,bufferSize));     }      static enum StreamState     {         HEADER,         CONTENT,         TRAILER     }      protected static class StatefullGzipStreamEnumerator implements Enumeration&lt;InputStream&gt;     {          protected final InputStream in;         protected final int bufferSize;         protected StreamState state;          public StatefullGzipStreamEnumerator(InputStream in, int bufferSize)         {             this.in=in;             this.bufferSize=bufferSize;             state=StreamState.HEADER;         }          public boolean hasMoreElements()         {             return state!=null;         }         public InputStream nextElement()         {             switch (state)             {                 case HEADER:                     state=StreamState.CONTENT;                     return createHeaderStream();                 case CONTENT:                     state=StreamState.TRAILER;                     return createContentStream();                 case TRAILER:                     state=null;                     return createTrailerStream();             }             return null;         }          static final int GZIP_MAGIC = 0x8b1f;         static final byte[] GZIP_HEADER=new byte[] {                 (byte) GZIP_MAGIC,        // Magic number (short)                 (byte)(GZIP_MAGIC &gt;&gt; 8),  // Magic number (short)                 Deflater.DEFLATED,        // Compression method (CM)                 0,                        // Flags (FLG)                 0,                        // Modification time MTIME (int)                 0,                        // Modification time MTIME (int)                 0,                        // Modification time MTIME (int)                 0,                        // Modification time MTIME (int)                 0,                        // Extra flags (XFLG)                 0                         // Operating system (OS)         };         protected InputStream createHeaderStream()         {             return new ByteArrayInputStream(GZIP_HEADER);         }         protected InternalGzipCompressingInputStream contentStream;         protected InputStream createContentStream()         {             contentStream=new InternalGzipCompressingInputStream(new CRC32InputStream(in), bufferSize);             return contentStream;         }         protected InputStream createTrailerStream()         {             return new ByteArrayInputStream(contentStream.createTrailer());         }     }      /**      * Internal stream without header/trailer        */     protected static class CRC32InputStream extends FilterInputStream     {         protected CRC32 crc = new CRC32();         protected long byteCount;         public CRC32InputStream(InputStream in)         {             super(in);         }          @Override         public int read() throws IOException         {             int val=super.read();             if (val&gt;=0)             {                 crc.update(val);                 byteCount++;             }             return val;         }         @Override         public int read(byte[] b, int off, int len) throws IOException         {             len=super.read(b, off, len);             if (len&gt;=0)             {                 crc.update(b,off,len);                 byteCount+=len;             }             return len;         }         public long getCrcValue()         {             return crc.getValue();         }         public long getByteCount()         {             return byteCount;         }     }      /**      * Internal stream without header/trailer        */     protected static class InternalGzipCompressingInputStream extends DeflaterInputStream     {         protected final CRC32InputStream crcIn;         public InternalGzipCompressingInputStream(CRC32InputStream in, int bufferSize)         {             super(in, new Deflater(Deflater.DEFAULT_COMPRESSION, true),bufferSize);             crcIn=in;         }         public void close() throws IOException         {             if (in != null)             {                 try                 {                     def.end();                     in.close();                 }                 finally                 {                     in = null;                 }             }         }          protected final static int TRAILER_SIZE = 8;          public byte[] createTrailer()         {             byte[] trailer= new byte[TRAILER_SIZE];             writeTrailer(trailer, 0);             return trailer;         }          /*          * Writes GZIP member trailer to a byte array, starting at a given          * offset.          */         private void writeTrailer(byte[] buf, int offset)         {             writeInt((int)crcIn.getCrcValue(), buf, offset); // CRC-32 of uncompr. data             writeInt((int)crcIn.getByteCount(), buf, offset + 4); // Number of uncompr. bytes         }          /*          * Writes integer in Intel byte order to a byte array, starting at a          * given offset.          */         private void writeInt(int i, byte[] buf, int offset)         {             writeShort(i &amp; 0xffff, buf, offset);             writeShort((i &gt;&gt; 16) &amp; 0xffff, buf, offset + 2);         }          /*          * Writes short integer in Intel byte order to a byte array, starting          * at a given offset          */         private void writeShort(int s, byte[] buf, int offset)         {             buf[offset] = (byte)(s &amp; 0xff);             buf[offset + 1] = (byte)((s &gt;&gt; 8) &amp; 0xff);         }     }  }"
"package com.displaytag.export.views;   import java.io.IOException; import java.io.OutputStream; import java.util.Iterator; import javax.servlet.jsp.JspException; import org.apache.commons.lang.ObjectUtils; import org.apache.commons.lang.StringUtils; import org.displaytag.export.BinaryExportView; import org.displaytag.model.Column; import org.displaytag.model.ColumnIterator; import org.displaytag.model.HeaderCell; import org.displaytag.model.RowIterator; import org.displaytag.model.TableModel; import org.apache.poi.ss.usermodel.Cell; import org.apache.poi.ss.usermodel.CellStyle; import org.apache.poi.ss.usermodel.IndexedColors; import org.apache.poi.ss.usermodel.Row; import org.apache.poi.ss.util.CellRangeAddress; import org.apache.poi.xssf.usermodel.XSSFFont; import org.apache.poi.xssf.usermodel.XSSFSheet; import org.apache.poi.xssf.usermodel.XSSFWorkbook; import com.lowagie.text.BadElementException;  public class myExcel2007ExportView implements BinaryExportView{   //private static Log log = LogFactory.getLog(myExcel2007ExportView.class); private TableModel model; private boolean exportFull; private boolean header; private boolean decorated; private XSSFWorkbook workbook; private XSSFSheet sheet; private int rowCount=0; private CellStyle normalstyle=null; private CellStyle headerstyle=null; private CellStyle captionstyle=null;  private XSSFFont defaultFont; private XSSFFont headerFont; private XSSFFont captionFont;  public String getMimeType() {      return &quot;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot;; }  public void setParameters(TableModel tableModel, boolean exportFullList, boolean includeHeader,        boolean decorateValues) {    this.model = tableModel;    this.exportFull = true;    this.header = includeHeader;    this.decorated = decorateValues; }  public boolean outputPage() {     return false; }  protected void initTable() throws BadElementException {     //Blank workbook     workbook = new XSSFWorkbook();           //Create a blank sheet     sheet = workbook.createSheet(&quot;Server Management System&quot;);               defaultFont= workbook.createFont();     defaultFont.setFontHeightInPoints((short)10);     defaultFont.setFontName(&quot;Arial&quot;);     defaultFont.setColor(IndexedColors.BLACK.getIndex());     defaultFont.setBold(false);     defaultFont.setItalic(false);      headerFont= workbook.createFont();     headerFont.setFontHeightInPoints((short)10);     headerFont.setFontName(&quot;Arial&quot;);     headerFont.setColor(IndexedColors.WHITE.getIndex());     headerFont.setBold(true);     headerFont.setItalic(false);          captionFont= workbook.createFont();     captionFont.setFontHeightInPoints((short)15);     captionFont.setFontName(&quot;Arial&quot;);     captionFont.setColor(IndexedColors.BLACK.getIndex());     captionFont.setBold(true);     captionFont.setItalic(false);               normalstyle= workbook.createCellStyle();      normalstyle.setFillBackgroundColor(IndexedColors.WHITE.getIndex());     normalstyle.setFillPattern(CellStyle.BIG_SPOTS);     normalstyle.setAlignment(CellStyle.ALIGN_CENTER);     normalstyle.setFont(defaultFont);          headerstyle= workbook.createCellStyle();      headerstyle.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());     headerstyle.setFillPattern(CellStyle.BIG_SPOTS);     headerstyle.setAlignment(CellStyle.ALIGN_CENTER);     headerstyle.setFont(headerFont);          captionstyle= workbook.createCellStyle();      captionstyle.setFillBackgroundColor(IndexedColors.GREY_25_PERCENT.getIndex());     captionstyle.setFillPattern(CellStyle.BIG_SPOTS);     captionstyle.setAlignment(CellStyle.ALIGN_CENTER);     captionstyle.setVerticalAlignment(CellStyle.VERTICAL_CENTER);     captionstyle.setFont(captionFont);      }  protected void generateXLSXTable() throws JspException, BadElementException {     //adding caption     if(this.model.getCaption()!=null &amp;&amp; this.model.getCaption()!=&quot;&quot;)     {      Row blankrow = sheet.createRow(rowCount++);      Row row = sheet.createRow(rowCount++);            row.setHeight((short)5000);      int columnCount=0;      Cell captionCell = row.createCell(columnCount++);      captionCell.setCellValue(this.model.getCaption());      captionCell.setCellStyle(captionstyle);      sheet.addMergedRegion(new CellRangeAddress(              rowCount-1, //first row (0-based)              rowCount-1, //last row  (0-based)              columnCount-1, //first column (0-based)              columnCount+5  //last column  (0-based)      ));      Row blankrow2 = sheet.createRow(rowCount++);     }          if (this.header)     {         generateHeaders();     }          generateRows();          //adding footer     if(this.model.getFooter()!=null &amp;&amp; this.model.getFooter()!=&quot;&quot;)     {      Row blankrow = sheet.createRow(rowCount++);      Row blankrow2 = sheet.createRow(rowCount++);      Row row = sheet.createRow(rowCount++);            row.setHeight((short)1000);      int columnCount=0;      Cell captionCell = row.createCell(columnCount++);      captionCell.setCellValue(this.model.getFooter());      captionCell.setCellStyle(captionstyle);      sheet.addMergedRegion(new CellRangeAddress(              rowCount-1, //first row (0-based)              rowCount-1, //last row  (0-based)              columnCount-1, //first column (0-based)              columnCount+5  //last column  (0-based)      ));     } }  protected void generateHeaders() throws BadElementException {     Iterator&lt;HeaderCell&gt; iterator = this.model.getHeaderCellList().iterator();     Row row = sheet.createRow(rowCount++);          int columnCount=0;     while (iterator.hasNext())     {         sheet.autoSizeColumn(columnCount);         HeaderCell headerCell = iterator.next();          String columnHeader = headerCell.getTitle();          if (columnHeader == null)         {             columnHeader = StringUtils.capitalize(headerCell.getBeanPropertyName());         }          Cell hdrCell = row.createCell(columnCount++);         hdrCell.setCellValue(columnHeader);         hdrCell.setCellStyle(headerstyle);     } }  protected void generateRows() throws JspException, BadElementException {     // get the correct iterator (full or partial list according to the exportFull field)     RowIterator rowIterator = this.model.getRowIterator(this.exportFull);     // iterator on rows     while (rowIterator.hasNext())     {         Row newrow = sheet.createRow(rowCount++);         org.displaytag.model.Row row = rowIterator.next();         // iterator on columns         ColumnIterator columnIterator = row.getColumnIterator(this.model.getHeaderCellList());         int columnCount=0;         while (columnIterator.hasNext())         {             Column column = columnIterator.nextColumn();              // Get the value to be displayed for the column             Object value = column.getValue(this.decorated);              Cell Cell = newrow.createCell(columnCount++);             Cell.setCellValue(ObjectUtils.toString(value));         }     }      }  @Override public void doExport(OutputStream out) throws IOException, JspException {          try {         // Initialize the table with the appropriate number of columns         initTable();                  generateXLSXTable();              } catch (BadElementException e) {         // TODO Auto-generated catch block         e.printStackTrace();     }                 workbook.write(out);     out.close(); } }"
"package mypackage;  import org.opencms.file.*; import org.opencms.main.*; import org.opencms.scheduler.I_CmsScheduledJob; import java.text.SimpleDateFormat; import java.util.*;   public class BuildTagCloud implements I_CmsScheduledJob {    private final String indexaddress = ""address/of/your/index/folder""; // something like ../webapps/opencms/WEB-INF/index/nameOfIndex   private final String tagsFile = ""address""; // part of my template; it's where I store the tag cloud   private final int numTerms = 10; // number of terms in the tag cloud                                                                        public String launch(CmsObject object, java.util.Map parameters) throws java.lang.Exception {       Cloud cloud = new Cloud(indexaddress, numTerms);        Calendar cal = Calendar.getInstance();       SimpleDateFormat sdf = new SimpleDateFormat(""yyyy-MM-dd HH:mm:ss"");       String data;       data = ""&lt;div style=\""border-top: 3px solid #000099; padding-top: 6px; margin-top: 17px;\""&gt;&lt;span style=\""font-weight: bold; font-size: 11px; color: #000099;\""&gt;Tag cloud&lt;/span&gt;&lt;br /&gt;"";       data += sdf.format(cal.getTime()) + ""&lt;br /&gt;"";        try {           List&lt;TermInfo&gt; list = cloud.getCloud();            for(int i = 0; i&lt;list.size(); i++) {               data += ""&lt;br /&gt;"" + i + "". "" + list.get(i).term.text() + "" ... "" + list.get(i).docFreq; // list.get(i).docFreq           }        } catch (Exception e) {            data += e.getMessage();           data += ""&lt;br /&gt;"";        } finally {            data+=""&lt;/div&gt;"";       }        writeAndPublishResource(object, tagsFile, data);        return ""OK"";   }    private void writeAndPublishResource(CmsObject object, String resouce, String data) throws java.lang.Exception {       object.loginUser(""administrator's user name"", ""and his password"");        CmsRequestContext cmsContext = object.getRequestContext();       CmsProject curProject = cmsContext.currentProject();        if(curProject.isOnlineProject()){             CmsProject offlineProject = object.readProject(""Name of the project"");             cmsContext.setCurrentProject(offlineProject);       }       CmsResource res = object.readResource(resouce);       object.lockResource(resouce);       CmsFile file = object.readFile(res);       file.setContents(data.getBytes());       object.writeFile(file);       OpenCms.getPublishManager().publishResource(object, resouce);       object.unlockResource(resouce);     }  }"
"package com.example;  import java.io.IOException; import java.io.PrintWriter; import java.util.ArrayList; import java.util.Enumeration; import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.regex.Pattern;  import javax.servlet.Filter; import javax.servlet.FilterChain; import javax.servlet.FilterConfig; import javax.servlet.ServletException; import javax.servlet.ServletRequest; import javax.servlet.ServletResponse; import javax.servlet.http.HttpServletResponse;  /**  * Applies search and replace patterns. To initialize this filter, the  * param-names should be ""search1"", ""replace1"", ""search2"", ""replace2"", etc.  */ public final class RegexFilter implements Filter {     private List&lt;Pattern&gt; searchPatterns;     private List&lt;String&gt; replaceStrings;      /**      * Finds the search and replace strings in the configuration file. Looks for      * matching searchX and replaceX parameters.      */     public void init(FilterConfig filterConfig) {         Map&lt;String, String&gt; patternMap = new HashMap&lt;String, String&gt;();          // Walk through the parameters to find those whose names start with         // search         Enumeration&lt;String&gt; names = (Enumeration&lt;String&gt;) filterConfig.getInitParameterNames();         while (names.hasMoreElements()) {             String name = names.nextElement();             if (name.startsWith(""search"")) {                 patternMap.put(name.substring(6), filterConfig.getInitParameter(name));             }         }         this.searchPatterns = new ArrayList&lt;Pattern&gt;(patternMap.size());         this.replaceStrings = new ArrayList&lt;String&gt;(patternMap.size());          // Walk through the parameters again to find the matching replace params         names = (Enumeration&lt;String&gt;) filterConfig.getInitParameterNames();         while (names.hasMoreElements()) {             String name = names.nextElement();             if (name.startsWith(""replace"")) {                 String searchString = patternMap.get(name.substring(7));                 if (searchString != null) {                     this.searchPatterns.add(Pattern.compile(searchString));                     this.replaceStrings.add(filterConfig.getInitParameter(name));                 }             }         }     }      public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException {         // Wrap the response in a wrapper so we can get at the text after calling the next filter         PrintWriter out = response.getWriter();         CharResponseWrapper wrapper = new CharResponseWrapper((HttpServletResponse) response);         chain.doFilter(request, wrapper);          // Extract the text from the completed servlet and apply the regexes         String modifiedHtml = wrapper.toString();         for (int i = 0; i &lt; this.searchPatterns.size(); i++) {             modifiedHtml = this.searchPatterns.get(i).matcher(modifiedHtml).replaceAll(this.replaceStrings.get(i));         }          // Write our modified text to the real response         response.setContentLength(modifiedHtml.getBytes().length);         out.write(modifiedHtml);         out.close();     }      public void destroy() {         this.searchPatterns = null;         this.replaceStrings = null;     } }"
"import java.io.IOException; import javax.tools.DiagnosticCollector; import javax.tools.JavaCompiler; import javax.tools.JavaFileObject; import javax.tools.StandardJavaFileManager; import javax.tools.ToolProvider; import javax.tools.JavaCompiler.CompilationTask; import com.sun.source.tree.CompilationUnitTree; import com.sun.source.tree.LineMap; import com.sun.source.tree.MethodTree; import com.sun.source.util.JavacTask; import com.sun.source.util.SourcePositions; import com.sun.source.util.TreeScanner; import com.sun.source.util.Trees;  public class MethodFinder {      public static void main(String[] args) {         JavaCompiler compiler = ToolProvider.getSystemJavaCompiler();         DiagnosticCollector&lt;JavaFileObject&gt; diagnosticsCollector = new DiagnosticCollector&lt;JavaFileObject&gt;();         StandardJavaFileManager fileManager = compiler.getStandardFileManager(diagnosticsCollector, null, null);         Iterable&lt;? extends JavaFileObject&gt; fileObjects = fileManager.getJavaFileObjects(""path/to/Source.java"");         CompilationTask task = compiler.getTask(null, fileManager, diagnosticsCollector, null, null, fileObjects);          // Here we switch to Sun-specific APIs         JavacTask javacTask = (JavacTask) task;         SourcePositions sourcePositions = Trees.instance(javacTask).getSourcePositions();         Iterable&lt;? extends CompilationUnitTree&gt; parseResult = null;         try {             parseResult = javacTask.parse();         } catch (IOException e) {              // Parsing failed             e.printStackTrace();             System.exit(0);         }         for (CompilationUnitTree compilationUnitTree : parseResult) {             compilationUnitTree.accept(new MethodLineLogger(compilationUnitTree, sourcePositions), null);         }     }      private static class MethodLineLogger extends TreeScanner&lt;Void, Void&gt; {         private final CompilationUnitTree compilationUnitTree;         private final SourcePositions sourcePositions;         private final LineMap lineMap;          private MethodLineLogger(CompilationUnitTree compilationUnitTree, SourcePositions sourcePositions) {             this.compilationUnitTree = compilationUnitTree;             this.sourcePositions = sourcePositions;             this.lineMap = compilationUnitTree.getLineMap();         }          @Override         public Void visitMethod(MethodTree arg0, Void arg1) {             long startPosition = sourcePositions.getStartPosition(compilationUnitTree, arg0);             long startLine = lineMap.getLineNumber(startPosition);             long endPosition = sourcePositions.getEndPosition(compilationUnitTree, arg0);             long endLine = lineMap.getLineNumber(endPosition);              // Voila!             System.out.println(""Found method "" + arg0.getName() + "" from line "" + startLine + "" to line ""  + endLine + ""."");              return super.visitMethod(arg0, arg1);         }     } }"
"import com.sun.jndi.ldap.LdapCtxFactory; import java.util.ArrayList; import java.util.Hashtable; import java.util.List; import java.util.Iterator; import javax.naming.Context; import javax.naming.AuthenticationException; import javax.naming.NamingEnumeration; import javax.naming.NamingException; import javax.naming.directory.Attribute; import javax.naming.directory.Attributes; import javax.naming.directory.DirContext; import javax.naming.directory.SearchControls; import javax.naming.directory.SearchResult; import static javax.naming.directory.SearchControls.SUBTREE_SCOPE;  class App2 {      public static void main(String[] args) {          if (args.length != 4 &amp;&amp; args.length != 2) {             System.out.println(""Purpose: authenticate user against Active Directory and list group membership."");             System.out.println(""Usage: App2 &lt;username&gt; &lt;password&gt; &lt;domain&gt; &lt;server&gt;"");             System.out.println(""Short usage: App2 &lt;username&gt; &lt;password&gt;"");             System.out.println(""(short usage assumes 'xyz.tld' as domain and 'abc' as server)"");             System.exit(1);         }          String domainName;         String serverName;          if (args.length == 4) {             domainName = args[2];             serverName = args[3];         } else {             domainName = ""xyz.tld"";             serverName = ""abc"";         }          String username = args[0];         String password = args[1];          System.out                 .println(""Authenticating "" + username + ""@"" + domainName + "" through "" + serverName + ""."" + domainName);          // bind by using the specified username/password         Hashtable props = new Hashtable();         String principalName = username + ""@"" + domainName;         props.put(Context.SECURITY_PRINCIPAL, principalName);         props.put(Context.SECURITY_CREDENTIALS, password);         DirContext context;          try {             context = LdapCtxFactory.getLdapCtxInstance(""ldap://"" + serverName + ""."" + domainName + '/', props);             System.out.println(""Authentication succeeded!"");              // locate this user's record             SearchControls controls = new SearchControls();             controls.setSearchScope(SUBTREE_SCOPE);             NamingEnumeration&lt;SearchResult&gt; renum = context.search(toDC(domainName),                     ""(&amp; (userPrincipalName="" + principalName + "")(objectClass=user))"", controls);             if (!renum.hasMore()) {                 System.out.println(""Cannot locate user information for "" + username);                 System.exit(1);             }             SearchResult result = renum.next();              List&lt;String&gt; groups = new ArrayList&lt;String&gt;();             Attribute memberOf = result.getAttributes().get(""memberOf"");             if (memberOf != null) {// null if this user belongs to no group at all                 for (int i = 0; i &lt; memberOf.size(); i++) {                     Attributes atts = context.getAttributes(memberOf.get(i).toString(), new String[] { ""CN"" });                     Attribute att = atts.get(""CN"");                     groups.add(att.get().toString());                 }             }              context.close();              System.out.println();             System.out.println(""User belongs to: "");             Iterator ig = groups.iterator();             while (ig.hasNext()) {                 System.out.println(""   "" + ig.next());             }          } catch (AuthenticationException a) {             System.out.println(""Authentication failed: "" + a);             System.exit(1);         } catch (NamingException e) {             System.out.println(""Failed to bind to LDAP / get account information: "" + e);             System.exit(1);         }     }      private static String toDC(String domainName) {         StringBuilder buf = new StringBuilder();         for (String token : domainName.split(""\\."")) {             if (token.length() == 0)                 continue; // defensive check             if (buf.length() &gt; 0)                 buf.append("","");             buf.append(""DC="").append(token);         }         return buf.toString();     }  }"
"import java.awt.Cursor; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.Transferable; import java.awt.datatransfer.UnsupportedFlavorException; import java.io.File; import java.io.IOException; import java.util.List;  import javax.swing.JComponent; import javax.swing.TransferHandler;  public class ImageTransferHandler extends TransferHandler {     private static final DataFlavor FILE_FLAVOR = DataFlavor.javaFileListFlavor;      private MainPanel mainPanel;      public ImageTransferHandler(MainPanel panel) {         mainPanel = panel;     }      /**      * The method to handle the transfer between the source of data and the      * destination, which is in our case the main panel.      */     public boolean importData(JComponent c, Transferable t) {         if (canImport(c, t.getTransferDataFlavors())) {             if (transferFlavor(t.getTransferDataFlavors(), FILE_FLAVOR)) {                 try {                     List&lt;File&gt; fileList = (List&lt;File&gt;) t.getTransferData(FILE_FLAVOR);                     if (fileList != null &amp;&amp; fileList.toArray() instanceof File[]) {                         File[] files = (File[]) fileList.toArray();                         mainPanel.addFiles(files);                     }                     return true;                 } catch (IOException e) {                     e.printStackTrace();                 } catch (UnsupportedFlavorException ex) {                     ex.printStackTrace();                 }             }         }         return false;     }      /**      * Returns the type of transfer actions to be supported.      */     public int getSourceActions(JComponent c) {         return COPY_OR_MOVE;     }      /**      * Specifies the actions to be performed after the data has been exported.      */     protected void exportDone(JComponent c, Transferable data, int action) {         c.setCursor(Cursor.getPredefinedCursor(Cursor.DEFAULT_CURSOR));     }      /**      * Returns true if the specified flavor is contained in the flavors array,      * false otherwise.      */     private boolean transferFlavor(DataFlavor[] flavors, DataFlavor flavor) {         boolean found = false;         for (int i = 0; i &lt; flavors.length &amp;&amp; !found; i++) {             found = flavors[i].equals(flavor);         }         return found;     }      /**      * Returns true if the component can import the specified flavours, false      * otherwise.      */     public boolean canImport(JComponent c, DataFlavor[] flavors) {         for (int i = 0; i &lt; flavors.length; i++) {             if (FILE_FLAVOR.equals(flavors[i])) {                 return true;             }         }         return false;     } }"
"enter code here /*  * Ext GWT - Ext for GWT  * Copyright(c) 2007, 2008, Ext JS, LLC.  * licensing@extjs.com  *   * http://extjs.com/license  */ package com.extjs.gxt.ui.client.data; import java.io.Serializable; import java.util.Collection; import java.util.Date;  import java.util.HashMap; import java.util.List; import java.util.Map; import java.util.Set;  /**  * RpcMap is used to workaround a part of GWT RPC system.  *   * &lt;p /&gt; The GWT RPC rebinder generates field serializers for every type that is  * assignable to any type in the RPC interfaces.  *   * &lt;p /&gt; If BaseModel was to use ""Map&amp;lt;String, Serializable&gt; map"" this would trigger  * the RPC system to generate field serializers for EVERY Serializable type in  * your GWT Module's class path.  *   * &lt;p /&gt; Therefore BaseModel uses ""Map&amp;lt;String, RpcField&gt; map"" and relies on type  * erasure (cast to Map&amp;lt;Object,Object&gt;) to work around this.  *   * &lt;p /&gt; The only drawback is that if you have to ensure that field serializers are  * generated for any type you add to this map  *   * &lt;p /&gt; RpcMap ensures that the following types are supported Byte, Short, Integer,  * Long, Float, Double, Date, Boolean, and arrays of these types. As well as  * List, Set and Map  */ @SuppressWarnings(""unused"") public class RpcMap implements Serializable{ /**      *       */     private static final long serialVersionUID = 1L; private Byte _byte;   private Short _short;   private Integer _integer;   private Long _long;    private Float _float;   private Double _double; private Date _date;   private Boolean _boolean;   private Byte[] _bytes;   private Short[] _shorts;   private Integer[] _integers;   private Long[] _longs;   private Float[] _floats;   private Double[] _doubles;   private Date[] _dates; private Boolean[] _booleans;  private List&lt;String&gt; _list;   private Set&lt;String&gt; _set;   private Map&lt;String, String&gt; _map;  private transient Map&lt;String, Object&gt; map = new HashMap&lt;String,Object&gt;();   public Map&lt;String, Object&gt; getTransientMap() {    return map;   }   public void clear() {    map.clear();   }   public boolean containsKey(Object key) {    return map.containsKey(key);   }   public boolean containsValue(Object value) {    return map.containsValue(value);   }   public Set&lt;Map.Entry&lt;String, Object&gt;&gt; entrySet() {    return map.entrySet();   }   public boolean equals(Object o) {    if(o instanceof RpcMap){      return map.equals(((RpcMap)o). map);    }    return false;   }   public Object get(Object key) {    return map.get(key);   }   public int hashCode() {    return map.hashCode();   }   public boolean isEmpty() {    return map.isEmpty();   }   public Set&lt;String&gt; keySet() {    return map.keySet();   }   public Object put(String key, Object value) {    return map.put(key, value);   }   public void putAll(Map&lt;? extends String, ? extends Object&gt; m) {    map.putAll(m);   }   public Object remove(Object key) {    return map.remove(key);   }   public int size() {    return map.size();   }   public Collection&lt;Object&gt; values() {    return map.values();   }   @Override   public String toString() {    return map.toString();   }  }"
"import java.io.IOException; import java.io.InputStream; import java.lang.annotation.Annotation; import java.lang.reflect.Type; import java.net.URL;  import javax.ws.rs.Consumes; import javax.ws.rs.WebApplicationException; import javax.ws.rs.core.Context; import javax.ws.rs.core.MediaType; import javax.ws.rs.core.MultivaluedMap; import javax.ws.rs.ext.ContextResolver; import javax.ws.rs.ext.MessageBodyReader; import javax.ws.rs.ext.Provider; import javax.ws.rs.ext.Providers; import javax.xml.XMLConstants; import javax.xml.bind.JAXBContext; import javax.xml.bind.JAXBException; import javax.xml.bind.Unmarshaller; import javax.xml.validation.Schema; import javax.xml.validation.SchemaFactory;  @Provider @Consumes(""application/xml"") public class ValidatingReader implements MessageBodyReader&lt;Customer&gt; {      @Context     protected Providers providers;      private Schema schema;      public ValidatingReader() {         try {             SchemaFactory sf = SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI);             URL schemaURL = null;             schema = sf.newSchema(schemaURL);         } catch(Exception e) {             throw new RuntimeException(e);         }     }      public boolean isReadable(Class&lt;?&gt; arg0, Type arg1, Annotation[] arg2, MediaType arg3) {         return arg0 == Customer.class;     }      public Customer readFrom(Class&lt;Customer&gt; arg0, Type arg1, Annotation[] arg2, MediaType arg3, MultivaluedMap&lt;String, String&gt; arg4, InputStream arg5)             throws IOException, WebApplicationException {         try {             JAXBContext jaxbContext = null;             ContextResolver&lt;JAXBContext&gt; resolver = providers.getContextResolver(JAXBContext.class, arg3);             if(null != resolver) {                 jaxbContext = resolver.getContext(arg0);             }             if(null == jaxbContext) {                 jaxbContext = JAXBContext.newInstance(arg0);             }             Unmarshaller unmarshaller = jaxbContext.createUnmarshaller();             unmarshaller.setSchema(schema);             return (Customer) unmarshaller.unmarshal(arg5);         } catch(JAXBException e) {             throw new RuntimeException(e);         }     }  }"
"import java.io.File; import java.io.FileOutputStream; import java.io.IOException; import java.io.PrintWriter; import java.util.HashSet; import java.util.LinkedHashMap; import java.util.Map; import java.util.Map.Entry; import java.util.Set;  import com.itextpdf.text.pdf.BaseFont; import com.itextpdf.text.pdf.DocumentFont; import com.itextpdf.text.pdf.PdfReader; import com.itextpdf.text.pdf.parser.PdfTextExtractor; import com.itextpdf.text.pdf.parser.SimpleTextExtractionStrategy; import com.itextpdf.text.pdf.parser.TextRenderInfo;  public class ExtractItalicText {      final static class ItalicTextExtractionStrategy extends SimpleTextExtractionStrategy {         @Override         public void renderText(TextRenderInfo arg0) {             DocumentFont font = arg0.getFont();             String[][] familyFontNamesArray = font.getFamilyFontName();             for(String[] familyFontNames : familyFontNamesArray) {                 for(String familyFontName : familyFontNames) {                     if(familyFontName.toLowerCase().contains(""italic"")) {                         float italicAngle = font.getFontDescriptor(BaseFont.ITALICANGLE,                                 0 /* not relevant for ItalicAngle otherwise 1000 is a good value                                       source: http://grepcode.com/file/repo1.maven.org/maven2/com.itextpdf/itextpdf/5.4.2/com/itextpdf/text/pdf/DocumentFont.java#DocumentFont */);                         if(italicAngle &lt; 0) {                             super.renderText(arg0);                         }                         break;                     }                 }                }         }     }      public static void extractItalicText(String pdf) throws IOException {         PdfReader reader = null;         PrintWriter out = null;         PrintWriter outItalic = null;         long s = System.currentTimeMillis();         try {             System.out.println(""Processing: "" + pdf + "" ..."");             // output for original text including italic styled             out = new PrintWriter(new FileOutputStream(""src/main/resources/"" + new File(pdf).getName() + "".txt""));             // output for italic styled text only             outItalic = new PrintWriter(new FileOutputStream(""src/main/resources/"" + new File(pdf).getName() + ""_italic.txt""));             reader = new PdfReader(pdf);             int numberOfPages = reader.getNumberOfPages();             for(int pageNumber = 1; pageNumber &lt;= numberOfPages; pageNumber++) {                 // extract italic text                 String pageItalicText = PdfTextExtractor.getTextFromPage(reader, pageNumber, new ItalicTextExtractionStrategy());                 if(pageItalicText.trim().length() &gt; 0) {                     // we have some italic text in the current page, so we get the hole text of the page                     // to search for the lines where the italic text is located                     String textFromPage = PdfTextExtractor.getTextFromPage(reader, pageNumber);                     String[] textLinesFromPage = textFromPage.split(""[\r\n]"");                      // punctuation marks etc. are sometime not part of the italic text, so we need to clean the line                     // map a cleaned line to a raw line                     Map&lt;String, String&gt; cleanedtextLines = new LinkedHashMap&lt;String, String&gt;(textLinesFromPage.length * 4 / 3 + 1);                     for(String line : textLinesFromPage) {                         out.println(line);                         // clean line from all non-word characters                         cleanedtextLines.put(line.replaceAll(""\\W"", """"), line);                     }                     // split the italic text into lines                     String[] italicTextLines = pageItalicText.split(""[\r\n]"");                     Set&lt;String&gt; linesContainingItalicText = new HashSet&lt;String&gt;(italicTextLines.length * 4 / 3 + 1);                     for(String italicText : italicTextLines) {                         // clean the italic text from non-word characters                         String cleanedItalicText = italicText.replaceAll(""\\W"", """");                         // search for the corresponding line                         for(Entry&lt;String, String&gt; lineEntry : cleanedtextLines.entrySet()) {                                                         if((! linesContainingItalicText.contains(lineEntry.getKey()))                                      &amp;&amp; lineEntry.getKey().contains(cleanedItalicText)) {                                 linesContainingItalicText.add(lineEntry.getKey());                                 // output the raw line                                 outItalic.println(lineEntry.getValue());                             }                         }                     }                 }                 out.println(""==== Page "" + pageNumber + "" =========================================================\n"");                 outItalic.println(""==== Page "" + pageNumber + "" =========================================================\n"");             }          } finally {             if(out != null) {                 out.close();             }             if(outItalic != null) {                 outItalic.close();             }             if(reader != null) {                 reader.close();              }             long e = System.currentTimeMillis();             System.out.println(""done ("" + (e-s) + "" ms)"");         }     }      /**      * @param args      * @throws IOException       */     public static void main(String[] args) throws IOException {         for(String arg: args) {             extractItalicText(arg);         }     } }"
"import java.io.BufferedInputStream; import java.io.BufferedOutputStream; import java.io.BufferedReader; import java.io.Closeable; import java.io.File; import java.io.FileInputStream; import java.io.FileOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.InputStreamReader; import java.io.OutputStream; import java.net.URI; import java.util.Deque; import java.util.Enumeration; import java.util.HashMap; import java.util.Iterator; import java.util.LinkedList; import java.util.Map; import java.util.UUID; import java.util.zip.ZipEntry; import java.util.zip.ZipFile; import java.util.zip.ZipOutputStream;  import javax.faces.context.ExternalContext; import javax.faces.context.FacesContext; import javax.servlet.http.HttpServletResponse;  public class DocxManipulator {      private static final String MAIN_DOCUMENT_PATH = ""word/document.xml"";     private static final String TEMPLATE_DIRECTORY_ROOT = ""TEMPLATES_DIRECTORY/"";       /*    PUBLIC METHODS    */      /**      * Generates .docx document from given template and the substitution data      *       * @param templateName      *            Template data      * @param substitutionData      *            Hash map with the set of key-value pairs that represent      *            substitution data      * @return      */     public static Boolean generateAndSendDocx(String templateName, Map&lt;String,String&gt; substitutionData) {          String templateLocation = TEMPLATE_DIRECTORY_ROOT + templateName;          String userTempDir = UUID.randomUUID().toString();         userTempDir = TEMPLATE_DIRECTORY_ROOT + userTempDir + ""/"";          try {              // Unzip .docx file             unzip(new File(templateLocation), new File(userTempDir));                     // Change data             changeData(new File(userTempDir + MAIN_DOCUMENT_PATH), substitutionData);              // Rezip .docx file             zip(new File(userTempDir), new File(userTempDir + templateName));              // Send HTTP response             sendDOCXResponse(new File(userTempDir + templateName), templateName);              // Clean temp data             deleteTempData(new File(userTempDir));         }          catch (IOException ioe) {             System.out.println(ioe.getMessage());             return false;         }          return true;     }       /*    PRIVATE METHODS    */      /**      * Unzipps specified ZIP file to specified directory      *       * @param zipfile      *            Source ZIP file      * @param directory      *            Destination directory      * @throws IOException      */     private static void unzip(File zipfile, File directory) throws IOException {          ZipFile zfile = new ZipFile(zipfile);         Enumeration&lt;? extends ZipEntry&gt; entries = zfile.entries();          while (entries.hasMoreElements()) {           ZipEntry entry = entries.nextElement();           File file = new File(directory, entry.getName());           if (entry.isDirectory()) {             file.mkdirs();           }            else {             file.getParentFile().mkdirs();             InputStream in = zfile.getInputStream(entry);             try {               copy(in, file);             }              finally {               in.close();             }           }         }       }       /**      * Substitutes keys found in target file with corresponding data      *       * @param targetFile      *            Target file      * @param substitutionData      *            Map of key-value pairs of data      * @throws IOException      */     @SuppressWarnings({ ""unchecked"", ""rawtypes"" })     private static void changeData(File targetFile, Map&lt;String,String&gt; substitutionData) throws IOException{          BufferedReader br = null;         String docxTemplate = """";         try {             br = new BufferedReader(new InputStreamReader(new FileInputStream(targetFile), ""UTF-8""));             String temp;             while( (temp = br.readLine()) != null)                 docxTemplate = docxTemplate + temp;              br.close();             targetFile.delete();         }          catch (IOException e) {             br.close();             throw e;         }          Iterator substitutionDataIterator = substitutionData.entrySet().iterator();         while(substitutionDataIterator.hasNext()){             Map.Entry&lt;String,String&gt; pair = (Map.Entry&lt;String,String&gt;)substitutionDataIterator.next();             if(docxTemplate.contains(pair.getKey())){                 if(pair.getValue() != null)                     docxTemplate = docxTemplate.replace(pair.getKey(), pair.getValue());                 else                     docxTemplate = docxTemplate.replace(pair.getKey(), ""NEDOSTAJE"");             }         }          FileOutputStream fos = null;         try{             fos = new FileOutputStream(targetFile);             fos.write(docxTemplate.getBytes(""UTF-8""));             fos.close();         }         catch (IOException e) {             fos.close();             throw e;         }     }      /**      * Zipps specified directory and all its subdirectories      *       * @param directory      *            Specified directory      * @param zipfile      *            Output ZIP file name      * @throws IOException      */     private static void zip(File directory, File zipfile) throws IOException {          URI base = directory.toURI();         Deque&lt;File&gt; queue = new LinkedList&lt;File&gt;();         queue.push(directory);         OutputStream out = new FileOutputStream(zipfile);         Closeable res = out;          try {           ZipOutputStream zout = new ZipOutputStream(out);           res = zout;           while (!queue.isEmpty()) {             directory = queue.pop();             for (File kid : directory.listFiles()) {               String name = base.relativize(kid.toURI()).getPath();               if (kid.isDirectory()) {                 queue.push(kid);                 name = name.endsWith(""/"") ? name : name + ""/"";                 zout.putNextEntry(new ZipEntry(name));               }                else {                 if(kid.getName().contains("".docx""))                     continue;                   zout.putNextEntry(new ZipEntry(name));                 copy(kid, zout);                 zout.closeEntry();               }             }           }         }          finally {           res.close();         }       }      /**      * Sends HTTP Response containing .docx file to Client      *       * @param generatedFile      *            Path to generated .docx file      * @param fileName      *            File name of generated file that is being presented to user      * @throws IOException      */     private static void sendDOCXResponse(File generatedFile, String fileName) throws IOException {          FacesContext facesContext = FacesContext.getCurrentInstance();         ExternalContext externalContext = facesContext.getExternalContext();         HttpServletResponse response = (HttpServletResponse) externalContext                 .getResponse();          BufferedInputStream input = null;         BufferedOutputStream output = null;          response.reset();         response.setHeader(""Content-Type"", ""application/msword"");         response.setHeader(""Content-Disposition"", ""attachment; filename=\"""" + fileName + ""\"""");         response.setHeader(""Content-Length"",String.valueOf(generatedFile.length()));          input = new BufferedInputStream(new FileInputStream(generatedFile), 10240);         output = new BufferedOutputStream(response.getOutputStream(), 10240);          byte[] buffer = new byte[10240];         for (int length; (length = input.read(buffer)) &gt; 0;) {             output.write(buffer, 0, length);         }          output.flush();         input.close();         output.close();          // Inform JSF not to proceed with rest of life cycle         facesContext.responseComplete();     }       /**      * Deletes directory and all its subdirectories      *       * @param file      *            Specified directory      * @throws IOException      */     public static void deleteTempData(File file) throws IOException {          if (file.isDirectory()) {              // directory is empty, then delete it             if (file.list().length == 0)                 file.delete();             else {                 // list all the directory contents                 String files[] = file.list();                  for (String temp : files) {                     // construct the file structure                     File fileDelete = new File(file, temp);                     // recursive delete                     deleteTempData(fileDelete);                 }                  // check the directory again, if empty then delete it                 if (file.list().length == 0)                     file.delete();             }         } else {             // if file, then delete it             file.delete();         }     }      private static void copy(InputStream in, OutputStream out) throws IOException {          byte[] buffer = new byte[1024];         while (true) {           int readCount = in.read(buffer);           if (readCount &lt; 0) {             break;           }           out.write(buffer, 0, readCount);         }       }        private static void copy(File file, OutputStream out) throws IOException {         InputStream in = new FileInputStream(file);         try {           copy(in, out);         } finally {           in.close();         }       }        private static void copy(InputStream in, File file) throws IOException {         OutputStream out = new FileOutputStream(file);         try {           copy(in, out);         } finally {           out.close();         }      }  }"
