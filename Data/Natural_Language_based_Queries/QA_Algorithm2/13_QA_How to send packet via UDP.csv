code
"WifiManager wifi = (WifiManager) getSystemService(Context.WIFI_SERVICE); Method[] wmMethods = wifi.getClass().getDeclaredMethods(); for(Method method: wmMethods){   if(method.getName().equals(""setWifiApEnabled"")){     WifiConfiguration netConfig = new WifiConfiguration();     netConfig.SSID = ""\""PROVAAP\"""";     netConfig.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);     netConfig.allowedProtocols.set(WifiConfiguration.Protocol.RSN);     netConfig.allowedProtocols.set(WifiConfiguration.Protocol.WPA);     netConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);    netConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);     netConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);     netConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);     netConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);        try {       method.invoke(wifi, netConfig,true);     } catch (IllegalArgumentException e) {       e.printStackTrace();     } catch (IllegalAccessException e) {       e.printStackTrace();     } catch (InvocationTargetException e) {       e.printStackTrace();     }   } }"
"class NodeThread extends Thread {      private int nodeId;     private VirtualNetwork network;      public NodeThread(int nodeId,VirtualNetwork network) {         this.network = network;         this.nodeId = nodeId;     }     public void run() {         /* when you have to send */         int nodeReceptor = this.nodeId -1; /* neighbor in the array of threads */         Message m = new Message(this.nodeId,nodeReceptor);         m.setContent(10);         network.send(m);          /* when you have to receive */         Message m = network.receive(this.nodeId);         /* it's your decision to implement this in a blocking way or not */     } }"
"Server server = ServerFactory.getServer();         Service[] services = server.findServices();         for (Service service : services) {             for (Connector connector : service.findConnectors()) {                 ProtocolHandler protocolHandler = connector.getProtocolHandler();                 if (protocolHandler instanceof Http11Protocol                     || protocolHandler instanceof Http11AprProtocol                     || protocolHandler instanceof Http11NioProtocol) {                     serverPort = connector.getPort();                     System.out.println(""HTTP Port: "" + connector.getPort());                 }             }           }"
"private HttpClient createHttpClientOrProxy() {      HttpClientBuilder hcBuilder = HttpClients.custom();      // Set HTTP proxy, if specified in system properties     if( isSet(System.getProperty(""http.proxyHost"")) ) {         int port = 80;         if( isSet(System.getProperty(""http.proxyPort"")) ) {             port = Integer.parseInt(System.getProperty(""http.proxyPort""));         }         HttpHost proxy = new HttpHost(System.getProperty(""http.proxyHost""), port, ""http"");         DefaultProxyRoutePlanner routePlanner = new DefaultProxyRoutePlanner(proxy);         hcBuilder.setRoutePlanner(routePlanner);     }      CloseableHttpClient httpClient = hcBuilder.build();      return httpClient; }"
"package com.mobinet.snmp;  import org.snmp4j.CommunityTarget; import org.snmp4j.PDU; import org.snmp4j.Snmp; import org.snmp4j.TransportMapping; import org.snmp4j.event.ResponseEvent; import org.snmp4j.mp.SnmpConstants; import org.snmp4j.smi.Address; import org.snmp4j.smi.GenericAddress; import org.snmp4j.smi.Integer32; import org.snmp4j.smi.OID; import org.snmp4j.smi.OctetString; import org.snmp4j.smi.VariableBinding; import org.snmp4j.transport.DefaultTcpTransportMapping;  /**  *  * @author batbayar  */ public class SnmpTest {     private String address = ""192.168.1.254/161""; // switch address and snmp port     private String writeCommunity = ""myCommunityWrite""; // write community name      private Snmp snmp;     private CommunityTarget target;      public SnmpTest() {         try {             TransportMapping transport = new DefaultTcpTransportMapping();             snmp = new Snmp(transport);              Address targetAddress = GenericAddress.parse(address);             target = new CommunityTarget();             target.setCommunity(new OctetString(writeCommunity));             target.setAddress(targetAddress);             target.setRetries(2);             target.setTimeout(1500);             target.setVersion(SnmpConstants.version2c);              PDU command = new PDU();             command.setType(PDU.SET);             command.add(new VariableBinding(new OID(""1.3.6.1.2.1.2.2.1.7.1""), new Integer32(2))); // port 1 down             command.add(new VariableBinding(new OID(""1.3.6.1.2.1.2.2.1.7.6""), new Integer32(1))); // port 6 up             ResponseEvent response = snmp.send(command, target);             System.out.println(""response: "" + response);         } catch(Exception e) {             e.printStackTrace();         }     }      public static void main(String[] args) {         SnmpTest test = new SnmpTest();     } }"
"Properties properties = System.getProperties();     properties.put(""mail.smtp.host"", server);     properties.put(""mail.smtp.port"", """" + port);      Session session = Session.getInstance(properties);     Transport transport = session.getTransport(""smtp"");      transport.connect(server, username, password);      for (int i = 0; i &lt; count; i++) {          Message message = new MimeMessage(session);         message.setFrom(new InternetAddress(from));         InternetAddress[] address = {new InternetAddress(to)};         message.setRecipients(Message.RecipientType.TO, address);          message.setSubject(subject + ""JavaMail API"");         message.setSentDate(new Date());          setHTMLContent(message);         message.saveChanges();         transport.sendMessage(message, address);      }      transport.close();"
"public String getLocalIpAddress() {     try {         for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {             NetworkInterface intf = en.nextElement();             for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {                 InetAddress inetAddress = enumIpAddr.nextElement();                 if (!inetAddress.isLoopbackAddress()) {                     return inetAddress.getHostAddress().toString();                 }             }         }     } catch (SocketException ex) {         Log.e(LOG_TAG, ex.toString());     }     return null; }"
"public String getLocalIpAddress() {         try {             for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface                     .getNetworkInterfaces(); en.hasMoreElements();) {                 NetworkInterface intf = en.nextElement();                 for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf                         .getInetAddresses(); enumIpAddr.hasMoreElements();) {                     InetAddress inetAddress = enumIpAddr.nextElement();                     if (!inetAddress.isLoopbackAddress()) {                         return inetAddress.getHostAddress().toString();                     }                 }             }         } catch (SocketException ex) {             Log.e(tag, ex.toString());         }         return """";     }"
"ByteBuffer reUsableBuffer = ByteBuffer.allocateDirect(5120); Selector selector = Selector.open(); ServerSocketChannel channel = .. // wherever you get it from  channel.register(selector, SelectionKey.OP_ACCEPT); Executor executor = Executors.newThreadPoolExecutor(); while(selector.isOpen()) {   int numKey = selector.select();  for (SelectionKey key: selector.selectedKeys()) {     if (key.isAcceptable()) {              /// Sort of included for completeness but you get the idea            ServerSocketChannel server = (ServerSocketChannel)key.channel();            SocketChannel channel = server.accept();            channel.register(selector, SelectionKey.OP_READ | Selection.OP_WRITE, new StringBuilder());     }    if (key.isReadable()) {           // READ the data           reUsableBuffer.clear();           // You have to keep track of previous state.           // NIO makes no guarantees of anything           StringBuilder builder = key.attachment();           SocketChannel socketChannel = (SocketChannel)key.channel();           int readCount = socketChannel.read(reUsableBuffer);           if (readCount &gt; 0) {              reUsableBuffer.flip();              byte[] subStringBytes = new byte[readCount];              reUsableBuffer.read(subStringBytes);              // Assuming ASCII (bad assumption but simplifies the example)              builder.append(new String(substringBytes));               Command[] commands = removeCommands(builder);              // Deal with your commands in some async manor defined by you              executor.execute(new Task(commands));           }         }         selector.selectedKeys().clear(); } ....      }     // // Parse out the commands and return them, also remove traces of them in the // the builder, such that for a string, ""COMMAND, COMMAND, COM"" // an array of 2 should be returned with a left over buffer of ""COM"" public Command[] parseCommands(StringBuilder s) { ... }"
"public static String getUrl(HttpServletRequest req) {     String scheme = req.getScheme();             // http     String serverName = req.getServerName();     // hostname.com     int serverPort = req.getServerPort();        // 80     String contextPath = req.getContextPath();   // /mywebapp     String servletPath = req.getServletPath();   // /servlet/MyServlet     String pathInfo = req.getPathInfo();         // /a/b;c=123     String queryString = req.getQueryString();          // d=789      // Reconstruct original requesting URL     String url = scheme+""://""+serverName+"":""+serverPort+contextPath+servletPath;     if (pathInfo != null) {         url += pathInfo;     }     if (queryString != null) {         url += ""?""+queryString;     }     return url; }"
"public String intercept (ActionInvocation invocation) throws Exception {     // Get the action context from the invocation so we can access the     // HttpServletRequest and HttpSession objects.     final ActionContext context = invocation.getInvocationContext ();     HttpServletRequest request = (HttpServletRequest) context.get(HTTP_REQUEST);     HttpSession session =  request.getSession (true);      // Is there a ""user"" object stored in the user's HttpSession?     Object user = session.getAttribute (USER_HANDLE);     if (user == null) {         // The user has not logged in yet.          // Is the user attempting to log in right now?         String loginAttempt = request.getParameter (LOGIN_ATTEMPT);         if (! StringUtils.isBlank (loginAttempt) ) { // The user is attempting to log in.              // Process the user's login attempt.             if (processLoginAttempt (request, session) ) {                 // The login succeeded send them the login-success page.                 return ""login-success"";             } else {                 // The login failed. Set an error if we can on the action.                 Object action = invocation.getAction ();                 if (action instanceof ValidationAware) {                     ((ValidationAware) action).addActionError (""Username or password incorrect."");                 }             }         }          // Either the login attempt failed or the user hasn't tried to login yet,          // and we need to send the login form.         return ""login"";     } else {         return invocation.invoke ();     } }"
"if (req.getRequestURI().equals(""/twitter"")) {     Token requestToken = service.getRequestToken();     System.out.println(""Got the Request Token!"" + requestToken.getToken());     session = request.getSession(true);     session.setAttribute(""TOKEN"", requestToken);     response.sendRedirect(service.getAuthorizationUrl(requestToken)); } else if (req.getRequestURI().equals(""/twitter/callback"")) {     String code = request.getParameter(""oauth_verifier"");     System.out.println(""Verifier :: "" + code);     System.out.println(""service.getRequestToken()"" + service.getRequestToken());     session = request.getSession(false);     Token requestToken = (Token) session.getAttribute(""TOKEN"");     System.out.println(""requestToken from Session "" + service.getRequestToken().getToken() + "" Secr"" + service.getRequestToken().getSecret());      if (code != null &amp;&amp; !code.isEmpty()) {         Verifier verifier = new Verifier(code);         Token accessToken = service.getAccessToken(requestToken, verifier);         OAuthRequest req = new OAuthRequest(Verb.GET, OAUTH_PROTECTED_URL);         service.signRequest(accessToken, req);         Response res = req.send();         response.setContentType(""text/plain"");         response.getWriter().println(res.getBody());     } }"
"private Drawable getQuestionImageDrawable(int questionNumber) { Drawable image; URL imageUrl;  try {     // Create a Drawable by decoding a stream from a remote URL     imageUrl = new URL(getQuestionImageUrl(questionNumber));     HttpURLConnection conn = (HttpURLConnection) imageUrl.openConnection();     conn.setDoInput(true);     conn.connect();     InputStream stream = conn.getInputStream();     Bitmap bitmap = BitmapFactory.decodeStream(stream);     image = new BitmapDrawable(getResources(), bitmap); } catch (Exception e) {     Log.e(TAG, ""Decoding Bitmap stream failed"");     image = getResources().getDrawable(R.drawable.noquestion); } return image; }"
"public String FileDownloadNonPersistently() {         String server_reply = new String();         try {             sc = (SocketConnection) Connector.open(""socket://"" + hostname + "":"" + port);             os = sc.openOutputStream();             os.write((""GET "" + link_to_file_to_be_downloaded +                      "" HTTP/1.0\r\n"").getBytes(""UTF-8""));             os.write((""HOST: "" + hostname + ""\r\n"").getBytes(""UTF-8""));             os.write((""\r\n"").getBytes(""UTF-8""));             os.flush();             os.close();              in = sc.openInputStream();             // 1. Read the response header from server separately beforehand.             byte data;             String temp_char = """";             while (!""\r\n\r\n"".equals(temp_char)) {                 data = (byte) in.read();                 server_reply += String.valueOf((char) data);                 if (((char) data) == '\r' || ((char) data) == '\n') {                     temp_char += String.valueOf((char) data);                 } else {                     temp_char = """";                 }             }              // 2. Recieving the actual data, be it text or binary             current = 0;             mybytearray  = new byte[filesize];             bytesRead = in.read(mybytearray,0,mybytearray.length);             current = bytesRead;             do {                 bytesRead = in.read(mybytearray, current,                        (mybytearray.length-current));                 if(bytesRead &gt;= 0) current += bytesRead;             } while(bytesRead &gt; -1);              // Store recieved data to file, if set true from options             if (tcp_save_downloaded_file == true) {                 // decide an appropriate file name acc. to download link                 String url = ""file:///E:/Data/"" + ""tcp_downloaded_file.pdf"";                 FileConnection fconn = (FileConnection)                          Connector.open(url, Connector.READ_WRITE);                 if (!fconn.exists()) {      // XXX. what if file already present? overwrite or append mode?                     fconn.create();                 }                 OutputStream ops = fconn.openOutputStream();                 ops.write(mybytearray, 0 , current);                 ops.flush();                 ops.close();             }          } catch (Exception ex) {             parent_class.main_form.append(""Exception occured while ""                     + ""downloading file: "" + ex.toString() + ""\n\n"");         } finally {             if (in != null) {                 try {                     in.close();                 } catch (IOException ex) {                     parent_class.main_form.append(""Exception occured while ""                             + ""closing inputstream ""                             + ""after downloading file: "" + ex.toString() + ""\n\n"");                 }             }             // XXX. see if you need to close the OutputStreams and              // SocketConnection as well.             return server_reply;         }     }"
"public class NetworkStateReceiver extends BroadcastReceiver {     public void onReceive(Context context, Intent intent) {      Log.d(""app"",""Network connectivity change"");      if(intent.getExtras()!=null) {         NetworkInfo ni=(NetworkInfo) intent.getExtras().get(ConnectivityManager.EXTRA_NETWORK_INFO);         if(ni!=null &amp;&amp; ni.getState()==NetworkInfo.State.CONNECTED) {             Log.i(""app"",""Network ""+ni.getTypeName()+"" connected"");         }      }      if(intent.getExtras().getBoolean(ConnectivityManager.EXTRA_NO_CONNECTIVITY,Boolean.FALSE)) {             Log.d(""app"",""There's no network connectivity"");      }    } }"
"try {         httpURL=""http://google.co.in/"";          if ((WLANInfo.getWLANState() == WLANInfo.WLAN_STATE_CONNECTED)                 &amp;&amp; RadioInfo                         .areWAFsSupported(RadioInfo.WAF_WLAN)) {             httpURL += "";interface=wifi"";         }else  if (TransportInfo.isTransportTypeAvailable(TransportInfo.TRANSPORT_BIS_B) &amp;&amp; TransportInfo.hasSufficientCoverage(TransportInfo.TRANSPORT_BIS_B)) {             System.out.println(""BIS CONNECTION-------------------"");             // Holder.connectionInterface="";deviceside=false;ConnectionType=mds-public"";             httpURL += "";deviceside=false;ConnectionType=mds-public"";         }          //Dialog.alert(httpURL);         HttpConnection httpConn;         httpConn = (HttpConnection) Connector.open(httpURL);         httpConn.setRequestMethod(HttpConnection.POST);         DataOutputStream _outStream = new DataOutputStream(httpConn.openDataOutputStream());         byte[] request_body = httpURL.getBytes();         for (int i = 0; i &lt; request_body.length; i++) {             _outStream.writeByte(request_body[i]);         }         DataInputStream _inputStream = new DataInputStream(         httpConn.openInputStream());         StringBuffer _responseMessage = new StringBuffer();         int ch;         while ((ch = _inputStream.read()) != -1) {             _responseMessage.append((char) ch);         }         String res = (_responseMessage.toString());         responce = res.trim();          //Dialog.alert(responce);          httpConn.close();       }catch (Exception e) {         Dialog.alert(""Error -""+e.toString());     }"
"String baseURL=""https://sb-ssl.google.com/safebrowsing/api/lookup"";  String arguments = """"; arguments + =URLEncoder.encode(""client"", ""UTF-8"") + ""="" + URLEncoder.encode(""myapp"", ""UTF-8"") + ""&amp;""; arguments + =URLEncoder.encode(""apikey"", ""UTF-8"") + ""="" + URLEncoder.encode(""12341234"", ""UTF-8"") + ""&amp;""; arguments + =URLEncoder.encode(""appver"", ""UTF-8"") + ""="" + URLEncoder.encode(""1.5.2"", ""UTF-8"") + ""&amp;""; arguments + =URLEncoder.encode(""pver"", ""UTF-8"") + ""="" + URLEncoder.encode(""3.0"", ""UTF-8"");  // Construct the url object representing cgi script URL url = new URL(baseURL + ""?"" + arguments);  // Get a URLConnection object, to write to POST method URLConnection connect = url.openConnection();  // Specify connection settings connect.setDoInput(true); connect.setDoOutput(true);  // Get an output stream for writing OutputStream output = connect.getOutputStream(); PrintStream pout = new PrintStream (output); pout.print(""2""); pout.println(); pout.print(""http://www.google.com""); pout.println(); pout.print(""http://www.facebook.com""); pout.close();"
"private Socket socket = null;         private Socket remoteSocket = null;         private HTTPReqHeader request = null;         ClientHandler(Socket socket)         {            this.socket = socket;            request = new HTTPReqHeader();            request.parse(socket); // I read and parse the HTTP request here         }         public void run()        {              remoteSocket = new Socket(request.url,request.port);              if(request.isSecure() )             {                  // send ok message to client                  String ConnectResponse = ""HTTP/1.0 200 Connection established\n"" +                                           ""Proxy-agent: ProxyServer/1.0\n"" +                                           ""\r\n"";                 try                 {            DataOutputStream out =  new DataOutputStream(socket.getOutputStream());                    out.writeByte(ConnectResponse);                     out.flush();                 } catch(Exception e) {}               }              // start connecting remoteSocket and clientSocket              ...........        }"
"logger.debug(""Configure port for SSL"");         String command = ""create-http-listener"";         ParameterMap params = new ParameterMap();         params.add(""listeneraddress"", ""0.0.0.0"");         params.add(""listenerport"", ""443"");         params.add(""defaultvs"", ""server"");         params.add(""securityenabled"", ""true"");         params.add(""enabled"", ""true"");         params.add(""DEFAULT"", ""http-listener2"");         CommandRunner runner = server.getHabitat().getComponent(CommandRunner.class);         ActionReport report = server.getHabitat().getComponent(ActionReport.class);         runner.getCommandInvocation(command, report).parameters(params).execute();"
"URI website; try {     HttpClient client = new DefaultHttpClient();     website = new URI(""http://""+ IP+ "":8080/ServerName/ServletName"");     HttpPost request = new HttpPost();     request.setHeader(""Data Name"", Data Value);     request.setURI(website);     HttpResponse response = client.execute(request);     // Response From Server     Header[] headers = response.getAllHeaders();     for (int i = 0; i &lt; headers.length; i++) {     Header h = headers[i];     }     } catch (URISyntaxException e) {          e.printStackTrace();     } catch (ClientProtocolException e) {         e.printStackTrace();     } catch (IOException e) {         e.printStackTrace();    }"
"public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {      //Get a hold of the http request     HttpServletRequest req = (HttpServletRequest)request;       //Access the HttpSession associated with the request     HttpSession session =  req.getSession(false);        //Take what you want from the session     activeUserModel = (ActiveUserModel) session.getAttribute(""ActiveUserModel"");               String username = SecurityAssociation.getPrincipal().getName();                       if(activeUserModel.getUsername() == null) {           try {            pBean.consultaProfile(username);                        } catch (SQLException e) {             e.printStackTrace();           } catch (NamingException e) {             e.printStackTrace();           }            }else{         }                filterChain.doFilter(servletRequest, servletResponse);            }"
"private static List&lt;InetAddress&gt; getIpAddress() {   try {     List&lt;InetAddress&gt; result = new ArrayList&lt;InetAddress&gt;();      Enumeration&lt;NetworkInterface&gt; interfaces = NetworkInterface.getNetworkInterfaces();     while (interfaces.hasMoreElements()) {       NetworkInterface intf = interfaces.nextElement();       Enumeration&lt;InetAddress&gt; addresses = intf.getInetAddresses();       while (addresses.hasMoreElements()) {         InetAddress address = addresses.nextElement();         if (!address.isLoopbackAddress() &amp;&amp; !address.isLinkLocalAddress()) {           result.add(address);         }       }     }     return result;   } catch (SocketException ex) {     Log.e(TAG, ""Failed to list network interfaces."", ex);     return null;   } }"
"log4j.rootLogger=DEBUG  # AdminFileAppender - used to log messages in the admin.log file. log4j.appender.AdminFileAppender=org.apache.log4j.FileAppender  log4j.appender.AdminFileAppender.File=admin.log  log4j.appender.AdminFileAppender.layout=org.apache.log4j.PatternLayout log4j.appender.AdminFileAppender.layout.ConversionPattern= %-4r [%t] %-5p %c %x - %m%n  # ReportFileAppender - used to log messages in the report.log file. log4j.appender.ReportFileAppender=org.apache.log4j.FileAppender  log4j.appender.ReportFileAppender.File=report.log  log4j.appender.ReportFileAppender.layout=org.apache.log4j.PatternLayout log4j.appender.ReportFileAppender.layout.ConversionPattern= %-4r [%t] %-5p %c %x - %m%n  log4j.logger.com.vaannila.admin=WARN,AdminFileAppender  log4j.logger.com.vaannila.report=DEBUG,ReportFileAppender"
"try             {                                    factory = new HttpConnectionFactory();                 url=""Here put any sample url or any of your web service to check network connection."";                 httpConnection = factory.getHttpConnection(url);                 response=httpConnection.getResponseCode();                 if(response==HttpConnection.HTTP_OK)                 {                     callback(response);                 }else                 {                     callback(response);                 }             } catch (Exception e)              {                 System.out.println(e.getMessage());                 callback(0);             }"
"try {      int cellID = GPRSInfo.getCellInfo().getCellId();     int lac = GPRSInfo.getCellInfo().getLAC();      String urlString2 = ""http://www.google.com/glm/mmap"";     if ((WLANInfo.getWLANState() == WLANInfo.WLAN_STATE_CONNECTED)             &amp;&amp; RadioInfo                     .areWAFsSupported(RadioInfo.WAF_WLAN)) {         urlString2 += "";interface=wifi;ConnectionTimeout=60000"";     }else  if (TransportInfo.isTransportTypeAvailable(TransportInfo.TRANSPORT_BIS_B) &amp;&amp; TransportInfo.hasSufficientCoverage(TransportInfo.TRANSPORT_BIS_B)) {         System.out.println(""BIS CONNECTION-------------------"");         // Holder.connectionInterface="";deviceside=false;ConnectionType=mds-public"";         urlString2 += "";deviceside=false;ConnectionType=mds-public;ConnectionTimeout=60000"";     }        // Open a connection to Google Maps API      ConnectionFactory connFact = new ConnectionFactory();     ConnectionDescriptor connDesc;     connDesc = connFact.getConnection(urlString2);      HttpConnection httpConn2;     httpConn2 = (HttpConnection)connDesc.getConnection();     httpConn2.setRequestMethod(""POST"");      // Write some custom data to Google Maps API      OutputStream outputStream2 = httpConn2.openOutputStream();//getOutputStream();     WriteDataGoogleMaps(outputStream2, cellID, lac);      // Get the response       InputStream inputStream2 = httpConn2.openInputStream();//getInputStream();     DataInputStream dataInputStream2 = new DataInputStream(inputStream2);      // Interpret the response obtained      dataInputStream2.readShort();     dataInputStream2.readByte();      int code = dataInputStream2.readInt();     //Dialog.alert(code+"""");      if (code == 0) {         latitude= dataInputStream2.readInt() / 1000000D;         longitude=dataInputStream2.readInt() / 1000000D;          //Dialog.alert(latitude+""-----""+longitude);            dataInputStream2.readInt();         dataInputStream2.readInt();         dataInputStream2.readUTF();      } else {         System.out.println(""Error obtaining Cell Id "");     }     outputStream2.close();     inputStream2.close(); } catch (Exception e) {     System.out.println(""Error: "" + e.getMessage()); }"
"int resCode; String location = ""http://company.com/temp1.aspx""; while (true) {        HttpConnection connection = (HttpConnection) Connector.open(location + "";deviceside=true"");      connection.setRequestMethod(HttpConnection.GET);      connection.setRequestProperty(HttpHeaders.HEADER_CONNECTION, ""close"");      connection.setRequestProperty(HttpHeaders.HEADER_CONTENT_LENGTH, ""0"");      resCode = connection.getResponseCode();      if( resCode == HttpConnection.HTTP_TEMP_REDIRECT           || resCode == HttpConnection.HTTP_MOVED_TEMP           || resCode == HttpConnection.HTTP_MOVED_PERM ) {           location = connection.getHeaderField(""location"").trim();      } else {           resCode = connection.getResponseCode();           break;      } }"
"public static String getStringContent(String uri, String postData,          HashMap&lt;String, String&gt; headers) throws Exception {          HttpClient client = new DefaultHttpClient();         HttpPost request = new HttpPost();         request.setURI(new URI(uri));         request.setEntity(new StringEntity(postData));         for(Entry&lt;String, String&gt; s : headers.entrySet())         {             request.setHeader(s.getKey(), s.getValue());         }         HttpResponse response = client.execute(request);          InputStream ips  = response.getEntity().getContent();         BufferedReader buf = new BufferedReader(new InputStreamReader(ips,""UTF-8""));         if(response.getStatusLine().getStatusCode()!=HttpStatus.SC_OK)         {             throw new Exception(response.getStatusLine().getReasonPhrase());         }         StringBuilder sb = new StringBuilder();         String s;         while(true )         {             s = buf.readLine();             if(s==null || s.length()==0)                 break;             sb.append(s);          }         buf.close();         ips.close();         return sb.toString();   }"
"CloseableHttpClient client = HttpClients.custom()     .disableContentCompression()     .build();  HttpGet request = new HttpGet(urlSring); request.setHeader(HttpHeaders.ACCEPT_ENCODING, ""gzip"");  CloseableHttpResponse response = client.execute(request, context); HttpEntity entity = response.getEntity(); Header contentEncodingHeader = entity.getContentEncoding();  if (contentEncodingHeader != null) {     HeaderElement[] encodings =contentEncodingHeader.getElements();     for (int i = 0; i &lt; encodings.length; i++) {         if (encodings[i].getName().equalsIgnoreCase(""gzip"")) {             entity = new GzipDecompressingEntity(entity);             break;         }     } }  String output = EntityUtils.toString(entity, Charset.forName(""UTF-8"").name());"
"HttpClient client = new DefaultHttpClient(); HttpPost post = new HttpPost(""http://localhost/something"");   post.setHeader(""Referer"", ""http://localhost/something""); post.setHeader(""Authorization"", ""Basic (with a username and password)""); post.setHeader(""Content-type"", ""application/json"");  // if you need any parameters List&lt;NameValuePair&gt; urlParameters = new ArrayList&lt;NameValuePair&gt;(); urlParameters.add(new BasicNameValuePair(""paramName"", ""paramValue"")); post.setEntity(new UrlEncodedFormEntity(urlParameters));  HttpResponse response = client.execute(post);  HttpEntity entity = response.getEntity(); Header encodingHeader = entity.getContentEncoding();  // you need to know the encoding to parse correctly Charset encoding = encodingHeader == null ? StandardCharsets.UTF_8 :  Charsets.toCharset(encodingHeader.getValue());  // use org.apache.http.util.EntityUtils to read json as string String json = EntityUtils.toString(entity, StandardCharsets.UTF_8);  JSONObject o = new JSONObject(json);"
"try {   InetAddress localhost = InetAddress.getLocalHost();   LOG.info("" IP Addr: "" + localhost.getHostAddress());   // Just in case this host has multiple IP addresses....   InetAddress[] allMyIps = InetAddress.getAllByName(localhost.getCanonicalHostName());   if (allMyIps != null &amp;&amp; allMyIps.length &gt; 1) {     LOG.info("" Full list of IP addresses:"");     for (int i = 0; i &lt; allMyIps.length; i++) {       LOG.info(""    "" + allMyIps[i]);     }   } } catch (UnknownHostException e) {   LOG.info("" (error retrieving server host name)""); }  try {   LOG.info(""Full list of Network Interfaces:"");   for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {     NetworkInterface intf = en.nextElement();     LOG.info(""    "" + intf.getName() + "" "" + intf.getDisplayName());     for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements(); ) {       LOG.info(""        "" + enumIpAddr.nextElement().toString());     }   } } catch (SocketException e) {   LOG.info("" (error retrieving network interface list)""); }"
