code
"import java.awt.*; import java.awt.event.ActionEvent; import java.awt.image.BufferedImage; //import java.awt.image.ColorModel; // I don't know how to use that //import java.awt.image.SampleModel;// I don't know how to use that import javax.swing.*; import javax.swing.RepaintManager; import javax.swing.event.ChangeEvent; import javax.swing.event.ChangeListener; import javax.swing.table.TableModel;  public class ViewPortFlickeringOriginal {      private JFrame frame = new JFrame(""Table"");     private JViewport viewport = new JViewport();     private Rectangle RECT = new Rectangle();     private Rectangle RECT1 = new Rectangle();     private JTable table = new JTable(50, 3);     private javax.swing.Timer timer;     private int count = 0;     private boolean topOrBottom = false;     private GradientViewPortOriginal tableViewPort;      public ViewPortFlickeringOriginal() {         tableViewPort = new GradientViewPortOriginal(table);         viewport = tableViewPort.getViewport();         viewport.addChangeListener(new ChangeListener() {              @Override             public void stateChanged(ChangeEvent e) {                 if (tableViewPort.bolStart) {                     RECT = table.getCellRect(0, 0, true);                     RECT1 = table.getCellRect(table.getRowCount() - 1, 0, true);                     Rectangle viewRect = viewport.getViewRect();                     if (viewRect.intersects(RECT)) {                         System.out.println(""Visible RECT -&gt; "" + RECT);                         tableViewPort.paintBackGround(new Color(250, 150, 150));                     } else if (viewRect.intersects(RECT1)) {                         System.out.println(""Visible RECT1 -&gt; "" + RECT1);                         tableViewPort.paintBackGround(new Color(150, 250, 150));                     } else {                         System.out.println(""Visible RECT1 -&gt; ???? "");                         tableViewPort.paintBackGround(new Color(150, 150, 250));                     }                 }             }         });         frame.add(tableViewPort);         frame.setPreferredSize(new Dimension(600, 300));         frame.pack();         frame.setLocation(50, 100);         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         RepaintManager.setCurrentManager(new RepaintManager() {              @Override             public void addDirtyRegion(JComponent c, int x, int y, int w, int h) {                 Container con = c.getParent();                 while (con instanceof JComponent) {                     if (!con.isVisible()) {                         return;                     }                     if (con instanceof GradientViewPortOriginal) {                         c = (JComponent) con;                         x = 0;                         y = 0;                         w = con.getWidth();                         h = con.getHeight();                     }                     con = con.getParent();                 }                 super.addDirtyRegion(c, x, y, w, h);             }         });         frame.setVisible(true);         start();     }      private void start() {         timer = new javax.swing.Timer(100, updateCol());         timer.start();     }      public Action updateCol() {         return new AbstractAction(""text load action"") {              private static final long serialVersionUID = 1L;              @Override             public void actionPerformed(ActionEvent e) {                  System.out.println(""updating row "" + (count + 1));                 TableModel model = table.getModel();                 int cols = model.getColumnCount();                 int row = 0;                 for (int j = 0; j &lt; cols; j++) {                     row = count;                     table.changeSelection(row, 0, false, false);                     timer.setDelay(100);                     Object value = ""row "" + (count + 1) + "" item "" + (j + 1);                     model.setValueAt(value, count, j);                 }                 count++;                 if (count &gt;= table.getRowCount()) {                     timer.stop();                     table.changeSelection(0, 0, false, false);                     java.awt.EventQueue.invokeLater(new Runnable() {                          @Override                         public void run() {                             table.clearSelection();                             tableViewPort.bolStart = true;                         }                     });                 }             }         };     }      public static void main(String[] args) {         java.awt.EventQueue.invokeLater(new Runnable() {              @Override             public void run() {                 ViewPortFlickeringOriginal viewPortFlickering = new ViewPortFlickeringOriginal();             }         });     } }  class GradientViewPortOriginal extends JScrollPane {      private static final long serialVersionUID = 1L;     private final int h = 50;     private BufferedImage img = null;     private BufferedImage shadow = new BufferedImage(1, h, BufferedImage.TYPE_INT_ARGB);     private JViewport viewPort;     public boolean bolStart = false;      public GradientViewPortOriginal(JComponent com) {         super(com);         viewPort = this.getViewport();         viewPort.setScrollMode(JViewport.BLIT_SCROLL_MODE);         viewPort.setScrollMode(JViewport.BACKINGSTORE_SCROLL_MODE);         viewPort.setScrollMode(JViewport.SIMPLE_SCROLL_MODE);         paintBackGround(new Color(250, 150, 150));     }      public void paintBackGround(Color g) {         Graphics2D g2 = shadow.createGraphics();         g2.setPaint(g);         g2.fillRect(0, 0, 1, h);         g2.setComposite(AlphaComposite.DstIn);         g2.setPaint(new GradientPaint(0, 0, new Color(0, 0, 0, 0f), 0, h,                 new Color(0.1f, 0.8f, 0.8f, 0.5f)));         g2.fillRect(0, 0, 1, h);         g2.dispose();     }      @Override     public void paint(Graphics g) {         if (img == null || img.getWidth() != getWidth() || img.getHeight() != getHeight()) {             img = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);         }         Graphics2D g2 = img.createGraphics();         super.paint(g2);         Rectangle bounds = getViewport().getVisibleRect();         g2.scale(bounds.getWidth(), -1);         int y = (getColumnHeader() == null) ? 0 : getColumnHeader().getHeight();         g2.drawImage(shadow, bounds.x, -bounds.y - y - h, null);         g2.scale(1, -1);         g2.drawImage(shadow, bounds.x, bounds.y + bounds.height - h + y, null);         g2.dispose();         g.drawImage(img, 0, 0, null);     } }"
"JNIEnv* create_vm(JavaVM ** jvm) {      JNIEnv *env;     JavaVMInitArgs vm_args;     JavaVMOption options[2];     options[0].optionString = CLASSPATH; //""-Djava.class.path=/scratch/workareas/JTest/Java/""     options[1].optionString = ""-DXcheck:jni:pedantic"";     vm_args.version = JNI_VERSION_1_6; //JDK version. This indicates version 1.6     vm_args.nOptions = 2;     vm_args.options = options;     vm_args.ignoreUnrecognized = JNI_TRUE; //drop unrecognized options      int ret = JNI_CreateJavaVM(jvm, (void**) &amp;env, &amp;vm_args);     if (ret &lt; 0) printf(""\n&lt;&lt;&lt;&lt;&lt; Unable to Launch JVM &gt;&gt;&gt;&gt;&gt;\n"");     return env; }"
"import javax.sound.midi.*; import java.util.ArrayList; import java.util.List; import java.io.*;     public class MidiHandler {      public MidiHandler()     {         MidiDevice device;         MidiDevice.Info[] infos = MidiSystem.getMidiDeviceInfo();         for (int i = 0; i &lt; infos.length; i++) {             try {             device = MidiSystem.getMidiDevice(infos[i]);             //does the device have any transmitters?             //if it does, add it to the device list             System.out.println(infos[i]);              //get all transmitters             List&lt;Transmitter&gt; transmitters = device.getTransmitters();             //and for each transmitter              for(int j = 0; j&lt;transmitters.size();j++) {                 //create a new receiver                 transmitters.get(j).setReceiver(                         //using my own MidiInputReceiver                         new MidiInputReceiver(device.getDeviceInfo().toString())                 );             }              Transmitter trans = device.getTransmitter();             trans.setReceiver(new MidiInputReceiver(device.getDeviceInfo().toString()));              //open each device             device.open();             //if code gets this far without throwing an exception             //print a success message             System.out.println(device.getDeviceInfo()+"" Was Opened"");           } catch (MidiUnavailableException e) {}     }   } //tried to write my own class. I thought the send method handles an MidiEvents sent to it public class MidiInputReceiver implements Receiver {     public String name;     public MidiInputReceiver(String name) {         this.name = name;     }     public void send(MidiMessage msg, long timeStamp) {         System.out.println(""midi received"");     }     public void close() {}     } }"
"import java.io.File;  import java.io.IOException;  import javax.sound.sampled.AudioFormat;  import javax.sound.sampled.AudioInputStream;  import javax.sound.sampled.AudioSystem;  import javax.sound.sampled.DataLine;  import javax.sound.sampled.FloatControl;  import javax.sound.sampled.LineUnavailableException;  import javax.sound.sampled.SourceDataLine;  import javax.sound.sampled.UnsupportedAudioFileException;   public class AePlayWave extends Thread {       private String filename;      private Position curPosition;      private final int EXTERNAL_BUFFER_SIZE = 524288; // 128Kb       enum Position {          LEFT, RIGHT, NORMAL     };      public AePlayWave(String wavfile) {          filename = wavfile;         curPosition = Position.NORMAL;     }       public AePlayWave(String wavfile, Position p) {          filename = wavfile;         curPosition = p;     }       public void run() {           File soundFile = new File(filename);         if (!soundFile.exists()) {              System.err.println(""Wave file not found: "" + filename);             return;         }           AudioInputStream audioInputStream = null;         try {              audioInputStream = AudioSystem.getAudioInputStream(soundFile);         } catch (UnsupportedAudioFileException e1) {              e1.printStackTrace();             return;         } catch (IOException e1) {              e1.printStackTrace();             return;         }           AudioFormat format = audioInputStream.getFormat();         SourceDataLine auline = null;         DataLine.Info info = new DataLine.Info(SourceDataLine.class, format);          try {              auline = (SourceDataLine) AudioSystem.getLine(info);             auline.open(format);         } catch (LineUnavailableException e) {              e.printStackTrace();             return;         } catch (Exception e) {              e.printStackTrace();             return;         }           if (auline.isControlSupported(FloatControl.Type.PAN)) {              FloatControl pan = (FloatControl) auline                     .getControl(FloatControl.Type.PAN);             if (curPosition == Position.RIGHT)                  pan.setValue(1.0f);             else if (curPosition == Position.LEFT)                  pan.setValue(-1.0f);         }           auline.start();         int nBytesRead = 0;         byte[] abData = new byte[EXTERNAL_BUFFER_SIZE];          try {              while (nBytesRead != -1) {                  nBytesRead = audioInputStream.read(abData, 0, abData.length);                 if (nBytesRead &gt;= 0)                      auline.write(abData, 0, nBytesRead);             }          } catch (IOException e) {              e.printStackTrace();             return;         } finally {              auline.drain();             auline.close();         }       }  }"
"import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.io.IOException; import java.net.URL;  import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.Clip; import javax.sound.sampled.LineUnavailableException; import javax.sound.sampled.UnsupportedAudioFileException; import javax.swing.JButton; import javax.swing.JFrame;  public class PlaySound extends JFrame{      private Clip clip;      public static void main(String [] args) {          PlaySound app = new PlaySound();      }      public PlaySound() {         JButton play = new JButton(""Play"");//here we make the button         play.addActionListener(new ActionListener() {//here we tell what the button will do         public void actionPerformed(ActionEvent e) {             playTheSound();//when its clicked call this method         }     });      this.add(play);     this.pack();     this.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);     this.setVisible(true); }  private void SoundEffect(URL url) {     try {         // Set up an audio input stream piped from the sound file.         AudioInputStream audioInputStream = AudioSystem.getAudioInputStream(url);         // Get a clip resource.         clip = AudioSystem.getClip();         // Open audio clip and load samples from the audio input stream.         clip.open(audioInputStream);     } catch (UnsupportedAudioFileException e) {         e.printStackTrace();     } catch (IOException e) {         e.printStackTrace();     } catch (LineUnavailableException e) {         e.printStackTrace();     } }  // Play or Re-play the sound effect from the beginning, by rewinding. public void playTheSound() {      URL url = getClass().getResource(""click.wav"");//You can change this to whatever other sound you have     SoundEffect(url);//this method will load the sound      if (clip.isRunning())         clip.stop();   // Stop the player if it is still running     clip.setFramePosition(0); // rewind to the beginning     clip.start();     // Start playing      }  }"
"package laboratorio9;  import java.util.Random; import java.util.Arrays;  public class ArregloBinario {     private int[] datos;     private static Random generador = new Random();      public ArregloBinario (int tamanio)     {         datos = new int[tamanio];          for (int i=0; i&lt;tamanio; i++)             datos[i] = 10 + generador.nextInt(90);          Arrays.sort(datos);     }      public int busquedaBinaria(int elementoBusqueda)     {         int inferior = 0;         int superior = datos.length-1;         int medio = (inferior + superior + 1 ) / 2;         int ubicacion = -1;          // **HOW CAN I CHANGE THE FOLLOWING NTO A RECURSIVE FUNCTION&gt;**         do          {             System.out.print(elementosRestantes(inferior,superior));              for (int i = 0; i&lt;medio; i++)                 System.out.print(""   "");             System.out.println("" * "");              if (elementoBusqueda == datos[medio])                 ubicacion=medio;             else if (elementoBusqueda&lt;datos[medio])                 superior = medio-1;             else                  inferior = medio+1;              medio = (inferior + superior + 1) / 2;         } while ((inferior &lt;=superior) &amp;&amp; (ubicacion == -1));         return ubicacion;                     }      public String elementosRestantes(int inferior, int superior)     {         StringBuilder temporal = new StringBuilder();          for (int i = 0; i &lt; inferior; i++)             temporal.append( ""   "" );          for (int i = inferior; i &lt;= superior; i++)             temporal.append( datos[i] + "" "");          temporal.append(""\n"");         return temporal.toString();     }      public String toString()     {         return elementosRestantes(0, datos.length-1);     } }"
"package secretgame.scripting;  import java.io.ByteArrayInputStream; import java.io.IOException; import java.io.InputStream; import java.util.ArrayList;  import org.luaj.vm2.LuaClosure; import org.luaj.vm2.LuaTable; import org.luaj.vm2.LuaValue; import org.luaj.vm2.Prototype; import org.luaj.vm2.compiler.LuaC; import org.luaj.vm2.lib.jse.CoerceJavaToLua; import org.luaj.vm2.lib.jse.JsePlatform;  import secretgame.SecretGameException; import secretgame.events.EventArgs; import secretgame.levels.Level;  public class DirectLuaj implements Lua {   private final Level level;   private final ScriptTools scriptTools;   private final ScriptEvents scriptEvents;   private int nextId = 0;   private ArrayList&lt;LuaClosure&gt; scripts = new ArrayList&lt;LuaClosure&gt;();    public DirectLuaj(Level level, ScriptTools scriptTools,       ScriptEvents scriptEvents)   {     this.level = level;     this.scriptTools = scriptTools;     this.scriptEvents = scriptEvents;   }    @Override   public int add(String scriptText) throws SecretGameException   {     try {       InputStream input = new ByteArrayInputStream(scriptText.getBytes());       Prototype p = LuaC.compile(input, ""script"");       LuaValue g = JsePlatform.standardGlobals();       LuaClosure c = new LuaClosure(p, g);       scripts.add(c);     }     catch (IOException e) {       throw new SecretGameException(""compile failed"", e);     }      return nextId++;   }    @Override   public void run(int id, EventArgs args) throws SecretGameException   {     LuaClosure script = scripts.get(id);      LuaTable bindings = new LuaTable();      bindings.set(""java"", toLua(scriptTools));     bindings.set(""level"", toLua(level));     bindings.set(""args"", toLua(args));     bindings.set(""events"", toLua(scriptEvents));      script.setfenv(bindings);      script.call();   }    private LuaValue toLua(Object javaValue) {     return javaValue == null? LuaValue.NIL:             javaValue instanceof LuaValue? (LuaValue) javaValue:             CoerceJavaToLua.coerce(javaValue);   } }"
"import java.io.IOException; import java.net.Socket; import java.net.UnknownHostException; import java.security.KeyManagementException; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.UnrecoverableKeyException; import java.security.cert.CertificateException; import java.security.cert.X509Certificate;  import javax.net.ssl.SSLContext; import javax.net.ssl.TrustManager; import javax.net.ssl.X509TrustManager;  import org.apache.http.conn.ssl.SSLSocketFactory; public class MySSLSocketFactory extends SSLSocketFactory {     SSLContext sslContext = SSLContext.getInstance(""TLS"");      public MySSLSocketFactory(KeyStore truststore) throws NoSuchAlgorithmException, KeyManagementException, KeyStoreException, UnrecoverableKeyException {         super(truststore);          TrustManager tm = new X509TrustManager() {             public void checkClientTrusted(X509Certificate[] chain, String authType) throws CertificateException {             }              public void checkServerTrusted(X509Certificate[] chain, String authType) throws CertificateException {             }              public X509Certificate[] getAcceptedIssuers() {                 return null;             }         };          sslContext.init(null, new TrustManager[] { tm }, null);     }      @Override     public Socket createSocket(Socket socket, String host, int port, boolean autoClose) throws IOException, UnknownHostException {         return sslContext.getSocketFactory().createSocket(socket, host, port, autoClose);     }      @Override     public Socket createSocket() throws IOException {         return sslContext.getSocketFactory().createSocket();     } }"
"import javax.swing.*; import java.awt.*; import java.awt.event.*; class GetFocusForJTextField extends JFrame { JButton jb; JFileChooser jf;      public GetFocusForJTextField()     {         createAndShowGUI();     }      private void createAndShowGUI()     {         // For NimbusLookAndFeel, JTextField is not         // the default focus owner in JFileChooser         try         {             UIManager.setLookAndFeel(""javax.swing.plaf.nimbus.NimbusLookAndFeel"");         }catch(Exception e){}          setTitle(""Get Focus for JTextField"");         setLayout(new FlowLayout());         setSize(400,400);         setVisible(true);         setDefaultCloseOperation(EXIT_ON_CLOSE);          jb=new JButton(""Open JFileChooser"");         jb.addActionListener(new ActionListener(){             public void actionPerformed(ActionEvent ae)             {                 showDialog();             }         });          jf=new JFileChooser();          // Even if you add some other JTextField         // as accessory to JFileChooser         jf.setAccessory(new JTextField(20));          jf.addHierarchyListener(new HierarchyListener(){             public void hierarchyChanged(HierarchyEvent he)             {                 grabFocusForTextField(jf.getComponents());             }         });               add(jb);     }      // Loop to find the JTextField, the first     // JTextField in JFileChooser     // Even if you setAccessory which contains a JTextField     // or which is JTextField itself, it will not get focus     private void grabFocusForTextField(Component[] c)     {         for(Component k:c)         {             if(k instanceof JTextField)             {                 JTextField jt=(JTextField)k;                 jt.grabFocus();                 break;             }             else if(k instanceof JPanel)             {                 JPanel jp=(JPanel)k;                 grabFocusForTextField(jp.getComponents());             }         }     }      private void showDialog()     {         jf.showOpenDialog(this);     }      public static void main(String args[])     {         SwingUtilities.invokeLater(new Runnable(){             public void run()             {                 new GetFocusForJTextField();             }         });     } }"
"import java.io.IOException; import java.net.URL; import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.Clip; import javax.sound.sampled.LineUnavailableException; import javax.sound.sampled.UnsupportedAudioFileException;  public class SoundClipTest{     public static void main(String[] args) throws UnsupportedAudioFileException, IOException, LineUnavailableException {        URL myURL= ClassLoader.getSystemResource(""abesti.wav"");        AudioInputStream audio = AudioSystem.getAudioInputStream(myURL);        Clip clip = AudioSystem.getClip();        clip.open(audio);        clip.setMicrosecondPosition(3000000);        clip.start();        try {         Thread.sleep(2000); //in milliseconds     } catch (InterruptedException e) {         e.printStackTrace();     }        clip.stop();    } }"
"import java.io.FileOutputStream; import java.io.IOException; import java.security.AlgorithmParameters; import java.security.InvalidAlgorithmParameterException; import java.security.InvalidKeyException; import java.security.KeyPair; import java.security.KeyPairGenerator; import java.security.NoSuchAlgorithmException; import java.security.NoSuchProviderException; import java.security.SecureRandom; import java.security.Security; import java.security.spec.InvalidKeySpecException; import java.security.spec.InvalidParameterSpecException;  import javax.crypto.BadPaddingException; import javax.crypto.Cipher; import javax.crypto.EncryptedPrivateKeyInfo; import javax.crypto.IllegalBlockSizeException; import javax.crypto.NoSuchPaddingException; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.PBEKeySpec; import javax.crypto.spec.PBEParameterSpec;  import org.bouncycastle.asn1.bc.BCObjectIdentifiers;  public class EncodePKCS8 {  /**  * @param args  * @throws NoSuchAlgorithmException   * @throws InvalidKeySpecException   * @throws NoSuchPaddingException   * @throws InvalidAlgorithmParameterException   * @throws InvalidKeyException   * @throws BadPaddingException   * @throws IllegalBlockSizeException   * @throws InvalidParameterSpecException   * @throws IOException   * @throws NoSuchProviderException   */ public static void main(String[] args) throws NoSuchAlgorithmException, InvalidKeySpecException, NoSuchPaddingException, InvalidKeyException, InvalidAlgorithmParameterException, IllegalBlockSizeException, BadPaddingException, InvalidParameterSpecException, IOException, NoSuchProviderException {     // before we can do anything with BouncyCastle we have to register its provider     Security.addProvider(new org.bouncycastle.jce.provider.BouncyCastleProvider());      String password = ""Very long and complex password"";      // generate RSA key pair     KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance(""RSA"");     keyPairGenerator.initialize(2048);     KeyPair keyPair = keyPairGenerator.genKeyPair();      byte[] encryptedPkcs8 = encryptPrivateKey(password, keyPair);      FileOutputStream fos = new FileOutputStream(""privkey.p8"");     fos.write(encryptedPkcs8);     fos.close();      return; }  private static byte[] encryptPrivateKey(String password, KeyPair keyPair)     throws InvalidKeyException, NoSuchAlgorithmException, NoSuchProviderException,     InvalidKeySpecException, NoSuchPaddingException,     InvalidAlgorithmParameterException, IllegalBlockSizeException,     BadPaddingException, InvalidParameterSpecException, IOException {     int count = 100000; // hash iteration count, best to leave at default or increase     return encryptPrivateKey(password, keyPair, count); }  /**  *   * @param password  * @param keyPair  * @param count  * @return PKCS#8 encoded, encrypted keyPair  * @throws NoSuchAlgorithmException  * @throws NoSuchProviderException  * @throws InvalidKeySpecException  * @throws NoSuchPaddingException  * @throws InvalidKeyException  * @throws InvalidAlgorithmParameterException  * @throws IllegalBlockSizeException  * @throws BadPaddingException  * @throws InvalidParameterSpecException  * @throws IOException  */ private static byte[] encryptPrivateKey(String password,          KeyPair keyPair, int count) throws NoSuchAlgorithmException,         NoSuchProviderException, InvalidKeySpecException,         NoSuchPaddingException, InvalidKeyException,         InvalidAlgorithmParameterException, IllegalBlockSizeException,         BadPaddingException, InvalidParameterSpecException, IOException {     // extract the encoded private key, this is an unencrypted PKCS#8 private key         byte[] encodedprivkey = keyPair.getPrivate().getEncoded();          // Use a PasswordBasedEncryption (PBE) algorithm, OID of this algorithm will be saved         // in the PKCS#8 file, so changing it (when more standard algorithm or safer         // algorithm is available) doesn't break backwards compatibility.         // In other words, decryptor doesn't need to know the algorithm before it will be         // able to decrypt the PKCS#8 object.         String encAlg = BCObjectIdentifiers.bc_pbe_sha256_pkcs12_aes256_cbc.getId();          SecureRandom random = new SecureRandom();         byte[] salt = new byte[16];         random.nextBytes(salt);          // Create PBE parameter set         PBEParameterSpec pbeParamSpec = new PBEParameterSpec(salt, count);         PBEKeySpec pbeKeySpec = new PBEKeySpec(password.toCharArray());         SecretKeyFactory keyFac = SecretKeyFactory.getInstance(encAlg, ""BC"");         SecretKey pbeKey = keyFac.generateSecret(pbeKeySpec);          Cipher pbeCipher = Cipher.getInstance(encAlg, ""BC"");          // Initialize PBE Cipher with key and parameters         pbeCipher.init(Cipher.ENCRYPT_MODE, pbeKey, pbeParamSpec);          // Encrypt the encoded Private Key with the PBE key         byte[] ciphertext = pbeCipher.doFinal(encodedprivkey);          // Now construct  PKCS #8 EncryptedPrivateKeyInfo object         AlgorithmParameters algparms = AlgorithmParameters.getInstance(encAlg, ""BC"");         algparms.init(pbeParamSpec);         EncryptedPrivateKeyInfo encinfo = new EncryptedPrivateKeyInfo(algparms, ciphertext);          // DER encoded PKCS#8 encrypted key         byte[] encryptedPkcs8 = encinfo.getEncoded();          return encryptedPkcs8;     } }"
import java.awt.Component; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.ArrayList; import java.util.List;  // I didn't seem to see anything like this with a quick look-through. // anybody else know differently? public class ComponentUpdater implements ActionListener {      private static List&lt;Component&gt; componenets = new ArrayList&lt;Component&gt;();      public void addComponent(Component component) {         componenets.add(component);     }      @Override     public void actionPerformed(ActionEvent arg0) {         for(Component component : componenets) {             component.repaint();         }     } }
"package test;  import java.io.File;  import javax.media.Format; import javax.media.Manager; import javax.media.MediaLocator; import javax.media.Player; import javax.media.PlugInManager; import javax.media.format.AudioFormat;  public class AudioTest { public static void main(String[] args) {     Format input1 = new AudioFormat(AudioFormat.MPEGLAYER3);     Format input2 = new AudioFormat(AudioFormat.MPEG);     Format output = new AudioFormat(AudioFormat.LINEAR);     PlugInManager.addPlugIn(         ""com.sun.media.codec.audio.mp3.JavaDecoder"",         new Format[]{input1, input2},         new Format[]{output},         PlugInManager.CODEC     );     try{         Player player = Manager.createPlayer(new MediaLocator(new File(""data/audioFiles/abc.mp3"").toURI().toURL()));         player.start();     }     catch(Exception ex){         ex.printStackTrace();     } } }"
"import java.awt.BorderLayout; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.Transferable; import java.awt.datatransfer.UnsupportedFlavorException; import java.awt.dnd.DnDConstants; import java.awt.dnd.DragGestureEvent; import java.awt.dnd.DragGestureListener; import java.awt.dnd.DragSource; import java.io.IOException; import javax.swing.DropMode; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.JScrollPane; import javax.swing.JTable; import javax.swing.SwingUtilities; import javax.swing.TransferHandler;  public class Test {      public static void main(String[] args) {         createAndShowJFrame();     }      public static void createAndShowJFrame() {         SwingUtilities.invokeLater(new Runnable() {             @Override             public void run() {                  JFrame frame = createJFrame();                 frame.setVisible(true);              }         });     }      private static JFrame createJFrame() {         JFrame frame = new JFrame();         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);          frame.setTitle(""Test"");          JTable table = createJTable();         JScrollPane js = new JScrollPane(table);          frame.add(js, BorderLayout.CENTER);          frame.add(createJLabelPanel(), BorderLayout.SOUTH);          frame.pack();          //frame.setResizable(false);//make it un-resizeable         //frame.setLocationRelativeTo(null);//center JFrame          return frame;     }      private static JTable createJTable() {         // setup table data         String[] columns = new String[]{""Foo"", ""Bar"", ""Baz"", ""Quux""};         String[][] data = new String[][]{{""A"", ""B"", ""C"", ""D""},             {""1"", ""2"", ""3"", ""4""},             {""i"", ""ii"", ""iii"", ""iv""}};         // create table         final JTable table = new JTable(data, columns);          // set up drag and drop         table.setDragEnabled(true);         table.setDropMode(DropMode.USE_SELECTION);         table.setFillsViewportHeight(true);          TransferHandler dnd = new TransferHandler() {             @Override             public boolean canImport(TransferSupport support) {                 if (!support.isDrop()) {                     return false;                 }                 //only Strings                 if (!support.isDataFlavorSupported(DataFlavor.stringFlavor)) {                     return false;                 }                 return true;             }              @Override             public boolean importData(TransferSupport support) {                 if (!canImport(support)) {                     return false;                 }                  Transferable tansferable = support.getTransferable();                 String line;                 try {                     line = (String) tansferable.getTransferData(DataFlavor.stringFlavor);                 } catch (Exception e) {                     e.printStackTrace();                     return false;                 }                  JTable.DropLocation dl = (JTable.DropLocation) support.getDropLocation();                 int column = dl.getColumn();                 int row = dl.getRow();                  String[] data = line.split("","");                 for (String item : data) {                     if (!item.isEmpty()) {                         table.getModel().setValueAt(item, row, column);                     }                 }                 return true;             }         };         table.setTransferHandler(dnd);         table.setPreferredScrollableViewportSize(table.getPreferredSize());         return table;     }      private static JPanel createJLabelPanel() {         JPanel panel = new JPanel();         JLabel label1 = new JLabel(""Hello"");         JLabel label2 = new JLabel(""Yay"");         JLabel label3 = new JLabel(""Bye"");          MyDragGestureListener dlistener = new MyDragGestureListener();         DragSource ds1 = new DragSource();         ds1.createDefaultDragGestureRecognizer(label1, DnDConstants.ACTION_COPY, dlistener);          DragSource ds2 = new DragSource();         ds2.createDefaultDragGestureRecognizer(label2, DnDConstants.ACTION_COPY, dlistener);          DragSource ds3 = new DragSource();         ds3.createDefaultDragGestureRecognizer(label3, DnDConstants.ACTION_COPY, dlistener);          panel.add(label1);         panel.add(label2);         panel.add(label3);         return panel;     } }  class MyDragGestureListener implements DragGestureListener {      @Override     public void dragGestureRecognized(DragGestureEvent event) {         JLabel label = (JLabel) event.getComponent();         final String text = label.getText();           Transferable transferable = new Transferable() {             @Override             public DataFlavor[] getTransferDataFlavors() {                 return new DataFlavor[]{DataFlavor.stringFlavor};             }              @Override             public boolean isDataFlavorSupported(DataFlavor flavor) {                 if (!isDataFlavorSupported(flavor)) {                     return false;                 }                 return true;             }              @Override             public Object getTransferData(DataFlavor flavor) throws UnsupportedFlavorException, IOException {                 return text;             }         };         event.startDrag(null, transferable);     } }"
"import java.io.File; import java.io.IOException; import java.net.MalformedURLException; import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.Clip; import javax.sound.sampled.LineUnavailableException; import javax.sound.sampled.UnsupportedAudioFileException;  /**  * Handles playing, stoping, and looping of sounds for the game.  * @author Tyler Thomas  *  */ public class Sound {     private Clip clip;     public Sound(String fileName) {         // specify the sound to play         // (assuming the sound can be played by the audio system)         // from a wave File         try {             File file = new File(fileName);             if (file.exists()) {                 AudioInputStream sound = AudioSystem.getAudioInputStream(file);              // load the sound into memory (a Clip)                 clip = AudioSystem.getClip();                 clip.open(sound);             }             else {                 throw new RuntimeException(""Sound: file not found: "" + fileName);             }         }         catch (MalformedURLException e) {             e.printStackTrace();             throw new RuntimeException(""Sound: Malformed URL: "" + e);         }         catch (UnsupportedAudioFileException e) {             e.printStackTrace();             throw new RuntimeException(""Sound: Unsupported Audio File: "" + e);         }         catch (IOException e) {             e.printStackTrace();             throw new RuntimeException(""Sound: Input/Output Error: "" + e);         }         catch (LineUnavailableException e) {             e.printStackTrace();             throw new RuntimeException(""Sound: Line Unavailable Exception Error: "" + e);         }      // play, stop, loop the sound clip     }     public void play(){         clip.setFramePosition(0);  // Must always rewind!         clip.start();     }     public void loop(){         clip.loop(Clip.LOOP_CONTINUOUSLY);     }     public void stop(){             clip.stop();         }     }"
"import javax.swing.ImageIcon; import javax.swing.JComponent; import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.JPanel; import javax.swing.TransferHandler; import java.awt.BorderLayout; import java.awt.EventQueue; import java.awt.Image; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.Transferable; import java.awt.datatransfer.UnsupportedFlavorException; import java.io.IOException; import java.lang.reflect.InvocationTargetException;  public class DragAndDropTester {   private static final JLabel TEST_LABEL = new JLabel( ""TestLabel"" );    public static void main( String[] args ) {     try {       EventQueue.invokeAndWait( new Runnable() {         public void run() {            JFrame testFrame = new JFrame( ""Test"" );            JPanel contents = new JPanel( new BorderLayout() );           contents.add( TEST_LABEL, BorderLayout.CENTER );            contents.setTransferHandler( createTransferHandler() );            testFrame.getContentPane().add( contents );           testFrame.setDefaultCloseOperation( JFrame.EXIT_ON_CLOSE );           testFrame.setSize( 200, 200 );           testFrame.setVisible( true );         }       } );     } catch ( InterruptedException e ) {     } catch ( InvocationTargetException e ) {     }   }    private static TransferHandler createTransferHandler(){     return new TransferHandler(  ){       @Override       public boolean importData( JComponent comp, Transferable aTransferable ) {         try {           Object transferData = aTransferable.getTransferData( DataFlavor.imageFlavor );           TEST_LABEL.setIcon( new ImageIcon( ( Image ) transferData ) );         } catch ( UnsupportedFlavorException e ) {         } catch ( IOException e ) {         }         return true;       }        @Override       public boolean canImport( JComponent comp, DataFlavor[] transferFlavors ) {         return true;       }     };   } }"
"import netscape.javascript.*; import java.applet.*; import java.awt.*; class MyApplet extends Applet {      public void init() {           // requesting the JSObject          JSObject win = JSObject.getWindow(this);           // here you call a javascript function          win.call(""myJavscriptFunction"", null);           // if you wish to pass an argument to the javascript function,          // do the following          String myString = ""World!"";          final Object[] args = { myString };            win.call(""myJavascriptFunction2()"", args);      } }"
"import java.io.ByteArrayInputStream; import java.io.File; import java.io.IOException;  import javax.sound.sampled.AudioFileFormat; import javax.sound.sampled.AudioFormat; import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.UnsupportedAudioFileException;  public class TrimmerAIS extends AudioInputStream{  private final AudioInputStream stream; private final long startByte,endByte; private long t_bytesRead=0;  public TrimmerAIS(AudioFormat audioFormat,AudioInputStream audioInputStream,long startMilli,long endMilli){     super(new ByteArrayInputStream(new byte[0]),audioFormat,AudioSystem.NOT_SPECIFIED);     stream=audioInputStream;     //calculate where to start and where to end     startByte=(long)((startMilli/1000)*stream.getFormat().getFrameRate()*stream.getFormat().getFrameSize());     endByte=(long)((endMilli/1000)*stream.getFormat().getFrameRate()*stream.getFormat().getFrameSize()); }  @Override public int available() throws IOException{     return (int)(endByte-startByte-t_bytesRead); } public int read(byte[] abData,int nOffset,int nLength) throws IOException{     int bytesRead=0;     if(t_bytesRead&lt;startByte){         do{             bytesRead=(int)skip(startByte-t_bytesRead);             t_bytesRead+=bytesRead;         }while(t_bytesRead&lt;startByte);     }     if(t_bytesRead&gt;=endByte)//end reached. signal EOF         return -1;      bytesRead=stream.read(abData,0,nLength);     if(bytesRead==-1)         return -1;     else if(bytesRead==0)         return 0;      t_bytesRead+=bytesRead;     if(t_bytesRead&gt;=endByte)// ""trim"" the extra by altering the number of bytes read         bytesRead=(int)(bytesRead-(t_bytesRead-endByte));      return bytesRead; } public static void main(String[] args) throws UnsupportedAudioFileException, IOException{     AudioInputStream music=null;     music = AudioSystem.getAudioInputStream(new File(""music/0.wav""));     music=new TrimmerAIS(music.getFormat(),music,0,15000);     AudioSystem.write(music,AudioFileFormat.Type.WAVE,new File(""out.wav"")); } }"
"import javax.microedition.lcdui.Command; import javax.microedition.lcdui.CommandListener; import javax.microedition.lcdui.Displayable; import javax.microedition.lcdui.Form; import javax.microedition.lcdui.Item; import javax.microedition.lcdui.ItemCommandListener; import javax.microedition.lcdui.StringItem; import javax.microedition.lcdui.TextField;  public class FormDemo extends Form implements ItemCommandListener{     private TextField tf1;     private TextField tf2;     private StringItem button;     private Command cmd_copy = new Command(""Copy"", Command.OK, 0);     FormDemo(){         super(""Name"");// Form Name         tf1 = new TextField(""Enter value"", """", 32, TextField.ANY);         tf2 = new TextField(""Copy Here"", """", 32, TextField.ANY);         append(tf1);         append(tf2);         button = new StringItem(""Submit"", ""Submit"");         append(button);         button.addCommand(cmd_copy);         button.setItemCommandListener(this);      }      public void commandAction(Command c, Item item) {         tf2.insert(tf1.getString(), 0);      } }"
"import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.security.InvalidAlgorithmParameterException; import java.security.KeyStore; import java.security.KeyStoreException; import java.security.NoSuchAlgorithmException; import java.security.cert.CertificateException; import java.security.cert.PKIXParameters; import java.security.cert.TrustAnchor; import java.security.cert.X509Certificate; import java.util.Iterator;   public class Main {      public static void main(String[] args) {         try {             // Load the JDK's cacerts keystore file             String filename = System.getProperty(""java.home"") + ""/lib/security/cacerts"".replace('/', File.separatorChar);             FileInputStream is = new FileInputStream(filename);             KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());             String password = ""changeit"";             keystore.load(is, password.toCharArray());              // This class retrieves the most-trusted CAs from the keystore             PKIXParameters params = new PKIXParameters(keystore);              // Get the set of trust anchors, which contain the most-trusted CA certificates             Iterator it = params.getTrustAnchors().iterator();             while( it.hasNext() ) {                 TrustAnchor ta = (TrustAnchor)it.next();                 // Get certificate                 X509Certificate cert = ta.getTrustedCert();                 System.out.println(cert);             }         } catch (CertificateException e) {         } catch (KeyStoreException e) {         } catch (NoSuchAlgorithmException e) {         } catch (InvalidAlgorithmParameterException e) {         } catch (IOException e) {         }      } }"
"import java.io.File; import java.io.IOException; import java.io.SequenceInputStream; import javax.sound.sampled.AudioFileFormat; import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem;  public class WavAppender {     public static void main(String[] args) {         String wavFile1 = ""D:\\wav1.wav"";         String wavFile2 = ""D:\\wav2.wav"";          try {             AudioInputStream clip1 = AudioSystem.getAudioInputStream(new File(wavFile1));             AudioInputStream clip2 = AudioSystem.getAudioInputStream(new File(wavFile2));              AudioInputStream appendedFiles =                              new AudioInputStream(                                 new SequenceInputStream(clip1, clip2),                                      clip1.getFormat(),                                  clip1.getFrameLength() + clip2.getFrameLength());              AudioSystem.write(appendedFiles,                              AudioFileFormat.Type.WAVE,                              new File(""D:\\wavAppended.wav""));         } catch (Exception e) {             e.printStackTrace();         }     } }"
"import java.io.File; import java.io.IOException; import java.io.SequenceInputStream; import javax.sound.sampled.AudioFileFormat; import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem;  public class WavAppender {     public static void main(String[] args) {         String wavFile1 = ""D:\\wav1.wav"";         String wavFile2 = ""D:\\wav2.wav"";          try {             AudioInputStream clip1 = AudioSystem.getAudioInputStream(new File(wavFile1));             AudioInputStream clip2 = AudioSystem.getAudioInputStream(new File(wavFile2));              AudioInputStream appendedFiles =                              new AudioInputStream(                                 new SequenceInputStream(clip1, clip2),                                      clip1.getFormat(),                                  clip1.getFrameLength() + clip2.getFrameLength());              AudioSystem.write(appendedFiles,                              AudioFileFormat.Type.WAVE,                              new File(""D:\\wavAppended.wav""));         } catch (Exception e) {             e.printStackTrace();         }     } }"
"import java.io.IOException;  import java.io.OutputStream; import java.io.OutputStreamWriter; import java.io.PrintWriter; import java.io.UnsupportedEncodingException; import java.util.HashMap; import java.util.Locale; import java.util.Map;  import javax.servlet.ServletOutputStream; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpServletResponseWrapper;  import org.springframework.beans.factory.annotation.Autowired; import org.springframework.ui.Model; import org.springframework.web.servlet.View; import org.springframework.web.servlet.ViewResolver;  public class InternalRenderer {      private final static String ENCODE = ""UTF-8"";      @Autowired     private ViewResolver viewResolver;      public String evalView(HttpServletRequest request, HttpServletResponse response, Model model, Locale locale, String viewName) throws Exception {          CustomHttpServletResponse customResponse = new CustomHttpServletResponse(response);          View view = viewResolver.resolveViewName(viewName, locale);          if(view != null){              view.render(fillModelMap(model), request, customResponse);              OutputStream os = customResponse.getOutputStream();              return os.toString();          }          throw new Exception(""no view found"");     }      private Map&lt;String, Object&gt; fillModelMap(Model model) {          if(model == null)             return new HashMap&lt;String,Object&gt;();          return model.asMap();     }      class CustomServletOutPutStream extends ServletOutputStream {          private StringBuilder stringBuilder = new StringBuilder();          @Override         public String toString() {             return stringBuilder.toString();         }          @Override         public void write(int b) {             stringBuilder.append(b);         }          @Override         public void write(byte b[], int off, int len) throws IOException {             stringBuilder.append(new String(b, off, len, ENCODE));         }     }      class CustomHttpServletResponse extends HttpServletResponseWrapper {          private ServletOutputStream outputStream;         private PrintWriter printWriter;          public CustomHttpServletResponse(HttpServletResponse response) throws UnsupportedEncodingException {             super(response);              this.outputStream = new CustomServletOutPutStream();             this.printWriter = new PrintWriter(new OutputStreamWriter(outputStream, ENCODE));          }          @Override         public ServletOutputStream getOutputStream() {             return this.outputStream;         }          @Override         public PrintWriter getWriter() throws IOException {             return this.printWriter;         }     }  }"
"package org.pscode.xui.sound.bigclip;  import java.awt.Component; import javax.swing.*;  // J2SE 1.3 import javax.sound.sampled.*;  import java.io.*;  // J2SE 1.4 import java.util.logging.*;  import java.util.Arrays;  /** An implementation of the javax.sound.sampled.Clip that is designed to handle Clips of arbitrary size, limited only by the amount of memory available to the app.    It uses the post 1.4 thread behaviour (daemon thread) that will stop the sound running after the main has exited. &lt;ul&gt; &lt;li&gt;2012-07-24 - Fixed bug in size of byte array (2^16 -&gt; (int)Math.pow(2, 16)). &lt;li&gt;2009-09-01 - Fixed bug that had clip ..clipped at the end, by calling drain() (before calling stop()) on the dataline after the play loop was complete. Improvement to frame and microsecond position determination. &lt;li&gt;2009-08-17 - added convenience constructor that accepts a Clip. Changed the private convertFrameToM..seconds methods from 'micro' to 'milli' to reflect that they were dealing with units of 1000/th of a second. &lt;li&gt;2009-08-14 - got rid of flush() after the sound loop, as it was cutting off tracks just before the end, and was found to be not needed for the fast-forward/rewind functionality it was introduced to support. &lt;li&gt;2009-08-11 - First binary release. &lt;/ul&gt; N.B. Remove @Override notation and logging to use in 1.3+ @since 1.5 @version 2009-08-17 @author Andrew Thompson */ public class BigClip implements Clip, LineListener {      /** The DataLine used by this Clip. */     private SourceDataLine dataLine;      /** The raw bytes of the audio data. */     private byte[] audioData;      /** The stream wrapper for the audioData. */     private ByteArrayInputStream inputStream;      /** Loop count set by the calling code. */     private int loopCount;     /** Internal count of how many loops to go. */     private int countDown;     /** The start of a loop point.    Defaults to 0. */     private int loopPointStart;     /** The end of a loop point.    Defaults to the end of the Clip. */     private int loopPointEnd;      /** Stores the current frame position of the clip. */     private int framePosition;      /** Thread used to run() sound. */     private Thread thread;     /** Whether the sound is currently playing or active. */     private boolean active;     /** Stores the last time bytes were dumped to the audio stream. */     private long timelastPositionSet;      private int bufferUpdateFactor = 2;      /** The parent Component for the loading progress dialog.    */     Component parent = null;      /** Used for reporting messages. */     private Logger logger = Logger.getAnonymousLogger();      /** Default constructor for a BigClip.    Does nothing.    Information from the     AudioInputStream passed in open() will be used to get an appropriate SourceDataLine. */     public BigClip() {}      /** There are a number of AudioSystem methods that will return a configured Clip.    This     convenience constructor allows us to obtain a SourceDataLine for the BigClip that uses     the same AudioFormat as the original Clip.     @param clip Clip The Clip used to configure the BigClip. */     public BigClip(Clip clip) throws LineUnavailableException {         dataLine = AudioSystem.getSourceDataLine( clip.getFormat() );     }      /** Provides the entire audio buffer of this clip.     @return audioData byte[] The bytes of the audio data that is loaded in this Clip. */     public byte[] getAudioData() {         return audioData;     }      /** Sets a parent component to act as owner of a ""Loading track.."" progress dialog.     If null, there will be no progress shown. */     public void setParentComponent(Component parent) {         this.parent = parent;     }      /** Converts a frame count to a duration in milliseconds. */     private long convertFramesToMilliseconds(int frames) {         return (frames/(long)dataLine.getFormat().getSampleRate())*1000;     }      /** Converts a duration in milliseconds to a frame count. */     private int convertMillisecondsToFrames(long milliseconds) {         return (int)(milliseconds/dataLine.getFormat().getSampleRate());     }      @Override     public void update(LineEvent le) {         logger.log(Level.FINEST, ""update: "" + le );     }      @Override     public void loop(int count) {         logger.log(Level.FINEST, ""loop("" + count + "") - framePosition: "" + framePosition);         loopCount = count;         countDown = count;         active = true;         inputStream.reset();          start();     }      @Override     public void setLoopPoints(int start, int end) {         if (             start&lt;0 ||             start&gt;audioData.length-1 ||             end&lt;0 ||             end&gt;audioData.length             ) {             throw new IllegalArgumentException(                 ""Loop points '"" +                 start +                 ""' and '"" +                 end +                 ""' cannot be set for buffer of size "" +                 audioData.length);         }         if (start&gt;end) {             throw new IllegalArgumentException(                 ""End position "" +                 end +                 "" preceeds start position "" + start);         }          loopPointStart = start;         framePosition = loopPointStart;         loopPointEnd = end;     }      @Override     public void setMicrosecondPosition(long milliseconds) {         framePosition = convertMillisecondsToFrames(milliseconds);     }      @Override     public long getMicrosecondPosition() {         return convertFramesToMilliseconds(getFramePosition());     }      @Override     public long getMicrosecondLength() {         return convertFramesToMilliseconds(getFrameLength());     }      @Override     public void setFramePosition(int frames) {         framePosition = frames;         int offset = framePosition*format.getFrameSize();         try {             inputStream.reset();             inputStream.read(new byte[offset]);         } catch(Exception e) {             e.printStackTrace();         }     }      @Override     public int getFramePosition() {         long timeSinceLastPositionSet = System.currentTimeMillis() - timelastPositionSet;         int size = dataLine.getBufferSize()*(format.getChannels()/2)/bufferUpdateFactor;         int framesSinceLast = (int)((timeSinceLastPositionSet/1000f)*             dataLine.getFormat().getFrameRate());         int framesRemainingTillTime = size - framesSinceLast;         return framePosition             - framesRemainingTillTime;     }      @Override     public int getFrameLength() {         return audioData.length/format.getFrameSize();     }      AudioFormat format;      @Override     public void open(AudioInputStream stream) throws         IOException,         LineUnavailableException {          AudioInputStream is1;         format = stream.getFormat();          if (format.getEncoding()!=AudioFormat.Encoding.PCM_SIGNED) {             is1 = AudioSystem.getAudioInputStream(                 AudioFormat.Encoding.PCM_SIGNED, stream );         } else {             is1 = stream;         }         format = is1.getFormat();         InputStream is2;         if (parent!=null) {             ProgressMonitorInputStream pmis = new ProgressMonitorInputStream(                 parent,                 ""Loading track.."",                 is1);             pmis.getProgressMonitor().setMillisToPopup(0);             is2 = pmis;         } else {             is2 = is1;         }          byte[] buf = new byte[ (int)Math.pow(2, 16) ];         int totalRead = 0;         int numRead = 0;         ByteArrayOutputStream baos = new ByteArrayOutputStream();         numRead = is2.read( buf );         while (numRead&gt;-1) {             baos.write( buf, 0, numRead );             numRead = is2.read( buf, 0, buf.length );             totalRead += numRead;         }         is2.close();         audioData = baos.toByteArray();         AudioFormat afTemp;         if (format.getChannels()&lt;2) {             afTemp = new AudioFormat(                 format.getEncoding(),                 format.getSampleRate(),                 format.getSampleSizeInBits(),                 2,                 format.getSampleSizeInBits()*2/8, // calculate frame size                 format.getFrameRate(),                 format.isBigEndian()                 );         } else {             afTemp = format;         }          setLoopPoints(0,audioData.length);         dataLine = AudioSystem.getSourceDataLine(afTemp);         dataLine.open();         inputStream = new ByteArrayInputStream( audioData );     }      @Override     public void open(AudioFormat format,         byte[] data,         int offset,         int bufferSize)         throws LineUnavailableException {         byte[] input = new byte[bufferSize];         for (int ii=0; ii&lt;input.length; ii++) {             input[ii] = data[offset+ii];         }         ByteArrayInputStream inputStream = new ByteArrayInputStream(input);         try {             AudioInputStream ais1 = AudioSystem.getAudioInputStream(inputStream);             AudioInputStream ais2 = AudioSystem.getAudioInputStream(format, ais1);             open(ais2);         } catch( UnsupportedAudioFileException uafe ) {             throw new IllegalArgumentException(uafe);         } catch( IOException ioe ) {             throw new IllegalArgumentException(ioe);         }         // TODO    -    throw IAE for invalid frame size, format.     }      @Override     public float getLevel() {         return dataLine.getLevel();     }      @Override     public long getLongFramePosition() {         return dataLine.getLongFramePosition()*2/format.getChannels();     }      @Override     public int available() {         return dataLine.available();     }      @Override     public int getBufferSize() {         return dataLine.getBufferSize();     }      @Override     public AudioFormat getFormat() {         return format;     }      @Override     public boolean isActive() {         return dataLine.isActive();     }      @Override     public boolean isRunning() {         return dataLine.isRunning();     }      @Override     public boolean isOpen() {         return dataLine.isOpen();     }      @Override     public void stop() {         logger.log(Level.FINEST, ""BigClip.stop()"");         active = false;         // why did I have this commented out?         dataLine.stop();         if (thread!=null) {             try {                 active = false;                 thread.join();             } catch(InterruptedException wakeAndContinue) {             }         }     }      public byte[] convertMonoToStereo(byte[] data, int bytesRead) {         byte[] tempData = new byte[bytesRead*2];         if (format.getSampleSizeInBits()==8) {             for(int ii=0; ii&lt;bytesRead; ii++) {                 byte b = data[ii];                 tempData[ii*2] = b;                 tempData[ii*2+1] = b;             }         } else {             for(int ii=0; ii&lt;bytesRead-1; ii+=2) {                 //byte b2 = is2.read();                 byte b1 = data[ii];                 byte b2 = data[ii+1];                 tempData[ii*2] = b1;                 tempData[ii*2+1] = b2;                 tempData[ii*2+2] = b1;                 tempData[ii*2+3] = b2;             }         }         return tempData;     }      boolean fastForward;     boolean fastRewind;      public void setFastForward(boolean fastForward) {         logger.log(Level.FINEST, ""FastForward "" + fastForward);         this.fastForward = fastForward;         fastRewind = false;         flush();     }      public boolean getFastForward() {         return fastForward;     }      public void setFastRewind(boolean fastRewind) {         logger.log(Level.FINEST, ""FastRewind "" + fastRewind);         this.fastRewind = fastRewind;         fastForward = false;         flush();     }      public boolean getFastRewind() {         return fastRewind;     }      /** TODO - fix bug in LOOP_CONTINUOUSLY */     @Override     public void start() {         Runnable r = new Runnable() {             public void run() {                 try {                     /* Should these open()/close() calls be here, or explicitly                     called by user program?    The JavaDocs for line suggest that                     Clip should throw an IllegalArgumentException, so we'll                     stick with that and call it explicitly. */                     dataLine.open();                      dataLine.start();                     int bytesRead = 0;                     int frameSize = dataLine.getFormat().getFrameSize();                     int bufSize = dataLine.getBufferSize();                     boolean startOrMove = true;                     byte[] data = new byte[bufSize];                     int offset = framePosition*frameSize;                     int totalBytes = offset;                     inputStream.read(new byte[offset], 0, offset);                     logger.log(Level.FINEST, ""loopCount "" + loopCount );                     while ((bytesRead = inputStream.read(data,0,data.length))                         != -1 &amp;&amp;                         (loopCount==Clip.LOOP_CONTINUOUSLY ||                         countDown&gt;0) &amp;&amp;                         active ) {                         logger.log(Level.FINEST,                             ""BigClip.start() loop "" + framePosition );                         totalBytes += bytesRead;                         int framesRead;                         byte[] tempData;                         if (format.getChannels()&lt;2) {                             tempData = convertMonoToStereo(data, bytesRead);                             framesRead = bytesRead/                                 format.getFrameSize();                             bytesRead*=2;                         } else {                             framesRead = bytesRead/                                 dataLine.getFormat().getFrameSize();                             tempData = Arrays.copyOfRange(data, 0, bytesRead);                         }                         framePosition += framesRead;                         if (framePosition&gt;=loopPointEnd) {                             framePosition = loopPointStart;                             inputStream.reset();                             countDown--;                             logger.log(Level.FINEST,                                 ""Loop Count: "" + countDown );                         }                         timelastPositionSet = System.currentTimeMillis();                         byte[] newData;                         if (fastForward) {                             newData = getEveryNthFrame(tempData, 2);                         } else if (fastRewind) {                             byte[] temp = getEveryNthFrame(tempData, 2);                             newData = reverseFrames(temp);                             inputStream.reset();                             totalBytes -= 2*bytesRead;                         framePosition -= 2*framesRead;                             if (totalBytes&lt;0) {                                 setFastRewind(false);                                 totalBytes = 0;                             }                             inputStream.skip(totalBytes);                             logger.log(Level.INFO, ""totalBytes "" + totalBytes);                         } else {                             newData = tempData;                         }                         dataLine.write(newData, 0, newData.length);                         if (startOrMove) {                             data = new byte[bufSize/                                 bufferUpdateFactor];                             startOrMove = false;                         }                     }                     logger.log(Level.FINEST,                         ""BigClip.start() loop ENDED"" + framePosition );                     active = false;                     dataLine.drain();                     dataLine.stop();                     /* should these open()/close() be here, or explicitly                     called by user program? */                     dataLine.close();                 } catch (LineUnavailableException lue) {                     logger.log( Level.SEVERE,                         ""No sound line available!"", lue );                     if (parent!=null) {                         JOptionPane.showMessageDialog(                             parent,                             ""Clear the sound lines to proceed"",                             ""No audio lines available!"",                             JOptionPane.ERROR_MESSAGE);                     }                 }             }         };         thread= new Thread(r);         // makes thread behaviour compatible with JavaSound post 1.4         thread.setDaemon(true);         thread.start();     }      /** Assume the frame size is 4. */     public byte[] reverseFrames(byte[] data) {         byte[] reversed = new byte[data.length];         byte[] frame = new byte[4];          for (int ii=0; ii&lt;data.length/4; ii++) {             int first = (data.length)-((ii+1)*4)+0;             int last = (data.length)-((ii+1)*4)+3;             frame[0] = data[first];             frame[1] = data[(data.length)-((ii+1)*4)+1];             frame[2] = data[(data.length)-((ii+1)*4)+2];             frame[3] = data[last];              reversed[ii*4+0] = frame[0];             reversed[ii*4+1] = frame[1];             reversed[ii*4+2] = frame[2];             reversed[ii*4+3] = frame[3];             if (ii&lt;5 || ii&gt;(data.length/4)-5) {                 logger.log(Level.FINER, ""From \t"" + first + "" \tlast "" + last );                 logger.log(Level.FINER, ""To \t"" + ((ii*4)+0) + "" \tlast "" + ((ii*4)+3) );             }         }  /*         for (int ii=0; ii&lt;data.length; ii++) {             reversed[ii] = data[data.length-1-ii];         } */          return reversed;     }      /** Assume the frame size is 4. */     public byte[] getEveryNthFrame(byte[] data, int skip) {         int length = data.length/skip;         length = (length/4)*4;         logger.log(Level.FINEST, ""length "" + data.length + "" \t"" + length);         byte[] b = new byte[length];         //byte[] frame = new byte[4];         for (int ii=0; ii&lt;b.length/4; ii++) {             b[ii*4+0] = data[ii*skip*4+0];             b[ii*4+1] = data[ii*skip*4+1];             b[ii*4+2] = data[ii*skip*4+2];             b[ii*4+3] = data[ii*skip*4+3];         }         return b;     }      @Override     public void flush() {         dataLine.flush();     }      @Override     public void drain() {         dataLine.drain();     }      @Override     public void removeLineListener(LineListener listener) {         dataLine.removeLineListener(listener);     }      @Override     public void addLineListener(LineListener listener) {         dataLine.addLineListener(listener);     }      @Override     public Control getControl(Control.Type control) {         return dataLine.getControl(control);     }      @Override     public Control[] getControls() {         if (dataLine==null) {             return new Control[0];         } else {             return dataLine.getControls();         }     }      @Override     public boolean isControlSupported(Control.Type control) {         return dataLine.isControlSupported(control);     }      @Override     public void close() {         dataLine.close();     }      @Override     public void open() throws LineUnavailableException {         throw new IllegalArgumentException(""illegal call to open() in interface Clip"");     }      @Override     public Line.Info getLineInfo() {         return dataLine.getLineInfo();     }      /** Determines the single largest sample size of all channels of the current clip.     This can be handy for determining a fraction to scal visual representations.     @return Double between 0 &amp; 1 representing the maximum signal level of any channel. */     public double getLargestSampleSize() {          int largest = 0;         int current;          boolean signed = (format.getEncoding()==AudioFormat.Encoding.PCM_SIGNED);         int bitDepth = format.getSampleSizeInBits();         boolean bigEndian = format.isBigEndian();          int samples = audioData.length*8/bitDepth;          if (signed) {             if (bitDepth/8==2) {                 if (bigEndian) {                     for (int cc = 0; cc &lt; samples; cc++) {                         current = (audioData[cc*2]*256 + (audioData[cc*2+1] &amp; 0xFF));                         if (Math.abs(current)&gt;largest) {                             largest = Math.abs(current);                         }                     }                 } else {                     for (int cc = 0; cc &lt; samples; cc++) {                         current = (audioData[cc*2+1]*256 + (audioData[cc*2] &amp; 0xFF));                         if (Math.abs(current)&gt;largest) {                             largest = Math.abs(current);                         }                     }                 }             } else {                 for (int cc = 0; cc &lt; samples; cc++) {                     current = (audioData[cc] &amp; 0xFF);                     if (Math.abs(current)&gt;largest) {                         largest = Math.abs(current);                     }                 }             }         } else {             if (bitDepth/8==2) {                 if (bigEndian) {                     for (int cc = 0; cc &lt; samples; cc++) {                         current = (audioData[cc*2]*256 + (audioData[cc*2+1] - 0x80));                         if (Math.abs(current)&gt;largest) {                             largest = Math.abs(current);                         }                     }                 } else {                     for (int cc = 0; cc &lt; samples; cc++) {                         current = (audioData[cc*2+1]*256 + (audioData[cc*2] - 0x80));                         if (Math.abs(current)&gt;largest) {                             largest = Math.abs(current);                         }                     }                 }             } else {                 for (int cc = 0; cc &lt; samples; cc++) {                     if ( audioData[cc]&gt;0 ) {                         current = (audioData[cc] - 0x80);                         if (Math.abs(current)&gt;largest) {                             largest = Math.abs(current);                         }                     } else {                         current = (audioData[cc] + 0x80);                         if (Math.abs(current)&gt;largest) {                             largest = Math.abs(current);                         }                     }                 }             }         }          // audioData         logger.log(Level.FINEST, ""Max signal level: "" + (double)largest/(Math.pow(2, bitDepth-1)));         return (double)largest/(Math.pow(2, bitDepth-1));     } }"
"import java.awt.FlowLayout; import java.awt.datatransfer.DataFlavor; import java.awt.datatransfer.UnsupportedFlavorException; import java.awt.dnd.DropTarget; import java.awt.dnd.DropTargetDragEvent; import java.awt.dnd.DropTargetDropEvent; import java.awt.dnd.DropTargetEvent; import java.awt.dnd.DropTargetListener; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.awt.event.MouseListener; import java.io.IOException;  import javax.swing.JFrame; import javax.swing.JLabel; import javax.swing.TransferHandler;  public class NameSlot extends JLabel implements DropTargetListener {     NameSlot(final String name) {         super(name);         new DropTarget(this, this);         this.setTransferHandler(new TransferHandler(""text""));         final MouseListener listener = new MouseAdapter() {             @Override             public void mousePressed(final MouseEvent me) {                 final JLabel comp = (JLabel) me.getSource();                 System.out.println(comp);                  final TransferHandler handler = comp.getTransferHandler();                 handler.exportAsDrag(comp, me, TransferHandler.COPY);             }         };         this.addMouseListener(listener);     }      @Override     public void dragEnter(final DropTargetDragEvent dtde) {         // TODO Auto-generated method stub      }      @Override     public void dragExit(final DropTargetEvent dte) {         // TODO Auto-generated method stub      }      @Override     public void dragOver(final DropTargetDragEvent dtde) {         // TODO Auto-generated method stub      }      @Override     public void drop(final DropTargetDropEvent dtde) {          // DropTarget dt = (DropTarget) dtde.getSource();         // NameSlot ns = (NameSlot) dt.getComponent();          try {             final String s = (String) dtde.getTransferable().getTransferData(                     new DataFlavor(""application/x-java-jvm-local-objectref; class=java.lang.String""));              System.out.println(""drop detected from "" + s + "" to "" + this.getText());         }         catch (final UnsupportedFlavorException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }         catch (final IOException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }         catch (final ClassNotFoundException e) {             // TODO Auto-generated catch block             e.printStackTrace();         }      }      @Override     public void dropActionChanged(final DropTargetDragEvent dtde) {         // TODO Auto-generated method stub      }      public static void main(final String[] args) {         final JFrame frame = new JFrame();         frame.setDefaultCloseOperation(JFrame.DISPOSE_ON_CLOSE);         frame.setLayout(new FlowLayout());          final NameSlot ns = new NameSlot(""test"");         frame.add(ns);          final NameSlot ns2 = new NameSlot(""test2"");         frame.add(ns2);          frame.pack();         frame.setLocationRelativeTo(null);         frame.setVisible(true);      } }"
"import java.io.ByteArrayOutputStream; import java.io.IOException; import java.io.InputStream; import java.io.UnsupportedEncodingException; import java.net.URLDecoder; import java.util.Enumeration; import java.util.HashMap; import java.util.Map;  import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  @WebServlet(name=""fooServlet"", urlPatterns=""/foo"") public class FooServlet extends HttpServlet {     @Override     protected void doPost(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException {         InputStream is = req.getInputStream();         ByteArrayOutputStream os = new ByteArrayOutputStream();         byte[] buf = new byte[32];         int r=0;         while( r &gt;= 0 ) {             r = is.read(buf);             if( r &gt;= 0 ) os.write(buf, 0, r);         }         String s = new String(os.toByteArray(), ""UTF-8"");         String decoded = URLDecoder.decode(s, ""UTF-8"");         System.err.println(""&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; DECODED: "" + decoded);          System.err.println(""================================"");          Enumeration&lt;String&gt; e = req.getParameterNames();         while( e.hasMoreElements() ) {             String ss = (String) e.nextElement();             System.err.println(""    &gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt;&gt; "" + ss);         }          System.err.println(""================================"");          Map&lt;String,String&gt; map = makeQueryMap(s);         System.err.println(map);         //////////////////////////////////////////////////////////////////         //// HERE YOU CAN DO map.get(""id"") AND THE SENT VALUE WILL BE ////         //// RETURNED AS EXPECTED WITH request.getParameter(""id"")     ////         //////////////////////////////////////////////////////////////////          System.err.println(""================================"");          resp.setContentType(""application/json; charset=UTF-8"");         resp.getWriter().println(""{'result':true}"");     }      // Based on code from: http://www.coderanch.com/t/383310/java/java/parse-url-query-string-parameter     private static Map&lt;String, String&gt; makeQueryMap(String query) throws UnsupportedEncodingException {         String[] params = query.split(""&amp;"");         Map&lt;String, String&gt; map = new HashMap&lt;String, String&gt;();         for( String param : params ) {             String[] split = param.split(""="");             map.put(URLDecoder.decode(split[0], ""UTF-8""), URLDecoder.decode(split[1], ""UTF-8""));         }         return map;     } }"
"import java.awt.BasicStroke; import java.awt.Color; import java.awt.Component; import java.awt.Dimension; import java.awt.Graphics; import java.awt.Graphics2D; import java.awt.Point; import java.awt.event.MouseAdapter; import java.awt.event.MouseEvent; import java.awt.event.MouseMotionAdapter; import java.awt.geom.AffineTransform; import java.awt.geom.NoninvertibleTransformException; import java.awt.image.BufferedImage; import java.io.IOException; import java.net.MalformedURLException; import java.net.URL;  import javax.imageio.ImageIO; import javax.swing.Box; import javax.swing.BoxLayout; import javax.swing.JComponent; import javax.swing.JFrame;  public class Main {     public static void main(String[] args) throws MalformedURLException, IOException {         JFrame frame = new JFrame();         Box box = new Box(BoxLayout.Y_AXIS);         BufferedImage image = ImageIO.read(new URL(""http://sstatic.net/so/img/logo.png""));         AffineTransform xfrm1 = AffineTransform.getScaleInstance(0.95, 1.25);         xfrm1.rotate(-0.3);         box.add(new ImageView(image, xfrm1));         AffineTransform xfrm2 = AffineTransform.getShearInstance(0.1, 0.2);         xfrm2.scale(1.3, 0.9);         box.add(new ImageView(image, xfrm2));         frame.add(box);         frame.pack();         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         frame.setVisible(true);     } }  @SuppressWarnings(""serial"") class ImageView extends JComponent {     @Override     public void paintComponent(Graphics g) {         Graphics2D g2d = (Graphics2D) g;         try {             paintXfrm = g2d.getTransform();             paintXfrm.invert();             g2d.translate(getWidth() / 2, getHeight() / 2);             g2d.transform(xfrm);             g2d.translate(image.getWidth() * -0.5, image.getHeight() * -0.5);             paintXfrm.concatenate(g2d.getTransform());             g2d.drawImage(image, 0, 0, this);         } catch (NoninvertibleTransformException ex) {             ex.printStackTrace();         }     }      @Override     public Dimension getPreferredSize() {         return new Dimension(image.getWidth() * 2, image.getHeight() * 2);     }      ImageView(final BufferedImage image, final AffineTransform xfrm) {         this.canvas = image.createGraphics();         canvas.setColor(Color.BLACK);         canvas.setStroke(new BasicStroke(3.0f));         this.image = image;         this.xfrm = xfrm;         addMouseListener(new MouseAdapter() {             @Override             public void mousePressed(MouseEvent e) {                 try {                     mouseDownCoord = e.getPoint();                     paintXfrm.inverseTransform(mouseDownCoord, mouseDownCoord);                 } catch (NoninvertibleTransformException ex) {                 }             }              @Override             public void mouseExited(MouseEvent e) {                 mouseDownCoord = null;             }         });         addMouseMotionListener(new MouseMotionAdapter() {             @Override             public void mouseDragged(MouseEvent e) {                 Point p = e.getPoint();                 try {                     paintXfrm.inverseTransform(p, p);                     if (mouseDownCoord != null) {                         canvas.drawLine(mouseDownCoord.x, mouseDownCoord.y, p.x, p.y);                         for (Component sibling: getParent().getComponents()) {                             sibling.repaint();                         }                     }                     mouseDownCoord = p;                 } catch (NoninvertibleTransformException ex) {                     ex.printStackTrace();                 }             }         });     }      private Graphics2D canvas;     private BufferedImage image;     private AffineTransform xfrm;     private AffineTransform paintXfrm;     private Point mouseDownCoord; }"
"import static java.lang.management.ManagementFactory.MEMORY_MXBEAN_NAME; import static java.lang.management.ManagementFactory.newPlatformMXBeanProxy;  import java.io.*; import java.lang.management.MemoryMXBean; import java.lang.management.MemoryUsage; import java.util.*;  import javax.management.MBeanServerConnection; import javax.management.remote.JMXConnector; import javax.management.remote.JMXConnectorFactory; import javax.management.remote.JMXServiceURL;  import com.sun.tools.attach.*;  public class CmdLineTool {   static final String CONNECTOR_ADDRESS =       ""com.sun.management.jmxremote.localConnectorAddress"";    public static void main(String[] args)   {     if(args.length!=1)       System.err.println(""Usage: java CmdLineTool &lt;pid&gt;"");     else if(printStats(args[0])) return;     System.out.println(""Currently running"");     for(VirtualMachineDescriptor vmd:VirtualMachine.list())       System.out.println(vmd.id()+""\t""+vmd.displayName());   }    private static boolean printStats(String id)   {     try     {       VirtualMachine vm=VirtualMachine.attach(id);       System.out.println(""Connected to ""+vm.id());       System.out.println(""System Properties:"");       for(Map.Entry&lt;?,?&gt; en:vm.getSystemProperties().entrySet())         System.out.println(""\t""+en.getKey()+"" = ""+en.getValue());       System.out.println();       try       {         MBeanServerConnection sc=connect(vm);         MemoryMXBean memoryMXBean =           newPlatformMXBeanProxy(sc, MEMORY_MXBEAN_NAME, MemoryMXBean.class);         getRamInfoHtml(memoryMXBean);       } catch(IOException ex)       {         System.out.println(""JMX: ""+ex);       }       vm.detach();       return true;     } catch(AttachNotSupportedException | IOException ex)     {       ex.printStackTrace();     }     return false;   }   // requires Java 8, alternative below the code   static MBeanServerConnection connect(VirtualMachine vm) throws IOException   {     String connectorAddress = vm.startLocalManagementAgent();     JMXConnector c=JMXConnectorFactory.connect(new JMXServiceURL(connectorAddress));     return c.getMBeanServerConnection();   }    static void getRamInfoHtml(MemoryMXBean memoryMXBean)   {     System.out.print(""Heap:\t"");     MemoryUsage mu=memoryMXBean.getHeapMemoryUsage();     System.out.println(       ""allocated ""+mu.getCommitted()+"", used ""+mu.getUsed()+"", max ""+mu.getMax());     System.out.print(""Non-Heap:\t"");     mu=memoryMXBean.getNonHeapMemoryUsage();     System.out.println(       ""allocated ""+mu.getCommitted()+"", used ""+mu.getUsed()+"", max ""+mu.getMax());     System.out.println(       ""Pending Finalizations: ""+memoryMXBean.getObjectPendingFinalizationCount());   } }"
"import java.io.IOException; import java.io.UnsupportedEncodingException; import java.security.AlgorithmParameters; import java.security.GeneralSecurityException; import java.security.NoSuchAlgorithmException; import java.security.spec.InvalidKeySpecException; import java.util.Base64; import javax.crypto.Cipher; import javax.crypto.SecretKey; import javax.crypto.SecretKeyFactory; import javax.crypto.spec.IvParameterSpec; import javax.crypto.spec.PBEKeySpec; import javax.crypto.spec.SecretKeySpec;  public class ProtectedConfigFile {      public static void main(String[] args) throws Exception {         String password = System.getProperty(""password"");         if (password == null) {             throw new IllegalArgumentException(""Run with -Dpassword=&lt;password&gt;"");         }          // The salt (probably) can be stored along with the encrypted data         byte[] salt = new String(""12345678"").getBytes();          // Decreasing this speeds down startup time and can be useful during testing, but it also makes it easier for brute force attackers         int iterationCount = 40000;         // Other values give me java.security.InvalidKeyException: Illegal key size or default parameters         int keyLength = 128;         SecretKeySpec key = createSecretKey(password.toCharArray(),                 salt, iterationCount, keyLength);          String originalPassword = ""secret"";         System.out.println(""Original password: "" + originalPassword);         String encryptedPassword = encrypt(originalPassword, key);         System.out.println(""Encrypted password: "" + encryptedPassword);         String decryptedPassword = decrypt(encryptedPassword, key);         System.out.println(""Decrypted password: "" + decryptedPassword);     }      private static SecretKeySpec createSecretKey(char[] password, byte[] salt, int iterationCount, int keyLength) throws NoSuchAlgorithmException, InvalidKeySpecException {         SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA512"");         PBEKeySpec keySpec = new PBEKeySpec(password, salt, iterationCount, keyLength);         SecretKey keyTmp = keyFactory.generateSecret(keySpec);         return new SecretKeySpec(keyTmp.getEncoded(), ""AES"");     }      private static String encrypt(String property, SecretKeySpec key) throws GeneralSecurityException, UnsupportedEncodingException {         Cipher pbeCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");         pbeCipher.init(Cipher.ENCRYPT_MODE, key);         AlgorithmParameters parameters = pbeCipher.getParameters();         IvParameterSpec ivParameterSpec = parameters.getParameterSpec(IvParameterSpec.class);         byte[] cryptoText = pbeCipher.doFinal(property.getBytes(""UTF-8""));         byte[] iv = ivParameterSpec.getIV();         return base64Encode(iv) + "":"" + base64Encode(cryptoText);     }      private static String base64Encode(byte[] bytes) {         return Base64.getEncoder().encodeToString(bytes);     }      private static String decrypt(String string, SecretKeySpec key) throws GeneralSecurityException, IOException {         String iv = string.split("":"")[0];         String property = string.split("":"")[1];         Cipher pbeCipher = Cipher.getInstance(""AES/CBC/PKCS5Padding"");         pbeCipher.init(Cipher.DECRYPT_MODE, key, new IvParameterSpec(base64Decode(iv)));         return new String(pbeCipher.doFinal(base64Decode(property)), ""UTF-8"");     }      private static byte[] base64Decode(String property) throws IOException {         return Base64.getDecoder().decode(property);     } }"
"import java.security.cert.X509Certificate; import javax.naming.InvalidNameException; import javax.naming.ldap.LdapName; import javax.naming.ldap.Rdn;  X509Certificate[] certs = (X509Certificate[])request.getAttribute(""javax.servlet.request.X509Certificate""); if ((certs == null) || (certs.length == 0)) {    return null; }  String name = certs[0].getSubjectX500Principal().getName(); // if you are looking for issuer then use cert[0].getIssuerX500Principal().getName(); LdapName ldapName = null; try {    ldapName = new LdapName(name); } catch (InvalidNameException e) {    throw new RuntimeException(e); }  for (Rdn rdn : ldapName.getRdns()) {    String type = rdn.getType();    if (""CN"".equals(type)) {          String issuedTo = (String)rdn.getValue();    } }"
