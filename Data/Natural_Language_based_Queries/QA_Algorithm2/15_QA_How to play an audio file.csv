code
"MediaRecorder recorder = new MediaRecorder();  recorder.setAudioSource(MediaRecorder.AudioSource.MIC);  recorder.setOutputFormat(MediaRecorder.OutputFormat.THREE_GPP);  recorder.setAudioEncoder(MediaRecorder.AudioEncoder.AMR_NB);  recorder.setOutputFile(PATH_NAME);  recorder.prepare();  recorder.start();   // Recording is now started  ...  while(recordingNotOver)  {     int lastMaxAmplitude = recorder.getMaxAmplitude();     // you have the value here in lastMaxAmplitude, do what u want to  }   recorder.stop();  recorder.reset();   // You can reuse the object by going back to setAudioSource() step  recorder.release(); // Now the object cannot be reused"
"writer.addVideoStream(videoStreamIndex, 0, videoCodec, width, height); writer.addAudioStream(audioStreamIndex, 0, audioCodec, channelCount, sampleRate);  while (... have more data ...) {     BufferedImage videoFrame = ...;     long videoFrameTime = ...; // this is the time to display this frame     writer.encodeVideo(videoStreamIndex, videoFrame, videoFrameTime, DEFAULT_TIME_UNIT);      short[] audioSamples = ...; // the size of this array should be number of samples * channelCount     long audioSamplesTime = ...; // this is the time to play back this bit of audio     writer.encodeAudio(audioStreamIndex, audioSamples, audioSamplesTime, DEFAULT_TIME_UNIT); }"
Mixer: Direct Audio Device: DirectSound Playback [Primary Sound Driver] Mixer: Direct Audio Device: DirectSound Playback [SigmaTel Audio] Mixer: Direct Audio Device: DirectSound Capture [Primary Sound Capture Driver] Mixer: Direct Audio Device: DirectSound Capture [SigmaTel Audio] Mixer: Software mixer and synthesizer [Java Sound Audio Engine] Mixer: Port Mixer [Port SigmaTel Audio]   Source Port: Stereo Mix source port     Control: Stereo Mix (compound - values below)       Control: Select (boolean)       Control: Volume (float: from 0.0 to 1.0)       Control: Balance (float: from -1.0 to 1.0)   Source Port: LINE_IN source port     Control: Line In (compound - values below)       Control: Select (boolean)       Control: Volume (float: from 0.0 to 1.0)       Control: Balance (float: from -1.0 to 1.0)   Source Port: MICROPHONE source port     Control: Microphone (compound - values below)       Control: Select (boolean)       Control: Microphone Boost (boolean)       Control: Volume (float: from 0.0 to 1.0)   Source Port: MICROPHONE source port     Control: Microphone (compound - values below)       Control: Select (boolean)       Control: Microphone Boost (boolean)       Control: Volume (float: from 0.0 to 1.0)   Target Port: SPEAKER target port     Control: Volume (float: from 0.0 to 1.0)     Control: Balance (float: from -1.0 to 1.0)     Control: Mute (boolean)     Control: PC Spk Mute (boolean)     Control: SPDIF Interface (boolean)     Control: Wave (compound - values below)       Control: Volume (float: from 0.0 to 1.0)       Control: Balance (float: from -1.0 to 1.0)       Control: Mute (boolean)     Control: SW Synth (compound - values below)       Control: Volume (float: from 0.0 to 1.0)       Control: Balance (float: from -1.0 to 1.0)       Control: Mute (boolean)     Control: CD Player (compound - values below)       Control: Volume (float: from 0.0 to 1.0)       Control: Balance (float: from -1.0 to 1.0)       Control: Mute (boolean)     Control: PC Speaker (compound - values below)       Control: Volume (float: from 0.0 to 1.0)       Control: Mute (boolean)
"byte[] buffer = new byte[4096];     for (File file : files) {         try {             AudioInputStream is = AudioSystem.getAudioInputStream(file);             AudioFormat format = is.getFormat();             SourceDataLine line = AudioSystem.getSourceDataLine(format);             line.open(format);             line.start();             while (is.available() &gt; 0) {                 int len = is.read(buffer);                 line.write(buffer, 0, len);             }             line.drain(); //**[DEIT]** wait for the buffer to empty before closing the line             line.close();         } catch (Exception e) {             e.printStackTrace();         }     }"
"public class mediaPlayer extends JFrame {     public mediaPlayer()     {         setLayout(new BorderLayout());          //file you want to play         URL mediaURL = //Whatever         //create the media player with the media url         Player mediaPlayer = Manager.createRealizedPlayer(mediaURL);         //get components for video and playback controls         Component video = mediaPlayer.getVisualComponent();         Component controls = mediaPlayer.getControlPanelComponent();         add(video,BorderLayout.CENTER);         add(controls,BorderLayout.SOUTH);     } }"
"private int RECORDER_CHANNELS = AudioFormat.CHANNEL_CONFIGURATION_MONO; private int RECORDER_AUDIO_ENCODING = AudioFormat.ENCODING_PCM_16BIT; private int RECORDER_SAMPLERATE = 44100; private byte RECORDER_BPP = (byte) 16;  private AudioRecord audioRecorder;  public void arm() {     // Get the minimum buffer size required for the successful creation of an AudioRecord object.     int bufferSizeInBytes = AudioRecord.getMinBufferSize(RECORDER_SAMPLERATE, RECORDER_CHANNELS,             RECORDER_AUDIO_ENCODING);      // Initialize Audio Recorder.     audioRecorder = new AudioRecord(MediaRecorder.AudioSource.MIC, RECORDER_SAMPLERATE,             RECORDER_CHANNELS, RECORDER_AUDIO_ENCODING, bufferSizeInBytes);      // Start Recording.     audioRecorder.startRecording();      int numberOfReadBytes = 0;     byte audioBuffer[] = new byte[bufferSizeInBytes];     boolean recording = false;     float tempFloatBuffer[] = new float[3];     int tempIndex = 0;     int totalReadBytes = 0;     byte totalByteBuffer[] = new byte[60 * 44100 * 2];      // While data come from microphone.     while (true) {         float totalAbsValue = 0.0f;         short sample = 0;          numberOfReadBytes = audioRecorder.read(audioBuffer, 0, bufferSizeInBytes);          // Analyze Sound.         for (int i = 0; i &lt; bufferSizeInBytes; i += 2) {             sample = (short) ((audioBuffer[i]) | audioBuffer[i + 1] &lt;&lt; 8);             totalAbsValue += Math.abs(sample) / (numberOfReadBytes / 2);         }          // Analyze temp buffer.         tempFloatBuffer[tempIndex % 3] = totalAbsValue;         float temp = 0.0f;         for (int i = 0; i &lt; 3; ++i)             temp += tempFloatBuffer[i];          if ((temp &gt;= 0 &amp;&amp; temp &lt;= 350) &amp;&amp; recording == false) {             Log.i(""TAG"", ""1"");             tempIndex++;             continue;         }          if (temp &gt; 350 &amp;&amp; recording == false) {             Log.i(""TAG"", ""2"");             recording = true;         }          if ((temp &gt;= 0 &amp;&amp; temp &lt;= 350) &amp;&amp; recording == true) {             Log.i(""TAG"", ""Save audio to file."");              // Save audio to file.             String filepath = Environment.getExternalStorageDirectory().getPath();             File file = new File(filepath, ""AudioRecorder"");             if (!file.exists())                 file.mkdirs();              String fn = file.getAbsolutePath() + ""/"" + System.currentTimeMillis() + "".wav"";              long totalAudioLen = 0;             long totalDataLen = totalAudioLen + 36;             long longSampleRate = RECORDER_SAMPLERATE;             int channels = 1;             long byteRate = RECORDER_BPP * RECORDER_SAMPLERATE * channels / 8;             totalAudioLen = totalReadBytes;             totalDataLen = totalAudioLen + 36;             byte finalBuffer[] = new byte[totalReadBytes + 44];              finalBuffer[0] = 'R'; // RIFF/WAVE header             finalBuffer[1] = 'I';             finalBuffer[2] = 'F';             finalBuffer[3] = 'F';             finalBuffer[4] = (byte) (totalDataLen &amp; 0xff);             finalBuffer[5] = (byte) ((totalDataLen &gt;&gt; 8) &amp; 0xff);             finalBuffer[6] = (byte) ((totalDataLen &gt;&gt; 16) &amp; 0xff);             finalBuffer[7] = (byte) ((totalDataLen &gt;&gt; 24) &amp; 0xff);             finalBuffer[8] = 'W';             finalBuffer[9] = 'A';             finalBuffer[10] = 'V';             finalBuffer[11] = 'E';             finalBuffer[12] = 'f'; // 'fmt ' chunk             finalBuffer[13] = 'm';             finalBuffer[14] = 't';             finalBuffer[15] = ' ';             finalBuffer[16] = 16; // 4 bytes: size of 'fmt ' chunk             finalBuffer[17] = 0;             finalBuffer[18] = 0;             finalBuffer[19] = 0;             finalBuffer[20] = 1; // format = 1             finalBuffer[21] = 0;             finalBuffer[22] = (byte) channels;             finalBuffer[23] = 0;             finalBuffer[24] = (byte) (longSampleRate &amp; 0xff);             finalBuffer[25] = (byte) ((longSampleRate &gt;&gt; 8) &amp; 0xff);             finalBuffer[26] = (byte) ((longSampleRate &gt;&gt; 16) &amp; 0xff);             finalBuffer[27] = (byte) ((longSampleRate &gt;&gt; 24) &amp; 0xff);             finalBuffer[28] = (byte) (byteRate &amp; 0xff);             finalBuffer[29] = (byte) ((byteRate &gt;&gt; 8) &amp; 0xff);             finalBuffer[30] = (byte) ((byteRate &gt;&gt; 16) &amp; 0xff);             finalBuffer[31] = (byte) ((byteRate &gt;&gt; 24) &amp; 0xff);             finalBuffer[32] = (byte) (2 * 16 / 8); // block align             finalBuffer[33] = 0;             finalBuffer[34] = RECORDER_BPP; // bits per sample             finalBuffer[35] = 0;             finalBuffer[36] = 'd';             finalBuffer[37] = 'a';             finalBuffer[38] = 't';             finalBuffer[39] = 'a';             finalBuffer[40] = (byte) (totalAudioLen &amp; 0xff);             finalBuffer[41] = (byte) ((totalAudioLen &gt;&gt; 8) &amp; 0xff);             finalBuffer[42] = (byte) ((totalAudioLen &gt;&gt; 16) &amp; 0xff);             finalBuffer[43] = (byte) ((totalAudioLen &gt;&gt; 24) &amp; 0xff);              for (int i = 0; i &lt; totalReadBytes; ++i)                 finalBuffer[44 + i] = totalByteBuffer[i];              FileOutputStream out;             try {                 out = new FileOutputStream(fn);                 try {                     out.write(finalBuffer);                     out.close();                 } catch (IOException e) {                     // TODO Auto-generated catch block                     e.printStackTrace();                 }              } catch (FileNotFoundException e1) {                 // TODO Auto-generated catch block                 e1.printStackTrace();             }              // */             tempIndex++;             break;         }          // -&gt; Recording sound here.         Log.i(""TAG"", ""Recording Sound."");         for (int i = 0; i &lt; numberOfReadBytes; i++)             totalByteBuffer[totalReadBytes + i] = audioBuffer[i];         totalReadBytes += numberOfReadBytes;         // */          tempIndex++;     } }"
"public class Audio{ public static void crossfade(MediaPlayer mp1, MediaPlayer mp2) {     double currentVol = mp1.getVolume();     mp2.setVolume(0);     mp2.play();     SequentialTransition crossfade = new SequentialTransition();     for (int i=0; i&lt;20 i++) {         PauseTransition pause = new PauseTransition(Duration.millis(100));         pause.setOnFinished(event -&gt; {                mp1.setVolume(mp1.getVolume()-currentVol/20);                mp2.setVolume(mp2.getVolume()+currentVol/20);         });         crossfade.getChildren().add(pause);     }     crossfade.setOnFinished(event -&gt; mp1.stop());     crossfade.play(); } }"
"File file = new File(filename); AudioInputStream in= AudioSystem.getAudioInputStream(file); AudioInputStream din = null; AudioFormat baseFormat = in.getFormat(); AudioFormat decodedFormat = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED,                                              baseFormat.getSampleRate(),                                             16,                                             baseFormat.getChannels(),                                             baseFormat.getChannels() * 2,                                             baseFormat.getSampleRate(),                                             false); din = AudioSystem.getAudioInputStream(decodedFormat, in);"
"import java.net.URL;          import javax.sound.sampled.AudioFormat;         import javax.sound.sampled.AudioInputStream;         import javax.sound.sampled.AudioSystem;         import javax.sound.sampled.Clip;         import javax.sound.sampled.DataLine;          public class SoundUtils {             public static double getLength(String path) throws Exception {                 AudioInputStream stream;                 stream = AudioSystem.getAudioInputStream(new URL(path));                 AudioFormat format = stream.getFormat();                 if (format.getEncoding() != AudioFormat.Encoding.PCM_SIGNED) {                     format = new AudioFormat(AudioFormat.Encoding.PCM_SIGNED, format                             .getSampleRate(), format.getSampleSizeInBits() * 2, format                             .getChannels(), format.getFrameSize() * 2, format                             .getFrameRate(), true); // big endian                     stream = AudioSystem.getAudioInputStream(format, stream);                 }                 DataLine.Info info = new DataLine.Info(Clip.class, stream.getFormat(),                         ((int) stream.getFrameLength() * format.getFrameSize()));                 Clip clip = (Clip) AudioSystem.getLine(info);                 clip.close();                 return clip.getBufferSize()                         / (clip.getFormat().getFrameSize() * clip.getFormat()                                 .getFrameRate());             }              public static void main(String[] args) {                 try {                      System.out                             .println(getLength(""...""));                 } catch (Exception e) {                     e.printStackTrace();                 }             }          }"
"AudioManager audioManager = (AudioManager) getSystemService(Context.AUDIO_SERVICE);         int sb2value = audioManager.getStreamMaxVolume(AudioManager.STREAM_RING);         NotificationManager notificationManager = (NotificationManager) getApplicationContext().getSystemService(Context.NOTIFICATION_SERVICE);         Notification notification = new Notification(R.drawable.ic_launcher, ""Testomg"", System.currentTimeMillis() + 5000);          Intent notificationIntent = new Intent(Intent.ACTION_VIEW);         notificationIntent.setData(Uri.parse(""market://details?id=com.karya.kot""));         notificationIntent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);         PendingIntent intent = PendingIntent.getActivity(getApplicationContext(), 0, notificationIntent, 0);         notification.setLatestEventInfo(getApplicationContext(), ""Google Play"", ""Download app"", intent);          notification.flags |= Notification.FLAG_AUTO_CANCEL;         notificationManager.notify(0, notification);"
"public void doRecordingDemo() {          // Get the default media capture device for audio and video         DataSource[] sources = new DataSource[2];         sources[0] = Manager.createDataSource(audioDevice.getLocator());         sources[1] = Manager.createDataSource(videoDevice.getLocator());          // Merge the audio and video streams         DataSource source = Manager.createMergingDataSource(sources);          // Create a processor to convert from raw format to a file format         // Notice that we are NOT starting the datasources, but letting the         //  processor take care of this for us.         Processor processor = Manager.createProcessor(source);          // Need a configured processor for this next step         processor.configure();         waitForState(processor, Processor.Configured);          // Modify this to suit your needs, but pay attention to what formats can go in what containers         processor.setContentDescriptor(new FileTypeDescriptor(FileTypeDescriptor.QUICKTIME));          // Use the processor to convert the audio and video into reasonable formats and sizes         // There are probably better ways to do this, but you should NOT make any assumptions         // about what formats are supported, and instead use a generic method of checking the         // available formats and sizes.  You have been warned!         for (TrackControl control : processor.getTrackControls()) {             if (control.getFormat() instanceof VideoFormat || control.getFormat() instanceof AudioFormat) {                 if (control.getFormat() instanceof AudioFormat) {                     // In general, this is safe for audio, but do not make assumptions for video.                     // Things get a little wonky for video because of how complex the options are.                     control.setFormat(new AudioFormat(AudioFormat.GSM));                 }                  if (control.getFormat() instanceof VideoFormat) {                     VideoFormat desiredVideoFormat = null;                     Dimension targetDimension = new Dimension(352, 288);                      // Search sequentially through this array of formats                     VideoFormat[] desiredFormats = new VideoFormat[] {new H263Format(), new JPEGFormat(), new RGBFormat(), new YUVFormat()};                     for (VideoFormat checkFormat : desiredFormats) {                         // Search the video formats looking for a match.                         List&lt;VideoFormat&gt; candidates = new LinkedList&lt;VideoFormat&gt;();                         for (Format format : control.getSupportedFormats()) {                             if (format.isSameEncoding(checkFormat)) {                                 candidates.add((VideoFormat) format);                             }                         }                         if (!candidates.isEmpty()) {                             // Get the first candidate for now since we have at least a format match                             desiredVideoFormat = candidates.get(0);                              for (VideoFormat format : candidates) {                                 if (targetDimension.equals(format.getSize())) {                                     // Found exactly what we're looking for                                     desiredVideoFormat = format;                                     break;                                 }                             }                         }                          if (desiredVideoFormat != null) {                             // If we found a match, stop searching formats                             break;                         }                     }                      if (desiredVideoFormat != null) {                         // It's entirely possible (but not likely) that we got here without a format                         //  selected, so this null check is unfortunately necessary.                         control.setFormat(desiredVideoFormat);                     }                 }                 control.setEnabled(true);                 System.out.println(""Enabled track: "" + control + "" ("" + control.getFormat() + "")"");             }          }          // To get the output from a processor, we need it to be realized.         processor.realize();         waitForState(processor, Processor.Realized);          // Get the data output so we can output it to a file.         DataSource dataOutput = processor.getDataOutput();          // Create a file to receive the media         File answerFile = new File(""recording.mov"");         MediaLocator dest = new MediaLocator(answerFile.toURI().toURL());          // Create a data sink to write to the disk         DataSink answerSink = Manager.createDataSink(dataOutput, dest);          // Start the processor spinning         processor.start();          // Open the file         answerSink.open();          // Start writing data         answerSink.start();          // SUCCESS!  We are now recording         Thread.sleep(10000);  // Wait for 10 seconds so we record 10 seconds of video          try {             // Stop the processor. This will also stop and close the datasources             processor.stop();             processor.close();              try {                 // Let the buffer run dry.  Event Listeners never seem to get called,                 // so this seems to be the most effective way.                 Thread.sleep(1000);             } catch (InterruptedException ex) {                 Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, ex);             }              try {                 // Stop recording to the file.                 answerSink.stop();             } catch (IOException ex) {                 Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, ex);             }         } finally {             try {                 // Whatever else we do, close the file if we can to avoid leaking.                 answerSink.close();             } catch (Exception ex) {                 Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, ex);             }              try {                 // Deallocate the native processor resources.                 processor.deallocate();             } catch (Exception ex) {                 Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, ex);             }         } }  // My little utility function to wait for a given state. private void waitForState(Player player, int state) {     // Fast abort     if (player.getState() == state) {         return;     }      long startTime = new Date().getTime();      long timeout = 10 * 1000;      final Object waitListener = new Object();      ControllerListener cl = new ControllerListener() {          @Override         public void controllerUpdate(ControllerEvent ce) {             synchronized (waitListener) {                 waitListener.notifyAll();             }         }     };     try {         player.addControllerListener(cl);          // Make sure we wake up every 500ms to check for timeouts and in case we miss a signal         synchronized (waitListener) {             while (player.getState() != state &amp;&amp; new Date().getTime() - startTime &lt; timeout) {                 try {                     waitListener.wait(500);                 } catch (InterruptedException ex) {                     Logger.getLogger(getClass().getName()).log(Level.SEVERE, null, ex);                 }             }         }     } finally {         // No matter what else happens, we want to remove this         player.removeControllerListener(cl);     } }"
"Player p ;   FileConnection connection = (FileConnection) Connector.open(""file:///M:/sampleVideo/file1.mpg"");         // If you run on the simulator then it is memorycard and if it device then it is specific to that device        // FileConnection connection = (FileConnection) Connector.open(""file:///memorycard/sampleVideo/6.mp4"");                                 InputStream inStream = null;                                 inStream = connection.openInputStream();                                 try {                                     p = Manager.createPlayer(inStream, ""video/mpg"");                                     p.addPlayerListener(this);                                    p.realize();"
ApplicationPermissions permRequest = new ApplicationPermissions();   permRequest.addPermission(ApplicationPermissions.PERMISSION_MEDIA);   permRequest.addPermission(ApplicationPermissions.PERMISSION_LOCATION_DATA);   permRequest.addPermission(ApplicationPermissions.PERMISSION_RECORDING);   permRequest.addPermission(ApplicationPermissions.PERMISSION_INPUT_SIMULATION);   permRequest.addPermission(ApplicationPermissions.PERMISSION_DEVICE_SETTINGS);   permRequest.addPermission(ApplicationPermissions.PERMISSION_CROSS_APPLICATION_COMMUNICATION);    permRequest.addPermission(ApplicationPermissions.PERMISSION_INTERNET);   permRequest.addPermission(ApplicationPermissions.PERMISSION_SERVER_NETWORK);   permRequest.addPermission(ApplicationPermissions.PERMISSION_EMAIL);
"class VoiceNotesRecorderThread extends Thread {      private Player _player;     private RecordControl _rcontrol;     private ByteArrayOutputStream _output;     private byte _data[];      VoiceNotesRecorderThread() {     }      public void run() {         try {             _player = Manager                 .createPlayer(""capture://audio?encoding=audio/basic"");             _player.realize();             _rcontrol = (RecordControl) _player                 .getControl(""RecordControl"");             _output = new ByteArrayOutputStream();             _rcontrol.setRecordStream(_output);             _rcontrol.startRecord();             _player.start();         } catch (final Exception e) {             UiApplication.getUiApplication().invokeAndWait(new Runnable() {                 public void run() {                     Dialog.inform(e.toString());                 }             });         }     }      public void stop() {         try {             _rcontrol.commit();             _data = _output.toByteArray();             _output.close();             _player.close();         } catch (Exception e) {             synchronized (UiApplication.getEventLock()) {                 Dialog.inform(e.toString());             }         }     }      byte[] getData() {         return _data;     } }"
"{         int genreId = 2; // &lt;&lt; Set Your Genre ID Here         Uri uri = MediaStore.Audio.Albums.getContentUri(""external"");         Log.i(""XXX"", ""uri = "" + uri.toString());         Cursor cursor = null;         try {              String selection = ""album_info._id IN ""                     + ""(SELECT (audio_meta.album_id) album_id FROM audio_meta, audio_genres_map ""                     + ""WHERE audio_genres_map.audio_id=audio_meta._id AND audio_genres_map.genre_id=?)"";             String[] selectionArgs = new String[] { String.valueOf(genreId) };             String[] proj = { AlbumColumns.ALBUM };             cursor = getContentResolver().query(uri, proj, selection,                     selectionArgs, null);             if (null != cursor) {                 Log.i(""XXX"", ""cursor rows count = "" + cursor.getCount());                 while (cursor.moveToNext()) {                     Log.i(""XXX"", ""  Album: "" + cursor.getString(0));                 }                 cursor.close();                 Log.i(""XXX"", ""cursor closed"");             }         } catch (Exception ex) {             Log.e(""XXX"", ""Error Querying Database"");         } finally {             if (cursor != null) {                 cursor.close();             }         }     }"
"public static String addTracksToPlaylist(final long id, List&lt;MediaData&gt; tracks, final Context context) {     int count = getPlaylistSize(id, context);     ContentValues[] values = new ContentValues[tracks.size()];     for (int i = 0; i &lt; tracks.size(); i++) {         values[i] = new ContentValues();         values[i].put(MediaStore.Audio.Playlists.Members.PLAY_ORDER, i + count + 1);         values[i].put(MediaStore.Audio.Playlists.Members.AUDIO_ID, tracks.get(i).getId());     }     Uri uri = MediaStore.Audio.Playlists.Members.getContentUri(""external"", id);     ContentResolver resolver = context.getContentResolver();     int num = resolver.bulkInsert(uri, values);     resolver.notifyChange(Uri.parse(""content://media""), null);     return String.format(context.getString(R.string.ADDED_TO_PLAYLIST), num, context.getString(R.string.CURRENT));  }"
"public static void main(String[] args) throws IOException {      String audioDeutsch = MuxMp4SourcesExample.class.getProtectionDomain().getCodeSource().getLocation().getFile() + ""/count-deutsch-audio.mp4"";     String audioEnglish = MuxMp4SourcesExample.class.getProtectionDomain().getCodeSource().getLocation().getFile() + ""/count-english-audio.mp4"";     String video = MuxMp4SourcesExample.class.getProtectionDomain().getCodeSource().getLocation().getFile() + ""/count-video.mp4"";       Movie countVideo = MovieCreator.build(new FileInputStream(video).getChannel());     Movie countAudioDeutsch = MovieCreator.build(new FileInputStream(audioDeutsch).getChannel());     Movie countAudioEnglish = MovieCreator.build(new FileInputStream(audioEnglish).getChannel());      Track audioTrackDeutsch = countAudioDeutsch.getTracks().get(0);     audioTrackDeutsch.getTrackMetaData().setLanguage(""deu"");     Track audioTrackEnglish = countAudioEnglish.getTracks().get(0);     audioTrackEnglish.getTrackMetaData().setLanguage(""eng"");      countVideo.addTrack(audioTrackDeutsch);     countVideo.addTrack(audioTrackEnglish);      Container out = new DefaultMp4Builder().build(countVideo);     FileOutputStream fos = new FileOutputStream(new File(""output.mp4""));     out.writeContainer(fos.getChannel());     fos.close();  }"
"private void lockScreenControls() {      // Use the media button APIs (if available) to register ourselves for media button     // events      MediaButtonHelper.registerMediaButtonEventReceiverCompat(mAudioManager, mMediaButtonReceiverComponent);     // Use the remote control APIs (if available) to set the playback state     if (mRemoteControlClientCompat == null) {         Intent intent = new Intent(Intent.ACTION_MEDIA_BUTTON);         intent.setComponent(mMediaButtonReceiverComponent);         mRemoteControlClientCompat = new RemoteControlClientCompat(PendingIntent.getBroadcast(this /*context*/,0 /*requestCode, ignored*/, intent /*intent*/, 0 /*flags*/));         RemoteControlHelper.registerRemoteControlClient(mAudioManager,mRemoteControlClientCompat);     }     mRemoteControlClientCompat.setPlaybackState(RemoteControlClient.PLAYSTATE_PLAYING);     mRemoteControlClientCompat.setTransportControlFlags(             RemoteControlClient.FLAG_KEY_MEDIA_PAUSE |             RemoteControlClient.FLAG_KEY_MEDIA_PREVIOUS |             RemoteControlClient.FLAG_KEY_MEDIA_NEXT |             RemoteControlClient.FLAG_KEY_MEDIA_STOP);    //update remote controls     mRemoteControlClientCompat.editMetadata(true)             .putString(MediaMetadataRetriever.METADATA_KEY_ARTIST, ""NombreArtista"")             .putString(MediaMetadataRetriever.METADATA_KEY_ALBUM, ""Titulo Album"")             .putString(MediaMetadataRetriever.METADATA_KEY_TITLE, nombreCancion)             //.putLong(MediaMetadataRetriever.METADATA_KEY_DURATION,playingItem.getDuration())                     // TODO: fetch real item artwork             .putBitmap(RemoteControlClientCompat.MetadataEditorCompat.METADATA_KEY_ARTWORK, getAlbumArt())             .apply();     } }"
"public class MusicPlayer {     private final int songResId = R.raw.your_song;     private final MediaPlayer mediaPlayer;      public MusicPlayer(Context context)     {         mediaPlayer = MediaPlayer.create(context, songResId);         mediaPlayer.setLooping(true);     }      public void setPlaying(boolean isPlaying)     {         if (isPlaying)         {             mediaPlayer.start();         }         else         {             mediaPlayer.stop();         }     }      public void release()     {         mediaPlayer.stop();         mediaPlayer.release();     } }"
"import java.io.File; import java.io.IOException;  import javax.sound.sampled.AudioFormat; import javax.sound.sampled.AudioInputStream; import javax.sound.sampled.AudioSystem; import javax.sound.sampled.DataLine; import javax.sound.sampled.LineUnavailableException; import javax.sound.sampled.SourceDataLine;  public class MakeSound {      private final int BUFFER_SIZE = 128000;     private File soundFile;     private AudioInputStream audioStream;     private AudioFormat audioFormat;     private SourceDataLine sourceLine;      /**      * @param filename the name of the file that is going to be played      */     public void playSound(String filename){          String strFilename = filename;          try {             soundFile = new File(strFilename);         } catch (Exception e) {             e.printStackTrace();             System.exit(1);         }          try {             audioStream = AudioSystem.getAudioInputStream(soundFile);         } catch (Exception e){             e.printStackTrace();             System.exit(1);         }          audioFormat = audioStream.getFormat();          DataLine.Info info = new DataLine.Info(SourceDataLine.class, audioFormat);         try {             sourceLine = (SourceDataLine) AudioSystem.getLine(info);             sourceLine.open(audioFormat);         } catch (LineUnavailableException e) {             e.printStackTrace();             System.exit(1);         } catch (Exception e) {             e.printStackTrace();             System.exit(1);         }          sourceLine.start();          int nBytesRead = 0;         byte[] abData = new byte[BUFFER_SIZE];         while (nBytesRead != -1) {             try {                 nBytesRead = audioStream.read(abData, 0, abData.length);             } catch (IOException e) {                 e.printStackTrace();             }             if (nBytesRead &gt;= 0) {                 @SuppressWarnings(""unused"")                 int nBytesWritten = sourceLine.write(abData, 0, nBytesRead);             }         }          sourceLine.drain();         sourceLine.close();     } }"
"try {      int cellID = GPRSInfo.getCellInfo().getCellId();     int lac = GPRSInfo.getCellInfo().getLAC();      String urlString2 = ""http://www.google.com/glm/mmap"";     if ((WLANInfo.getWLANState() == WLANInfo.WLAN_STATE_CONNECTED)             &amp;&amp; RadioInfo                     .areWAFsSupported(RadioInfo.WAF_WLAN)) {         urlString2 += "";interface=wifi;ConnectionTimeout=60000"";     }else  if (TransportInfo.isTransportTypeAvailable(TransportInfo.TRANSPORT_BIS_B) &amp;&amp; TransportInfo.hasSufficientCoverage(TransportInfo.TRANSPORT_BIS_B)) {         System.out.println(""BIS CONNECTION-------------------"");         // Holder.connectionInterface="";deviceside=false;ConnectionType=mds-public"";         urlString2 += "";deviceside=false;ConnectionType=mds-public;ConnectionTimeout=60000"";     }        // Open a connection to Google Maps API      ConnectionFactory connFact = new ConnectionFactory();     ConnectionDescriptor connDesc;     connDesc = connFact.getConnection(urlString2);      HttpConnection httpConn2;     httpConn2 = (HttpConnection)connDesc.getConnection();     httpConn2.setRequestMethod(""POST"");      // Write some custom data to Google Maps API      OutputStream outputStream2 = httpConn2.openOutputStream();//getOutputStream();     WriteDataGoogleMaps(outputStream2, cellID, lac);      // Get the response       InputStream inputStream2 = httpConn2.openInputStream();//getInputStream();     DataInputStream dataInputStream2 = new DataInputStream(inputStream2);      // Interpret the response obtained      dataInputStream2.readShort();     dataInputStream2.readByte();      int code = dataInputStream2.readInt();     //Dialog.alert(code+"""");      if (code == 0) {         latitude= dataInputStream2.readInt() / 1000000D;         longitude=dataInputStream2.readInt() / 1000000D;          //Dialog.alert(latitude+""-----""+longitude);            dataInputStream2.readInt();         dataInputStream2.readInt();         dataInputStream2.readUTF();      } else {         System.out.println(""Error obtaining Cell Id "");     }     outputStream2.close();     inputStream2.close(); } catch (Exception e) {     System.out.println(""Error: "" + e.getMessage()); }"
"public class CachedSoundClipTest {     static ArrayList&lt;AudioInputStream&gt; cachedSounds =          new ArrayList&lt;AudioInputStream&gt;();      public static void main(String[] args) throws Exception     {         File[] audioFiles = new File(""/audio_storage_directory"").listFiles();         for (File file : audioFiles)         {             AudioInputStream reusableAudioInputStream =                  createReusableAudioInputStream(file);             cachedSounds.add(reusableAudioInputStream);         }          while(true)         {             System.out.println(""Press enter to play next clip"");             BufferedReader br =                  new BufferedReader(new InputStreamReader(System.in));             br.readLine();             playCachedSound(0);         }     }      private static void playCachedSound(int i)          throws IOException, LineUnavailableException     {         AudioInputStream stream = cachedSounds.get(i);         stream.reset();         Clip clip = AudioSystem.getClip();         clip.open(stream);         clip.start();     }      private static AudioInputStream createReusableAudioInputStream(File file)          throws IOException, UnsupportedAudioFileException     {         AudioInputStream ais = null;         try         {             ais = AudioSystem.getAudioInputStream(file);             byte[] buffer = new byte[1024 * 32];             int read = 0;             ByteArrayOutputStream baos =                  new ByteArrayOutputStream(buffer.length);             while ((read = ais.read(buffer, 0, buffer.length)) != -1)             {                 baos.write(buffer, 0, read);             }             AudioInputStream reusableAis =                  new AudioInputStream(                         new ByteArrayInputStream(baos.toByteArray()),                         ais.getFormat(),                         AudioSystem.NOT_SPECIFIED);             return reusableAis;         }         finally         {             if (ais != null)             {                 ais.close();             }         }     } }"
"if (new File(destination).listFiles().length &lt;= 1) {     return ""/GUI/printServerSide.xhtml""; } else if(""txt"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""jpeg"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""jpg"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""png"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""gif"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""pdf"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""html"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else {     return ""/GUI/printServerSide.xhtml""; }"
"try {         httpURL=""http://google.co.in/"";          if ((WLANInfo.getWLANState() == WLANInfo.WLAN_STATE_CONNECTED)                 &amp;&amp; RadioInfo                         .areWAFsSupported(RadioInfo.WAF_WLAN)) {             httpURL += "";interface=wifi"";         }else  if (TransportInfo.isTransportTypeAvailable(TransportInfo.TRANSPORT_BIS_B) &amp;&amp; TransportInfo.hasSufficientCoverage(TransportInfo.TRANSPORT_BIS_B)) {             System.out.println(""BIS CONNECTION-------------------"");             // Holder.connectionInterface="";deviceside=false;ConnectionType=mds-public"";             httpURL += "";deviceside=false;ConnectionType=mds-public"";         }          //Dialog.alert(httpURL);         HttpConnection httpConn;         httpConn = (HttpConnection) Connector.open(httpURL);         httpConn.setRequestMethod(HttpConnection.POST);         DataOutputStream _outStream = new DataOutputStream(httpConn.openDataOutputStream());         byte[] request_body = httpURL.getBytes();         for (int i = 0; i &lt; request_body.length; i++) {             _outStream.writeByte(request_body[i]);         }         DataInputStream _inputStream = new DataInputStream(         httpConn.openInputStream());         StringBuffer _responseMessage = new StringBuffer();         int ch;         while ((ch = _inputStream.read()) != -1) {             _responseMessage.append((char) ch);         }         String res = (_responseMessage.toString());         responce = res.trim();          //Dialog.alert(responce);          httpConn.close();       }catch (Exception e) {         Dialog.alert(""Error -""+e.toString());     }"
"int find(int x,int y,int h) {         int result = -1;     if   ((x+1&lt;rows &amp;&amp; m[x+1][y].c=='@'   &amp;&amp;  !m[x+1][y].done)          ||(x-1&gt;=0   &amp;&amp; m[x-1][y].c=='@'   &amp;&amp;  !m[x-1][y].done)         ||(y+1&lt;cols &amp;&amp; m[x][y+1].c=='@'   &amp;&amp;  !m[x][y+1].done)            ||(y-1&gt;=0   &amp;&amp; m[x][y-1].c=='@'   &amp;&amp;  !m[x][y-1].done)){            return h + 1;          }       else        {          if(x-1&gt;=0   &amp;&amp;  m[x-1][y].c=='1' &amp;&amp; !m[x-1][y].done){   /*north cell*/                    m[x][y].done=true;                     result = find(x-1,y,h + 1)                    if (result &gt; -1) {                        return result;                     }                    m[x][y].done=false;         }"
"package test;  import jmtp.PortableDevice; import jmtp.PortableDeviceManager; import jmtp.PortableDeviceObject; import jmtp.PortableDeviceStorageObject;  public class FileConnectionTest {      public static void main(String[] args) {         PortableDeviceManager manager = new PortableDeviceManager();         PortableDevice device = manager.getDevices()[0];           // Connect to my mp3-player         device.open();         System.out.println(device.getModel());         System.out.println(""---------------"");          // Iterate over deviceObjects         for(PortableDeviceObject object : device.getRootObjects()) {              // If the object is a storage object             if(object instanceof PortableDeviceStorageObject) {                 PortableDeviceStorageObject storage = (PortableDeviceStorageObject)object;                  for(PortableDeviceObject o2 :  storage.getChildObjects()){                     System.out.println(o2.getName());                  }                           }         }         manager.getDevices()[0].close();     } }"
"import net.rim.device.api.ui.Color; import net.rim.device.api.ui.Field; import net.rim.device.api.ui.FieldChangeListener; import net.rim.device.api.ui.Graphics; import net.rim.device.api.ui.Manager; import net.rim.device.api.ui.component.BasicEditField; import net.rim.device.api.ui.container.HorizontalFieldManager; import net.rim.device.api.ui.container.VerticalFieldManager; import net.rim.device.api.util.Arrays;  public class CustomTextField extends VerticalFieldManager {     private int textWidth = 0;    private int textHeight = 0;    private CustomHorizontalFieldManager hfm;     public CustomTextField(int width, int height) {       super();        textWidth = width;       textHeight = height;        hfm = new CustomHorizontalFieldManager();       add(hfm);    }     protected void sublayout(int maxWidth, int maxHeight) {       super.sublayout(textWidth, textHeight);       setExtent(textWidth, textHeight);    }     protected void paint(Graphics graphics) {       // TODO: change me!       super.paint(graphics);       graphics.setColor(Color.BLACK);       graphics.drawRect(0, 0, textWidth, textHeight);    }     private class CustomHorizontalFieldManager extends HorizontalFieldManager implements FieldChangeListener {        private BasicEditField basicEditField;       /** the maximum virtual width of the edit field, based on the max num of chars */       private int maxVirtualWidth;        public CustomHorizontalFieldManager() {          super(Manager.HORIZONTAL_SCROLL);           int maxNumChars = 200;          basicEditField = new BasicEditField("""", """", maxNumChars, BasicEditField.NO_NEWLINE);           // determine how wide the field would need to be to hold 'maxNumChars', with the font          //   in use ... just pick a long string of all W's, since that's usually the widest char          char[] buffer = new char[maxNumChars];          Arrays.fill(buffer, 'W');          String spacer = new String(buffer);          maxVirtualWidth = basicEditField.getFont().getAdvance(spacer);           // we need to listen as the user types in this field, so we can dynamically alter its          //   virtual width          basicEditField.setChangeListener(this);           add(basicEditField);       }        protected void sublayout(int maxWidth, int maxHeight) {          super.sublayout(maxWidth, maxHeight);          // extent is the visible size, virtual extent can be wider if we want scrolling          setExtent(textWidth, textHeight);          setVirtualExtent(maxVirtualWidth, textHeight);       }        public void fieldChanged(Field f, int context) {          if (f == basicEditField) {             // recalculate how much virtual width the edit field needs, based on the              //  current text content             int newWidth = basicEditField.getFont().getAdvance(basicEditField.getText());             setVirtualExtent(newWidth, textHeight);          }       }    }  }"
"String fileName   = ""path/to/my/file""; File file         = new File(fileName); MediaInfo info    = new MediaInfo(); info.open(file);  String format     = info.get(MediaInfo.StreamKind.Video, i, ""Format"",                          MediaInfo.InfoKind.Text, MediaInfo.InfoKind.Name); int bitRate       = info.get(MediaInfo.StreamKind.Video, i, ""BitRate"",                          MediaInfo.InfoKind.Text, MediaInfo.InfoKind.Name); float frameRate   = info.get(MediaInfo.StreamKind.Video, i, ""FrameRate"",                          MediaInfo.InfoKind.Text, MediaInfo.InfoKind.Name); short width       = info.get(MediaInfo.StreamKind.Video, i, ""Width"",                          MediaInfo.InfoKind.Text, MediaInfo.InfoKind.Name);  int audioBitrate  = info.get(MediaInfo.StreamKind.Audio, i, ""BitRate"",                          MediaInfo.InfoKind.Text, MediaInfo.InfoKind.Name); int audioChannels = info.get(MediaInfo.StreamKind.Audio, i, ""Channels"",                          MediaInfo.InfoKind.Text, MediaInfo.InfoKind.Name);"
"InputFormat             | Description                                      | Key                                      | Value -------------------------------------------------------------------------------------------------------------------------------------------------------- TextInputFormat         | Default format; reads lines of text files        | The byte offset of the line              | The line contents KeyValueInputFormat     | Parses lines into key, val pairs                 | Everything up to the first tab character | The remainder of the line SequenceFileInputFormat | A Hadoop-specific high-performance binary format | user-defined                             | user-defined"
"public class Main extends Application {      @Override     public void start(Stage primaryStage) {          Media pick = new Media(""put.mp3""); // replace this with your own audio file         MediaPlayer player = new MediaPlayer(pick);          // Add a mediaView, to display the media. Its necessary !         // This mediaView is added to a Pane         MediaView mediaView = new MediaView(player);          // Add to scene         Group root = new Group(mediaView);         Scene scene = new Scene(root, 500, 200);          // Show the stage         primaryStage.setTitle(""Media Player"");         primaryStage.setScene(scene);         primaryStage.show();          // Play the media once the stage is shown         player.play();     }      public static void main(String[] args) {          launch(args);     } }"
