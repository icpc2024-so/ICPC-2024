code
"String str = ""kushal,mayurv,narendra,dhrumil,mark, ,,,, "";         String splitted[] = str.split("","");         StringBuffer sb = new StringBuffer();         String retrieveData = """";         for(int i =0; i&lt;splitted.length; i++){             retrieveData = splitted[i];             if((retrieveData.trim()).length()&gt;0){                  if(i!=0){                     sb.append("","");                 }                 sb.append(retrieveData);              }         }      str = sb.toString();     System.out.println(str);"
"finalText = textField.getText().toString();  String[] textArrayWithFullStop = finalText.split(""\\. ""); String colelctionOfFiveSentences = """"; int sentenceAdded = 0;  List&lt;String&gt;textCollection = new ArrayList&lt;String&gt;(); for(int i=0;i&lt;textArrayWithFullStop.length;i++) {     colelctionOfFiveSentences += textArrayWithFullStop[i] + "". "";     sentenceAdded++;     if(sentenceAdded == 5)     {         textCollection.add(colelctionOfFiveSentences);         colelctionOfFiveSentences = """";         sentenceAdded = 0;     }  }"
"String sourceUrl = ""http://www.example.com/mysite/whatever/somefolder/bar/unsecure!+?#whätyöühäv€it/site.html""; // your current site     String targetUrl = ""http://www.example.com/mysite/whatever/otherfolder/other.html""; // the link target     String expectedTarget = ""../../../otherfolder/other.html"";     String[] sourceElements = sourceUrl.split(""/"");     String[] targetElements = targetUrl.split(""/""); // keep in mind that the arrays are of different length!     StringBuilder uniquePart = new StringBuilder();     StringBuilder relativePart = new StringBuilder();     boolean stillSame = true;     for(int ii = 0; ii &lt; sourceElements.length || ii &lt; targetElements.length; ii++) {         if(ii &lt; targetElements.length &amp;&amp; ii &lt; sourceElements.length &amp;&amp;                  stillSame &amp;&amp; sourceElements[ii].equals(targetElements[ii]) &amp;&amp; stillSame) continue;         stillSame = false;         if(targetElements.length &gt; ii)           uniquePart.append(""/"").append(targetElements[ii]);         if(sourceElements.length &gt; ii +1)             relativePart.append(""../"");     }      String result = relativePart.toString().substring(0, relativePart.length() -1) + uniquePart.toString();     System.out.println(""result: "" + result);"
"String myString = ""width:17px;background:#555;float:left;""; String[] sections = myString.split("";""); // split string in multiple sections for (String section : sections) {    // check if this section contains a width definition   if (section.matches(""width\\s*:\\s*(\\d+)px.*"")) {     System.out.println(""width: "" + section.split("":"")[1].trim());   }    // check if this section contains a background definition   if (section.matches(""background\\s*:\\s*#[0-9A-Fa-f]+.*"")) {     System.out.println(""background: "" + section.split("":"")[1].trim());   }    ... }"
"Method         = ""OPTIONS""                ; Section 9.2                   | ""GET""                    ; Section 9.3                   | ""HEAD""                   ; Section 9.4                   | ""POST""                   ; Section 9.5                   | ""PUT""                    ; Section 9.6                   | ""DELETE""                 ; Section 9.7                   | ""TRACE""                  ; Section 9.8                   | ""CONNECT""                ; Section 9.9                   | extension-method    extension-method = token"
"StringBuilder answer = new StringBuilder(); String s  = ""This is a sample sentence so that Ang Mo Kio Avenue 1 is part of Ang Mo Kio."";     String[] words = s.split(""\\s+"");     int count=0;     for (int i = 0; i &lt; words.length; i++) {         char firstChar=words[i].charAt(0);         if (Character.isUpperCase(firstChar)                   ||(count&gt;0  &amp;&amp; Character.isDigit(firstChar))) {             answer.append("" ""+words[i]);             count++;         } else {             //To avoid less than 3 word apply this logic.             if(count&gt;2){             System.out.println(answer);             }             count=0;             answer = new StringBuilder();         }     }     System.out.println(answer);// Also need to print answer here."
"String cronAttribute = taskElement.getAttribute(""cron""); if (StringUtils.hasText(cronAttribute)) {     cronTaskMap.put(runnableBeanRef, cronAttribute); } else {     String fixedDelayAttribute = taskElement.getAttribute(""fixed-delay"");     if (StringUtils.hasText(fixedDelayAttribute)) {         fixedDelayTaskMap.put(runnableBeanRef, fixedDelayAttribute);     }     else {         String fixedRateAttribute = taskElement.getAttribute(""fixed-rate"");         if (!StringUtils.hasText(fixedRateAttribute)) {             parserContext.getReaderContext().error(                     ""One of 'cron', 'fixed-delay', or 'fixed-rate' is required"",                     taskElement);             // Continue with the possible next task element             continue;         }         fixedRateTaskMap.put(runnableBeanRef, fixedRateAttribute);     } }"
"public void populate(Bundle bundle) {     String localisation = (String) bundle.getHeaders().get(""Bundle-Localization"");     Locale locale = Locale.getDefault();      populate(bundle.getEntry(getFileName(localisation)));     populate(bundle.getEntry(getFileName(localisation, locale.getLanguage())));     populate(bundle.getEntry(getFileName(localisation, locale.getLanguage(), locale.getCountry())));     populate(bundle.getResource(getFileName(""fragment"")));     populate(bundle.getResource(getFileName(""fragment"", locale.getLanguage())));     populate(bundle.getResource(getFileName(""fragment"", locale.getLanguage(), locale.getCountry()))); }"
"int[] charCounts = new int[26];      //Separate the string into individual words     //The string "" /n"" tells it to look for spaces and newline characters ""/n""     StringTokenizer st = new StringTokenizer(inputString, "" /n"");      //Loop until all the words are processed     while (st.hasMoreTokens()) {          //Select the next word         String word = st.nextToken();          //Convert the string to upper case so that lower case and upper case characters are represented the same         word = word.toUpperCase();          //Get the first character from the word         char firstChar = word.charAt(0);          //Convert the character to an integer representing it as an ASCII code         int charCode = (int) firstChar;          //Increment the count for that character by 1          //(We subtract 65 from the ASCII code because the array starts at 0 but 'A' is at 65)         charCounts[charCode - 65]++;     }      //Obviously replace this section with whatever you like. It's just to show you how to get the values out again.     for (int i = 0; i &lt; charCounts.length; i++){         System.out.println((char)(i + 65) + "": "" + charCounts[i]);     }"
"boolean isPattern(String givenPattern, String stringToMatch) {     if (givenPattern.empty)         return stringToMatch.isEmpty();     char patternCh = givenPatter.charAt(0);     boolean atEnd = stringToMatch.isEmpty();     if (patternCh == '*') {         return isPattenn(givenPattern.substring(1), stringToMatch)             || (!atEnd &amp;&amp; isPattern(givenPattern, stringToMatch.substring(1)));     } else if (patternCh == '?') {         return !atEnd &amp;&amp; isPattern(givenPattern.substring(1),              stringToMatch.substring(1));     }     return !atEnd &amp;&amp; patternCh == stringToMatch.charAt(0)           &amp;&amp; isPattern(givenPattern.substring(1), stringToNatch.subtring(1); }"
"public static &lt;T&gt; ConcurrentMap&lt;String,Collection&lt;T&gt;&gt; reduceMap(ConcurrentMap&lt;String, ConcurrentHashMap&lt;String, Collection&lt;T&gt;&gt;&gt; map) {     ConcurrentMap&lt;String, Collection&lt;T&gt;&gt; smallerMap = new ConcurrentHashMap&lt;String, Collection&lt;T&gt;&gt;();     for (String material : map.keySet()) {         for(String genre: map.get(material).keySet()) {             if (smallerMap.get(genre) == null) {                 smallerMap.put(genre, map.get(material).get(genre));             }             else {                 Collection&lt;T&gt; stories = smallerMap.get(genre);                 for (T o : map.get(material).get(genre)) {                     if (!smallerMap.get(genre).contains(o)) {                         stories.add(o); // error here                     }                 }                 smallerMap.put(genre, stories);             }         }     }        return smallerMap; }"
"try {          JsonRootNode json = JDOM.parse(l);         final String xVal = json.getNode(""sr"").getNode(""posx"").getText();         final String yVal = json.getNode(""sr"").getNode(""posy"").getText();         final String zVal = json.getNode(""sr"").getNode(""posz"").getText();         final String aVal = json.getNode(""sr"").getNode(""posa"").getText();          // here you are calling UI getter, and parse it each time         // it would be more optimal to store `x` value in separate variable         // between updates         final float x = Float.parseFloat(xAxisVal.getText());         final float y = Float.parseFloat(yAxisVal.getText());          Platform.runLater(new Runnable() {              public void run() {                 //We are now back in the EventThread and can update the GUI                 try {                      xAxisVal.setText(xVal);                     yAxisVal.setText(yVal);                     zAxisVal.setText(zVal);                     aAxisVal.setText(aVal);                     xl.setX(x + 400);                     y1.setY(y + 400);                     LineTo tmpL = new LineTo(x * 2 + 400, y * 2 + 400);                     path.getElements().add(tmpL);                  }             }         }      } catch (argo.saj.InvalidSyntaxException ex) {         //Json line invalid.     }"
"JSONObject jsonObject = new JSONObject(""Your JSON STRING HERE"");  JSONArray  jsonArray =jsonObject.getJSONArray(""item"");   for (int i = 0; i &lt; jsonArray.length(); i++) {     JSONObject jsonObjectitem=                            jsonArray.getJSONObject(i);                                                                                // get title or link here      String strtitle=jsonObjectitem.getString(""title"");       //....get other values in same way      // get media:content json object   JSONObject jsonObjectmediacontent =                         jsonObjectitem.getJSONObject(""media:content"");     // get url,medium,...       String strurl=jsonObjectmediacontent.getString(""-url"");       //....get other values in same way                                     }"
"package com.bullethq.jawr.postprocessor;  import net.jawr.web.resource.FileNameUtils; import net.jawr.web.resource.bundle.factory.util.PathNormalizer; import net.jawr.web.resource.bundle.postprocess.BundleProcessingStatus; import net.jawr.web.resource.bundle.postprocess.impl.CSSURLPathRewriterPostProcessor; import net.jawr.web.resource.bundle.postprocess.impl.PostProcessorCssImageUrlRewriter;  import java.io.IOException;  public class CustomCssUrlPathRewriterPostProcessor extends CSSURLPathRewriterPostProcessor {      public static final String CUSTOM_URL_PATH_REWRITER = ""customcsspathrewriter"";      public CustomCssUrlPathRewriterPostProcessor() {         super(CUSTOM_URL_PATH_REWRITER);     }      // ========================================================================     // ========================================================================     // ========================================================================     @Override     protected PostProcessorCssImageUrlRewriter createImageUrlRewriter(BundleProcessingStatus status) {         return new CustomPostProcessorCssImageUrlRewriter(status);     }      // ========================================================================     // ========================================================================     // ========================================================================     public class CustomPostProcessorCssImageUrlRewriter extends PostProcessorCssImageUrlRewriter {          public CustomPostProcessorCssImageUrlRewriter(BundleProcessingStatus status) {             super(status);         }          // ========================================================================         // ========================================================================         // ========================================================================         @Override         protected String getUrlPath(String match, String originalPath, String newCssPath) throws IOException {             String url = match.substring(match.indexOf('(') + 1, match.lastIndexOf(')')).trim();              // Remove any quotes if necessary.             String quoteStr = """";             if (url.startsWith(""'"") || url.startsWith(""\"""")) {                 quoteStr = String.valueOf(url.charAt(0));                 url = url.substring(1, url.length() - 1);             }              // We now check if the url ends in a known image file extension             // If not, the url is ignored.             if (FileNameUtils.hasImageExtension(url)) {                 return super.getUrlPath(match, originalPath, newCssPath);             } else {                 // We need to rewrite the path, as any relative URLs will                 // not resolve correctly if Jawr has changed the CSS path.                 url = PathNormalizer.concatWebPath(originalPath, url);                 url = PathNormalizer.getRelativeWebPath(PathNormalizer.getParentPath(newCssPath), url);                 return ""url("" + quoteStr + url + quoteStr + "")"";             }         }     } }"
"Collections.sort(listA); Collections.sort(listB);  ListIterator&lt;String&gt; aIter = listA.listIterator(); ListIterator&lt;String&gt; bIter = listB.listIterator(); List&lt;String&gt; listC = new List&lt;String&gt;();  while(aIter.hasNext() || bIter.hasNext()) {    if(!bIter.hasNext())       listC.add(aIter.next());    else if(!aIter.hasNext())       listC.add(bIter.next());    else    {       //kinda smells from a C# background to mix the List and its Iterator,        //but this avoids ""backtracking"" the Iterators when their value isn't selected.       String a = listA[aIter.nextIndex()];       String b = listB[bIter.nextIndex()];        if(a==b)        {          listC.add(aIter.next());          listC.add(bIter.next());       }       else if(a.CompareTo(b) &lt; 0)          listC.add(aIter.next());       else          listC.add(bIter.next());              } }"
"public void shortenMessage() {     String body = composeEditText.getText().toString();     StringBuilder shortenedBody = new StringBuilder();     String [] tokens = body.split(""\\s"");      // Attempt to convert each item into an URL.       for( String token : tokens )      {         try         {             Url url = as(""mycompany"", ""someapikey"").call(shorten(token));             Log.d(""SHORTENED"", token + "" was shortened!"");             shortenedBody.append(url.getShortUrl()).append("" "");         }         catch(BitlyException e)         {             //Log.d(""BitlyException"", token + "" could not be shortened!"");          }     }      composeEditText.setText(shortenedBody.toString());     // url.getShortUrl() -&gt; http://bit.ly/fB05 }"
"public class CoordTest {      private static String  coords = ""N 39° 28.941 W 0° 23.275"";      public static void main(String[] args) {         String[] cArray = coords.split("" "");         String latSign = cArray[0];         String latDegrees = cArray[1].substring(0, cArray[1].length()-1);         String latSubdegrees = cArray[2];         String lonSign = cArray[3];         String lonDegrees = cArray[4].substring(0, cArray[4].length()-1);         String lonSubdegrees = cArray[5];         double lat = getSign(latSign) * (Integer.valueOf(latDegrees) + convertFromDegreesToDecimal(Double.valueOf(latSubdegrees)));         double lon = getSign(lonSign) * (Integer.valueOf(lonDegrees) + convertFromDegreesToDecimal(Double.valueOf(lonSubdegrees)));     }       private static int getSign(String c){         if (c.equals(""N"") || c.equals(""E"")){             return 1;         }         return -1;     }      private static double convertFromDegreesToDecimal(Double value){         double result = value/60d;         return result;     } }"
"String input = ""SrcAddr: 0.0.21.201\n""+            ""DstAddr: 7.202.10.100\n""+            ""NextHop: 0.33.189.142\n""+            ""InputIf: 19\n""+            ""OutputIf: 50715"";   String SrcAddr=getMatchedString(""SrcAddr"",input); String NextHop=getMatchedString(""NextHop"",input); String InputIf=getMatchedString(""InputIf"",input); String OutputIf=getMatchedString(""OutputIf"",input);  System.out.println(SrcAddr); System.out.println(NextHop); System.out.println(InputIf); System.out.println(OutputIf);     ..........   public static String getMatchedString(String word,String input){       String REGEX = ""(?:""+word+"":)\\s(.*)"";      Pattern p = Pattern.compile(REGEX);      Matcher m = p.matcher(input);      if (m.find()) {         String matched = m.group(1);         return matched;      }      return null;   }"
"String input = ""Lorem ipsum dolor sit amet, consectetur adipisicing #{key1}. "" +    ""Proin nibh augue, suscipit a, scelerisque #{key1},"" +     ""lacinia in, mi. Cras vel #{key2}. Etiam pellentesque aliquet tellus."" +     "" Phasellus pharetra nulla ac diam. Quisque semper #{key3} at risus.""; StringBuffer result = new StringBuffer();  Pattern p = Pattern.compile( ""#\\{([\\w\\.]+)\\}"" ); Matcher m = p.matcher( input );  while( m.find() ) {         //extract the message for key = m.group( 1 ) here   //i'll just mark the found keys    m.appendReplacement( result,  ""##"" + m.group( 1 ) + ""##"" );       } m.appendTail( result );  System.out.println(result); //output: ... consectetur adipisicing ##key1## ...  etc."
"ConfigureForm form = new ConfigureForm(FormType.submit); form.setPersistentItems(false); form.setDeliverPayloads(true); form.setAccessModel(AccessModel.open);  PubSubManager manager        = new PubSubManager(connection, ""pubsub.communitivity.com""); Node myNode = manager.createNode(""http://jabber.org/protocol/geoloc"", form);  StringBuilder body = new StringBuilder(); //ws for readability body.append(""&lt;geoloc xmlns='http://jabber.org/protocol/geoloc' xml:lang='en'&gt;""); body.append(""   &lt;country&gt;Italy&lt;/country&gt;""); body.append(""   &lt;lat&gt;45.44&lt;/lat&gt;""); body.append(""   &lt;locality&gt;Venice&lt;/locality&gt;""); body.append(""   &lt;lon&gt;12.33&lt;/lon&gt;""); body.append(""   &lt;accuracy&gt;20&lt;/accuracy&gt;""); body.append(""&lt;/geoloc&gt;"");  SimplePayload payload = new SimplePayload(                               ""geoloc"",                               ""http://jabber.org/protocol/geoloc"",                                body.toString()); String itemId = ""zz234""; Item&lt;SimplePayload&gt; item = new Item&lt;SimplePayload&gt;(itemId, payload);  // Required to recieve the events being published myNode.addItemEventListener(myEventHandler);  // Publish item myNode.publish(item);"
"TextView text = (TextView) findViewById(R.id.text); text.setText(""""); String linkName = ""@appamatto""; String linkUrl = ""http://twitter.com/appamatto"" SpannableString str = SpannableString.valueOf(linkName); str.setSpan(new URLSpan(linkUrl), 0, linkName.length(),     Spannable.SPAN_INCLUSIVE_EXCLUSIVE); str.setSpan(new ForegroundColorSpan(0xffffffff), 0, linkName.length(),     Spannable.SPAN_INCLUSIVE_EXCLUSIVE); str.setSpan(new BackgroundColorSpan(0xff0099ff), 0, linkName.length(),     Spannable.SPAN_INCLUSIVE_EXCLUSIVE); text.append(str);"
"String sequence = ""People,Object,Environment,Message,Service"";  Map&lt;String, String&gt; lhm = new TreeMap&lt;String, String&gt;(); lhm.put( ""Objectabc"", ""biu"" ); lhm.put( ""Message someText"", ""nuios"" ); lhm.put( ""Servicexyxyx"", ""sdfe"" ); lhm.put( ""People bcda"", ""dfdfh"" ); lhm.put( ""Environment qwer"", ""qwe"" ); lhm.put( ""Other"", ""names"" ); lhm.put( ""Elements"", ""ioup"" ); lhm.put( ""Rand"", ""uiy"" );  for( String element : sequence.split( "","" ) ) {   final String elem = element;    //try to get the value and remove it in one step   String value = lhm.remove( new Comparable&lt;String&gt;()   {     public int compareTo( String other )     {       if( other.contains( elem ) )       {         return 0;       }        return elem.compareTo( other );     }   } );    if( value != null )   {     System.out.println(""values according with the sequence (key:"" + element + "") is "" + value);    } }  for( Map.Entry&lt;String, String&gt; e : lhm.entrySet()) {   System.out.println(""non equal elements are "" + e.getKey() + "" (value: "" + e.getValue() + "")""); }"
"DrawPageElement drawPageElement = slide.getOdfElement(); DrawFrameElement drawFrame = OdfElement.findFirstChildNode(DrawFrameElement.class, drawPageElement); DrawImageElement image = drawFrame.newDrawImageElement(); OdfPackage mOdfPackage = odp.getPackage(); String imageRef = ""/some/path/to/chart.png"";  String packagePath = odp.getDocumentPath() + OdfPackage.OdfFile.IMAGE_DIRECTORY.getPath() + ""/"" + someMethodToCreateRandomString();  mOdfPackage.insert(new URI(imageRef), packagePath, OdfFileEntry.getMediaTypeString(imageRef)); packagePath = packagePath.replaceFirst(odp.getDocumentPath(), """"); URI uri = new URI(AnyURI.encodePath(packagePath).toString()); image.setXlinkHrefAttribute(AnyURI.decodePath(uri.toString())); image.setXlinkActuateAttribute(""onLoad""); image.setXlinkShowAttribute(""embed""); image.setXlinkTypeAttribute(""simple"");"
"RelatedResults results = t.getRelatedResults(tweetId); List&lt;Status&gt; conversations = results.getTweetsWithConversation(); ///////// Status originalStatus = t.showStatus(tweetId); if (conversations.isEmpty()) {     conversations = results.getTweetsWithReply(); }  if (conversations.isEmpty()) {     conversations = new ArrayList&lt;Status&gt;();     Status status = originalStatus;     while (status.getInReplyToStatusId() &gt; 0) {         status = t.showStatus(status.getInReplyToStatusId());         conversations.add(status);     } } // show the current message in the conversation, if there's such if (!conversations.isEmpty()) {     conversations.add(originalStatus); }"
"public static URI relativize(URI base, URI child) {   // Normalize paths to remove . and .. segments   base = base.normalize();   child = child.normalize();    // Split paths into segments   String[] bParts = base.getPath().split(""\\/"");   String[] cParts = child.getPath().split(""\\/"");    // Discard trailing segment of base path   if (bParts.length &gt; 0 &amp;&amp; !base.getPath().endsWith(""/"")) {     bParts = Arrays.copyOf(bParts, bParts.length - 1);   }    // Remove common prefix segments   int i = 0;   while (i &lt; bParts.length &amp;&amp; i &lt; cParts.length &amp;&amp; bParts[i].equals(cParts[i])) {     i++;   }    // Construct the relative path   StringBuilder sb = new StringBuilder();   for (int j = 0; j &lt; (bParts.length - i); j++) {     sb.append(""../"");   }   for (int j = i; j &lt; cParts.length; j++) {     if (j != i) {       sb.append(""/"");     }     sb.append(cParts[j]);   }    return URI.create(sb.toString()); }"
"If you need to get first letter of all words capital .. -----------------------------------------------------     public String toTheUpperCase(String givenString) {             String[] arr = givenString.split("" "");             StringBuffer sb = new StringBuffer();             for (int i = 0; i &lt; arr.length; i++) {                 sb.append(Character.toUpperCase(arr[i].charAt(0)))                         .append(arr[i].substring(1)).append("" "");             }             return sb.toString().trim();         }    When you need first letter of first word to be capitalized  -------------------------------------------------------------   public String toTheUpperCaseSingle(String givenString) {                 String example = givenString;                  example = example.substring(0, 1).toUpperCase()                         + example.substring(1, example.length());                  System.out.println(example);                 return example;             }"
"public static String[] Split(String splitStr, String delimiter) {      StringBuffer token = new StringBuffer();      Vector tokens = new Vector();      // split      char[] chars = splitStr.toCharArray();      for (int i=0; i &lt; chars.length; i++) {          if (delimiter.indexOf(chars[i]) != -1) {              // we bumbed into a delimiter              if (token.length() &gt; 0) {                  tokens.addElement(token.toString());                  token.setLength(0);              }          } else {              token.append(chars[i]);          }      }      // don't forget the ""tail""...      if (token.length() &gt; 0) {          tokens.addElement(token.toString());      }      // convert the vector into an array      String[] splitArray = new String[tokens.size()];      for (int i=0; i &lt; splitArray.length; i++) {          splitArray[i] = (String)tokens.elementAt(i);      }      return splitArray;  }"
"public void commitData(){      Bundle bundle = new Bundle();     bundle.putString(""key"", txtBuildingName.getText().toString()); //Gets the TEXT that the TEXTVIEW was holding converts it to a String and adds to the Extras bundle     bundle.putString(""key1"", txtDescription.getText().toString()); // Same again     bundle.putString(""key2"", type.getItemAtPosition(type.getSelectedItemPosition()).toString());     bundle.putString(""key3"", project.getItemAtPosition(project.getSelectedItemPosition()).toString());"
"recurrsiveFill(Pixel p, Color fill, Color bound) {     p.setColor(fill);     if(p.left.color  != bound &amp;&amp; p.left.color != fill)          recurrsiveFill(p.left , fill, bound);     if(p.right.color != bound &amp;&amp; p.right.color != fill)          recurrsiveFill(p.right, fill, bound);     if(p.up.color    != boun d&amp;&amp; p.up.color    != fill)          recurrsiveFill(p.up,    fill, bound);     if(p.down.color  != bound &amp;&amp; p.down.color  != fill)          recurrsiveFill(p.down,  fill, bound); }"
"layout.setHorizontalGroup(layout     .createParallelGroup(GroupLayout.Alignment.LEADING)     .addGroup(layout.createSequentialGroup()         .addComponent(one, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)         .addComponent(two, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)         .addComponent(three, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))     .addGroup(layout.createSequentialGroup()         .addComponent(four, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)         .addComponent(five, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))     .addComponent(six, 0, GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE));  layout.setVerticalGroup(layout.createSequentialGroup()     .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)         .addComponent(one).addComponent(two).addComponent(three))     .addGroup(layout.createParallelGroup(GroupLayout.Alignment.BASELINE)         .addComponent(four).addComponent(five))     .addComponent(six));"
