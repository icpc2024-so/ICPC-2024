code
"OpenVPN-AS REST API -------------------  The OpenVPN Access Server supports a Web Services API that can be used to fetch a client configuration file from the Access Server.  The curl command can be used to easily access this API as follows:    curl -u USERNAME:PASSWORD https://ACCESS_SERVER:CWS_PORT/rest/METHOD  Any generic HTTPS client tool (including even a web browser) can be used to access the API -- curl is just used here as an example.  Whatever method is used, the USERNAME:PASSWORD pair should be passed to the API using HTTP Basic Authentication.  Replace the above variables in the curl command as follows:  USERNAME -- the username of the Access Server user for whom a configuration             file is sought.  PASSWORD -- the password of the Access Server user for whom a configuration             file is sought.  ACCESS_SERVER -- the domain name or public IP address of the Access Server.  CWS_PORT -- the port that the client web server is listening on.  Usually             443 but may be different based on the specific Access Server             configuration.  This is normally the same port that you would             use to connect to the Client Web Server UI.  METHOD:    * GetUserlogin -- get an OpenVPN client configuration file     that will require a username and password to connect to the Access     Server.    * GetAutologin -- get an OpenVPN configuration file that will     authenticate with the Access Server using only a client     certificate, with no username and password required.  This is ideal     for unattended clients such as routers, servers, or appliances.     Note that for Autologin configurations, the user (specified by     USERNAME) must have the Autologin permission enabled in the User     Permissions page of the Access Server Admin UI.    * GetGeneric -- get a generic OpenVPN configuration file that is not     customized to a particular user.  This type of configuration is     used in External PKI mode, when client certificates/keys are     distributed out-of-band relative to the OpenVPN configuration     file.  Also note that when External PKI mode is enabled, both     GetUserlogin and GetAutologin methods return the generic     version configuration file.  On success, the web services API will return the OpenVPN client configuration file as content-type text/plain.  On error, an error message will be returned as content-type text/xml.  These are some of the common error returns:  Authentication failed (bad USERNAME or PASSWORD):  &lt;?xml version=""1.0"" encoding=""UTF-8""?&gt; &lt;Error&gt;   &lt;Type&gt;Authorization Required&lt;/Type&gt;   &lt;Synopsis&gt;REST method failed&lt;/Synopsis&gt;   &lt;Message&gt;AUTH_FAILED: Server Agent XML method requires authentication (9007)&lt;/Message&gt; &lt;/Error&gt;  User does not have permission to use an Autologin profile:  &lt;?xml version=""1.0"" encoding=""UTF-8""?&gt; &lt;Error&gt;   &lt;Type&gt;Internal Server Error&lt;/Type&gt;   &lt;Synopsis&gt;REST method failed&lt;/Synopsis&gt;   &lt;Message&gt;NEED_AUTOLOGIN: User 'USERNAME' lacks autologin privilege (9000)&lt;/Message&gt; &lt;/Error&gt;  Handling challenge/response authentication:  It is possible that the server may issue a challenge to the authentication request, for example suppose we have a user called 'test' and a password of 'mypass"".  Get the OpenVPN config file:    curl -u test:mypass https://ACCESS_SERVER/rest/GetUserlogin  But instead of immediately receiving the config file, we might get a challenge instead:  &lt;Error&gt;   &lt;Type&gt;Authorization Required&lt;/Type&gt;   &lt;Synopsis&gt;REST method failed&lt;/Synopsis&gt;   &lt;Message&gt;CRV1:R,E:miwN39AlF4k40Fd8X8r9j74FuOoaJKJM:dGVzdA==:Turing test: what is 1 x 3? (9007)&lt;/Message&gt; &lt;/Error&gt;  a challenge is indicated by the ""CRV1:"" prefix in the &lt;Message&gt; (meaning Challenge Response protocol Version 1).  The CRV1 message is formatted as follows:  CRV1:&lt;flags&gt;:&lt;state_id&gt;:&lt;username_base64&gt;:&lt;challenge_text&gt;  flags : a series of optional, comma-separated flags:   E : echo the response when the user types it   R : a response is required  state_id: an opaque string that should be returned to the server along with the response.  username_base64 : the username formatted as base64  challenge_text : the challenge text to be shown to the user  After showing the challenge_text and getting a response from the user (if R flag is specified), the client should resubmit the REST request with the USERNAME:PASSWORD field in the HTTP header set as follows:  &lt;username decoded from username_base64&gt;:CRV1::&lt;state_id&gt;::&lt;response_text&gt;  Where state_id is taken from the challenge request and response_text is what the user entered in response to the challenge_text. If the R flag is not present, response_text may be the empty string.  Using curl to respond to the turing test given in the example above:    curl -u ""test:CRV1::miwN39AlF4k40Fd8X8r9j74FuOoaJKJM::3"" https://ACCESS_SERVER/rest/GetUserlogin  If the challenge response (In this case '3' in response to the turing test) is verified by the server, it will then return the configuration file per the GetUserlogin method."
"Server server = ServerFactory.getServer();         Service[] services = server.findServices();         for (Service service : services) {             for (Connector connector : service.findConnectors()) {                 ProtocolHandler protocolHandler = connector.getProtocolHandler();                 if (protocolHandler instanceof Http11Protocol                     || protocolHandler instanceof Http11AprProtocol                     || protocolHandler instanceof Http11NioProtocol) {                     serverPort = connector.getPort();                     System.out.println(""HTTP Port: "" + connector.getPort());                 }             }           }"
"ByteBuffer reUsableBuffer = ByteBuffer.allocateDirect(5120); Selector selector = Selector.open(); ServerSocketChannel channel = .. // wherever you get it from  channel.register(selector, SelectionKey.OP_ACCEPT); Executor executor = Executors.newThreadPoolExecutor(); while(selector.isOpen()) {   int numKey = selector.select();  for (SelectionKey key: selector.selectedKeys()) {     if (key.isAcceptable()) {              /// Sort of included for completeness but you get the idea            ServerSocketChannel server = (ServerSocketChannel)key.channel();            SocketChannel channel = server.accept();            channel.register(selector, SelectionKey.OP_READ | Selection.OP_WRITE, new StringBuilder());     }    if (key.isReadable()) {           // READ the data           reUsableBuffer.clear();           // You have to keep track of previous state.           // NIO makes no guarantees of anything           StringBuilder builder = key.attachment();           SocketChannel socketChannel = (SocketChannel)key.channel();           int readCount = socketChannel.read(reUsableBuffer);           if (readCount &gt; 0) {              reUsableBuffer.flip();              byte[] subStringBytes = new byte[readCount];              reUsableBuffer.read(subStringBytes);              // Assuming ASCII (bad assumption but simplifies the example)              builder.append(new String(substringBytes));               Command[] commands = removeCommands(builder);              // Deal with your commands in some async manor defined by you              executor.execute(new Task(commands));           }         }         selector.selectedKeys().clear(); } ....      }     // // Parse out the commands and return them, also remove traces of them in the // the builder, such that for a string, ""COMMAND, COMMAND, COM"" // an array of 2 should be returned with a left over buffer of ""COM"" public Command[] parseCommands(StringBuilder s) { ... }"
"KeyManagerFactory kmf = //... Initialise a KMF with your server's keystore  TrustManagerFactory tmf = TrustManagerFactory     .getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init((KeyStore) null); // Use the default trust store TrustManager[] trustManagers = tmf.getTrustManagers(); final X509TrustManager origTrustManager = (X509TrustManager) trustManagers[0]; final X509Certificate caCert = // Load your test CA certificate here. X509TrustManager fakeTrustManager = new X509TrustManager() {     public void checkClientTrusted(X509Certificate[] chain,             String authType) throws CertificateException {         // Key the behaviour of the default trust manager.         origTrustManager.checkClientTrusted(chain, authType);     }      public void checkServerTrusted(X509Certificate[] chain,             String authType) throws CertificateException {         // Key the behaviour of the default trust manager.         origTrustManager.checkServerTrusted(chain, authType);     }      public X509Certificate[] getAcceptedIssuers() {         // This is only used for sending the list of acceptable CA DNs.         return new X509Certificate[] { caCert };     } }; trustManagers = new X509TrustManager[] { fakeTrustManager };  SSLContext sslContext = SSLContext.getInstance(""TLS""); sslContext.init(kmf.getKeyManagers(), trustManagers, null);"
"Connection con = connectToDB(USERNAME, PASSWORD); /* Note that con is a connection to database, and not the server. if You have a connection to the server, the first command in the dumpfile should be the USE db_name; */ String q = """"; File f = new File(sourcePath); // source path is the absolute path of dumpfile. try {     BufferedReader bf = new BufferedReader(new FileReader(f));         String line = null;         line = bf.readLine();         while (line != null) {             q = q + line + ""\n"";             line = bf.readLine();         }     } catch (Exception ex) {         ex.printStackTrace();     } // Now we have the content of the dumpfile in 'q'. // We must separate the queries, so they can be executed. And Java Simply does this: String[] commands = q.split("";"");  try {     Statement statement = con.createStatement();     for (String s : commands) {         statement.execute(s);     } } catch (Exception ex) { } closeConnection(con);"
"Selector selector = Selector.open();  int[] ports = {4000,4001,6000};  for (int port : ports) {    ServerSocketChannel server = ServerSocketChannel.open();    server.configureBlocking(false);     server.socket().bind(new InetSocketAddress(port)); // we are only interested when accept evens occur on this socket    server.register(selector, SelectionKey.OP_ACCEPT);  }  while (selector.isOpen()) {    selector.select();    Set readyKeys = selector.selectedKeys();    Iterator iterator = readyKeys.iterator();    while (iterator.hasNext()) {       SelectionKey key = (SelectionKey) iterator.next();       if (key.isAcceptable()) {          SocketChannel client = server.accept();          Socket socket = client.socket(); // create new thread to deal with connection (closing both socket and client when done)       }    } }  // tidy up selector and channels"
"KeyStore trustStore = KeyStore.getInstance(""JKS""); InputStream tsis = new FileInputStream(""trustedcerts.jks""); trustStore.load(tsis, ""clientpublicpw"".toCharArray()); tsis.close();  KeyStore serverKeyStore = KeyStore.getInstance(""JKS""); InputStream ksis = new FileInputStream(""server.jks""); clientKeyStore.load(ksis.close(), ""serverprivatepw"".toCharArray()); ksis.close();  TrustManagerFactory tmf =      TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); tmf.init(trustStore);  KeyManagerFactory kmf =      KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); kmf.init(serverKeyStore, ""serverprivatepw"".toCharArray());  SSLContext sslContext = SSLContext.getInstance(""TLS""); sslContext.init(kmf.getKeyManagers(), tmf.getTrustManagers(), null);  SSLServerSocketFactory sf = sslContext.getServerSocketFactory(); SSLServerSocket ss = (SSLServerSocket)sf.createServerSocket(SslServer.PORT); ss.setNeedClientAuth(true);"
"public static &lt;T&gt; T getApplicationService(Class&lt;T&gt; type) {     // applicationServices needs to be a ConcurrentHashMap otherwise      // the following containsKey can conflict with the subsequent put     if(!applicationServices.containsKey(type)) {         // need to synchronize before modifying the map         synchronized(applicationServices) {             // check if another thread created the same service while              // we were waiting for the lock             if(!applicationServices.containsKey(type)) {                 T newService = ServiceLoader.create(type);                 applicationServices.put(type, newService);             }         }     }     return (T) applicationServices.get(type); }"
".---- |     try  |     { |       FileConnection fc = (FileConnection)Connector.open(...); |      // If no exception is thrown, then the URI is valid |      if (!fc.exists()) |      { |          fc.create();  // create the file if it doesn't exist |      } |      OutputStream outStream = fc.openOutputStream();  | '--&gt;  for(int i=0;i&lt;v.size();i++){        outStream.write(((String) v.elementAt(i)).getBytes());        String br = ""\r\n"";       outStream.write (br.getBytes ()); .--&gt; } | |      outStream.close(); |      fc.close(); |     } |     catch (IOException ioe)  |     { |        System.out.println(ioe.getMessage() ); |     } |   } '--"
"import java.net.*; import java.util.concurrent.*;  public class CoordinateServer {   public static void main(String... argv) throws Exception {     // 'port' is known to the server and the client     int port = Integer.valueOf(argv[0]);     ServerSocket ss = new ServerSocket(port);      // You should decide what the best type of service is here     ExecutorService es = Executors.newCachedThreadPool ();      // How will you decide to shut the server down?     while (true) {       // Blocks until a client connects, returns the new socket        // to use to talk to the client       Socket s = ss.accept ();        // CoordinateOutputter is a class that implements Runnable        // and sends co-ordinates to a given socket; it's also       // responsible for cleaning up the socket and any other       // resources when the client leaves       es.submit(new CoordinateOutputter(s));     }   } }"
"public String intercept (ActionInvocation invocation) throws Exception {     // Get the action context from the invocation so we can access the     // HttpServletRequest and HttpSession objects.     final ActionContext context = invocation.getInvocationContext ();     HttpServletRequest request = (HttpServletRequest) context.get(HTTP_REQUEST);     HttpSession session =  request.getSession (true);      // Is there a ""user"" object stored in the user's HttpSession?     Object user = session.getAttribute (USER_HANDLE);     if (user == null) {         // The user has not logged in yet.          // Is the user attempting to log in right now?         String loginAttempt = request.getParameter (LOGIN_ATTEMPT);         if (! StringUtils.isBlank (loginAttempt) ) { // The user is attempting to log in.              // Process the user's login attempt.             if (processLoginAttempt (request, session) ) {                 // The login succeeded send them the login-success page.                 return ""login-success"";             } else {                 // The login failed. Set an error if we can on the action.                 Object action = invocation.getAction ();                 if (action instanceof ValidationAware) {                     ((ValidationAware) action).addActionError (""Username or password incorrect."");                 }             }         }          // Either the login attempt failed or the user hasn't tried to login yet,          // and we need to send the login form.         return ""login"";     } else {         return invocation.invoke ();     } }"
"public class DatabaseOperator {        private Configuration configuration = Configuration.DEFAULT;     private AuthDetails authDetails = AuthDetails.DEFAULT;      public DatabaseOperator withConfigurationsFrom(String fileName) {         //Get the configurations from the file, and initialize the 'Configuration' object         configuration = initializeFrom(fileName);         return this;     }      public DatabaseOperator withAuthenticationDetailsFrom(String fileName) {         // Get authentication details from the file, and initialize AuthenticationDetails         authDetails = initializeAuthDetailsFrom(fileName);         return this;     }      //.. and so on      public void initiateConnection() {         //Uses configuration and authDetails     }  }"
"import java.io.File;  import org.apache.commons.vfs2.FileObject; import org.apache.commons.vfs2.FileSystemException; import org.apache.commons.vfs2.FileSystemOptions; import org.apache.commons.vfs2.Selectors; import org.apache.commons.vfs2.impl.StandardFileSystemManager; import org.apache.commons.vfs2.provider.sftp.SftpFileSystemConfigBuilder;  /**  * The class SFTPUtil containing uploading, downloading, checking if file exists  * and deleting functionality using Apache Commons VFS (Virtual File System)  * Library  *   * @author Ashok  *   */ public class SFTPUtility {      public static void main(String[] args) {         String hostName = ""PutYourHostNameHere"";         String username = ""PutYourUserNameForHostHere"";         String password = ""PutYourPasswordForHostHere"";          String localFilePath = ""C:\\FakePath\\FakeFile.txt"";         String remoteFilePath = ""/FakeRemotePath/FakeRemoteFile.txt"";                String remoteTempFilePath = ""/FakeRemoteTempPath/FakeRemoteTempFile.txt"";          upload(hostName, username, password, localFilePath, remoteFilePath);         exist(hostName, username, password, remoteFilePath);         download(hostName, username, password, localFilePath,remoteFilePath);         move(hostName, username, password, remoteFilePath, remoteTempFilePath);         delete(hostName, username, password, remoteFilePath);     }      /**      * Method to upload a file in Remote server      *       * @param hostName      *            HostName of the server      * @param username      *            UserName to login      * @param password      *            Password to login      * @param localFilePath      *            LocalFilePath. Should contain the entire local file path -      *            Directory and Filename with \\ as separator      * @param remoteFilePath      *            remoteFilePath. Should contain the entire remote file path -      *            Directory and Filename with / as separator      */     public static void upload(String hostName, String username, String password, String localFilePath, String remoteFilePath) {          File file = new File(localFilePath);         if (!file.exists())             throw new RuntimeException(""Error. Local file not found"");          StandardFileSystemManager manager = new StandardFileSystemManager();          try {             manager.init();              // Create local file object             FileObject localFile = manager.resolveFile(file.getAbsolutePath());              // Create remote file object             FileObject remoteFile = manager.resolveFile(createConnectionString(hostName, username, password, remoteFilePath), createDefaultOptions());             /*              * use createDefaultOptions() in place of fsOptions for all default              * options - Ashok.              */              // Copy local file to sftp server             remoteFile.copyFrom(localFile, Selectors.SELECT_SELF);              System.out.println(""File upload success"");         } catch (Exception e) {             throw new RuntimeException(e);         } finally {             manager.close();         }     }      public static boolean move(String hostName, String username, String password, String remoteSrcFilePath, String remoteDestFilePath){         StandardFileSystemManager manager = new StandardFileSystemManager();          try {             manager.init();              // Create remote object             FileObject remoteFile = manager.resolveFile(createConnectionString(hostName, username, password, remoteSrcFilePath), createDefaultOptions());             FileObject remoteDestFile = manager.resolveFile(createConnectionString(hostName, username, password, remoteDestFilePath), createDefaultOptions());              if (remoteFile.exists()) {                 remoteFile.moveTo(remoteDestFile);;                 System.out.println(""Move remote file success"");                 return true;             }             else{                 System.out.println(""Source file doesn't exist"");                 return false;             }         } catch (Exception e) {             throw new RuntimeException(e);         } finally {             manager.close();         }     }      /**      * Method to download the file from remote server location      *       * @param hostName      *            HostName of the server      * @param username      *            UserName to login      * @param password      *            Password to login      * @param localFilePath      *            LocalFilePath. Should contain the entire local file path -      *            Directory and Filename with \\ as separator      * @param remoteFilePath      *            remoteFilePath. Should contain the entire remote file path -      *            Directory and Filename with / as separator      */     public static void download(String hostName, String username, String password, String localFilePath, String remoteFilePath) {          StandardFileSystemManager manager = new StandardFileSystemManager();          try {             manager.init();              // Append _downlaod_from_sftp to the given file name.             //String downloadFilePath = localFilePath.substring(0, localFilePath.lastIndexOf(""."")) + ""_downlaod_from_sftp"" + localFilePath.substring(localFilePath.lastIndexOf("".""), localFilePath.length());              // Create local file object. Change location if necessary for new downloadFilePath             FileObject localFile = manager.resolveFile(localFilePath);              // Create remote file object             FileObject remoteFile = manager.resolveFile(createConnectionString(hostName, username, password, remoteFilePath), createDefaultOptions());              // Copy local file to sftp server             localFile.copyFrom(remoteFile, Selectors.SELECT_SELF);              System.out.println(""File download success"");         } catch (Exception e) {             throw new RuntimeException(e);         } finally {             manager.close();         }     }      /**      * Method to delete the specified file from the remote system      *       * @param hostName      *            HostName of the server      * @param username      *            UserName to login      * @param password      *            Password to login      * @param localFilePath      *            LocalFilePath. Should contain the entire local file path -      *            Directory and Filename with \\ as separator      * @param remoteFilePath      *            remoteFilePath. Should contain the entire remote file path -      *            Directory and Filename with / as separator      */     public static void delete(String hostName, String username, String password, String remoteFilePath) {         StandardFileSystemManager manager = new StandardFileSystemManager();          try {             manager.init();              // Create remote object             FileObject remoteFile = manager.resolveFile(createConnectionString(hostName, username, password, remoteFilePath), createDefaultOptions());              if (remoteFile.exists()) {                 remoteFile.delete();                 System.out.println(""Delete remote file success"");             }         } catch (Exception e) {             throw new RuntimeException(e);         } finally {             manager.close();         }     }      // Check remote file is exist function:     /**      * Method to check if the remote file exists in the specified remote      * location      *       * @param hostName      *            HostName of the server      * @param username      *            UserName to login      * @param password      *            Password to login      * @param remoteFilePath      *            remoteFilePath. Should contain the entire remote file path -      *            Directory and Filename with / as separator      * @return Returns if the file exists in the specified remote location      */     public static boolean exist(String hostName, String username, String password, String remoteFilePath) {         StandardFileSystemManager manager = new StandardFileSystemManager();          try {             manager.init();              // Create remote object             FileObject remoteFile = manager.resolveFile(createConnectionString(hostName, username, password, remoteFilePath), createDefaultOptions());              System.out.println(""File exist: "" + remoteFile.exists());              return remoteFile.exists();         } catch (Exception e) {             throw new RuntimeException(e);         } finally {             manager.close();         }     }      /**      * Generates SFTP URL connection String      *       * @param hostName      *            HostName of the server      * @param username      *            UserName to login      * @param password      *            Password to login      * @param remoteFilePath      *            remoteFilePath. Should contain the entire remote file path -      *            Directory and Filename with / as separator      * @return concatenated SFTP URL string      */     public static String createConnectionString(String hostName, String username, String password, String remoteFilePath) {         return ""sftp://"" + username + "":"" + password + ""@"" + hostName + ""/"" + remoteFilePath;     }      /**      * Method to setup default SFTP config      *       * @return the FileSystemOptions object containing the specified      *         configuration options      * @throws FileSystemException      */     public static FileSystemOptions createDefaultOptions() throws FileSystemException {         // Create SFTP options         FileSystemOptions opts = new FileSystemOptions();          // SSH Key checking         SftpFileSystemConfigBuilder.getInstance().setStrictHostKeyChecking(opts, ""no"");          /*          * Using the following line will cause VFS to choose File System's Root          * as VFS's root. If I wanted to use User's home as VFS's root then set          * 2nd method parameter to ""true""          */         // Root directory set to user home         SftpFileSystemConfigBuilder.getInstance().setUserDirIsRoot(opts, false);          // Timeout is count by Milliseconds         SftpFileSystemConfigBuilder.getInstance().setTimeout(opts, 10000);          return opts;     } }"
"if(set.next()) {         userName = set.getString(&quot;FirstName&quot;);         Email = set.getString(&quot;Email&quot;);          // start the session and take to his homepage         HttpSession session = request.getSession();         session.setAttribute(&quot;UserName&quot;, userName);         session.setMaxInactiveInterval(900); // If the request doesn't come withing 900 seconds the server will invalidate the session         RequestDispatcher rd = request.getRequestDispatcher(&quot;portfolio_one.jsp&quot;);         rd.forward(request, response); // forward to the user home-page     } else {         // turn to the error page         response.sendRedirect(&quot;LoginFailure.jsp&quot;);     }"
"URLClassLoader application1Loader = new ClassLoader(/* URLs to common Jars and the config files for instance 1*/); URLClassLoader application2Loader = new ClassLoader(/* URLs to common Jars and the config files for instance 2*/);  // Assuming you have a wrapper for your application that you can run() to get it going // in its own thread via reflection.  Class&lt;? extends Runnable&gt; app1Class = application1Loader.loadClass(""my.pkg.MyApplicaion"")     .asSubclass(Runnable.class); // newInstance() is problematic but I want this code to be brief. app1Class.newInstance().run();  Class&lt;? extends Runnable&gt; app2Class = application2Loader.loadClass(""my.pkg.MyApplicaion"")     .asSubclass(Runnable.class); app2Class.newInstance().run();"
"The HEAD method is identical to GET except that the server MUST NOT return a message-body in the response. The metainformation contained in the HTTP headers in response to a HEAD request SHOULD be identical to the information sent in response to a GET request. This method can be used for obtaining metainformation about the entity implied by the request without transferring the entity-body itself. This method is often used for testing hypertext links for validity, accessibility, and recent modification."
"FTPClient client = new FTPClient(); FileInputStream fis = null;  try  {     client.connect(serverip);     client.login(""user, pass);     client.setFileType(FTPClient.BINARY_FILE_TYPE);      // change directory to serverip/file/     if (client.changeWorkingDirectory(""/file""))     {                // Create an InputStream of the file to be uploaded         String filename = Shared.saveLocation + Shared.saveAs;         fis = new FileInputStream(filename);          // Store file to server         client.storeFile(Shared.saveAs, fis);     }     client.logout(); }  catch (IOException e)  {     e.printStackTrace(); }  finally  {     try     {         if (fis != null)          {             fis.close();         }         client.disconnect();     }      catch (IOException e)      {         e.printStackTrace();     } }"
public class MyRestService {     private DataStoreService dataStoreService;      // constructor used on the server     public MyRestService() {         this.dataStoreService = DatastoreServiceFactory.getDatastoreService();     }      // constructor used by the unit tests     public MyRestService(DataStoreService dataStoreService) {         this.dataStoreService = dataStoreService;     }      public Response initialize(String DatabaseSchema) {          ...          // use this.dataStoreService instead of datastore     } }
"public enum MongoDBHelper { // the best way to implement singletons, due to the author of Effective Java   INSTANCE;  private DB db; private Datastore datastore;  private final String SERVER_URL = ""...""; private final int SERVER_PORT = ...; private final String USERNAME= ""...""; private final String PASSWORD = ""...""; private final String DATABASE_NAME = ""..."";  private MongoDBHelper() {      try {          MongoClient mongoClient = new MongoClient(SERVER_URL, SERVER_PORT);          this.db = mongoClient.getDB(DATABASE_NAME);         this.db.authenticate(USERNAME,PASSWORD.toCharArray());          Morphia morphia = new Morphia();          this.datastore = morphia.createDatastore(mongoClient, DATABASE_NAME);          morphia.mapPackage(""package"");     } catch (UnknownHostException e) {         e.printStackTrace();     }  }  public DB getDB() {     return this.db; }  public Datastore getDatastore() {     return this.datastore; } }"
"{     ""entry"": ""132456"",     ""product"":      {         ""item"": ""123456"",         ""prompts"":          [             {                 ""promptId"": ""1"",                 ""promptNumber"": ""109"",                 ""promptType"": 4,                 ""promptTypeDesc"": ""desc1"",                 ""validations"":                 [                     {                         ""minLen"": 10,                         ""maxLen"": 10,                         ""required"": true                      }                  ]              }          ]      } }"
"public class FetchProfileInterceptor implements MethodInterceptor {      private SessionFactory sessionFactory;     private String fetchProfile;      ... setters ...          public Object invoke(MethodInvocation invocation) throws Throwable {         Session s = sessionFactory.openSession(); // The transaction interceptor has already opened the session, so this returns it.         s.enableFetchProfile(fetchProfile);         try {             return invocation.proceed();         } finally {             s.disableFetchProfile(fetchProfile);         }     } }"
"ServerSocketFactory ssf = ServerSocketFactory.getDefault(); ServerSocket serverSocket = ssf.createServerSocket(12345);  // I've initialised an sslContext with a keystore, as you normally would. Socket socket = serverSocket.accept(); SSLSocketFactory sslSf = sslContext.getSocketFactory(); // The host name doesn't really matter, since we're turning it into a server socket // (No need to match the host name to the certificate on this side). SSLSocket sslSocket = (SSLSocket) sslSf.createSocket(socket, null,     socket.getPort(), false); sslSocket.setUseClientMode(false);  // Use the sslSocket InputStream/OutputStream as usual."
"class ReportDirectory{     static final String path = ""./path/to/reports/""; //&lt;-- generic path on your SERVER!     static{        //static initializer to make sure directory gets created.  Better ways to do this but this will work!         File pathAsFile = new File(path).mkdirs()         if (pathAsFile.exists()){           println(""CREATED REPORT DIRECTORY @ ${pathAsFile.absolutePath}"");        }else{           println(""FAILED TO CREATE REPORT DIRECTORY @ ${pathAsFile.absolutePath}"");        }     }     public static File[] listFiles(){        return new File(path).listFiles(); //&lt;-- maybe use filters to just pull pdfs?    }     public static void addFile(File file){        FilesUtil.copyFileToDirectory(file, new File(path)); //&lt;-- using apache-commons-io    }     public static void deleteAll(){        listFiles().each(){ fileToDelete -&gt;            fileToDelete.delete();        }    }     public static File findFile(String name){        listFiles().each(){ fileToCheck -&gt;             if (fileToCheck.name.equals(name)){                return fileToCheck            }        }        return null    }  }"
"[…] ServerName apache.mydom.com:80 […] LoadModule auth_kerb_module modules/mod_auth_kerb.so […] &lt;LocationMatch /secure)&gt;     [… some other stuff …]     Order allow,deny     Allow from all     AuthType Kerberos         AuthName ""Authentification requise""         KrbAuthRealms MYDOM.COM         #this allows user to be saved in the request         KrbSaveCredentials on         #this one force Negotiate AuthType instead of basic fallback         KrbMethodNegotiate on         #this trim the realm from username saved in the request (request.getRemoteUser() will give you ""user"" instead of ""user@MYDOM.COM""         KrbLocalUserMapping on         KrbAuthoritative on         KrbVerifyKDC on         Krb5Keytab /install/binaries/httpd/apache.keytab         KrbServiceName HTTP     require valid-user &lt;/LocationMatch&gt;"
"TrustManagerFactory tmf = TrustManagerFactory.getInstance(     TrustManagerFactory.getDefaultAlgorithm()); // Initialise the TMF as you normally would, for example: tmf.init((KeyStore)null);   TrustManager[] trustManagers = tmf.getTrustManagers(); final X509TrustManager origTrustmanager = (X509TrustManager)trustManagers[0];  TrustManager[] wrappedTrustManagers = new TrustManager[]{    new X509TrustManager() {        public java.security.cert.X509Certificate[] getAcceptedIssuers() {           return origTrustmanager.getAcceptedIssuers();        }         public void checkClientTrusted(X509Certificate[] certs, String authType) {            origTrustmanager.checkClientTrusted(certs, authType);        }         public void checkServerTrusted(X509Certificate[] certs, String authType) {            try {                origTrustmanager.checkServerTrusted(certs, authType);            } catch (CertificateExpiredException e) {}        }    } };  SSLContext sc = SSLContext.getInstance(""TLS""); sc.init(null, wrappedTrustManagers, null); HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());"
"String filename = System.getProperty(""java.home"") + ""/lib/security/cacerts"".replace('/', File.separatorChar);         Set&lt;X509Certificate&gt; additionalCerts = new HashSet&lt;X509Certificate&gt;();         FileInputStream is = new FileInputStream(filename);         KeyStore keystore = KeyStore.getInstance(KeyStore.getDefaultType());         String password = ""changeit"";         keystore.load(is, password.toCharArray());          // This class retrieves the most-trusted CAs from the keystore         PKIXParameters params = new PKIXParameters(keystore);          // Get the set of trust anchors, which contain the most-trusted CA certificates         Iterator it = params.getTrustAnchors().iterator();         while( it.hasNext() ) {             TrustAnchor ta = (TrustAnchor)it.next();             // Get certificate             X509Certificate cert = ta.getTrustedCert();             additionalCerts.add(cert);         }"
"Part 1:  Explores attributes of application performance management (APM) systems Describes common antipatterns for system monitoring Presents methods for monitoring the performance of JVMs Offers techniques for efficiently instrumenting application source code  Part 2 will focus on methods of instrumenting Java classes and resources without modification of the originating source code.  Part 3 will address methods for monitoring resources outside the JVM, including hosts and their operating systems and remote services such as databases and messaging systems. It will conclude with a discussion of additional APM issues such as data management, data visualization, reporting, and alerting."
"public static String getUrl(HttpServletRequest req) {     String scheme = req.getScheme();             // http     String serverName = req.getServerName();     // hostname.com     int serverPort = req.getServerPort();        // 80     String contextPath = req.getContextPath();   // /mywebapp     String servletPath = req.getServletPath();   // /servlet/MyServlet     String pathInfo = req.getPathInfo();         // /a/b;c=123     String queryString = req.getQueryString();          // d=789      // Reconstruct original requesting URL     String url = scheme+""://""+serverName+"":""+serverPort+contextPath+servletPath;     if (pathInfo != null) {         url += pathInfo;     }     if (queryString != null) {         url += ""?""+queryString;     }     return url; }"
"import org.jboss.system.ServiceControllerMBean; import org.jboss.system.ServiceMBeanSupport;  public class MyService extends ServiceMBeanSupport {      public void workWithEar()      {         ServiceControllerMBean serviceController = (ServiceControllerMBean) MBeanProxy.get(                     ServiceControllerMBean.class,                     ServiceControllerMBean.OBJECT_NAME, server);         // server is ServiceMBeanSupport member          ClassLoader cl = serviceController.getClass().getClassLoader();          String path = cl.getResource(""META-INF/jboss-service.xml"").getPath()         InputStream file = cl.getResourceAsStream(""META-INF/jboss-service.xml"");     } }"
"TServerSocket serverTransport = new TServerSocket(7911);  // new server on port 7911 HelloWorldService.Processor&lt;Iface&gt; processor = new HelloWorldService.Processer&lt;Iface&gt;(new ThriftServerImpl());  // This is my thrift implementation for my server Map&lt;String, String&gt; saslProperties = new HashMap&lt;String, String&gt;();  // need a map for properties saslProperties.put(Sasl.QOP, ""true""); saslProperties.put(Sasl.QOP, ""auth-conf"");  // authorization and confidentiality  TSaslServerTransport.Factory saslTransportFactory = new TSaslServerTransport.Factory();     // Creating the server definition saslTransportFactory.addServerDefinition(             ""GSSAPI"",       //  tell SASL to use GSSAPI, which supports Kerberos             ""myserviceprincipal"",   //  base kerberos principal name - myprincipal/my.server.com@MY.REALM              ""my.server.com"",    //  kerberos principal server - myprincipal/my.server.com@MY.REALM             saslProps,      //  Properties set, above             new SaslRpcServer.SaslGssCallbackHandler()));  //  I don't know what this really does... but I stole it from Hadoop and it works.. so there.  Tserver server = new TThreadPoolServer(newTThreadPoolSErver.Args(serverTransport).transportFactory(saslTrasnportFactory).processor(processor));  server.serve();   // Thrift server start"
