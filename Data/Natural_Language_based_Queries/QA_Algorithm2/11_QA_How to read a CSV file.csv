code
"Path p = Paths.get(""/your/file""); // where you want to write FileSystem fileSystem = FileSystems.getDefault(); Iterable&lt;FileStore&gt; iterable = fileSystem.getFileStores();  Iterator&lt;FileStore&gt; it = iterable.iterator(); // iterate the FileStore instances while(it.hasNext()) {     FileStore fileStore = it.next();     long sizeAvail = fileStore.getUsableSpace(); // or maybe getUnallocatedSpace()     if (Files.getFileStore(p).equals(fileStore) { // your Path belongs to this FileStore         if (sizeAvail &gt; theSizeOfBytesYouWantToWrite) {             // do your thing         }     } }"
"public void readFromFile(String fileName, ListInterface&lt;User&gt; userList) {         String oneLine, oneLine2;         User user;         try {             /*              * Create a FileWriter object that handles the low-level details of              * reading              */             FileReader theFile = new FileReader(fileName);              /*              * Create a BufferedReader object to wrap around the FileWriter              * object              */             /* This allows the use of high-level methods like readline */             BufferedReader fileIn = new BufferedReader(theFile);              /* Read the first line of the file */             oneLine = fileIn.readLine();             /*              * Read the rest of the lines of the file and output them on the              * screen              */             while (oneLine != null) /* A null string indicates the end of file */             {                 oneLine2 = fileIn.readLine();                 user = new User(oneLine, oneLine2);                 oneLine = fileIn.readLine();                 userList.append(user);             }              /* Close the file so that it is no longer accessible to the program */             fileIn.close();         }          /*          * Handle the exception thrown by the FileReader constructor if file is          * not found          */         catch (FileNotFoundException e) {             System.out.println(""Unable to locate the file: "" + fileName);         }          /* Handle the exception thrown by the FileReader methods */         catch (IOException e) {             System.out.println(""There was a problem reading the file: ""                     + fileName);         }     } /* End of method readFromFile */       public void writeToFile(String fileName, ListInterface&lt;User&gt; userList) {         try {             /*              * Create a FileWriter object that handles the low-level details of              * writing              */             FileWriter theFile = new FileWriter(fileName);              /* Create a PrintWriter object to wrap around the FileWriter object */             /* This allows the use of high-level methods like println */             PrintWriter fileOut = new PrintWriter(theFile);              /* Print some lines to the file using the println method */             for (int i = 1; i &lt;= userList.size(); i++) {                 fileOut.println(userList.get(i).getUsername());                 fileOut.println(userList.get(i).getPassword());             }             /* Close the file so that it is no longer accessible to the program */             fileOut.close();         }          /* Handle the exception thrown by the FileWriter methods */         catch (IOException e) {             System.out.println(""Problem writing to the file"");         }     } /* End of method writeToFile */"
"InputFormat             | Description                                      | Key                                      | Value -------------------------------------------------------------------------------------------------------------------------------------------------------- TextInputFormat         | Default format; reads lines of text files        | The byte offset of the line              | The line contents KeyValueInputFormat     | Parses lines into key, val pairs                 | Everything up to the first tab character | The remainder of the line SequenceFileInputFormat | A Hadoop-specific high-performance binary format | user-defined                             | user-defined"
"public void readFile(String absoluteFilePath){     ByteBuffer buf = ByteBuffer.allocate(2+4+8) // creating a buffer that is suited for data you are reading     Path path = Paths.get(absoluteFilePath);      try(FileChannel fileChannel = (FileChannel)Files.newByteChannel(path,Enum.setOf(READ))){         while(true){             int bytesRead = fileChannel.read(buf);             if(bytesRead==-1){                 break;             }             buf.flip(); //get the buffer ready for reading.             char c = buf.asCharBuffer().readChar(); // create a view buffer and read char             buf.position(buf.position() + 2); //now, lets go to the int             int i = buf.asIntBuffer().readInt(); //read the int             buf.position(buf.position()+ 4); //now, lets go for the double.             double d = buf.asDoubleBuffer().readDouble();             System.out.println(""Character: "" + c + "" Integer: "" + i + "" Double: "" + d);             buf.clear();         }     }catch(IOException e){         e.printStackTrace();     }// AutoClosable so no need to explicitly close }"
"String data = ""temp/*.jpg, usr/*.pdf, var/lib/*.so, tmp/*, usr/*, usr/*.*"";  Pattern p = Pattern         .compile(""(?&lt;path&gt;(\\w+/)+)((?&lt;name&gt;\\w+|[*]))?([.](?&lt;extension&gt;\\w+|[*]))?"");  Matcher m = p.matcher(data); while (m.find()) {     System.out.println(""data="" + m.group());     System.out.println(""path="" + m.group(""path""));     System.out.println(""name="" + m.group(""name""));     System.out.println(""extension="" + m.group(""extension""));     System.out.println(""------------""); }"
"public int searchPageNumber() {     XController xController = OODocument.getCurrentDocument().getXFrame().getController();      XTextViewCursorSupplier supTextViewCursor =                 (XTextViewCursorSupplier) UnoRuntime.queryInterface(                     XTextViewCursorSupplier.class, xController);      XTextViewCursor curTextView = supTextViewCursor.getViewCursor();      // gets the page cursor and assigns the text view cursor to the page     XPageCursor curPage =                 (XPageCursor) UnoRuntime.queryInterface(                     XPageCursor.class, curTextView);     System.out.println(""The current page number is "" + curPage.getPage());      // gets the model     XModel model = xController.getModel();     // assigns model to the document     XTextDocument xTextDocument = (XTextDocument) UnoRuntime.queryInterface(XTextDocument.class, model);     // Xsearchable so we can search the text     XSearchable xSearchable = (XSearchable) UnoRuntime.queryInterface(XSearchable.class, xTextDocument);      XSearchDescriptor xsd = (XSearchDescriptor) xSearchable.createSearchDescriptor();       xsd.setSearchString(""zzzzz"");      XInterface xfi = (XInterface) xSearchable.findFirst(xsd);      if (xfi != null) {          XTextRange xStart = (com.sun.star.text.XTextRange) UnoRuntime.queryInterface(                  com.sun.star.text.XTextRange.class, xfi);           curTextView.gotoRange(xStart, false);      }       System.out.println(""current page = "" + curPage.getPage());     return curPage.getPage(); }"
"InputStream stream = new FileInputStream(""C:\\Thumbs.db""); POIFSFileSystem fs = new POIFSFileSystem(stream); DirectoryEntry root = fs.getRoot(); Entry entry = root.getEntry(""2""); DocumentInputStream is = fs.createDocumentInputStream(entry.getName());  //Added to read the header lines and fix the ImageFormatException int header_len = is.read(); for (int i = 1; i &lt; header_len; i++) {         is.read(); }  JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(is); JPEGDecodeParam param = JPEGCodec.getDefaultJPEGEncodeParam(4,JPEGDecodeParam.COLOR_ID_RGBA); decoder.setJPEGDecodeParam(param); BufferedImage originalBufferedImage = decoder.decodeAsBufferedImage();"
"public Stack&lt;File&gt; getFilesInFolder(String startPath) {     File startFolder = new File(startPath);     Stack&lt;File&gt; picturestack = new Stack&lt;File&gt;();      String extension;     int dotindex;      // Go through the folder     for (File file : startFolder.listFiles()) {         extension = """";         dotindex = file.getName().lastIndexOf('.'); // Get the index of the dot in the filename          if (dotindex &gt; 0) {             extension = file.getName().substring(dotindex + 1);              // Iterate all valid file types and check it             for (String filetype : validpicturetypes) {                 if (extension.equals(filetype)) {                     picturestack.add(file);                 }             }         }     }     return picturestack; }"
"import static java.nio.file.FileVisitResult.*;  public static class PrintFiles     extends SimpleFileVisitor&lt;Path&gt; {      // Print information about     // each type of file.     @Override     public FileVisitResult visitFile(Path file,                                    BasicFileAttributes attr) {         if (attr.isSymbolicLink()) {             System.out.format(""Symbolic link: %s "", file);         } else if (attr.isRegularFile()) {             System.out.format(""Regular file: %s "", file);         } else {             System.out.format(""Other: %s "", file);         }         System.out.println(""("" + attr.size() + ""bytes)"");         return CONTINUE;     }      // Print each directory visited.     @Override     public FileVisitResult postVisitDirectory(Path dir,                                           IOException exc) {         System.out.format(""Directory: %s%n"", dir);         return CONTINUE;     }      // If there is some error accessing     // the file, let the user know.     // If you don't override this method     // and an error occurs, an IOException      // is thrown.     @Override     public FileVisitResult visitFileFailed(Path file,                                        IOException exc) {         System.err.println(exc);         return CONTINUE;     } }"
"Path file = Paths.get(""C:\\Users\\Ali Y. Akgul\\Desktop\\150004_15122012_G.txt"");  ArrayList&lt;String&gt; lines = Files.readAllLines(file, Charset.defaultCharset()); ArrayList&lt;String []&gt; columns = new ArrayList&lt;&gt;(); for(String line : lines){     columns.add(line.split('\|')); }  // Now for each line you have columns. for(String [] s : columns){      System.out.println(Arrays.toString(s)); }  // To get only the values for column 8 onwards (in response to your comment) for(String [] s : columns){      String [] sublist = Arrays.copyOfRange(s, 8, s.length);     System.out.println(Arrays.toString(sublist)); }  // To get only the columns from line 8 onwards for(int i = 0; i &lt; columns.size(); i++){     System.out.println(Arrays.toString(columns.get(i))); }"
"public String convertFile(HttpServletRequest request, HttpSession session) {     // cast request     MultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;     // You can get your file from request     CommonsMultipartFile multipartFile =  null; // multipart file class depends on which class you use assuming you are using org.springframework.web.multipart.commons.CommonsMultipartFile      Iterator&lt;String&gt; iterator = multipartRequest.getFileNames();      while (iterator.hasNext()) {         String key = (String) iterator.next();         // create multipartFile array if you upload multiple files         multipartFile = (CommonsMultipartFile) multipartRequest.getFile(key);     }      // logic for conversion }"
"public class PdfMergeHelper {      /**      * Merges the passed in PDFs, in the order that they are listed in the java.util.List.      * Writes the resulting PDF out to the OutputStream provided.      *       * Sample Usage:      * List&lt;InputStream&gt; pdfs = new ArrayList&lt;InputStream&gt;();      * pdfs.add(new FileInputStream(""/location/of/pdf/OQS_FRSv1.5.pdf""));      * pdfs.add(new FileInputStream(""/location/of/pdf/PPFP-Contract_Genericv0.5.pdf""));      * pdfs.add(new FileInputStream(""/location/of/pdf/PPFP-Quotev0.6.pdf""));      * FileOutputStream output = new FileOutputStream(""/location/to/write/to/merge.pdf"");      * PdfMergeHelper.concatPDFs(pdfs, output, true);      *       * @param streamOfPDFFiles the list of files to merge, in the order that they should be merged      * @param outputStream the output stream to write the merged PDF to      * @param paginate true if you want page numbers to appear at the bottom of each page, false otherwise      */     public static void concatPDFs(List&lt;InputStream&gt; streamOfPDFFiles, OutputStream outputStream, boolean paginate) {         Document document = new Document();         try {             List&lt;InputStream&gt; pdfs = streamOfPDFFiles;             List&lt;PdfReader&gt; readers = new ArrayList&lt;PdfReader&gt;();             int totalPages = 0;             Iterator&lt;InputStream&gt; iteratorPDFs = pdfs.iterator();              // Create Readers for the pdfs.             while (iteratorPDFs.hasNext()) {                 InputStream pdf = iteratorPDFs.next();                 PdfReader pdfReader = new PdfReader(pdf);                 readers.add(pdfReader);                 totalPages += pdfReader.getNumberOfPages();             }             // Create a writer for the outputstream             PdfWriter writer = PdfWriter.getInstance(document, outputStream);              document.open();             BaseFont bf = BaseFont.createFont(BaseFont.HELVETICA, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);             PdfContentByte cb = writer.getDirectContent(); // Holds the PDF             // data              PdfImportedPage page;             int currentPageNumber = 0;             int pageOfCurrentReaderPDF = 0;             Iterator&lt;PdfReader&gt; iteratorPDFReader = readers.iterator();              // Loop through the PDF files and add to the output.             while (iteratorPDFReader.hasNext()) {                 PdfReader pdfReader = iteratorPDFReader.next();                  // Create a new page in the target for each source page.                 while (pageOfCurrentReaderPDF &lt; pdfReader.getNumberOfPages()) {                     document.newPage();                     pageOfCurrentReaderPDF++;                     currentPageNumber++;                     page = writer.getImportedPage(pdfReader, pageOfCurrentReaderPDF);                     cb.addTemplate(page, 0, 0);                      // Code for pagination.                     if (paginate) {                         cb.beginText();                         cb.setFontAndSize(bf, 9);                         cb.showTextAligned(PdfContentByte.ALIGN_CENTER, """" + currentPageNumber + "" of "" + totalPages,                                 520, 5, 0);                         cb.endText();                     }                 }                 pageOfCurrentReaderPDF = 0;             }             outputStream.flush();             document.close();             outputStream.close();         } catch (Exception e) {             e.printStackTrace();         } finally {             if (document.isOpen()) {                 document.close();             }             try {                 if (outputStream != null) {                     outputStream.close();                 }             } catch (IOException ioe) {                 ioe.printStackTrace();             }         }     } }"
"public DDHLogger(String filePath, String yourfilename)  {     System.out.println(""filePath: "" + filePath);     System.out.println(""yourfilename: "" + yourfilename);      //String fileName = ""C:\\Users\\home-1\\Desktop\\"" + yourfilename;      String fileName = filePath + yourfilename;      System.out.println(""fileName::--&gt; "" + fileName);     // file = new File(fileName);//Creates the file      file = new File(fileName);//Creates the file      System.out.println(""file: "" + file);      try {         fw = new FileWriter(file, true);         //INSTANTIATE PRINTWRITER HERE         pw = new PrintWriter(fw);     } catch (IOException e) {         e.printStackTrace();     }//allows append to the file without over writing. The TRUE keyword is used for append  }"
"try {         BufferedReader in = new BufferedReader(new FileReader(""plaintext.txt""));         String inputDataLine;         while ((inputDataLine = in.readLine()) != null) {             if (!(inputDataLine.contentEquals("" ""))) {                 System.out.println(""What you want to do with a paragraph line"");             } else {                 System.out.println(""What you want to do with a paragraph seperator"");             }         }         in.close();     } catch (IOException e) {     }"
"CSVReader reader = ...; CSVWriter writer = ...;  Multimap&lt;String, String&gt; results = TreeMultimap.create();  // read the file String[] line; for ((line = reader.readNext()) != null) {     results.put(line[0], line[1]); }  // output the file Map&lt;String, Collection&lt;String&gt;&gt; mapView = results.asMap(); for (Map.Entry&lt;String, Collection&lt;String&gt; entry : mapView.entries()) {     String[] nextLine = new String[2];     nextLine[0] = entry.getKey();     nextLine[1] = formatCollection(entry.getValue());     writer.writeNext(nextLine); }"
"Path folder = Paths.get(System.getProperty(&quot;upload.location&quot;)); String filename = FilenameUtils.getBaseName(uploadedFile.getName());  String extension = FilenameUtils.getExtension(uploadedFile.getName()); Path file = Files.createTempFile(folder, filename + &quot;-&quot;, &quot;.&quot; + extension);  try (InputStream input = uploadedFile.getInputStream()) {     Files.copy(input, file, StandardCopyOption.REPLACE_EXISTING); }  String uploadedFileName = file.getFileName().toString(); // Now store it in DB."
package namepackage;  import com.panayotis.gnuplot.JavaPlot; import com.panayotis.gnuplot.plot.DataSetPlot; import com.panayotis.gnuplot.style.PlotStyle; import com.panayotis.gnuplot.style.Style;  /**  * on NetBeans add library -&gt; jar -&gt;   * package namepackage;  *  * import com.panayotis.gnuplot.JavaPlot;  * import com.panayotis.gnuplot.plot.DataSetPlot;  * import com.panayotis.gnuplot.style.PlotStyle;  * import com.panayotis.gnuplot.style.Style;  * @author mkwest  *  */ public class Main {      /**      * @param args the command line arguments      */     public static void main(String[] args) {         // TODO code application logic here         JavaPlot p = new JavaPlot();         double tab[][];          tab = new double[2][2];         tab[0][0] = 0.0000;         tab[0][1] = 2.0000;         tab[1][0] = 1.0000;         tab[1][1] = 6.0000;         PlotStyle myPlotStyle = new PlotStyle();         myPlotStyle.setStyle(Style.LINES);         DataSetPlot s = new DataSetPlot(tab);         myPlotStyle.setLineWidth(1);         DataSetPlot testDataSetPlot = new DataSetPlot(tab);         //DataSetPlot.setPlotStyle(myPlotStyle);         s.setPlotStyle(myPlotStyle);         //p.newGraph();         p.addPlot(s);         p.newGraph();         p.plot();     } }
"Intent intent = new Intent(); intent.setAction(Intent.ACTION_SEND_MULTIPLE); intent.putExtra(Intent.EXTRA_SUBJECT, ""Here are some files.""); intent.setType(""image/jpeg""); /* This example is sharing jpeg images. */  ArrayList&lt;Uri&gt; files = new ArrayList&lt;Uri&gt;();  for(String path : filesToSend /* List of the files you want to send */) {     File file = new File(path);     Uri uri = Uri.fromFile(file);     files.add(uri); }  intent.putParcelableArrayListExtra(Intent.EXTRA_STREAM, files); startActivity(intent);"
"[alqualos@brededor tmp]$ mkdir -p 'String s1 = ""something something ./files/icon.gif"";' [alqualos@brededor tmp]$ ll -d String* drwxr-xr-x 3 alqualos alqualos   4096 2011-02-26 16:31 String s1 = ""something something . [alqualos@brededor tmp]$ ll String\ s1\ \=\ \""something\ something\ ./ total 4K drwxr-xr-x 3 alqualos alqualos 4096 2011-02-26 16:31 files [alqualos@brededor tmp]$ ll String\ s1\ \=\ \""something\ something\ ./files/ total 4K drwxr-xr-x 2 alqualos alqualos 4096 2011-02-26 16:31 icon.gif"";"
"import com.xuggle.mediatool.IMediaWriter; import com.xuggle.mediatool.ToolFactory; import com.xuggle.xuggler.IAudioSamples; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture;    /**  * This class is used to merge audio and video file.  *  * @author Arslaan Ejaz  */ public class DecodeAndSaveAudioVideo {   public static void main(String[] args)   {      String filenamevideo = ""f:/testvidfol/video.mp4""; //this is the input file for video. you can change extension     String filenameaudio = ""f:/testvidfol/audio.wav""; //this is the input file for audio. you can change extension       IMediaWriter mWriter = ToolFactory.makeWriter(""f:/testvidfol/audiovideooutput.flv""); //output file      IContainer containerVideo = IContainer.make();     IContainer containerAudio = IContainer.make();      if (containerVideo.open(filenamevideo, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenamevideo);      if (containerAudio.open(filenameaudio, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenameaudio);      int numStreamVideo = containerVideo.getNumStreams();     int numStreamAudio = containerAudio.getNumStreams();      System.out.println(""Number of video streams: ""+numStreamVideo + ""\n"" + ""Number of audio streams: ""+numStreamAudio );  int videostreamt = -1; //this is the video stream id int audiostreamt = -1;  IStreamCoder  videocoder = null;      for(int i=0; i&lt;numStreamVideo; i++){         IStream stream = containerVideo.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO)         {             videostreamt = i;             videocoder = code;             break;         }      }      for(int i=0; i&lt;numStreamAudio; i++){         IStream stream = containerAudio.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO)         {             audiostreamt = i;             break;         }      }      if (videostreamt == -1) throw new RuntimeException(""No video steam found"");     if (audiostreamt == -1) throw new RuntimeException(""No audio steam found"");      if(videocoder.open()&lt;0 ) throw new RuntimeException(""Cant open video coder"");     IPacket packetvideo = IPacket.make();      IStreamCoder audioCoder = containerAudio.getStream(audiostreamt).getStreamCoder();      if(audioCoder.open()&lt;0 ) throw new RuntimeException(""Cant open audio coder"");     mWriter.addAudioStream(1, 1, audioCoder.getChannels(), audioCoder.getSampleRate());      mWriter.addVideoStream(0, 0, videocoder.getWidth(), videocoder.getHeight());      IPacket packetaudio = IPacket.make();      while(containerVideo.readNextPacket(packetvideo) &gt;= 0 ||             containerAudio.readNextPacket(packetaudio) &gt;= 0){          if(packetvideo.getStreamIndex() == videostreamt){              //video packet             IVideoPicture picture = IVideoPicture.make(videocoder.getPixelType(),                     videocoder.getWidth(),                     videocoder.getHeight());             int offset = 0;             while (offset &lt; packetvideo.getSize()){                 int bytesDecoded = videocoder.decodeVideo(picture,                          packetvideo,                          offset);                 if(bytesDecoded &lt; 0) throw new RuntimeException(""bytesDecoded not working"");                 offset += bytesDecoded;                  if(picture.isComplete()){                     System.out.println(picture.getPixelType());                     mWriter.encodeVideo(0, picture);                  }             }         }           if(packetaudio.getStreamIndex() == audiostreamt){            //audio packet              IAudioSamples samples = IAudioSamples.make(512,                      audioCoder.getChannels(),                     IAudioSamples.Format.FMT_S32);               int offset = 0;             while(offset&lt;packetaudio.getSize())             {                 int bytesDecodedaudio = audioCoder.decodeAudio(samples,                          packetaudio,                         offset);                 if (bytesDecodedaudio &lt; 0)                     throw new RuntimeException(""could not detect audio"");                 offset += bytesDecodedaudio;                  if (samples.isComplete()){                      mWriter.encodeAudio(1, samples);          }             }      }    } } }"
"import liquibase.database.Database; import liquibase.exception.CustomPreconditionErrorException; import liquibase.exception.CustomPreconditionFailedException; import liquibase.precondition.CustomPrecondition; import liquibase.snapshot.SnapshotGeneratorFactory; import liquibase.structure.core.ForeignKey; import liquibase.structure.core.Schema; import liquibase.structure.core.Table; import liquibase.util.StringUtils;  /**  * {@link CustomPrecondition} implementation that checks if a column on a table  * has a foreign key constraint for some other table.  */ public final class CheckForeignKey implements CustomPrecondition {      /**      * Schema.      */     private String schemaName;      /**      * Table name (that has the column).      */     private String tableName;      /**      * Column (that might have the foreign key).      */     private String columnName;      /**      * Referenced table of the foreign key.      */     private String foreignTableName;      @Override     public void check(final Database db)             throws CustomPreconditionFailedException,             CustomPreconditionErrorException {          try {             // The fkey we are looking for             final ForeignKey fKey = new ForeignKey();              // Schema, base table             fKey.setForeignKeyTable(new Table());             if (StringUtils.trimToNull(getTableName()) != null) {                 fKey.getForeignKeyTable().setName(getTableName());             }              final Schema schema = new Schema();             schema.setName(getSchemaName());             fKey.getForeignKeyTable().setSchema(schema);              // Base column             fKey.addForeignKeyColumn(getColumnName());              // Referenced table             fKey.setPrimaryKeyTable(new Table());             if (StringUtils.trimToNull(getForeignTableName()) != null) {                 fKey.getPrimaryKeyTable().setName(getForeignTableName());             }              if (!SnapshotGeneratorFactory.getInstance().has(fKey, db)) {                 throw new CustomPreconditionFailedException(                         String.format(                                 ""Error fkey not found schema %s table %s column %s ftable %s"",                                 getSchemaName(), getTableName(),                                 getColumnName(), getForeignTableName()));             }         } catch (final CustomPreconditionFailedException e) {             throw e;         } catch (final Exception e) {             throw new CustomPreconditionErrorException(""Error"", e);         }     }      public String getSchemaName() {         return schemaName;     }      public void setSchemaName(final String schemaName) {         this.schemaName = schemaName;     }      public String getTableName() {         return tableName;     }      public void setTableName(final String tableName) {         this.tableName = tableName;     }      public String getColumnName() {         return columnName;     }      public void setColumnName(final String columnName) {         this.columnName = columnName;     }      public String getForeignTableName() {         return foreignTableName;     }      public void setForeignTableName(final String foreignTableName) {         this.foreignTableName = foreignTableName;     } }"
"421       /* Returns a string representation of this collection.  The string   422        * representation consists of a list of the collection's elements in the   423        * order they are returned by its iterator, enclosed in square brackets   424        * (&lt;tt&gt;""[]""&lt;/tt&gt;).  Adjacent elements are separated by the characters   425        * &lt;tt&gt;"", ""&lt;/tt&gt; (comma and space).  Elements are converted to strings as   426        * by {@link String#valueOf(Object)}.   427        *   428        * @return a string representation of this collection   429        */   430       public String toString() {   431           Iterator&lt;E&gt; i = iterator();   432           if (! i.hasNext())   433               return ""[]"";   434      435           StringBuilder sb = new StringBuilder();   436           sb.append('[');   437           for (;;) {   438               E e = i.next();   439               sb.append(e == this ? ""(this Collection)"" : e);   440               if (! i.hasNext())   441                   return sb.append(']').toString();   442               sb.append("", "");   443           }"
"Git git = ... // you get it through a CloneCommand, InitCommand                // or through the file system  CheckoutCommand coCmd = git.checkout();  // Commands are part of the api module, which include git-like calls coCmd.setName(""master""); coCmd.setCreateBranch(false); // probably not needed, just to make sure coCmd.call(); // switch to ""master"" branch  MergeCommand mgCmd = git.merge(); mgCmd.include(""foo""); // ""foo"" is considered as a Ref to a branch MergeResult res = mgCmd.call(); // actually do the merge  if (res.getMergeStatus().equals(MergeResult.MergeStatus.CONFLICTING)){    System.out.println(res.getConflicts().toString());    // inform the user he has to handle the conflicts }"
"try {     OutputStream servletOutputStream = httpServletResponse.getOutputStream(); // retrieve OutputStream from HttpServletResponse     ZipOutputStream zos = new ZipOutputStream(servletOutputStream); // create a ZipOutputStream from servletOutputStream      List&lt;String[]&gt; csvFileContents  = getContentToZIP(); // get the list of csv contents. I am assuming the CSV content is generated programmatically     int count = 0;     for (String[] entries : csvFileContents) {         String filename = ""file-"" + ++count  + "".csv"";         ZipEntry entry = new ZipEntry(filename); // create a zip entry and add it to ZipOutputStream         zos.putNextEntry(entry);          CSVWriter writer = new CSVWriter(new OutputStreamWriter(zos));  // There is no need for staging the CSV on filesystem or reading bytes into memory. Directly write bytes to the output stream.         writer.writeNext(entries);  // write the contents         writer.flush(); // flush the writer. Very important!         zos.closeEntry(); // close the entry. Note : we are not closing the zos just yet as we need to add more files to our ZIP     }      zos.close(); // finally closing the ZipOutputStream to mark completion of ZIP file } catch (Exception e) {     log.error(e); // handle error }"
"public class Xattrj {      /**      * Write the extended attribute to the given file      * @param file      * @param attrKey      * @param attrValue      */     public void writeAttribute(File file, String attrKey, String attrValue){         writeAttribute(file.getAbsolutePath(), attrKey, attrValue);     }      /**      * Read the extended attribute from the given file      * @param file      * @param attrKey      * @return      */     public String readAttribute(File file, String attrKey){         return readAttribute(file.getAbsolutePath(), attrKey);     }      /**      * Write the extended attribute to the given file      * @param file      * @param attrKey      * @param attrValue      */     private native void writeAttribute(String file, String attrKey, String attrValue);      /**      * Read the extended attribute from the given file      * @param file      * @param attrKey      * @return      */     private native String readAttribute(String file, String attrKey);       static {         try {             System.out.println(""loading xattrj..."");             LibraryLoader.loadLibrary(""xattrj"");             System.out.println(""loaded!"");         } catch (Exception e) {             e.printStackTrace();         }     } }"
"public class Data {     private String componentType, text;     private int column, row, width, height, weightX, weightY;      public Data(String componentType, int column, int row, int width, int height                 ,int weightX, int weightY, String text) {          this.componentType = componentType;         this.column = column;         this.row = row;         this.width = width;         this.height = height;         this.weightX = weightX;         this.weightY = weightY;         this.text = text;    }     // getters and setters here }"
"dos.writeInt(yourList.size()); // tell how many items for (SubImage si: yourList) {    // write every field, in order (this should be a method called writeSubImage :)    dos.writeInt(...);    dos.writeInt(...);    ... }  // to read the thing just: int size = dis.readInt(); for (int i=0; i&lt;size; i++) {    // read every field, in the same order (this should be a method called readSubImage :)    dis.readInt(...);    dis.readInt(...);    ...    // create the subimage    // add it to the list you are recreating }"
"public class DownloadPDF extends HttpServlet {  public void doGet(HttpServletRequest req, HttpServletResponse res)         throws ServletException, IOException {          //Extract some request parameters, fetch your data and generate your document          String fileName = ""&lt;SomeFileName&gt;.pdf"";         res.setContentType(""application/pdf"");         res.setHeader(""Content-Disposition"", ""attachment;filename=\"""" + fileName + ""\"""");         writePDF(&lt;SomeObjectData&gt;, res.getOutputStream());     } }"
"task copyDependenciesToTarget(type: Copy) {     println 'Copying dependencies to target...'      configurations.compile.collect().each { compileDependency -&gt;         copy {             with from (compileDependency.getPath()) {                 include '*'             }             into 'target/libs/libs'         }     } }  build.dependsOn(copyDependenciesToTarget)   jar {     manifest.attributes(             ""Main-Class"": ""Main"",             ""Class-Path"": configurations.compile.collect { 'libs/' + it.getName()}.join(' ')     ) }"
private void getMyComponents() {     Component findList = getJList(chooser);     JList myList = (JList) findList;     //find fileName in the JList and move with ViewPort view to the expected Rectangle     Component myScrollPane = getJScrollPane(chooser);     JScrollPane scrollPane = (JScrollPane) myScrollPane;     JViewport vport = scrollPane.getViewport();     //move with ViewPort view to the expected Rectangle }  private Component getJList(Component comp) {     if (comp.getClass() == JList.class) {         return comp;     }     if (comp instanceof Container) {         Component[] components = ((Container) comp).getComponents();         for (int i = 0; i &lt; components.length; i++) {             Component child = getJList(components[i]);             if (child != null) {                 return child;             }         }     }     return null; }  private Component getJScrollPane(Component comp) {     if (comp.getClass() == JScrollPane.class) {         return comp;     }     if (comp instanceof Container) {         Component[] components = ((Container) comp).getComponents();         for (int i = 0; i &lt; components.length; i++) {             Component child = getJScrollPane(components[i]);             if (child != null) {                 return child;             }         }     }     return null; }
