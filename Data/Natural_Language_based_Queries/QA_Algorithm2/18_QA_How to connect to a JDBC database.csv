code
"public class myConnection  {  // JDBC driver name and database URL private static final String JDBC_DRIVER = ""sun.jdbc.odbc.JdbcOdbcDriver""; private static final String DATABASE_URL =""jdbc:odbc:Driver={Microsoft Access Driver (*.mdb, *.accdb)};DBQ=.\\database.accdb"";  // declare Connection for accessing and querying database private Connection connection;   // constructor connects to database public myConnection ()  {      try      {         Class.forName(JDBC_DRIVER);         connection = DriverManager.getConnection(DATABASE_URL);      }       catch (SQLException sqlException)     {         JOptionPane.showMessageDialog(null, sqlException.getMessage(),                 ""Database Error"", JOptionPane.ERROR_MESSAGE);          System.exit(1);     }      catch (ClassNotFoundException classNotFound)     {         JOptionPane.showMessageDialog(null, classNotFound.getMessage(),                 ""Driver Not Found"", JOptionPane.ERROR_MESSAGE);          System.exit(1);     } }  public void closeConnection() {     try      {         connection.close();     }      catch (SQLException sqlException)     {         JOptionPane.showMessageDialog(null, sqlException.getMessage(),                 ""Database Error"", JOptionPane.ERROR_MESSAGE);          System.exit(1);     } }  public Connection getConnection() {     return connection; }"
"import java.math.BigDecimal; import java.sql.Array; import java.sql.CallableStatement; import java.sql.Connection; import java.sql.SQLException; import java.util.ArrayList; import java.util.List;  import javax.sql.DataSource;  import oracle.jdbc.OracleTypes; import oracle.sql.ARRAY; import oracle.sql.ArrayDescriptor; import oracle.sql.STRUCT;  import org.apache.log4j.Logger; import org.springframework.jdbc.core.SqlOutParameter; import org.springframework.jdbc.core.SqlParameter; import org.springframework.jdbc.object.StoredProcedure;  import com.****.****.****.ExcelListenerBean; import com.****.****.****.RevAppViewBean;  public class RevPrdBrkDwnSP extends StoredProcedure{      private final Logger log = Logger.getLogger(this.getClass().getName());      private  Connection con = null;     private DataSource ds = null;      public RevPrdBrkDwnSP(DataSource dataSource, String storeProcName) throws SQLException {          // Run the Parent         super(dataSource, storeProcName);          con = dataSource.getConnection();         ds = dataSource;          if (log.isInfoEnabled()) {             log.info(""Stored Procedure Name : ""+ storeProcName);         }         // Declare the Parameter Details         declareParameter(new SqlParameter(""IN_ARRAY"", OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY""));         declareParameter(new SqlOutParameter(""OUT_ARRAY"", OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY""));          // Compile the SP         compile();     }       public List&lt;ExcelListenerBean&gt; execute(final RevAppViewBean appViewBean$Session, DataSource dataSource) throws Exception {         dataSource = ds;         List&lt;ExcelListenerBean&gt; beans = new ArrayList&lt;ExcelListenerBean&gt;();          log.info(""Setting up the Store Procedure Params"");          String getDBUSERByUserIdSql = ""{call ****.PRCS_PROD_PRCT_BRKDWN_ENTRIES(?,?)}"";         CallableStatement cs = con.prepareCall(getDBUSERByUserIdSql);          ArrayDescriptor des = ArrayDescriptor.createDescriptor(""PBAREV.PROD_PRCT_BRKDWN_TYPE_ARRAY"", con);         ARRAY a = new ARRAY(des, con, appViewBean$Session.getExcelRecLst().toArray());         cs.setObject(1, (Object)a);          cs.registerOutParameter(2, OracleTypes.ARRAY, ""****.PROD_PRCT_BRKDWN_TYPE_ARRAY"");          if (log.isDebugEnabled()) {             log.debug(""Executing the PBAREV Store Procedure "");         }          cs.execute();         log.info(""Executed ****.PRCS_PROD_PRCT_BRKDWN_ENTRIES... Processing values to beans"");           Array arr = cs.getArray(2);          Object[] objArr = (Object[]) arr.getArray();         for(int i=0; i&lt;objArr.length;i++){             STRUCT st = (STRUCT)objArr[i];             ExcelListenerBean bean = new ExcelListenerBean();             Object[] obj = st.getAttributes();             bean.setPrntGdwIdN(((BigDecimal)obj[1]).longValue());             bean.setChldGdwIdN(((BigDecimal)obj[2]).longValue());             bean.setChldAsetPrcntN(Double.valueOf(String.valueOf(obj[4])));             bean.setStatus(String.valueOf(obj[8]));             bean.setStatusMessage(String.valueOf(obj[9]));             beans.add(bean);         }          if (log.isDebugEnabled()) {             log.info(""Finised processing SP output values to ExcelListenerBeans"");         }          return beans;     } }"
"try         {             Class.forName(""sun.jdbc.odbc.JdbcOdbcDriver"");             String connString=""jdbc:odbc:Driver={Microsoft dBASE Driver (*.dbf)};DefaultDir=E:\\db"";//DeafultDir indicates the location of the db             Connection connection=DriverManager.getConnection(connString);             String sql=""SELECT * FROM table_name where condition"";// usual sql query             Statement stmt=connection.createStatement();             ResultSet resultSet=stmt.executeQuery(sql);             while(resultSet.next())             {                 System.out.println();             }             System.out.println();         }         catch (ClassNotFoundException e)         {             e.printStackTrace();         }         catch (SQLException e)         {             e.printStackTrace();         }"
"public int num() throws Exception {  try {  // This will load the MySQL driver, each DB has its own driver  Class.forName(""com.mysql.jdbc.Driver"");  // Setup the connection with the DB  connect = DriverManager.getConnection(""jdbc:mysql://localhost/testdb?""  + ""user=root&amp;password="");   // Statements allow to issue SQL queries to the database  statement = connect.createStatement();  resultSet = statement.executeQuery(""select count(*) from testdb.emg"");   while (resultSet.next()) {  return resultSet.getInt(1);  } } catch (Exception e) { }"
"String sqlQuery = ""SELECT kompetence.kompetence_odlisujici_subcategories.nazev as odlisujici_nazev, tolerovana, zadana, aktualni ""+                 ""FROM IPR.kompetence_odlisujici, kompetence.kompetence_odlisujici_subcategories ""+                 ""WHERE IPR.kompetence_odlisujici.os_cislo_zamestnanec = ? AND tolerovana &lt;&gt; 0 AND zadana &lt;&gt; 0 AND aktualni &lt;&gt; 0 AND year = ? AND IPR.kompetence_odlisujici.active = 1 ""+                 ""AND kompetence.kompetence_odlisujici_subcategories.id = IPR.kompetence_odlisujici.id_odlisujici_subcategory"";"
"create or replace type stringArray is table of varchar2(4000); / CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED Parser AS import java.sql.Connection; import oracle.jdbc.OracleDriver; import oracle.jdbc.OracleConnection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Array;  public class Parser {      public static Array parseToArray(String str, String delim) throws SQLException {         OracleDriver ora = new oracle.jdbc.OracleDriver();         Connection conn = ora.defaultConnection();         OracleConnection oraConn = (OracleConnection)conn;         Array arr = oraConn.createARRAY(""STRINGARRAY"", str.split(delim));         return arr;     } } / CREATE OR REPLACE FUNCTION PARSETOARRAY (str IN VARCHAR2, delim IN VARCHAR2)  RETURN STRINGARRAY AS LANGUAGE JAVA NAME 'Parser.parseToArray (java.lang.String, java.lang.String) return java.sql.Array'; / DECLARE v_array STRINGARRAY; BEGIN   FOR testing IN (SELECT record FROM interfacelog) LOOP     v_array := PARSETOARRAY(testing.record, '|');    END LOOP; END;"
"import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; /**  * Creates a JSONARRAY from an java.sql.ResultSet.  * @author Aries  *  */ public class SQL2JSON  {      public static JSONArray convert(ResultSet rs) throws SQLException, JSONException           {             JSONArray json = new JSONArray();             ResultSetMetaData rsmd = rs.getMetaData();             rs.beforeFirst();             while(rs.next()) {                   int numColumns = rsmd.getColumnCount();                   JSONObject obj = new JSONObject();                    for(int i=1; i&lt;numColumns+1; i++) {                      String column_name = rsmd.getColumnLabel(i);  //Bugfix , works better than getColumnName() /Aries                       switch( rsmd.getColumnType( i ) ) {                       case java.sql.Types.ARRAY:                         obj.put(column_name, rs.getArray(column_name));     break;                       case java.sql.Types.BIGINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.BOOLEAN:                         obj.put(column_name, rs.getBoolean(column_name));   break;                       case java.sql.Types.BLOB:                         obj.put(column_name, rs.getBlob(column_name));      break;                       case java.sql.Types.DOUBLE:                         obj.put(column_name, rs.getDouble(column_name));    break;                       case java.sql.Types.FLOAT:                         obj.put(column_name, rs.getFloat(column_name));     break;                       case java.sql.Types.INTEGER:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.NVARCHAR:                         obj.put(column_name, rs.getNString(column_name));   break;                       case java.sql.Types.VARCHAR:                         obj.put(column_name, rs.getString(column_name));    break;                       case java.sql.Types.TINYINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.SMALLINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.DATE:                         obj.put(column_name, SQL2JSON.convertDateToString(rs.getDate(column_name)));      break;                       case java.sql.Types.TIMESTAMP:                         obj.put(column_name, SQL2JSON.convertDateToString(rs.getTimestamp(column_name))); break;                       default:                         obj.put(column_name, rs.getObject(column_name));    break;                     }                   }                    json.put(obj);                 }              return json;           } }"
"package yourPackage;  import java.io.FileInputStream; import java.io.FileOutputStream; import java.sql.Connection; import java.sql.DriverManager; import org.dbunit.DBTestCase; import org.dbunit.PropertiesBasedJdbcDatabaseTester; import org.dbunit.database.DatabaseConnection; import org.dbunit.database.IDatabaseConnection; import org.dbunit.database.QueryDataSet; import org.dbunit.dataset.xml.XmlDataSet; import org.junit.Test; import org.dbunit.dataset.IDataSet; import org.dbunit.dataset.xml.FlatXmlDataSet;  public class TestDBUnitDummy extends DBTestCase {      public TestDBUnitDummy( String name ) throws Exception     {         super( name );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, ""com.microsoft.sqlserver.jdbc.SQLServerDriver"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, ""jdbc:sqlserver://MyServer;databaseName=MyDatabase"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, ""sa"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, """" );     }      public static void Export() throws Exception     {         Class.forName(""com.microsoft.sqlserver.jdbc.SQLServerDriver"");         Connection jdbcConnection = DriverManager.getConnection(""jdbc:sqlserver://MySourceServer;databaseName=MyDatabase"", ""sa"", """");         IDatabaseConnection connection = new DatabaseConnection(jdbcConnection);          QueryDataSet partialDataSet = new QueryDataSet(connection);         partialDataSet.addTable(""TABLE-NAME"", ""SELECT * FROM [TABLE-NAME]"");         XmlDataSet.write(partialDataSet, new FileOutputStream(""table.xml""));         FlatXmlDataSet.write(partialDataSet, new FileOutputStream(""table_flat.xml""));     }      protected void setUpDatabaseConfig( DatabaseConfig config )     {     config.setProperty(DatabaseConfig.PROPERTY_ESCAPE_PATTERN , ""[?]"");     }      protected IDataSet getDataSet() throws Exception     {         Export();         return new XmlDataSet( new FileInputStream( ""table.xml"" ) );     }       @Test     public void test_001()     {         assertEquals( ""Dummy test"", true, true );            }  }"
"try{         String dbName = t12.getText();//assuming dbName is t12.getText();         Class.forName(""com.mysql.jdbc.Driver"");         Connection con = DriverManager.getConnection(""jdbc:mysql://localhost/"",""root"","""");//use your username and password for connection         Statement statement = con.createStatement();         int resultset = statement.executeUpdate(""create database "" + dbName );     }catch(SQLException e){         e.printStackTrace();     }catch(ClassNotFoundException e){         e.printStackTrace();     }"
"package persistence;  import java.sql.Connection; import java.sql.Driver; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.List; import java.util.Map;  public class DatabaseUtils {     private static final String URL = ""jdbc:mysql://localhost:3306/contacts"";     private static final String USERNAME = ""contacts"";     private static final String PASSWORD = ""contacts"";      public static final String SELECT_SQL = ""select customer_id, name, street, city, state, zip, phone, url from customer order by customer_id"";     public static final String INSERT_SQL = ""insert into customer(name, street, city, state, zip, phone, url) values(?,?,?,?,?,?,?)"";      public static void main(String[] args)     {         Connection connection = null;          try         {             connection = getConnection(URL, USERNAME, PASSWORD);             List&lt;Map&gt; rows = findAllCustomers(connection);              for (Map row : rows)             {                 System.out.println(row);                                 }         }         catch (SQLException e)         {             e.printStackTrace();         }         finally         {             close(connection);         }     }      public static List&lt;Map&gt; findAllCustomers(Connection connection) throws SQLException     {         List&lt;Map&gt; rows = new ArrayList&lt;Map&gt;();         PreparedStatement st = null;         ResultSet rs = null;          try         {             st = connection.prepareStatement(SELECT_SQL);             rs = st.executeQuery();             while (rs.next())             {                 rows.add(map(rs));                             }         }         finally         {             close(rs);             close(st);         }          return rows;     }      private static Map&lt;String, Object&gt; map(ResultSet rs) throws SQLException     {         Map&lt;String, Object&gt; row = new LinkedHashMap&lt;String, Object&gt;();          ResultSetMetaData meta = rs.getMetaData();          int numColumns = meta.getColumnCount();         for (int i = 1; i &lt;= numColumns; ++i)         {             String column = meta.getColumnName(i);             Object value = rs.getObject(i);             row.put(column, value);         }          return row;     }      public static Connection getConnection(String url, String username, String password) throws SQLException     {         Driver driver = DriverManager.getDriver(url);          DriverManager.registerDriver(driver);          return DriverManager.getConnection(url, username, password);     }      public static void close(Connection connection)     {         try         {             if (connection != null)             {                 connection.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public static void close(Statement st)     {         try         {             if (st != null)             {                 st.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public static void close(ResultSet rs)     {         try         {             if (rs != null)             {                 rs.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public void rollback(Connection connection)     {         try         {             if (connection != null)             {                 connection.rollback();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     } }"
"WebView  web = new WebView(); WebEngine webEngine = web.getEngine(); webEngine.loadContent (     ""&lt;b&gt;AlgorithmType:&lt;/b&gt; "" + paggingTest.getAlgorithmType()     + ""&lt;br/&gt;&lt;b&gt;Memory Pages:&lt;/b&gt; "" + paggingTest.getMemoryPages()     + ""&lt;br/&gt;&lt;b&gt;Program Pages:&lt;/b&gt; "" + paggingTest.getProgramPages()     + ""&lt;br/&gt;&lt;b&gt;Sample Count:&lt;/b&gt; "" + paggingTest.getSampleCount()     + ""&lt;br/&gt;&lt;b&gt;Distribution Type:&lt;/b&gt; "" + paggingTest.getDistributionType() );  Tooltip  tip = new Tooltip(); tip.setContentDisplay(ContentDisplay.GRAPHIC_ONLY); tip.setGraphic(web);"
"import com.datastax.driver.core.Cluster; import com.datastax.driver.core.Session;  public class App  {     public static void main( String[] args )     {         Cluster cluster = Cluster.builder()                           .addContactPoints(""127.0.0.1"")                           .build();         Session session = cluster.connect();         String cqlStatement = ""CREATE KEYSPACE myfirstcassandradb WITH "" +                                ""replication = {'class':'SimpleStrategy','replication_factor':1}"";                 session.execute(cqlStatement);          String cqlStatement2 = ""CREATE TABLE myfirstcassandradb.users ("" +                                 "" user_name varchar PRIMARY KEY,"" +                                 "" password varchar "" +                                 "");"";         session.execute(cqlStatement2);          System.out.println(""Done"");         System.exit(0);     } }"
"import java.io.FileReader; import java.sql.Connection; import java.sql.DriverManager;  import org.postgresql.copy.CopyManager; import org.postgresql.core.BaseConnection;  public class PgSqlJdbcCopyStreamsExample {      public static void main(String[] args) throws Exception {          if(args.length!=4) {             System.out.println(""Please specify database URL, user, password and file on the command line."");             System.out.println(""Like this: jdbc:postgresql://localhost:5432/test test password file"");         } else {              System.err.println(""Loading driver"");             Class.forName(""org.postgresql.Driver"");              System.err.println(""Connecting to "" + args[0]);             Connection con = DriverManager.getConnection(args[0],args[1],args[2]);              System.err.println(""Copying text data rows from stdin"");              CopyManager copyManager = new CopyManager((BaseConnection) con);              FileReader fileReader = new FileReader(args[3]);             copyManager.copyIn(""COPY t FROM STDIN"", fileReader );              System.err.println(""Done."");         }     } }"
cd /absolute/path/to/your/project  /usr/java6/bin/javac  -classpath :.:/usr/jdk/commons-net-3.0.1.jar:/usr/jdk/classes12.jar:/usr/jdk/mysql-connector-java-5.1.17-bin.jar:/usr/jdk/jtds-1.2.5.jar:/usr/jdk/mail.jar:/usr/jdk/joda-time-1.6.2.jar:/usr/jdk/commons-codec-1.4.jar:/usr/jdk/commons-logging-1.1.1.jar:/usr/jdk/httpclient-4.1.1.jar:/usr/jdk/httpclient-cache-4.1.1.jar:/usr/jdk/httpcore-4.1.jar:/usr/jdk/httpmime-4.1.1.jar:/usr/jdk/mailapi.jar:/usr/jdk/pop3.jar:/usr/jdk/smtp.jar:/usr/jdk/dsn.jar:/usr/jdk/imap.jar -d . daily_transmission.java  java -classpath :.:/usr/jdk/commons-net-3.0.1.jar:/usr/jdk/classes12.jar:/usr/jdk/mysql-connector-java-5.1.17-bin.jar:/usr/jdk/jtds-1.2.5.jar:/urs/jdk/mail.jar:/usr/jdk/joda-time-1.6.2.jar:/usr/jdk/commons-codec-1.4.jar:/usr/jdk/commons-logging-1.1.1.jar:/usr/jdk/httpclient-4.1.1.jar:/usr/jdk/httpclient-cache-4.1.1.jar:/usr/jdk/httpcore-4.1.jar:/usr/jdk/httpmime-4.1.1.jar:/usr/jdk/mailapi.jar:/usr/jdk/pop3.jar:/usr/jdk/smtp.jar:/usr/jdk/dsn.jar:/usr/jdk/imap.jar daily_transmission
"Connection conn; try {     String[] tableNames = {""tableA"", ""tableB""};     String[] createTableStmts = ... // read the CREATE TABLE SQL statements from a file into this String array. First statement is for the tableA, and so on.     conn = DriverManager.getConnection(""jdbc:derby:sampleDB;create=true"");     for(int ctr =0 ; ctr &lt; tableNames.length; ctr++)     {         PreparedStatement pStmt = conn.prepareStatement(""SELECT t.tablename FROM sys.systables t WHERE t.tablename = ?"");         pStmt.setString(1, tableNames[ctr]);         ResultSet rs = pStmt.executeQuery();         if(!rs.next())         {             // Create the table             Statement stmt = conn.createStatement();             stmt.executeUpdate(createTableStmts[ctr]);             stmt.close();         }         rs.close();         pStmt.close();     } } catch (SQLException e) {     throw new RuntimeException(""Problem starting the app..."", e); }"
"import java.sql.Driver; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Enumeration;  import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.sql.DataSource;  import org.apache.tomcat.jdbc.pool.DataSourceProxy;  public class JdbcPoolListener implements ServletContextListener {      @Override     public void contextInitialized(ServletContextEvent myServletContextEvent) {          // initialize jdbc-pool datasource to start out with pooled connections          try {             Context myContext = (Context) new InitialContext().lookup(""java:comp/env"");             DataSource myDataSource = (DataSource) myContext.lookup(""jdbc/cf"");             myServletContextEvent.getServletContext().setAttribute(""JdbcPool"", myDataSource);         } catch (NamingException e) {             System.out.println(""Error initializing jdbc-pool datasource"");             e.printStackTrace();         }     }      @Override     public void contextDestroyed(ServletContextEvent myServletContextEvent) {      // close datasource from proxy?     ServletContext myServletContext = myServletContextEvent.getServletContext();         DataSourceProxy myDataSource = (DataSourceProxy) myServletContext.getAttribute(""JdbcPool"");         myDataSource.close();                myServletContext.removeAttribute(""JdbcPool"");          // deregister JDBC driver to prevent Tomcat 7 from complaining about memory leaks         Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();         while (drivers.hasMoreElements()) {             Driver driver = drivers.nextElement();             try {                 DriverManager.deregisterDriver(driver);                 System.out.println(String.format(""Deregistering jdbc driver: %s"", driver));             } catch (SQLException e) {                 System.out.println(String.format(""Error deregistering driver %s"", driver));                 e.printStackTrace();             }         }     } }"
"import java.util.ArrayList; import java.sql.*;  public class OracleConnection {      public static void main(String[] args) throws Exception {         //connect to database         Class.forName(""oracle.jdbc.driver.OracleDriver"");         ArrayList&lt;String&gt; serverNames = new ArrayList&lt;String&gt;();         serverNames.add(""yourhostname1"");         serverNames.add(""yourhostname2"");         serverNames.add(""yourhostname3"");         serverNames.add(""yourhostname4"");         String portNumber = ""1521"";         String sid = ""ORCLSID"";         String url = ""jdbc:oracle:thin:@(DESCRIPTION=(ADDRESS_LIST=(LOAD_BALANCE=ON)(FAILOVER=ON)"" ;         for (String serverName : serverNames) {               url += ""(ADDRESS=(PROTOCOL=tcp)(HOST=""+serverName+"")(PORT=""+portNumber+""))"";         }         url += "")(CONNECT_DATA=(SID=""+sid+"")))"";         String username = ""USERNAME"";         String password = ""PASSWORD"";         // System.out.println(url); // for debugging, if you want to see the url that was built         Connection conn = DriverManager.getConnection(url, username, password);     } }"
├── src        ├── main             ├── scala                  ├── br                  │   └── com                  │       └── caelum                  │           └── vraptor                  │               └── blank                  └── org                      └── nanokb                          ├── api                          ├── common                          ├── index                          ├── integration                          ├── interpreter                          ├── object                          ├── search                          └── test
"import oracle.jdbc.OracleConnection;      //Declare variables String url = ""...""; String username = ""...""; String password = ""..."";  //Create the Connection Connection conn = DriverManager.getConnection(url, username, password);  //Set the proxy properties java.util.Properties prop = new java.util.Properties(); prop.put(OracleConnection.PROXY_USER_NAME, ""BILL""); prop.put(OracleConnection.PROXY_USER_PASSWORD, ""password"");  //Cast the Connection to an OracleConnection and create the proxy session ((OracleConnection)conn).openProxySession(OracleConnection.PROXYTYPE_USER_NAME, prop);  /* The Connection credentials have now been changed */"
"import java.io.Serializable; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException;  import org.hibernate.HibernateException; import org.hibernate.engine.spi.SessionImplementor; import org.hibernate.id.IdentifierGenerator;  public class StringKeyGenerator implements IdentifierGenerator {      @Override     public Serializable generate(SessionImplementor session, Object collection) throws HibernateException {         Connection connection = session.connection();         PreparedStatement ps = null;         String result = """";          try {             // Oracle-specific code to query a sequence             ps = connection.prepareStatement(""SELECT TABLE_SEQ.nextval AS TABLE_PK FROM dual"");             ResultSet rs = ps.executeQuery();              if (rs.next()) {                 int pk = rs.getInt(""TABLE_PK"");                  // Convert to a String                 result = Integer.toString(pk);             }         } catch (SQLException e) {             throw new HibernateException(""Unable to generate Primary Key"");         } finally {             if (ps != null) {                 try {                     ps.close();                 } catch (SQLException e) {                     throw new HibernateException(""Unable to close prepared statement."");                 }             }         }          return result;     } }"
"import java.sql.*; import javax.sql.*;  public class MysqlPathFinderDemo{  public static void main(String args[]){ String dbtime; String dbUrl = ""jdbc:mysql://your.database.domain/yourDBname""; String dbClass = ""com.mysql.jdbc.Driver""; String query = ""Select * FROM users"";  try {        Class.forName(""com.mysql.jdbc.Driver"");       Connection con = DriverManager.getConnection (dbUrl);       Statement stmt = con.createStatement();       res = Myconnection.st.executeQuery(""select @@datadir"");       String Mysqlpath = """";        while(res.next()){           Mysqlpath=res.getString(1) ;       }        Mysqlpath = Mysqlpath.replace(""Data"", ""bin"");        System.err.println(""Mysql path is :""+a);    } catch(Exception ee) {    }  } }"
"String sql = ""SELECT m.member_id, searscc FROM member m, member_attribute ma "" +             ""WHERE m.member_number=:memberNumber AND m.ref_club_status IN ('A','S') AND m.member_id=ma.member_id""; String memberNumber = ""John Doe"";                   //the argument value for the sql above JdbcTemplate jdbcTemplate = new JdbcTemplate();     //replace this line with your own code to get JdbcTemplate instance. List&lt;Map&lt;String, Object&gt;&gt; rows = jdbcTemplate.queryForList(sql, new Object[]{memberNumber}) ; byte[] tempMemberIds = null; String tempSearscc = null; if ((rows != null) || (rows.size() &gt; 0)) {     for (Map&lt;String, Object&gt; tempRow : rows) {         tempMemberIds = (byte[])(tempRow.get(""member_id""));     //key is your search field in your sql         tempSearscc = (String)(tempRow.get(""searscc""));         //do your own jobs     } } else {     //do something else }"
"import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.LinkedHashMap; import java.util.Map;   public class SqlDemo {      private static final String SELECT_USER_ROLE_SQL =             ""SELECT m.user_name, m.user_role "" +             ""FROM User as u "" +             ""JOIN Usermap as m"" +             ""ON u.user_name = m.user_name "";      public Map&lt;String, String&gt; getAllUserRoles(Connection connection) {         Map&lt;String, String&gt; userRoles = new LinkedHashMap&lt;String, String&gt;();          PreparedStatement ps = null;         ResultSet rs = null;          try {             ps = connection.prepareStatement(SELECT_USER_ROLE_SQL);             rs = ps.executeQuery();             while (rs.next()) {                 String user = rs.getString(""user_name"");                 String role = rs.getString(""user_role"");                 userRoles.put(user, role);             }         } catch (SQLException e) {             e.printStackTrace();         }         finally {             close(rs);             close(ps);         }          return userRoles;     }      private static void close(ResultSet rs) {         try {             if (rs != null) rs.close();         } catch (Exception e) {             e.printStackTrace();         }     }      private static void close(Statement st) {         try {             if (st != null) st.close();         } catch (Exception e) {             e.printStackTrace();         }     } }"
"com.google.gwt.dev.shell.HostedModeException: Something other than an int was returned from JSNI method '@com.google.gwt.user.client.rpc.impl.ClientSerializationStreamReader::readInt()': JS value of type string, expected int at com.google.gwt.dev.shell.JsValueGlue.getIntRange(JsValueGlue.java:266) at com.google.gwt.dev.shell.JsValueGlue.get(JsValueGlue.java:144) at com.google.gwt.dev.shell.ModuleSpace.invokeNativeInt(ModuleSpace.java:247) at com.google.gwt.dev.shell.JavaScriptHost.invokeNativeInt(JavaScriptHost.java:75)"
"package com.your.package.hibernate.types;  import java.io.Serializable; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Types;  import org.hibernate.HibernateException; import org.hibernate.usertype.UserType; import org.joda.time.DurationFieldType; import org.joda.time.Period; import org.joda.time.ReadableDuration; import org.joda.time.ReadablePeriod; import org.postgresql.util.PGInterval;  public class JodaTimeDurationType     implements UserType {      public Class&lt;?&gt; returnedClass() {         return ReadableDuration.class;     }       public int[] sqlTypes() {         return new int[] {Types.OTHER};     }       public Object nullSafeGet(ResultSet resultSet, String[] names, Object owner)         throws HibernateException, SQLException {          try {             final PGInterval pgi = (PGInterval)resultSet.getObject(names[0]);              final int years = pgi.getYears();             final int months = pgi.getMonths();             final int days = pgi.getDays();             final int hours = pgi.getHours();             final int mins = pgi.getMinutes();             final double secs = pgi.getSeconds();              return new Period(years, months, 0, days, hours, mins, (int)secs, 0).toStandardDuration();          }         catch (Exception e) {             return null;         }     }       public void nullSafeSet(PreparedStatement statement, Object value, int index)         throws HibernateException, SQLException {          if (value == null) {             statement.setNull(index, Types.OTHER);         }         else {             final ReadablePeriod period = ((ReadableDuration)value).toPeriod();              final int years = period.get(DurationFieldType.years());             final int months = period.get(DurationFieldType.months());             final int days = period.get(DurationFieldType.days());             final int hours = period.get(DurationFieldType.hours());             final int mins = period.get(DurationFieldType.minutes());             final int secs = period.get(DurationFieldType.seconds());              final PGInterval pgi = new PGInterval(years, months, days, hours, mins, secs);             statement.setObject(index, pgi);         }     }       public boolean equals(Object x, Object y)         throws HibernateException {          return x == y;     }       public int hashCode(Object x)         throws HibernateException {         return x.hashCode();     }       public Object deepCopy(Object value)         throws HibernateException {         return value;     }       public boolean isMutable() {         return false;     }       public Serializable disassemble(Object value)         throws HibernateException {         throw new HibernateException(""not implemented"");     }       public Object assemble(Serializable cached, Object owner)         throws HibernateException {         throw new HibernateException(""not implemented"");     }       public Object replace(Object original, Object target, Object owner)         throws HibernateException {         throw new HibernateException(""not implemented"");     } }"
"package test;  import java.sql.Connection; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.sql.Statement; import java.util.Arrays;  public class SQLiteTest {  public static void main(String[] args) throws SQLException,         ClassNotFoundException {     Class.forName(""org.sqlite.JDBC"");     Connection connection = DriverManager             .getConnection(""jdbc:sqlite:test.db"");     Statement statement = connection.createStatement();     createTable(statement);     insertBlob(connection);     byte[] bytes = query(statement);     System.out.println(Arrays.toString(bytes));             statement.close();     connection.close(); }  private static void createTable(Statement statement) throws SQLException {     statement.execute(""CREATE TABLE test (data BLOB)""); }  private static void insertBlob(Connection connection) throws SQLException {     PreparedStatement pStatement = connection             .prepareStatement(""INSERT INTO test VALUES (?)"");     pStatement.setBytes(1, new byte[] { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 });     pStatement.execute();     pStatement.close(); }  private static byte[] query(Statement statement) throws SQLException {     ResultSet rs = statement.executeQuery(""SELECT data FROM test"");     byte[] bytes = rs.getBytes(1);     return bytes; }  }"
"import java.sql.SQLException; import com.hp.hpl.jena.util.FileManager; import com.hp.hpl.jena.rdf.model.Model; import com.hp.hpl.jena.rdf.model.SimpleSelector; import com.hp.hpl.jena.rdf.model.Property; import com.hp.hpl.jena.rdf.model.RDFNode; import com.hp.hpl.jena.rdf.model.Literal; import com.hp.hpl.jena.rdf.model.StmtIterator; import com.hp.hpl.jena.rdf.model.Statement; import com.hp.hpl.jena.db.DBConnection; import com.hp.hpl.jena.rdf.model.ModelMaker; import com.hp.hpl.jena.rdf.model.ModelFactory;  public class TestJena {      public static void main(String[] args) throws java.lang.ClassNotFoundException, java.sql.SQLException {         Class.forName(""com.mysql.jdbc.Driver"");                      //The database backend initialization.         DBConnection connection = new DBConnection(MY_DB, USER, PASS, ""mysql"");         ModelMaker dbMaker = ModelFactory.createModelRDBMaker(connection);          //A file manager to get the triples from the DBPedia revolvable URI.          FileManager fManager = FileManager.get();         fManager.addLocatorURL();         Model linkedDataModel =               fManager.loadModel(""http://dbpedia.org/data/Frederick_of_Sweden.rdf"");           //Now we copy the in-memory model into our DB backend.          //When the model is created you can give it the name that you like.         Model dbModel =                dbMaker.createModel(""http://dbpedia.org/resource/Frederick_of_Sweden"");          dbModel.add(linkedDataModel);          StmtIterator iter = dbModel.listStatements();         while (iter.hasNext()) {             Statement stmt = iter.nextStatement();             System.out.println(stmt);         }           linkedDataModel.close();         dbModel.close();         connection.close(); }"
"ImageLoaderConfiguration config = new ImageLoaderConfiguration.Builder(thisContext)             // You can pass your own memory cache implementation            .discCacheFileNameGenerator(new HashCodeFileNameGenerator())            .build();  DisplayImageOptions options = new DisplayImageOptions.Builder()             .displayer(new RoundedBitmapDisplayer(10)) //rounded corner bitmap             .cacheInMemory(true)             .cacheOnDisc(true)             .build();  ImageLoader imageLoader = ImageLoader.getInstance(); imageLoader.init(config); imageLoader.displayImage(image_url,image_view, options );"
"import liquibase.database.Database; import liquibase.exception.CustomPreconditionErrorException; import liquibase.exception.CustomPreconditionFailedException; import liquibase.precondition.CustomPrecondition; import liquibase.snapshot.SnapshotGeneratorFactory; import liquibase.structure.core.ForeignKey; import liquibase.structure.core.Schema; import liquibase.structure.core.Table; import liquibase.util.StringUtils;  /**  * {@link CustomPrecondition} implementation that checks if a column on a table  * has a foreign key constraint for some other table.  */ public final class CheckForeignKey implements CustomPrecondition {      /**      * Schema.      */     private String schemaName;      /**      * Table name (that has the column).      */     private String tableName;      /**      * Column (that might have the foreign key).      */     private String columnName;      /**      * Referenced table of the foreign key.      */     private String foreignTableName;      @Override     public void check(final Database db)             throws CustomPreconditionFailedException,             CustomPreconditionErrorException {          try {             // The fkey we are looking for             final ForeignKey fKey = new ForeignKey();              // Schema, base table             fKey.setForeignKeyTable(new Table());             if (StringUtils.trimToNull(getTableName()) != null) {                 fKey.getForeignKeyTable().setName(getTableName());             }              final Schema schema = new Schema();             schema.setName(getSchemaName());             fKey.getForeignKeyTable().setSchema(schema);              // Base column             fKey.addForeignKeyColumn(getColumnName());              // Referenced table             fKey.setPrimaryKeyTable(new Table());             if (StringUtils.trimToNull(getForeignTableName()) != null) {                 fKey.getPrimaryKeyTable().setName(getForeignTableName());             }              if (!SnapshotGeneratorFactory.getInstance().has(fKey, db)) {                 throw new CustomPreconditionFailedException(                         String.format(                                 ""Error fkey not found schema %s table %s column %s ftable %s"",                                 getSchemaName(), getTableName(),                                 getColumnName(), getForeignTableName()));             }         } catch (final CustomPreconditionFailedException e) {             throw e;         } catch (final Exception e) {             throw new CustomPreconditionErrorException(""Error"", e);         }     }      public String getSchemaName() {         return schemaName;     }      public void setSchemaName(final String schemaName) {         this.schemaName = schemaName;     }      public String getTableName() {         return tableName;     }      public void setTableName(final String tableName) {         this.tableName = tableName;     }      public String getColumnName() {         return columnName;     }      public void setColumnName(final String columnName) {         this.columnName = columnName;     }      public String getForeignTableName() {         return foreignTableName;     }      public void setForeignTableName(final String foreignTableName) {         this.foreignTableName = foreignTableName;     } }"
"public class JdbcSQLServerDriverUrlExample {   public static void main(String[] args)   {     Connection connection = null;     try     {       // the sql server driver string       Class.forName(""com.microsoft.sqlserver.jdbc.SQLServerDriver"");        // the sql server url       String url = ""jdbc:microsoft:sqlserver://HOST:1433;DatabaseName=DATABASE"";        // get the sql server database connection       connection = DriverManager.getConnection(url,""THE_USER"", ""THE_PASSWORD"");        // now do whatever you want to do with the connection       // ...      }     catch (ClassNotFoundException e)     {       e.printStackTrace();       System.exit(1);     }     catch (SQLException e)     {       e.printStackTrace();       System.exit(2);     }   } }"
