code
cd /absolute/path/to/your/project  /usr/java6/bin/javac  -classpath :.:/usr/jdk/commons-net-3.0.1.jar:/usr/jdk/classes12.jar:/usr/jdk/mysql-connector-java-5.1.17-bin.jar:/usr/jdk/jtds-1.2.5.jar:/usr/jdk/mail.jar:/usr/jdk/joda-time-1.6.2.jar:/usr/jdk/commons-codec-1.4.jar:/usr/jdk/commons-logging-1.1.1.jar:/usr/jdk/httpclient-4.1.1.jar:/usr/jdk/httpclient-cache-4.1.1.jar:/usr/jdk/httpcore-4.1.jar:/usr/jdk/httpmime-4.1.1.jar:/usr/jdk/mailapi.jar:/usr/jdk/pop3.jar:/usr/jdk/smtp.jar:/usr/jdk/dsn.jar:/usr/jdk/imap.jar -d . daily_transmission.java  java -classpath :.:/usr/jdk/commons-net-3.0.1.jar:/usr/jdk/classes12.jar:/usr/jdk/mysql-connector-java-5.1.17-bin.jar:/usr/jdk/jtds-1.2.5.jar:/urs/jdk/mail.jar:/usr/jdk/joda-time-1.6.2.jar:/usr/jdk/commons-codec-1.4.jar:/usr/jdk/commons-logging-1.1.1.jar:/usr/jdk/httpclient-4.1.1.jar:/usr/jdk/httpclient-cache-4.1.1.jar:/usr/jdk/httpcore-4.1.jar:/usr/jdk/httpmime-4.1.1.jar:/usr/jdk/mailapi.jar:/usr/jdk/pop3.jar:/usr/jdk/smtp.jar:/usr/jdk/dsn.jar:/usr/jdk/imap.jar daily_transmission
"set.JBOSS_HOME={your jboss home dir} set.JAVA_HOME={path to the jvm}  wrapper.java.command=%JAVA_HOME%\bin\java  wrapper.java.mainclass=org.tanukisoftware.wrapper.WrapperSimpleApp  wrapper.java.classpath.1=%JBOSS_HOME%/jboss-modules.jar wrapper.java.classpath.2=%JBOSS_HOME%/lib/wrapper.jar  # Java Library Path (location of Wrapper.DLL or libwrapper.so) wrapper.java.library.path.1=%JBOSS_HOME%/lib  # Java Bits.  On applicable platforms, tells the JVM to run in 32 or 64-bit mode. wrapper.java.additional.auto_bits=TRUE  # Java Additional Parameters wrapper.java.additional.1=-XX:+TieredCompilation wrapper.java.additional.2=-Dprogram.name=standalone.bat wrapper.java.additional.3=-XX:MaxPermSize=256M wrapper.java.additional.4=-Dsun.rmi.dgc.client.gcInterval=3600000 wrapper.java.additional.5=-Dsun.rmi.dgc.server.gcInterval=3600000 wrapper.java.additional.6=-Djava.net.preferIPv4Stack=true wrapper.java.additional.7=-Djboss.server.default.config=standalone.xml wrapper.java.additional.8=-Dorg.jboss.resolver.warning=true wrapper.java.additional.9=-Djboss.modules.system.pkgs=org.jboss.byteman wrapper.java.additional.10=-Dorg.jboss.boot.log.file=%JBOSS_HOME%\standalone\log\boot.log wrapper.java.additional.11=-Dlogging.configuration=file:%JBOSS_HOME%/standalone/configuration/logging.properties wrapper.java.additional.12=-Dorg.tanukisoftware.wrapper.WrapperManager.mbean=false  # Initial Java Heap Size (in MB) wrapper.java.initmemory=64  # Maximum Java Heap Size (in MB) wrapper.java.maxmemory=512  # Application parameters.  Add parameters as needed starting from 1 wrapper.app.parameter.1=org.jboss.modules.Main wrapper.app.parameter.2=-mp wrapper.app.parameter.3=%JBOSS_HOME%\modules wrapper.app.parameter.4=-jaxpmodule  wrapper.app.parameter.5=javax.xml.jaxp-provider wrapper.app.parameter.6=org.jboss.as.standalone wrapper.app.parameter.7=-Djboss.home.dir=%JBOSS_HOME%"
";-------------------------------- ;Defines    !define JavaRegKey 'HKLM ""Software\JavaSoft\Java Runtime Environment"" """"'  ;-------------------------------- ;Installer Sections Section 'Java Runtime' SecJava    SetOutPath '$TEMP'   SetOverwrite on   File 'c:\&lt;yourdir&gt;\javasetup.exe'   ExecWait '$TEMP\javasetup.exe' $0   DetailPrint '..Java Runtime Setup exit code = $0'   Delete '$TEMP\javasetup.exe'  SectionEnd  ;-------------------------------- ;   Functions Function .onInit    ReadRegStr $R0 ${JavaRegKey}   StrCmp $R0 """" JavaMissing JavaFound    JavaFound:    !insertmacro UnselectSection ${SecJava}   Goto JavaCheckDone    JavaMissing:   !insertmacro SelectSection ${SecJava}    JavaCheckDone:  FunctionEnd"
"package acme.annotation.processing;  import java.util.HashSet; import java.util.Set;  import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.lang.model.element.TypeElement;  import acme.annotation.FooEntity;  @SupportedAnnotationTypes(""*"") public class FooEntityExtendedProcessor extends AbstractProcessor {      private void log(String msg) {         System.out.println(msg);     }      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         log(""Initially I was asked to process:"" + annotations.toString());          Set&lt;TypeElement&gt; fooAnnotations = new HashSet&lt;&gt;();         for (TypeElement elem : annotations) {             if (isFoo(elem)) fooAnnotations.add(elem);         }          if (fooAnnotations.size() &gt; 0) {             log(""... but I am now going to process:"" + fooAnnotations.toString());             processInternal(fooAnnotations, roundEnv);         } else {             log(""... but none of those was my business!"");         }          // always return false so that other processors get a chance to process the annotations not consumed here         return false;     }      private void processInternal(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         // TODO: do your foo processing here     }      private boolean isFoo(TypeElement elem) {         if (elem.getQualifiedName().toString().equals(""acme.annotation.FooEntity"")                 || elem.getAnnotation(FooEntity.class) != null) {             return true;                     } else {             return false;         }     }  }"
"scala&gt; class IsPrimitiveChar {      |   def myChar(i: Int): Char = i.toChar   // I am clearly a Char, whatever that is!      | } defined class IsPrimitiveChar  scala&gt; :javap IsPrimitveChar Compiled from ""&lt;console&gt;"" public class IsPrimitiveChar extends java.lang.Object implements scala.ScalaObject{     public char myChar(int);  // Look, it returns a char!     public IsPrimitiveChar(); }   scala&gt; :javap -c -private IsPrimitiveChar Compiled from ""&lt;console&gt;"" public class IsPrimitiveChar extends java.lang.Object implements scala.ScalaObject{ public char myChar(int);   Code:    0:   iload_1    1:   i2c               // Look, primitive int to char conversion in bytecode!    2:   ireturn           // And that's all!"
"create or replace type stringArray is table of varchar2(4000); / CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED Parser AS import java.sql.Connection; import oracle.jdbc.OracleDriver; import oracle.jdbc.OracleConnection; import java.sql.DriverManager; import java.sql.SQLException; import java.sql.Array;  public class Parser {      public static Array parseToArray(String str, String delim) throws SQLException {         OracleDriver ora = new oracle.jdbc.OracleDriver();         Connection conn = ora.defaultConnection();         OracleConnection oraConn = (OracleConnection)conn;         Array arr = oraConn.createARRAY(""STRINGARRAY"", str.split(delim));         return arr;     } } / CREATE OR REPLACE FUNCTION PARSETOARRAY (str IN VARCHAR2, delim IN VARCHAR2)  RETURN STRINGARRAY AS LANGUAGE JAVA NAME 'Parser.parseToArray (java.lang.String, java.lang.String) return java.sql.Array'; / DECLARE v_array STRINGARRAY; BEGIN   FOR testing IN (SELECT record FROM interfacelog) LOOP     v_array := PARSETOARRAY(testing.record, '|');    END LOOP; END;"
"import java.sql.Driver; import java.sql.DriverManager; import java.sql.SQLException; import java.util.Enumeration;  import javax.naming.Context; import javax.naming.InitialContext; import javax.naming.NamingException; import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener; import javax.sql.DataSource;  import org.apache.tomcat.jdbc.pool.DataSourceProxy;  public class JdbcPoolListener implements ServletContextListener {      @Override     public void contextInitialized(ServletContextEvent myServletContextEvent) {          // initialize jdbc-pool datasource to start out with pooled connections          try {             Context myContext = (Context) new InitialContext().lookup(""java:comp/env"");             DataSource myDataSource = (DataSource) myContext.lookup(""jdbc/cf"");             myServletContextEvent.getServletContext().setAttribute(""JdbcPool"", myDataSource);         } catch (NamingException e) {             System.out.println(""Error initializing jdbc-pool datasource"");             e.printStackTrace();         }     }      @Override     public void contextDestroyed(ServletContextEvent myServletContextEvent) {      // close datasource from proxy?     ServletContext myServletContext = myServletContextEvent.getServletContext();         DataSourceProxy myDataSource = (DataSourceProxy) myServletContext.getAttribute(""JdbcPool"");         myDataSource.close();                myServletContext.removeAttribute(""JdbcPool"");          // deregister JDBC driver to prevent Tomcat 7 from complaining about memory leaks         Enumeration&lt;Driver&gt; drivers = DriverManager.getDrivers();         while (drivers.hasMoreElements()) {             Driver driver = drivers.nextElement();             try {                 DriverManager.deregisterDriver(driver);                 System.out.println(String.format(""Deregistering jdbc driver: %s"", driver));             } catch (SQLException e) {                 System.out.println(String.format(""Error deregistering driver %s"", driver));                 e.printStackTrace();             }         }     } }"
"package hibernatehelper;  import java.io.Serializable; import java.lang.reflect.Method; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException; import java.util.Properties; import org.hibernate.HibernateException; import org.hibernate.type.AbstractSingleColumnStandardBasicType; import org.hibernate.type.TypeResolver; import org.hibernate.usertype.ParameterizedType; import org.hibernate.usertype.UserType;   public class GenericEnumUserType implements UserType, ParameterizedType {      private Class &lt;? extends Enum&gt; enumClass;      private Class &lt;?&gt; identifierType;      private Method identifierMethod;      private Method valueOfMethod;      private static final String defaultIdentifierMethodName = ""getId"";      private static final String defaultValueOfMethodName = ""parseId"";      private AbstractSingleColumnStandardBasicType type;      private int[] sqlTypes;      @Override     public void setParameterValues(Properties parameters) {         String enumClassName = parameters.getProperty(""enumClass"");         try {             enumClass = Class.forName(enumClassName).asSubclass(Enum.class);         } catch (ClassNotFoundException exception) {             throw new HibernateException(""Enum class not found"", exception);         }          String identifierMethodName =                 parameters.getProperty(""identifierMethod"",                         defaultIdentifierMethodName);          try {             identifierMethod =                     enumClass.getMethod(identifierMethodName, new Class[0]);             identifierType = identifierMethod.getReturnType();         } catch (Exception exception) {             throw new HibernateException(""Failed to optain identifier method"",                     exception);         }          TypeResolver tr = new TypeResolver();         type =                 (AbstractSingleColumnStandardBasicType) tr.basic(identifierType                         .getName());         if (type == null) {             throw new HibernateException(""Unsupported identifier type ""                     + identifierType.getName());         }         sqlTypes = new int[] {type.sqlType()};          String valueOfMethodName = parameters.getProperty(""valueOfMethod"",                 defaultValueOfMethodName);         try {             valueOfMethod = enumClass.getMethod(valueOfMethodName,                             new Class[] {identifierType});         } catch (Exception exception) {             throw new HibernateException(""Failed to optain valueOf method"",                     exception);         }     }      @Override     public Class returnedClass() {         return enumClass;     }      @Override     public Object nullSafeGet(ResultSet rs, String[] names, Object owner)             throws HibernateException, SQLException {         Object identifier = type.get(rs, names[0]);         if (identifier == null) {             return null;         }          if (valueOfMethod == null) {          }          try {             return valueOfMethod.invoke(enumClass, new Object[] {identifier});         } catch (Exception exception) {             throw new HibernateException(                     ""Exception while invoking valueOfMethod of enumeration class: "",                     exception);         }     }      public void nullSafeSet(PreparedStatement st, Object value, int index)             throws HibernateException, SQLException {         try {             Object identifier =                     value != null ? identifierMethod.invoke(value,                             new Object[0]) : null;             st.setObject(index, identifier);         } catch (Exception exception) {             throw new HibernateException(                     ""Exception while invoking identifierMethod of enumeration class: "",                     exception);          }     }      @Override     public int[] sqlTypes() {         return sqlTypes;     }      @Override     public Object assemble(Serializable cached, Object owner)             throws HibernateException {         return cached;     }      @Override     public Object deepCopy(Object value) throws HibernateException {         return value;     }      @Override     public Serializable disassemble(Object value) throws HibernateException {         return (Serializable) value;     }      @Override     public boolean equals(Object x, Object y) throws HibernateException {         return x == y;     }      @Override     public int hashCode(Object x) throws HibernateException {         return x.hashCode();     }      public boolean isMutable() {         return false;     }      public Object replace(Object original, Object target, Object owner)             throws HibernateException {         return original;     } }"
"import java.io.*; import java.util.*; import java.text.*; import java.lang.*;   import org.hyperic.sigar.Mem; import org.hyperic.sigar.Sigar; import org.hyperic.sigar.SigarException;  public class MemExample {      private static Sigar sigar = new Sigar();      public static void getInformationsAboutMemory() {         System.out.println(""**************************************"");         System.out.println(""*** Informations about the Memory: ***"");         System.out.println(""**************************************\n"");          Mem mem = null;         try {             mem = sigar.getMem();         } catch (SigarException se) {             se.printStackTrace();         }          System.out.println(""Actual total free system memory: ""                 + mem.getActualFree() / 1024 / 1024+ "" MB"");         System.out.println(""Actual total used system memory: ""                 + mem.getActualUsed() / 1024 / 1024 + "" MB"");         System.out.println(""Total free system memory ......: "" + mem.getFree()                 / 1024 / 1024+ "" MB"");         System.out.println(""System Random Access Memory....: "" + mem.getRam()                 + "" MB"");         System.out.println(""Total system memory............: "" + mem.getTotal()                 / 1024 / 1024+ "" MB"");         System.out.println(""Total used system memory.......: "" + mem.getUsed()                 / 1024 / 1024+ "" MB"");          System.out.println(""\n**************************************\n"");       }      public static void main(String[] args) throws Exception{                  getInformationsAboutMemory();                  }  }"
"char *concatenated; const jbyte *sx; jstring retval;  /* Get the UTF-8 characters that represent our java string */ sx = (*env)-&gt;GetStringUTFChars(env, s, NULL);  /* Concatenate the two strings. */ concatenated = malloc(strlen(""asd "") + strlen(sx) + 1); strcpy(concatenated, ""asd ""); strcat(concatenated, sx);  /* Create java string from our concatenated C string */ retval = (*env)-&gt;NewStringUTF(env, concatenated);  /* Free the memory in sx */ (*env)-&gt;ReleaseStringUTFChars(env, s, sx);  /* Free the memory in concatenated */ free(concatenated);  return retval;"
"JNIEXPORT jintArray JNICALL Java_ArrayTest_initIntArray(JNIEnv *env, jclass cls, int size) {  jintArray result;  result = (*env)-&gt;NewIntArray(env, size);  if (result == NULL) {      return NULL; /* out of memory error thrown */  }  int i;  // fill a temp structure to use to populate the java int array  jint fill[size];  for (i = 0; i &lt; size; i++) {      fill[i] = 0; // put whatever logic you want to populate the values here.  }  // move from the temp structure to the java structure  (*env)-&gt;SetIntArrayRegion(env, result, 0, size, fill);  return result; }"
"import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.TypeElement;  @SupportedSourceVersion(SourceVersion.RELEASE_7) @SupportedAnnotationTypes(""*"") public class Processor extends AbstractProcessor {      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         ImportScanner scanner = new ImportScanner();         scanner.scan(roundEnv.getRootElements(), null);          Set&lt;String&gt; importedTypes = scanner.getImportedTypes();         // do something with the types          return false;     }  }"
"package addtext;   import java.io.BufferedReader; import java.io.BufferedWriter; import java.io.File; import java.io.FileNotFoundException; import java.io.FileReader; import java.io.FileWriter; import java.io.IOException; import java.util.logging.Level; import java.util.logging.Logger; /**  *  * @author Dan300  */ public class AddText {      File yourFile = new File(""YourFileHere.txt""); //add the name of your file in the brackets     int numLines; //this will store the number of lines in the file     String[] lines; //the lines of text that make up the file will be stored here      public AddText() {         numLines = getNumberLines(yourFile);         lines = new String[numLines];//here we set the size of the array to be the same as the number of lines in the file         for(int count = 0; count &lt; numLines; count++) {             lines[count] = readLine(count,yourFile);//here we set each string in the array to be each new line of the file         }          doSomethingToStrings();     }  public static void main(String[] args) {         new AddText();     }"
"import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Arrays;  public class InvokeMain {     public static void main(String... args) {     try {         Class&lt;?&gt; c = Class.forName(args[0]);         Class[] argTypes = new Class[] { String[].class };         Method main = c.getDeclaredMethod(""main"", argTypes);         String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);         System.out.format(""invoking %s.main()%n"", c.getName());         main.invoke(null, (Object)mainArgs);          // production code should handle these exceptions more gracefully     } catch (ClassNotFoundException x) {         x.printStackTrace();     } catch (NoSuchMethodException x) {         x.printStackTrace();     } catch (IllegalAccessException x) {         x.printStackTrace();     } catch (InvocationTargetException x) {         x.printStackTrace();     }     } }"
"Welcome to Scala version 2.11.0-20130930-063927-2bba779702 (Java HotSpot(TM) 64-Bit Server VM, Java 1.8.0-ea). Type in expressions to have them evaluated. Type :help for more information.  scala&gt; import java.util.regex._ import java.util.regex._  scala&gt; Pattern.compile(""((?:White )?Zinfandel|Merlot)"") res0: java.util.regex.Pattern = ((?:White )?Zinfandel|Merlot)  scala&gt; .matcher(""Merlot"") res1: java.util.regex.Matcher = java.util.regex.Matcher[pattern=((?:White )?Zinfandel|Merlot) region=0,6 lastmatch=]  scala&gt; .find() res2: Boolean = true"
"set JAVA_HOME=""C:\Program Files (x86)\Java\jre6"" set CLASSPATH=%JAVA_HOME%\lib\deploy.jar  set BOOTCP=%JAVA_HOME%\lib\javaws.jar;%JAVA_HOME%\lib\deploy.jar;%JAVA_HOME%\lib\plugin.jar set SECPOL=file:%JAVA_HOME%\lib\security\javaws.policy set SPLASHPORT=""-Djnlpx.splashport=49688""  %JAVA_HOME%\bin\javaw.exe -Xbootclasspath/a:%BOOTCP% -classpath %CLASSPATH% -Djava.security.policy=%SECPOL% -DtrustProxy=true -Xverify:remote -Djnlpx.home=%JAVA_HOME%\bin -Dsun.aws.warmpu=true -Djnlpx.origFilenameArg=C:\opt\kvm\ui.jnlp -Djnlpx.remove=false -Xnoclassgc -XX:PermSize=64m -Xms1028m -Djnlpx.heapsize=1028m,NULL %SPLASHPORT% com.sun.javaws.Main C:\opt\kvm\ui.jnlp"
"import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.util.Vector; import java.util.concurrent.ExecutionException; import java.util.logging.Level; import java.util.logging.Logger; import javax.swing.JTable; import javax.swing.SwingWorker; import javax.swing.table.DefaultTableModel; import javax.swing.table.TableModel; import sun.applet.Main;  public class DataLoadWorker extends SwingWorker&lt;TableModel, TableModel&gt; {      private final JTable table;      public DataLoadWorker(JTable table) {         this.table = table;     }      @Override     protected TableModel doInBackground() throws Exception {         Vector data = new Vector();         Vector columns = new Vector();         PreparedStatement ps = null;         ResultSet rs = null;         try {             String stmt = ""SELECT * FROM APP.DATAVAULT"";             ps = Main.getPreparedStatement(stmt);             rs = ps.executeQuery();             ResultSetMetaData md = rs.getMetaData();             int columnCount = md.getColumnCount();             //store column names               for (int i = 1; i &lt;= columnCount; i++) {                 columns.add(md.getColumnName(i));             }              columns.ensureCapacity(columnCount);              Vector row;             while (rs.next()) {                  row = new Vector(columnCount);                 for (int i = 1; i &lt;= columnCount; i++) {                     row.add(rs.getString(i));                 }                 data.add(row);                  //Debugging                             }              // List.setModel(tableModel);          } finally {             try {                 ps.close();             } catch (Exception e) {             }             try {                 rs.close();             } catch (Exception e) {             }         }          DefaultTableModel tableModel = new DefaultTableModel(data, columns);         return tableModel;     }      @Override     protected void done() {         try {             TableModel model = get();             table.setModel(model);         } catch (InterruptedException | ExecutionException ex) {             ex.printStackTrace();         }     } }"
"import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.security.GeneralSecurityException; import java.security.KeyStore;  import org.apache.commons.io.IOUtils; import org.apache.commons.lang.SystemUtils;  public class MyKeystoreProvider {   public KeyStore getKeystore(char[] password) throws GeneralSecurityException, IOException {     KeyStore keystore = KeyStore.getInstance(""jks"");     InputStream input = new FileInputStream(SystemUtils.USER_HOME + File.separator + "".keystore"");     try {       keystore.load(input, password);     } catch (IOException e) {     } finally {       IOUtils.closeQuietly(input);     }     return keystore;   } }"
"import java.util.HashMap; import java.util.HashSet; import java.util.Map; import java.util.Set;  import javax.ws.rs.ApplicationPath; import javax.ws.rs.core.Application;  // This is Jackson 2.x, Jackson 1.x used org.codehaus.jackson! import com.fasterxml.jackson.jaxrs.json.JacksonJsonProvider;  import org.slf4j.Logger; import org.slf4j.LoggerFactory;  @ApplicationPath(""rest"") public class RestConfig extends Application {      private final static Logger log = LoggerFactory.getLogger(RestConfig.class);      @Override     public Set&lt;Object&gt; getSingletons() {         Set&lt;Object&gt; set = new HashSet&lt;&gt;();         log.info(""Enabling custom Jackson JSON provider"");         set.add(new JacksonJsonProvider() /* optionally add .configure(SerializationFeature.INDENT_OUTPUT, true) */);         return set;     }      @Override     public Map&lt;String, Object&gt; getProperties() {         Map&lt;String, Object&gt; map = new HashMap&lt;&gt;();         log.info(""Disabling MOXy JSON provider"");         map.put(""jersey.config.disableMoxyJson.server"", true);         return map;     }      @Override     public Set&lt;Class&lt;?&gt;&gt; getClasses() {         Set&lt;Class&lt;?&gt;&gt; resources = new java.util.HashSet&lt;&gt;();         // ... add your own REST enabled classes here ...         return resources;     } }"
"package org.stackoverflowusers.file;  import java.io.ByteArrayOutputStream; import java.io.File; import java.io.FileInputStream; import java.io.IOException; import java.io.InputStream; import java.text.ParseException;  /**  * Represents a Windows shortcut (typically visible to Java only as a '.lnk' file).  *  * Retrieved 2011-09-23 from http://stackoverflow.com/questions/309495/windows-shortcut-lnk-parser-in-java/672775#672775  * Originally called LnkParser  *  * Written by: (the stack overflow users, obviously!)  *   Apache Commons VFS dependency removed by crysxd (why were we using that!?) https://github.com/crysxd  *   Headerified, refactored and commented by Code Bling http://stackoverflow.com/users/675721/code-bling  *   Network file support added by Stefan Cordes http://stackoverflow.com/users/81330/stefan-cordes  *   Adapted by Sam Brightman http://stackoverflow.com/users/2492/sam-brightman  *   Based on information in 'The Windows Shortcut File Format' by Jesse Hager &amp;lt;jessehager@iname.com&amp;gt;  *   And somewhat based on code from the book 'Swing Hacks: Tips and Tools for Killer GUIs'  *     by Joshua Marinacci and Chris Adamson  *     ISBN: 0-596-00907-0  *     http://www.oreilly.com/catalog/swinghks/  */ public class WindowsShortcut {     private boolean isDirectory;     private boolean isLocal;     private String real_file;      /**      * Provides a quick test to see if this could be a valid link !      * If you try to instantiate a new WindowShortcut and the link is not valid,      * Exceptions may be thrown and Exceptions are extremely slow to generate,      * therefore any code needing to loop through several files should first check this.      *      * @param file the potential link      * @return true if may be a link, false otherwise      * @throws IOException if an IOException is thrown while reading from the file      */     public static boolean isPotentialValidLink(File file) throws IOException {         final int minimum_length = 0x64;         InputStream fis = new FileInputStream(file);         boolean isPotentiallyValid = false;         try {             isPotentiallyValid = file.isFile()                 &amp;&amp; file.getName().toLowerCase().endsWith("".lnk"")                 &amp;&amp; fis.available() &gt;= minimum_length                 &amp;&amp; isMagicPresent(getBytes(fis, 32));         } finally {             fis.close();         }         return isPotentiallyValid;     }      public WindowsShortcut(File file) throws IOException, ParseException {         InputStream in = new FileInputStream(file);         try {             parseLink(getBytes(in));         } finally {             in.close();         }     }      /**      * @return the name of the filesystem object pointed to by this shortcut      */     public String getRealFilename() {         return real_file;     }      /**      * Tests if the shortcut points to a local resource.      * @return true if the 'local' bit is set in this shortcut, false otherwise      */     public boolean isLocal() {         return isLocal;     }      /**      * Tests if the shortcut points to a directory.      * @return true if the 'directory' bit is set in this shortcut, false otherwise      */     public boolean isDirectory() {         return isDirectory;     }      /**      * Gets all the bytes from an InputStream      * @param in the InputStream from which to read bytes      * @return array of all the bytes contained in 'in'      * @throws IOException if an IOException is encountered while reading the data from the InputStream      */     private static byte[] getBytes(InputStream in) throws IOException {         return getBytes(in, null);     }      /**      * Gets up to max bytes from an InputStream      * @param in the InputStream from which to read bytes      * @param max maximum number of bytes to read      * @return array of all the bytes contained in 'in'      * @throws IOException if an IOException is encountered while reading the data from the InputStream      */     private static byte[] getBytes(InputStream in, Integer max) throws IOException {         // read the entire file into a byte buffer         ByteArrayOutputStream bout = new ByteArrayOutputStream();         byte[] buff = new byte[256];         while (max == null || max &gt; 0) {             int n = in.read(buff);             if (n == -1) {                 break;             }             bout.write(buff, 0, n);             if (max != null)                 max -= n;         }         in.close();         return bout.toByteArray();     }      private static boolean isMagicPresent(byte[] link) {         final int magic = 0x0000004C;         final int magic_offset = 0x00;         return link.length &gt;= 32 &amp;&amp; bytesToDword(link, magic_offset) == magic;     }      /**      * Gobbles up link data by parsing it and storing info in member fields      * @param link all the bytes from the .lnk file      */     private void parseLink(byte[] link) throws ParseException {         try {             if (!isMagicPresent(link))                 throw new ParseException(""Invalid shortcut; magic is missing"", 0);              // get the flags byte             byte flags = link[0x14];              // get the file attributes byte             final int file_atts_offset = 0x18;             byte file_atts = link[file_atts_offset];             byte is_dir_mask = (byte)0x10;             if ((file_atts &amp; is_dir_mask) &gt; 0) {                 isDirectory = true;             } else {                 isDirectory = false;             }              // if the shell settings are present, skip them             final int shell_offset = 0x4c;             final byte has_shell_mask = (byte)0x01;             int shell_len = 0;             if ((flags &amp; has_shell_mask) &gt; 0) {                 // the plus 2 accounts for the length marker itself                 shell_len = bytesToWord(link, shell_offset) + 2;             }              // get to the file settings             int file_start = 0x4c + shell_len;              final int file_location_info_flag_offset_offset = 0x08;             int file_location_info_flag = link[file_start + file_location_info_flag_offset_offset];             isLocal = (file_location_info_flag &amp; 2) == 0;             // get the local volume and local system values             //final int localVolumeTable_offset_offset = 0x0C;             final int basename_offset_offset = 0x10;             final int networkVolumeTable_offset_offset = 0x14;             final int finalname_offset_offset = 0x18;             int finalname_offset = link[file_start + finalname_offset_offset] + file_start;             String finalname = getNullDelimitedString(link, finalname_offset);             if (isLocal) {                 int basename_offset = link[file_start + basename_offset_offset] + file_start;                 String basename = getNullDelimitedString(link, basename_offset);                 real_file = basename + finalname;             } else {                 int networkVolumeTable_offset = link[file_start + networkVolumeTable_offset_offset] + file_start;                 int shareName_offset_offset = 0x08;                 int shareName_offset = link[networkVolumeTable_offset + shareName_offset_offset]                     + networkVolumeTable_offset;                 String shareName = getNullDelimitedString(link, shareName_offset);                 real_file = shareName + ""\\"" + finalname;             }         } catch (ArrayIndexOutOfBoundsException e) {             throw new ParseException(""Could not be parsed, probably not a valid WindowsShortcut"", 0);         }     }      private static String getNullDelimitedString(byte[] bytes, int off) {         int len = 0;         // count bytes until the null character (0)         while (true) {             if (bytes[off + len] == 0) {                 break;             }             len++;         }         return new String(bytes, off, len);     }      /*      * convert two bytes into a short note, this is little endian because it's      * for an Intel only OS.      */     private static int bytesToWord(byte[] bytes, int off) {         return ((bytes[off + 1] &amp; 0xff) &lt;&lt; 8) | (bytes[off] &amp; 0xff);     }      private static int bytesToDword(byte[] bytes, int off) {         return (bytesToWord(bytes, off + 2) &lt;&lt; 16) | bytesToWord(bytes, off);     }  }"
"import org.json.JSONArray; import org.json.JSONException; import org.json.JSONObject; /**  * Creates a JSONARRAY from an java.sql.ResultSet.  * @author Aries  *  */ public class SQL2JSON  {      public static JSONArray convert(ResultSet rs) throws SQLException, JSONException           {             JSONArray json = new JSONArray();             ResultSetMetaData rsmd = rs.getMetaData();             rs.beforeFirst();             while(rs.next()) {                   int numColumns = rsmd.getColumnCount();                   JSONObject obj = new JSONObject();                    for(int i=1; i&lt;numColumns+1; i++) {                      String column_name = rsmd.getColumnLabel(i);  //Bugfix , works better than getColumnName() /Aries                       switch( rsmd.getColumnType( i ) ) {                       case java.sql.Types.ARRAY:                         obj.put(column_name, rs.getArray(column_name));     break;                       case java.sql.Types.BIGINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.BOOLEAN:                         obj.put(column_name, rs.getBoolean(column_name));   break;                       case java.sql.Types.BLOB:                         obj.put(column_name, rs.getBlob(column_name));      break;                       case java.sql.Types.DOUBLE:                         obj.put(column_name, rs.getDouble(column_name));    break;                       case java.sql.Types.FLOAT:                         obj.put(column_name, rs.getFloat(column_name));     break;                       case java.sql.Types.INTEGER:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.NVARCHAR:                         obj.put(column_name, rs.getNString(column_name));   break;                       case java.sql.Types.VARCHAR:                         obj.put(column_name, rs.getString(column_name));    break;                       case java.sql.Types.TINYINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.SMALLINT:                         obj.put(column_name, rs.getInt(column_name));       break;                       case java.sql.Types.DATE:                         obj.put(column_name, SQL2JSON.convertDateToString(rs.getDate(column_name)));      break;                       case java.sql.Types.TIMESTAMP:                         obj.put(column_name, SQL2JSON.convertDateToString(rs.getTimestamp(column_name))); break;                       default:                         obj.put(column_name, rs.getObject(column_name));    break;                     }                   }                    json.put(obj);                 }              return json;           } }"
"package restclient; import java.io.BufferedReader; import java.io.InputStreamReader; import java.net.HttpURLConnection; import java.net.URL;  public class NetClientGet {     public static void main(String[] args) {         try {              URL url = new URL(""http://localhost:3002/RestWebserviceDemo/rest/json/product/dynamicData?size=5"");//your url i.e fetch data from .             HttpURLConnection conn = (HttpURLConnection) url.openConnection();             conn.setRequestMethod(""GET"");             conn.setRequestProperty(""Accept"", ""application/json"");             if (conn.getResponseCode() != 200) {                 throw new RuntimeException(""Failed : HTTP Error code : ""                         + conn.getResponseCode());             }             InputStreamReader in = new InputStreamReader(conn.getInputStream());             BufferedReader br = new BufferedReader(in);             String output;             while ((output = br.readLine()) != null) {                 System.out.println(output);             }             conn.disconnect();          } catch (Exception e) {             System.out.println(""Exception in NetClientGet:- "" + e);         }     } }"
"var jsonObjArr = [];  var itr:java.util.Iterator = recordMap.keySet().iterator(); while (itr.hasNext()) {     var record = recordMap.get(itr.next());    var jsonObj:com.ibm.commons.util.io.json.JsonJavaObject =            new com.ibm.commons.util.io.json.JsonJavaObject();      jsonObj.putJsonProperty(""fieldName1"", record.getFieldName1());     jsonObj.putJsonProperty(""fieldName2"", record.getFieldName2());     jsonObj.putJsonProperty(""fieldName3"", record.getFieldName3());     jsonObj.putJsonProperty(""fieldName4"", record.getFieldName4());     jsonObj.putJsonProperty(""fieldName5"", record.getFieldName5());     jsonObj.putJsonProperty(""fieldName6"", record.getFieldName6());      jsonObjArr.push(com.ibm.commons.util.io.json.JsonGenerator         .toJson(com.ibm.commons.util.io.json.JsonJavaFactory.instanceEx, empr));  };  var jsonString = ""{"" +     ""count:"" + @Text(jsonObjArr.length) + "","" +     ""employees:"" + ""["" + jsonObjArr.join("","") + ""]"" +  ""}"";  return jsonString;"
"import java.io.Serializable; import java.sql.Connection; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.SQLException;  import org.hibernate.HibernateException; import org.hibernate.engine.spi.SessionImplementor; import org.hibernate.id.IdentifierGenerator;  public class StringKeyGenerator implements IdentifierGenerator {      @Override     public Serializable generate(SessionImplementor session, Object collection) throws HibernateException {         Connection connection = session.connection();         PreparedStatement ps = null;         String result = """";          try {             // Oracle-specific code to query a sequence             ps = connection.prepareStatement(""SELECT TABLE_SEQ.nextval AS TABLE_PK FROM dual"");             ResultSet rs = ps.executeQuery();              if (rs.next()) {                 int pk = rs.getInt(""TABLE_PK"");                  // Convert to a String                 result = Integer.toString(pk);             }         } catch (SQLException e) {             throw new HibernateException(""Unable to generate Primary Key"");         } finally {             if (ps != null) {                 try {                     ps.close();                 } catch (SQLException e) {                     throw new HibernateException(""Unable to close prepared statement."");                 }             }         }          return result;     } }"
"package model;  import java.util.Hashtable;  import javax.naming.Context; import javax.naming.NamingException; import javax.naming.directory.Attribute; import javax.naming.directory.Attributes; import javax.naming.directory.BasicAttribute; import javax.naming.directory.BasicAttributes; import javax.naming.ldap.InitialLdapContext; import javax.naming.ldap.LdapContext;  public class NewUser {      private static final String DOMAIN_NAME = ""Dom215-01"";     private static final String DOMAIN_ROOT = ""DC=Dom215-01,DC=local"";     private static final String DOMAIN_URL = ""ldap://10.18.215.112:389"";     private static final String ADMIN_NAME = ""CN=Administrator,CN=Users,DC=Dom215-01,DC=local"";     private static final String ADMIN_PASS = ""g18"";      private String userName, firstName, lastName, password, organisationUnit;     private LdapContext context;      public NewUser(String userName, String firstName, String lastName,                     String password, String organisationUnit) {          this.userName = userName;         this.firstName = firstName;         this.lastName = lastName;         this.password = password;         this.organisationUnit = organisationUnit;          Hashtable&lt;String, String&gt; env = new Hashtable&lt;String, String&gt;();          env.put(Context.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");          // set security credentials, note using simple cleartext authentication         env.put(Context.SECURITY_AUTHENTICATION, ""simple"");         env.put(Context.SECURITY_PRINCIPAL, ADMIN_NAME);         env.put(Context.SECURITY_CREDENTIALS, ADMIN_PASS);          // connect to my domain controller         env.put(Context.PROVIDER_URL, DOMAIN_URL);          try {             this.context = new InitialLdapContext(env, null);         } catch (NamingException e) {             System.err.println(""Problem creating object: "");             e.printStackTrace();         }      }      public boolean addUser() throws NamingException {          // Create a container set of attributes         Attributes container = new BasicAttributes();          // Create the objectclass to add         Attribute objClasses = new BasicAttribute(""objectClass"");         objClasses.add(""top"");         objClasses.add(""person"");         objClasses.add(""organizationalPerson"");         objClasses.add(""user"");          // Assign the username, first name, and last name         String cnValue = new StringBuffer(firstName).append("" "").append(lastName).toString();         Attribute cn = new BasicAttribute(""cn"", cnValue);         Attribute sAMAccountName = new BasicAttribute(""sAMAccountName"", userName);         Attribute principalName = new BasicAttribute(""userPrincipalName"", userName                 + ""@"" + DOMAIN_NAME);         Attribute givenName = new BasicAttribute(""givenName"", firstName);         Attribute sn = new BasicAttribute(""sn"", lastName);         Attribute uid = new BasicAttribute(""uid"", userName);          // Add password         Attribute userPassword = new BasicAttribute(""userpassword"", password);          // Add these to the container         container.put(objClasses);         container.put(sAMAccountName);         container.put(principalName);         container.put(cn);         container.put(sn);         container.put(givenName);         container.put(uid);         container.put(userPassword);          // Create the entry         try {             context.createSubcontext(getUserDN(cnValue, organisationUnit), container);             return true;         } catch (Exception e) {             return false;         }     }      private static String getUserDN(String aUsername, String aOU) {         return ""cn="" + aUsername + "",ou="" + aOU + "","" + DOMAIN_ROOT;     } }"
"import java.util.Comparator;  public class MyComparator implements Comparator&lt;String&gt; {      @Override     public int compare(String arg0, String arg1) {          int indexOf = arg0.indexOf(""-"");         String substring = arg0.substring(0, indexOf-1);         int indexOf1 = arg1.indexOf(""-"");         String substring1 = arg1.substring(0, indexOf1-1);         return Integer.valueOf(substring) - Integer.valueOf(substring1);     }  }   import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List;  public class Runner {      /**      * @param args      */     public static void main(String[] args) {         // TODO Auto-generated method stub         List&lt;String&gt; entries = new ArrayList&lt;String&gt;();         entries.add(""0 - name1"");         entries.add(""1000 - name2"");         entries.add(""1004 - name4"");         entries.add(""1002 - name3"");         entries.add(""10000 - name5"");         entries.add(""2000 - name5"");          Comparator&lt;String&gt; comparator = new MyComparator();         Collections.sort(entries, comparator );          for (String e : entries){             System.out.println(e);         }      } }"
"package persistence;  import java.sql.Connection; import java.sql.Driver; import java.sql.DriverManager; import java.sql.PreparedStatement; import java.sql.ResultSet; import java.sql.ResultSetMetaData; import java.sql.SQLException; import java.sql.Statement; import java.util.ArrayList; import java.util.LinkedHashMap; import java.util.List; import java.util.Map;  public class DatabaseUtils {     private static final String URL = ""jdbc:mysql://localhost:3306/contacts"";     private static final String USERNAME = ""contacts"";     private static final String PASSWORD = ""contacts"";      public static final String SELECT_SQL = ""select customer_id, name, street, city, state, zip, phone, url from customer order by customer_id"";     public static final String INSERT_SQL = ""insert into customer(name, street, city, state, zip, phone, url) values(?,?,?,?,?,?,?)"";      public static void main(String[] args)     {         Connection connection = null;          try         {             connection = getConnection(URL, USERNAME, PASSWORD);             List&lt;Map&gt; rows = findAllCustomers(connection);              for (Map row : rows)             {                 System.out.println(row);                                 }         }         catch (SQLException e)         {             e.printStackTrace();         }         finally         {             close(connection);         }     }      public static List&lt;Map&gt; findAllCustomers(Connection connection) throws SQLException     {         List&lt;Map&gt; rows = new ArrayList&lt;Map&gt;();         PreparedStatement st = null;         ResultSet rs = null;          try         {             st = connection.prepareStatement(SELECT_SQL);             rs = st.executeQuery();             while (rs.next())             {                 rows.add(map(rs));                             }         }         finally         {             close(rs);             close(st);         }          return rows;     }      private static Map&lt;String, Object&gt; map(ResultSet rs) throws SQLException     {         Map&lt;String, Object&gt; row = new LinkedHashMap&lt;String, Object&gt;();          ResultSetMetaData meta = rs.getMetaData();          int numColumns = meta.getColumnCount();         for (int i = 1; i &lt;= numColumns; ++i)         {             String column = meta.getColumnName(i);             Object value = rs.getObject(i);             row.put(column, value);         }          return row;     }      public static Connection getConnection(String url, String username, String password) throws SQLException     {         Driver driver = DriverManager.getDriver(url);          DriverManager.registerDriver(driver);          return DriverManager.getConnection(url, username, password);     }      public static void close(Connection connection)     {         try         {             if (connection != null)             {                 connection.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public static void close(Statement st)     {         try         {             if (st != null)             {                 st.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public static void close(ResultSet rs)     {         try         {             if (rs != null)             {                 rs.close();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     }      public void rollback(Connection connection)     {         try         {             if (connection != null)             {                 connection.rollback();             }         }         catch (SQLException e)         {             e.printStackTrace();         }     } }"
"import java.awt.*; import java.awt.event.ActionEvent; import javax.swing.*; import javax.swing.DefaultListSelectionModel; import javax.swing.table.DefaultTableModel;  /** @see http://stackoverflow.com/questions/4526779 */ public class CheckABunch extends JPanel {      private static final int CHECK_COL = 1;     private static final Object[][] DATA = {         {""One"", Boolean.TRUE}, {""Two"", Boolean.FALSE},         {""Three"", Boolean.TRUE}, {""Four"", Boolean.FALSE},         {""Five"", Boolean.TRUE}, {""Six"", Boolean.FALSE},         {""Seven"", Boolean.TRUE}, {""Eight"", Boolean.FALSE},         {""Nine"", Boolean.TRUE}, {""Ten"", Boolean.FALSE}};     private static final String[] COLUMNS = {""Number"", ""CheckBox""};     private DataModel dataModel = new DataModel(DATA, COLUMNS);     private JTable table = new JTable(dataModel);     private DefaultListSelectionModel selectionModel;      public CheckABunch() {         super(new BorderLayout());         this.add(new JScrollPane(table));         this.add(new ControlPanel(), BorderLayout.SOUTH);         table.setPreferredScrollableViewportSize(new Dimension(250, 175));         selectionModel = (DefaultListSelectionModel) table.getSelectionModel();     }      private class DataModel extends DefaultTableModel {          public DataModel(Object[][] data, Object[] columnNames) {             super(data, columnNames);         }          @Override         public Class&lt;?&gt; getColumnClass(int columnIndex) {             if (columnIndex == CHECK_COL) {                 return getValueAt(0, CHECK_COL).getClass();             }             return super.getColumnClass(columnIndex);         }          @Override         public boolean isCellEditable(int row, int column) {             return column == CHECK_COL;         }     }      private class ControlPanel extends JPanel {          public ControlPanel() {             this.add(new JLabel(""Selection:""));             this.add(new JButton(new SelectionAction(""Clear"", false)));             this.add(new JButton(new SelectionAction(""Check"", true)));         }     }      private class SelectionAction extends AbstractAction {          boolean value;          public SelectionAction(String name, boolean value) {             super(name);             this.value = value;         }          @Override         public void actionPerformed(ActionEvent e) {             for (int i = 0; i &lt; dataModel.getRowCount(); i++) {                 if (selectionModel.isSelectedIndex(i)) {                     dataModel.setValueAt(value, i, CHECK_COL);                 }             }         }     }      private static void createAndShowUI() {         JFrame frame = new JFrame(""CheckABunch"");         frame.add(new CheckABunch());         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         frame.pack();         frame.setLocationRelativeTo(null);         frame.setVisible(true);     }      public static void main(String[] args) {         java.awt.EventQueue.invokeLater(new Runnable() {              @Override             public void run() {                 createAndShowUI();             }         });     } }"
"import java.io.IOException; import java.io.OutputStream; import java.io.PrintStream; import org.apache.log4j.Logger;  public class RecursiveLogging {   /**    * log4j.properties file:    *     * log4j.rootLogger=DEBUG, A1    * log4j.appender.A1=org.apache.log4j.ConsoleAppender    * log4j.appender.A1.layout=org.apache.log4j.PatternLayout    * log4j.appender.A1.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n    *     */   public static void main(String[] args) {     // Logger.getLogger(RecursiveLogging.class).info(""This initializes log4j!"");     System.setOut(new PrintStream(new CustomOutputStream()));     System.out.println(""This message causes a stack overflow exception!"");   } }  class CustomOutputStream extends OutputStream {   @Override   public final void write(int b) throws IOException {     // the correct way of doing this would be using a buffer     // to store characters until a newline is encountered,     // this implementation is for illustration only     Logger.getLogger(CustomOutputStream.class).info((char) b);   } }"
"package yourPackage;  import java.io.FileInputStream; import java.io.FileOutputStream; import java.sql.Connection; import java.sql.DriverManager; import org.dbunit.DBTestCase; import org.dbunit.PropertiesBasedJdbcDatabaseTester; import org.dbunit.database.DatabaseConnection; import org.dbunit.database.IDatabaseConnection; import org.dbunit.database.QueryDataSet; import org.dbunit.dataset.xml.XmlDataSet; import org.junit.Test; import org.dbunit.dataset.IDataSet; import org.dbunit.dataset.xml.FlatXmlDataSet;  public class TestDBUnitDummy extends DBTestCase {      public TestDBUnitDummy( String name ) throws Exception     {         super( name );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_DRIVER_CLASS, ""com.microsoft.sqlserver.jdbc.SQLServerDriver"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_CONNECTION_URL, ""jdbc:sqlserver://MyServer;databaseName=MyDatabase"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_USERNAME, ""sa"" );         System.setProperty( PropertiesBasedJdbcDatabaseTester.DBUNIT_PASSWORD, """" );     }      public static void Export() throws Exception     {         Class.forName(""com.microsoft.sqlserver.jdbc.SQLServerDriver"");         Connection jdbcConnection = DriverManager.getConnection(""jdbc:sqlserver://MySourceServer;databaseName=MyDatabase"", ""sa"", """");         IDatabaseConnection connection = new DatabaseConnection(jdbcConnection);          QueryDataSet partialDataSet = new QueryDataSet(connection);         partialDataSet.addTable(""TABLE-NAME"", ""SELECT * FROM [TABLE-NAME]"");         XmlDataSet.write(partialDataSet, new FileOutputStream(""table.xml""));         FlatXmlDataSet.write(partialDataSet, new FileOutputStream(""table_flat.xml""));     }      protected void setUpDatabaseConfig( DatabaseConfig config )     {     config.setProperty(DatabaseConfig.PROPERTY_ESCAPE_PATTERN , ""[?]"");     }      protected IDataSet getDataSet() throws Exception     {         Export();         return new XmlDataSet( new FileInputStream( ""table.xml"" ) );     }       @Test     public void test_001()     {         assertEquals( ""Dummy test"", true, true );            }  }"
