code
"RepositoryConnection conn = rep.getConnection(); try {    // prepare the query    String queryString = ""SELECT * WHERE {?s ?p ?o . }"";    TupleQuery query = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);     // open a file to write the result to it in JSON format    OutputStream out = new FileOutputStream(""/path/to/output.json"");    TupleQueryResultHandler writer = new SPARQLResultJSONWriter(out);     // execute the query and write the result directly to file    query.evaluate(writer);   } finally {    conn.close(); }"
"Path p = Paths.get(""/your/file""); // where you want to write FileSystem fileSystem = FileSystems.getDefault(); Iterable&lt;FileStore&gt; iterable = fileSystem.getFileStores();  Iterator&lt;FileStore&gt; it = iterable.iterator(); // iterate the FileStore instances while(it.hasNext()) {     FileStore fileStore = it.next();     long sizeAvail = fileStore.getUsableSpace(); // or maybe getUnallocatedSpace()     if (Files.getFileStore(p).equals(fileStore) { // your Path belongs to this FileStore         if (sizeAvail &gt; theSizeOfBytesYouWantToWrite) {             // do your thing         }     } }"
"task copyDependenciesToTarget(type: Copy) {     println 'Copying dependencies to target...'      configurations.compile.collect().each { compileDependency -&gt;         copy {             with from (compileDependency.getPath()) {                 include '*'             }             into 'target/libs/libs'         }     } }  build.dependsOn(copyDependenciesToTarget)   jar {     manifest.attributes(             ""Main-Class"": ""Main"",             ""Class-Path"": configurations.compile.collect { 'libs/' + it.getName()}.join(' ')     ) }"
"public void readFromFile(String fileName, ListInterface&lt;User&gt; userList) {         String oneLine, oneLine2;         User user;         try {             /*              * Create a FileWriter object that handles the low-level details of              * reading              */             FileReader theFile = new FileReader(fileName);              /*              * Create a BufferedReader object to wrap around the FileWriter              * object              */             /* This allows the use of high-level methods like readline */             BufferedReader fileIn = new BufferedReader(theFile);              /* Read the first line of the file */             oneLine = fileIn.readLine();             /*              * Read the rest of the lines of the file and output them on the              * screen              */             while (oneLine != null) /* A null string indicates the end of file */             {                 oneLine2 = fileIn.readLine();                 user = new User(oneLine, oneLine2);                 oneLine = fileIn.readLine();                 userList.append(user);             }              /* Close the file so that it is no longer accessible to the program */             fileIn.close();         }          /*          * Handle the exception thrown by the FileReader constructor if file is          * not found          */         catch (FileNotFoundException e) {             System.out.println(""Unable to locate the file: "" + fileName);         }          /* Handle the exception thrown by the FileReader methods */         catch (IOException e) {             System.out.println(""There was a problem reading the file: ""                     + fileName);         }     } /* End of method readFromFile */       public void writeToFile(String fileName, ListInterface&lt;User&gt; userList) {         try {             /*              * Create a FileWriter object that handles the low-level details of              * writing              */             FileWriter theFile = new FileWriter(fileName);              /* Create a PrintWriter object to wrap around the FileWriter object */             /* This allows the use of high-level methods like println */             PrintWriter fileOut = new PrintWriter(theFile);              /* Print some lines to the file using the println method */             for (int i = 1; i &lt;= userList.size(); i++) {                 fileOut.println(userList.get(i).getUsername());                 fileOut.println(userList.get(i).getPassword());             }             /* Close the file so that it is no longer accessible to the program */             fileOut.close();         }          /* Handle the exception thrown by the FileWriter methods */         catch (IOException e) {             System.out.println(""Problem writing to the file"");         }     } /* End of method writeToFile */"
"StructDescriptor projectTypeDesc = StructDescriptor.createDescriptor(""MY_TYPE"", connection);  // array holding structs, where each struct is based on an array //   with fields of Project object STRUCT[] projectsAsStructs = new STRUCT[projectList.size()];  // for each Project object, create a STRUCT object containing its fields for (int i = 0; i &lt; projectList.size(); ++i) {   Project project = projectList.get(i);    Object[] projectFields = new Object[] {project.getProjectId(),                                          project.getProjectTitle()};    STRUCT projectStruct = new STRUCT(projectTypeDesc,                                     connection, projectFields);    projectsAsStructs[i] = projectStruct; }  // now you have all your Project objects ready to be saved in one go: ArrayDescriptor projectTypeArrayDesc = ArrayDescriptor.createDescriptor (""MY_ARRAY"", connection);   ARRAY arrayOfProjects = new ARRAY(projectTypeArrayDesc, connection,                                   projectsAsStructs);  callablestatement.setArray(1, arrayOfProjects);"
"PngReader pngr = new PngReader(origFile); PngWriter pngw = new PngWriter(destFile, pngr.imgInfo, true); // instruct the writer to copy all ancillary chunks from source pngw.copyChunksFrom(pngr.getChunksList(), ChunkCopyBehaviour.COPY_ALL); // add a new textual chunk (can also be done after writing the rows) pngw.getMetadata().setText(""my key"", ""my val""); // copy all rows for (int row = 0; row &lt; pngr.imgInfo.rows; row++) {   IImageLine l1 = pngr.readRow();   pngw.writeRow(l1); } pngr.end();  pngw.end();"
"public class PdfMergeHelper {      /**      * Merges the passed in PDFs, in the order that they are listed in the java.util.List.      * Writes the resulting PDF out to the OutputStream provided.      *       * Sample Usage:      * List&lt;InputStream&gt; pdfs = new ArrayList&lt;InputStream&gt;();      * pdfs.add(new FileInputStream(""/location/of/pdf/OQS_FRSv1.5.pdf""));      * pdfs.add(new FileInputStream(""/location/of/pdf/PPFP-Contract_Genericv0.5.pdf""));      * pdfs.add(new FileInputStream(""/location/of/pdf/PPFP-Quotev0.6.pdf""));      * FileOutputStream output = new FileOutputStream(""/location/to/write/to/merge.pdf"");      * PdfMergeHelper.concatPDFs(pdfs, output, true);      *       * @param streamOfPDFFiles the list of files to merge, in the order that they should be merged      * @param outputStream the output stream to write the merged PDF to      * @param paginate true if you want page numbers to appear at the bottom of each page, false otherwise      */     public static void concatPDFs(List&lt;InputStream&gt; streamOfPDFFiles, OutputStream outputStream, boolean paginate) {         Document document = new Document();         try {             List&lt;InputStream&gt; pdfs = streamOfPDFFiles;             List&lt;PdfReader&gt; readers = new ArrayList&lt;PdfReader&gt;();             int totalPages = 0;             Iterator&lt;InputStream&gt; iteratorPDFs = pdfs.iterator();              // Create Readers for the pdfs.             while (iteratorPDFs.hasNext()) {                 InputStream pdf = iteratorPDFs.next();                 PdfReader pdfReader = new PdfReader(pdf);                 readers.add(pdfReader);                 totalPages += pdfReader.getNumberOfPages();             }             // Create a writer for the outputstream             PdfWriter writer = PdfWriter.getInstance(document, outputStream);              document.open();             BaseFont bf = BaseFont.createFont(BaseFont.HELVETICA, BaseFont.CP1252, BaseFont.NOT_EMBEDDED);             PdfContentByte cb = writer.getDirectContent(); // Holds the PDF             // data              PdfImportedPage page;             int currentPageNumber = 0;             int pageOfCurrentReaderPDF = 0;             Iterator&lt;PdfReader&gt; iteratorPDFReader = readers.iterator();              // Loop through the PDF files and add to the output.             while (iteratorPDFReader.hasNext()) {                 PdfReader pdfReader = iteratorPDFReader.next();                  // Create a new page in the target for each source page.                 while (pageOfCurrentReaderPDF &lt; pdfReader.getNumberOfPages()) {                     document.newPage();                     pageOfCurrentReaderPDF++;                     currentPageNumber++;                     page = writer.getImportedPage(pdfReader, pageOfCurrentReaderPDF);                     cb.addTemplate(page, 0, 0);                      // Code for pagination.                     if (paginate) {                         cb.beginText();                         cb.setFontAndSize(bf, 9);                         cb.showTextAligned(PdfContentByte.ALIGN_CENTER, """" + currentPageNumber + "" of "" + totalPages,                                 520, 5, 0);                         cb.endText();                     }                 }                 pageOfCurrentReaderPDF = 0;             }             outputStream.flush();             document.close();             outputStream.close();         } catch (Exception e) {             e.printStackTrace();         } finally {             if (document.isOpen()) {                 document.close();             }             try {                 if (outputStream != null) {                     outputStream.close();                 }             } catch (IOException ioe) {                 ioe.printStackTrace();             }         }     } }"
"DiffFormatter formatter = new DiffFormatter( System.out ); formatter.setRepository( git.getRepository() ); AbstractTreeIterator commitTreeIterator = prepareTreeParser( git.getRepository(),  Constants.HEAD ); FileTreeIterator workTreeIterator = new FileTreeIterator( git.getRepository() ); List&lt;DiffEntry&gt; diffEntries = formatter.scan( commitTreeIterator, workTreeIterator );  for( DiffEntry entry : diffEntries ) {   System.out.println( ""Entry: "" + entry + "", from: "" + entry.getOldId() + "", to: "" + entry.getNewId() );   formatter.format( entry ); }"
"String insert = ""INSERT INTO queries (data_id, query, query_name,"" +         "" query_file_name, status) VALUES (?,?,?,?,?)"";  PreparedStatement stmt = dbconn.prepareStatement(insert, Statement.RETURN_GENERATED_KEYS); // Why do you set this if you want the DB to generate it? stmt.setInt(1, currentDataID); // or setLong() depending on data type stmt.setString(2, params[1]); // I assume params is a String[] stmt.setString(3, params[2]); stmt.setString(4, params[3]); stmt.setString(5, params[4]); stmt.execute();  ResultSet rs = stmt.getGeneratedKeys(); if (rs.next()) {     // if it's an int, avoid the cast and use rs.getInt(1) instead     currentDataID = (int) rs.getLong(1); }"
"try {         BufferedReader in = new BufferedReader(new FileReader(""plaintext.txt""));         String inputDataLine;         while ((inputDataLine = in.readLine()) != null) {             if (!(inputDataLine.contentEquals("" ""))) {                 System.out.println(""What you want to do with a paragraph line"");             } else {                 System.out.println(""What you want to do with a paragraph seperator"");             }         }         in.close();     } catch (IOException e) {     }"
"import org.icepdf.ri.common.SwingController; import org.icepdf.ri.common.SwingViewBuilder;  import javax.swing.*;  /**  * The &lt;code&gt;ViewerComponentExample&lt;/code&gt; class is an example of how to use  * &lt;code&gt;SwingController&lt;/code&gt; and &lt;code&gt;SwingViewBuilder&lt;/code&gt;  * to build a PDF viewer component.  A file specified at the command line is  * opened in a JFrame which contains the viewer component.  *  * @since 2.0  */ public class ViewerComponentExample {     public static void main(String[] args) {         // Get a file from the command line to open         String filePath = args[0];          // build a component controller         SwingController controller = new SwingController();          SwingViewBuilder factory = new SwingViewBuilder(controller);          JPanel viewerComponentPanel = factory.buildViewerPanel();          // add interactive mouse link annotation support via callback         controller.getDocumentViewController().setAnnotationCallback(                 new org.icepdf.ri.common.MyAnnotationCallback(                         controller.getDocumentViewController()));          JFrame applicationFrame = new JFrame();         applicationFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         applicationFrame.getContentPane().add(viewerComponentPanel);          // Now that the GUI is all in place, we can try openning a PDF         controller.openDocument(filePath);          // show the component         applicationFrame.pack();         applicationFrame.setVisible(true);     } }"
"Path file = ...; BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);  System.out.println(""creationTime: "" + attr.creationTime()); System.out.println(""lastAccessTime: "" + attr.lastAccessTime()); System.out.println(""lastModifiedTime: "" + attr.lastModifiedTime());  System.out.println(""isDirectory: "" + attr.isDirectory()); System.out.println(""isOther: "" + attr.isOther()); System.out.println(""isRegularFile: "" + attr.isRegularFile()); System.out.println(""isSymbolicLink: "" + attr.isSymbolicLink()); System.out.println(""size: "" + attr.size());"
"UIManager.LookAndFeelInfo[] lookAndFeelInfos = UIManager.getInstalledLookAndFeels();     for (int i = 0; i &lt; lookAndFeelInfos.length; i++) {         UIManager.LookAndFeelInfo lookAndFeelInfo = lookAndFeelInfos[i];          //         // Get the name of the look and feel         //         String name = lookAndFeelInfo.getName();         System.out.println(""name = "" + name);          //         // Get the implementation class for the look and feel         //         String className = lookAndFeelInfo.getClassName();         System.out.println(""className = "" + className);     }"
"String data = ""temp/*.jpg, usr/*.pdf, var/lib/*.so, tmp/*, usr/*, usr/*.*"";  Pattern p = Pattern         .compile(""(?&lt;path&gt;(\\w+/)+)((?&lt;name&gt;\\w+|[*]))?([.](?&lt;extension&gt;\\w+|[*]))?"");  Matcher m = p.matcher(data); while (m.find()) {     System.out.println(""data="" + m.group());     System.out.println(""path="" + m.group(""path""));     System.out.println(""name="" + m.group(""name""));     System.out.println(""extension="" + m.group(""extension""));     System.out.println(""------------""); }"
"public class View extends JPanel implements ActionListener {    JButton transform = new JButton(""Transform1"");   Model m;   public View(Model m) {        super();        this.m = m;        transform.setActionListener(this);        // lay out the GUI        setLayout(...);        add(// whatever view you need to visualize the data);        add(transform);   }    /**    Make sure all of the GUI elements are correct */   public void update() {     State transformState = m.getTransformState();     transform.setText(transformState.getNextStateDescription());      // Draw the state of the file they loaded in, probably to another JPanel   }    public void actionPerformed(ActionEvent e) {     m.transform();   }  }"
"import java.io.*;  public class CharacterStretcher {      public static void main(String[] args) {          //Assumes the input is at c:\data.txt         File inputFile = new File(""c:\\data.txt"");         //Assumes the output is at c:\temp.txt         File outputFile = new File(""c:\\temp.txt"");         try {             //Construct a file reader and writer             final FileInputStream fstream = new FileInputStream(inputFile);             final BufferedReader reader = new BufferedReader(new InputStreamReader(fstream));             final BufferedWriter writer = new BufferedWriter(new FileWriter(outputFile, false));              //Read the file line by line...             String line;             while ((line = reader.readLine()) != null) {                 //Create a StringBuilder to build our modified lines that will                 //go into the output file                 StringBuilder newLine = new StringBuilder();                  //Split each line from the input file by spaces                 String[] parts = line.split("" "");                  //For each part of the input line, check if it's a number                 for (String part : parts) {                     try {                         //If we can parse the part as an integer, we assume                         //it's a number because it almost certainly is!                         int number = Integer.parseInt(part);                         //We add this to out new line, but multiply it by 4                         newLine.append(String.valueOf(number * 4));                     } catch (NumberFormatException nfEx) {                         //If we couldn't parse it as an integer, we just add it                         //to the new line - it's going to be a String.                         newLine.append(part);                     }                      //Add a space between each part on the new line                     newLine.append("" "");                 }                 //Write the new line to the output file remembering to chop the                 //trailing space off the end, and remembering to add the line                 //breaks                 writer.append(newLine.toString().substring(0, newLine.toString().length() - 1) + ""\r\n"");                 writer.flush();             }              //Close the file handles.             reader.close();             writer.close();         } catch (FileNotFoundException e) {             e.printStackTrace();         } catch (IOException e) {             e.printStackTrace();         }     } }"
"JTextPane textPane = new JTextPane(); textPane.setText(""Line1""); StyledDocument doc = textPane.getStyledDocument();  //  Define the attribute you want for the line of text  SimpleAttributeSet center = new SimpleAttributeSet(); StyleConstants.setAlignment(center, StyleConstants.ALIGN_CENTER);  //  Add some text to the end of the Document  try {     int length = doc.getLength();     doc.insertString(doc.getLength(), ""\ntest"", null);     doc.setParagraphAttributes(length+1, 1, center, false); } catch(Exception e) { System.out.println(e);}"
"OutputStream os = conn.getOutputStream(); os.write(input.getBytes()); // The input you need to pass to the webservice os.flush(); ... BufferedReader br = new BufferedReader(new InputStreamReader(         (conn.getInputStream()))); // Getting the response from the webservice  String output; System.out.println(""Output from Server .... \n""); while ((output = br.readLine()) != null) {     System.out.println(output); // Instead of this, you could append all your response to a StringBuffer and use `toString()` to get the entire JSON response as a String.     // This string json response can be parsed using any json library. Eg. GSON from Google. }"
"int count = 0; while (scan.hasNext()) {         String line = scan.nextLine();         //Scanner to read individual items from a string          Scanner lineScan = new Scanner(line);         lineScan.useDelimiter("","");         String question = lineScan.next();         String answer = lineScan.next();          if (count &lt; 5)           //lineScan contains one of the first 5 lines           //call a method to do something with these lines here         else {           //Create the new Wordpair           Wordpair wp = new Wordpair(question, answer);           //Add the new wordpair to the list           temp.add(wp);         }          count++;     }"
"public class DownloadPDF extends HttpServlet {  public void doGet(HttpServletRequest req, HttpServletResponse res)         throws ServletException, IOException {          //Extract some request parameters, fetch your data and generate your document          String fileName = ""&lt;SomeFileName&gt;.pdf"";         res.setContentType(""application/pdf"");         res.setHeader(""Content-Disposition"", ""attachment;filename=\"""" + fileName + ""\"""");         writePDF(&lt;SomeObjectData&gt;, res.getOutputStream());     } }"
"public class Xattrj {      /**      * Write the extended attribute to the given file      * @param file      * @param attrKey      * @param attrValue      */     public void writeAttribute(File file, String attrKey, String attrValue){         writeAttribute(file.getAbsolutePath(), attrKey, attrValue);     }      /**      * Read the extended attribute from the given file      * @param file      * @param attrKey      * @return      */     public String readAttribute(File file, String attrKey){         return readAttribute(file.getAbsolutePath(), attrKey);     }      /**      * Write the extended attribute to the given file      * @param file      * @param attrKey      * @param attrValue      */     private native void writeAttribute(String file, String attrKey, String attrValue);      /**      * Read the extended attribute from the given file      * @param file      * @param attrKey      * @return      */     private native String readAttribute(String file, String attrKey);       static {         try {             System.out.println(""loading xattrj..."");             LibraryLoader.loadLibrary(""xattrj"");             System.out.println(""loaded!"");         } catch (Exception e) {             e.printStackTrace();         }     } }"
"public ModelAndView searchAssets(HttpRequest request) {     StringBuilder builder = new StringBuilder();     for (String param : request.getParameterNames()) {         value = request.getParameter(param);         builder.append(param);         builder.append(""=""); // or LIKE         builder.append(""\'"" + value ""\'"");         builder.append("" AND "");     }     // deleting the last "" AND ""     builder.delete(builder.length-5, builder.length);     // In the entity create a method that executes a query with the string     // If the parameter names are column names then you'd have to use a nativeQuery     // You'd have to look it up in JPA    List&lt;Asset&gt; list = Asset.search(builder.toString());    // put the list in the ModelAndView }"
boolean isMultipart = ServletFileUpload.isMultipartContent(request);         if (isMultipart)         {             try              {                 List items = upload.parseRequest(request);                 Iterator iterator = items.iterator();                 while (iterator.hasNext())                  {                     FileItem item = (FileItem) iterator.next();                      if (item.isFormField()) //your code for getting form fields                     {                         String name = item.getFieldName();                         String value = item.getString();                         System.out.println(name+value);                     }                      if (!item.isFormField())                      {                        //your code for getting multipart                      }                 }             }
"InputStream stream = new FileInputStream(""C:\\Thumbs.db""); POIFSFileSystem fs = new POIFSFileSystem(stream); DirectoryEntry root = fs.getRoot(); Entry entry = root.getEntry(""2""); DocumentInputStream is = fs.createDocumentInputStream(entry.getName());  //Added to read the header lines and fix the ImageFormatException int header_len = is.read(); for (int i = 1; i &lt; header_len; i++) {         is.read(); }  JPEGImageDecoder decoder = JPEGCodec.createJPEGDecoder(is); JPEGDecodeParam param = JPEGCodec.getDefaultJPEGEncodeParam(4,JPEGDecodeParam.COLOR_ID_RGBA); decoder.setJPEGDecodeParam(param); BufferedImage originalBufferedImage = decoder.decodeAsBufferedImage();"
"MultipartEntity multipart = new MultipartEntity(); File file = new File(""/filepath"");  // File with some location (filepath) Charset chars = Charset.forName(""UTF-8""); // Setting up the encoding FileBody fileB = new FileBody(file); // Create a new FileBody with the above mentioned file multipart.addPart(""data"", fileB); // Add the part to my MultipartEntity. ""data"" is parameter name for the file StringBody stringB;  // Now lets add some extra information in a StringBody try {     stringB = new StringBody(""I am the caption of the file"",chars);  // Adding the content to the StringBody and setting up the encoding     multipart.addPart(""caption"", stringB); // Add the part to my MultipartEntity } catch (UnsupportedEncodingException e) {     // TODO Auto-generated catch block     e.printStackTrace(); }  HttpPost post = new HttpPost(url); // Setting up a HTTP Post method with the target url post.setEntity(multipart); // Setting the multipart Entity to the post method HttpResponse resp = client.execute(post);  // Using some HttpClient (I'm using DefaultHttpClient) to execute the post method and receive the response"
"method processWSDL(Document wsdl) {     for each (""/wsdl:definitions/wsdl:types/xsd:schema"" in wsdl) {         call processXSD(""inline_[i].xsd"",""."")     }     for each (""/wsdl:definitions/wsdl:import"" in wsdl) {         Document x = read and parse (""@location"")         if (x is WSDL) call processWSDL(x)         else if (x is XSD) call processXSD(""@location"", x)     } }  method processXSD(String filename, Document xsd) {     write ""xsd"" to a new file ""filename""   // if 'filename' is a URL, take only the part after the last '/'     for each (""/xsd:schema/xsd:import"" or ""/xsd:schema/xsd:include"" in xsd) {         if (""@schemaLocation"" is local reference) {     // no 'http://' prefix             Document x = read and parse (""@schemaLocation"")             call processXSD(""@schemaLocation"", x)         }     } }"
"public DDHLogger(String filePath, String yourfilename)  {     System.out.println(""filePath: "" + filePath);     System.out.println(""yourfilename: "" + yourfilename);      //String fileName = ""C:\\Users\\home-1\\Desktop\\"" + yourfilename;      String fileName = filePath + yourfilename;      System.out.println(""fileName::--&gt; "" + fileName);     // file = new File(fileName);//Creates the file      file = new File(fileName);//Creates the file      System.out.println(""file: "" + file);      try {         fw = new FileWriter(file, true);         //INSTANTIATE PRINTWRITER HERE         pw = new PrintWriter(fw);     } catch (IOException e) {         e.printStackTrace();     }//allows append to the file without over writing. The TRUE keyword is used for append  }"
"Dyld maintains a current stack of paths called the run path list.   When @rpath is encountered it is substituted with each path in the   run path list until a loadable dylib if found. The run path stack   is built from the LC_RPATH load commands in the depencency chain   that lead to the current dylib load. You can add an LC_RPATH load   command to an image with the -rpath option to ld(1). You can even add   a LC_RPATH load command path that starts with @loader_path/, and it   will push a path on the run path stack that relative to the image   containing the LC_RPATH. The use of @rpath is most useful when you   have a complex directory structure of programs and dylibs which can be   installed anywhere, but keep their relative positions. This scenario   could be implemented using @loader_path, but every client of a dylib   could need a different load path because its relative position in the   file system is different. The use of @rpath introduces a level of   indirection that simplies things. You pick a location in your directory   structure as an anchor point. Each dylib then gets an install path that   starts with @rpath and is the path to the dylib relative to the anchor   point. Each main executable is linked with -rpath @loader_path/zzz,   where zzz is the path from the executable to the anchor point. At runtime   dyld sets it run path to be the anchor point, then each dylib is found   relative to the anchor point."
"String filename = &quot;C:\\a.xml&quot;; String expression = &quot;//TextVar&quot;; try {  Document document = DocumentBuilderFactory.newInstance()    .newDocumentBuilder().parse(new File(filename));  NodeList nn = (NodeList) XPathFactory.newInstance().newXPath()    .evaluate(expression, document, XPathConstants.NODESET);  for (int i = 0; i &lt; nn.getLength(); i++) {   Node item = nn.item(i);   String field = item.getAttributes().getNamedItem(&quot;field&quot;).getTextContent();   String number = item.getTextContent();   System.out.println(&quot;field=&quot; + field);   System.out.println(&quot;number=&quot; + number);  } } catch (Exception e) {  throw new RuntimeException(e); }"
"CloseableHttpClient httpClient = HttpClients.createDefault(); HttpPost uploadFile = new HttpPost(""...""); MultipartEntityBuilder builder = MultipartEntityBuilder.create(); builder.addTextBody(""field1"", ""yes"", ContentType.TEXT_PLAIN);  // This attaches the file to the POST: File f = new File(""[/path/to/upload]""); builder.addBinaryBody(     ""file"",     new FileInputStream(f),     ContentType.APPLICATION_OCTET_STREAM,     f.getName() );  HttpEntity multipart = builder.build(); uploadFile.setEntity(multipart); CloseableHttpResponse response = httpClient.execute(uploadFile); HttpEntity responseEntity = response.getEntity();"
