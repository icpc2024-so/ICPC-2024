code
"final String path = ""sample/folder""; final File jarFile = new File(getClass().getProtectionDomain().getCodeSource().getLocation().getPath());  if(jarFile.isFile()) {  // Run with JAR file     final JarFile jar = new JarFile(jarFile);     final Enumeration&lt;JarEntry&gt; entries = jar.entries(); //gives ALL entries in jar     while(entries.hasMoreElements()) {         final String name = entries.nextElement().getName();         if (name.startsWith(path + ""/"")) { //filter according to the path             System.out.println(name);         }     }     jar.close(); } else { // Run with IDE     final URL url = Launcher.class.getResource(""/"" + path);     if (url != null) {         try {             final File apps = new File(url.toURI());             for (File app : apps.listFiles()) {                 System.out.println(app);             }         } catch (URISyntaxException ex) {             // never happens         }     } }"
Document retDoc; byte[] c14nOutputbytes; DocumentBuilderFactory factory; DocumentBuilder parser;  // CANONICALIZE THE ORIGINAL DOM c14nOutputbytes = Canonicalizer.getInstance(Canonicalizer.ALGO_ID_C14N_WITH_COMMENTS).canonicalizeSubtree(inXMLDoc.getDocumentElement());  // PARSE THE CANONICALIZED BYTES (IF YOU WANT ANOTHER DOM) OR JUST USE THE BYTES factory = DocumentBuilderFactory.newInstance(); factory.set ... // SETUP THE FACTORY parser = factory.newDocumentBuilder(); // REPARSE TO GET ANOTHER DOM WITH THE ATTRIBUTES IN ALPHA ORDER ByteArrayInputStream bais = new ByteArrayInputStream(c14nOutputbytes); retDoc = parser.parse(bais);
"DiffFormatter formatter = new DiffFormatter( System.out ); formatter.setRepository( git.getRepository() ); AbstractTreeIterator commitTreeIterator = prepareTreeParser( git.getRepository(),  Constants.HEAD ); FileTreeIterator workTreeIterator = new FileTreeIterator( git.getRepository() ); List&lt;DiffEntry&gt; diffEntries = formatter.scan( commitTreeIterator, workTreeIterator );  for( DiffEntry entry : diffEntries ) {   System.out.println( ""Entry: "" + entry + "", from: "" + entry.getOldId() + "", to: "" + entry.getNewId() );   formatter.format( entry ); }"
"String insert = ""INSERT INTO queries (data_id, query, query_name,"" +         "" query_file_name, status) VALUES (?,?,?,?,?)"";  PreparedStatement stmt = dbconn.prepareStatement(insert, Statement.RETURN_GENERATED_KEYS); // Why do you set this if you want the DB to generate it? stmt.setInt(1, currentDataID); // or setLong() depending on data type stmt.setString(2, params[1]); // I assume params is a String[] stmt.setString(3, params[2]); stmt.setString(4, params[3]); stmt.setString(5, params[4]); stmt.execute();  ResultSet rs = stmt.getGeneratedKeys(); if (rs.next()) {     // if it's an int, avoid the cast and use rs.getInt(1) instead     currentDataID = (int) rs.getLong(1); }"
"if (!window.Clipboard) {    var pasteCatcher = document.createElement(""apDiv1"");    pasteCatcher.setAttribute(""contenteditable"", """");    pasteCatcher.style.opacity = 0;    document.body.appendChild(pasteCatcher);    pasteCatcher.focus();    document.addEventListener(""click"", function() { pasteCatcher.focus(); }); }   window.addEventListener(""paste"", onPasteHandler);  function onPasteHandler(e) {     if(e.clipboardData) {         var items = e.clipboardData.items;         if(!items){             alert(""Image Not found"");         }         for (var i = 0; i &lt; items.length; ++i) {         if (items[i].kind === 'file' &amp;&amp; items[i].type === 'image/png') {             var blob = items[i].getAsFile(),                 source = window.webkitURL.createObjectURL(blob);              pastedImage = new Image();             pastedImage.src = source;              pasteData();             }         }     } }  function pasteData() {     drawCanvas = document.getElementById('drawCanvas1');     ctx = drawCanvas.getContext( '2d' );     ctx.clearRect(0, 0, 640,480);     ctx.drawImage(pastedImage, 0, 0); }"
"try {     ProcessBuilder pb = new ProcessBuilder(""/bin/chmod"", ""777"", path);         pb.redirectErrorStream(true); // merge stdout, stderr of process      Process p = pb.start();     InputStreamReader isr = new  InputStreamReader(p.getInputStream());     BufferedReader br = new BufferedReader(isr);      String lineRead;     while ((lineRead = br.readLine()) != null) {         // swallow the line, or print it out - System.out.println(lineRead);     }      int rc = p.waitFor();     // TODO error handling for non-zero rc } catch (IOException e) {     e.printStackTrace(); // or log it, or otherwise handle it } catch (InterruptedException ie) {     ie.printStackTrace(); // or log it, or otherwise handle it }"
"public &lt;A, B&gt; B cast( A sourceObject, Class&lt;B&gt; targetClass ) {     AutoBean&lt;A&gt; sourceBean = AutoBeanUtils.getAutoBean( sourceObject ); // Get the corresponding AutoBean.     HasSplittable splittableBean = ( HasSplittable ) sourceBean;       // Implementation (if still AbstractAutoBean) supports this interface ;)     Splittable splittable = splittableBean.getSplittable().deepCopy(); // If you don't copy it, decode() tries to be clever and returns                                                                        // the original bean!     AutoBean&lt;B&gt; targetBean = AutoBeanCodex.decode( typeFactory, targetClass, splittable ); // Create new AutoBean of                                                                                            // the target type.     return targetBean.as(); // Get the proxy for the outside world. }"
"Process proc = Runtime.getRuntime().exec(cmd) // Start a stream gobbler to read the error stream. StreamGobbler errorGobbler = new StreamGobbler(proc.getErrorStream()); errorGobbler.start();  OutputStreamWriter osw = new OutputStreamWriter(proc.getOutputStream()) osw.write(mailBody) osw.close();  int exitStatus = proc.waitFor(); if (0 != exitStatus) {     /*      * If you had not used a StreamGobbler to read the errorStream, you wouldn't have      * had a chance to know what went wrong with this command execution.      */     LOG.warn(""Error while sending email: "" + errorGobbler.getContent()); }"
"URL urlToDictionary = this.getClass().getResource(""eula/"" + ""eula.txt"");   try {     InputStream stream = urlToDictionary.openStream();     BufferedReader br = new BufferedReader(new InputStreamReader(stream));     String line = null;     StringBuffer lineContent = new StringBuffer();     while((line = br.readLine()) != null){         lineContent.append(line).append(""\n"");     }     br.close().     System.out.println(lineContent.toString()); } catch (IOException e1) {     // TODO Auto-generated catch block     e1.printStackTrace(); }"
"Session sesion = Session.getInstance(System.getProperties()); Store store = sesion.getStore(""imap""); store.connect(host, user, passwd); Folder inbox = store.getFolder(""INBOX""); inbox.open(Folder.READ_WRITE);  // Convert to MimeMessage after search  MimeMessage[] messages = (MimeMessage[]) carpetaInbox.search(new FlagTerm(new Flags(Flags.Flag.SEEN), false)); for (int i = 0 ; i&lt; messages.length ; i++){     // Create a new message using MimeMessage copy constructor     MimeMessage cmsg = new MimeMessage(messages[i]);     // Use this message to read its contents      Object obj = cmsg.getContent();  // .... }"
"JarFile jarFile = new JarFile(""my.jar"");      for(Enumeration&lt;JarEntry&gt; em = jarFile.entries(); em.hasMoreElements();) {           String s= em.nextElement().toString();          if(s.startsWith((""path/to/resource/directory/""))){             ZipEntry entry = jarFile.getEntry(s);              String fileName = s.substring(s.lastIndexOf(""/"")+1, s.length());             if(fileName.endsWith("".yml"")){                 InputStream inStream= jarFile.getInputStream(entry);                 OutputStream out = new FileOutputStream(fileName);                 int c;                 while ((c = inStream.read()) != -1){                     out.write(c);                 }                 inStream.close();                 out.close();              }         }     }       jarFile.close();"
boolean isMultipart = ServletFileUpload.isMultipartContent(request);         if (isMultipart)         {             try              {                 List items = upload.parseRequest(request);                 Iterator iterator = items.iterator();                 while (iterator.hasNext())                  {                     FileItem item = (FileItem) iterator.next();                      if (item.isFormField()) //your code for getting form fields                     {                         String name = item.getFieldName();                         String value = item.getString();                         System.out.println(name+value);                     }                      if (!item.isFormField())                      {                        //your code for getting multipart                      }                 }             }
"try {      String shopName = jComboBox1.getSelectedItem().toString();     String actionCode = jComboBox2.getSelectedItem().toString();      HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();     map.put(""storeName"", shopName);     map.put(""actionCode"", actionCode);      URL reportFileURL = getClass().getResource(""../ireps/AccessCounter.jrxml"");     File reportFile = new File(reportFileURL.toURI());     JasperDesign jasperDesign = JRXmlLoader.load(reportFile);     JasperReport jasperReport = JasperCompileManager.compileReport(jasperDesign);     JasperPrint jasperPrint = JasperFillManager.fillReport(jasperReport, map, con);      JasperViewer jv = new JasperViewer(jasperPrint);     JDialog viewer = new JDialog(this, ""Batch Report"", true);     viewer.setBounds(jv.getBounds());     viewer.getContentPane().add(jv.getContentPane());     viewer.setResizable(true);     viewer.setIconImage(jv.getIconImage());     viewer.setVisible(true);  } catch (JRException exc) {    System.out.println(exc.getMessage()); } catch (URISyntaxException exs) {    System.out.println(exs.getMessage()); }"
"ConfigureForm form = new ConfigureForm(FormType.submit); form.setPersistentItems(false); form.setDeliverPayloads(true); form.setAccessModel(AccessModel.open);  PubSubManager manager        = new PubSubManager(connection, ""pubsub.communitivity.com""); Node myNode = manager.createNode(""http://jabber.org/protocol/geoloc"", form);  StringBuilder body = new StringBuilder(); //ws for readability body.append(""&lt;geoloc xmlns='http://jabber.org/protocol/geoloc' xml:lang='en'&gt;""); body.append(""   &lt;country&gt;Italy&lt;/country&gt;""); body.append(""   &lt;lat&gt;45.44&lt;/lat&gt;""); body.append(""   &lt;locality&gt;Venice&lt;/locality&gt;""); body.append(""   &lt;lon&gt;12.33&lt;/lon&gt;""); body.append(""   &lt;accuracy&gt;20&lt;/accuracy&gt;""); body.append(""&lt;/geoloc&gt;"");  SimplePayload payload = new SimplePayload(                               ""geoloc"",                               ""http://jabber.org/protocol/geoloc"",                                body.toString()); String itemId = ""zz234""; Item&lt;SimplePayload&gt; item = new Item&lt;SimplePayload&gt;(itemId, payload);  // Required to recieve the events being published myNode.addItemEventListener(myEventHandler);  // Publish item myNode.publish(item);"
"package com.bullethq.jawr.postprocessor;  import net.jawr.web.resource.FileNameUtils; import net.jawr.web.resource.bundle.factory.util.PathNormalizer; import net.jawr.web.resource.bundle.postprocess.BundleProcessingStatus; import net.jawr.web.resource.bundle.postprocess.impl.CSSURLPathRewriterPostProcessor; import net.jawr.web.resource.bundle.postprocess.impl.PostProcessorCssImageUrlRewriter;  import java.io.IOException;  public class CustomCssUrlPathRewriterPostProcessor extends CSSURLPathRewriterPostProcessor {      public static final String CUSTOM_URL_PATH_REWRITER = ""customcsspathrewriter"";      public CustomCssUrlPathRewriterPostProcessor() {         super(CUSTOM_URL_PATH_REWRITER);     }      // ========================================================================     // ========================================================================     // ========================================================================     @Override     protected PostProcessorCssImageUrlRewriter createImageUrlRewriter(BundleProcessingStatus status) {         return new CustomPostProcessorCssImageUrlRewriter(status);     }      // ========================================================================     // ========================================================================     // ========================================================================     public class CustomPostProcessorCssImageUrlRewriter extends PostProcessorCssImageUrlRewriter {          public CustomPostProcessorCssImageUrlRewriter(BundleProcessingStatus status) {             super(status);         }          // ========================================================================         // ========================================================================         // ========================================================================         @Override         protected String getUrlPath(String match, String originalPath, String newCssPath) throws IOException {             String url = match.substring(match.indexOf('(') + 1, match.lastIndexOf(')')).trim();              // Remove any quotes if necessary.             String quoteStr = """";             if (url.startsWith(""'"") || url.startsWith(""\"""")) {                 quoteStr = String.valueOf(url.charAt(0));                 url = url.substring(1, url.length() - 1);             }              // We now check if the url ends in a known image file extension             // If not, the url is ignored.             if (FileNameUtils.hasImageExtension(url)) {                 return super.getUrlPath(match, originalPath, newCssPath);             } else {                 // We need to rewrite the path, as any relative URLs will                 // not resolve correctly if Jawr has changed the CSS path.                 url = PathNormalizer.concatWebPath(originalPath, url);                 url = PathNormalizer.getRelativeWebPath(PathNormalizer.getParentPath(newCssPath), url);                 return ""url("" + quoteStr + url + quoteStr + "")"";             }         }     } }"
"try {         BufferedReader in = new BufferedReader(new FileReader(""plaintext.txt""));         String inputDataLine;         while ((inputDataLine = in.readLine()) != null) {             if (!(inputDataLine.contentEquals("" ""))) {                 System.out.println(""What you want to do with a paragraph line"");             } else {                 System.out.println(""What you want to do with a paragraph seperator"");             }         }         in.close();     } catch (IOException e) {     }"
"RepositoryConnection conn = rep.getConnection(); try {    // prepare the query    String queryString = ""SELECT * WHERE {?s ?p ?o . }"";    TupleQuery query = conn.prepareTupleQuery(QueryLanguage.SPARQL, queryString);     // open a file to write the result to it in JSON format    OutputStream out = new FileOutputStream(""/path/to/output.json"");    TupleQueryResultHandler writer = new SPARQLResultJSONWriter(out);     // execute the query and write the result directly to file    query.evaluate(writer);   } finally {    conn.close(); }"
ProcessBuilder processbuilder try  {     processbuilder.directory(file);     processbuilder.redirectErrorStream(true);      process = processbuilder.start();      String readLine;     BufferedReader output = new BufferedReader(new InputStreamReader(process.getInputStream()));     // include this too:      // BufferedReader output = new BufferedReader(new InputStreamReader(process.getErrorStream()));     while((readLine = output.readLine()) != null)     {         m_Logger.info(readLine);     }      process.waitFor(); }
"public void commitData(){      Bundle bundle = new Bundle();     bundle.putString(""key"", txtBuildingName.getText().toString()); //Gets the TEXT that the TEXTVIEW was holding converts it to a String and adds to the Extras bundle     bundle.putString(""key1"", txtDescription.getText().toString()); // Same again     bundle.putString(""key2"", type.getItemAtPosition(type.getSelectedItemPosition()).toString());     bundle.putString(""key3"", project.getItemAtPosition(project.getSelectedItemPosition()).toString());"
"List&lt;GarbageCollectorMXBean&gt; gcList = ManagementFactory.getGarbageCollectorMXBeans();     for(GarbageCollectorMXBean tmpGC : gcList){          System.out.println(""\nName: "" + tmpGC.getName());         System.out.println(""Collection count: "" + tmpGC.getCollectionCount());         System.out.println(""Collection time: "" + tmpGC.getCollectionTime());         System.out.println(""Memory Pools: "");          String[] memoryPoolNames = tmpGC.getMemoryPoolNames();         for(String mpnTmp : memoryPoolNames){             System.out.println(""\t"" + mpnTmp);         }      }      System.out.println( ""Memory Pools Info"" );     List&lt;MemoryPoolMXBean&gt; memoryList = ManagementFactory.getMemoryPoolMXBeans();     for(MemoryPoolMXBean tmpMem : memoryList){          System.out.println(""\nName: "" + tmpMem.getName());         System.out.println(""Usage: "" + tmpMem.getUsage());         System.out.println(""Collection Usage: "" + tmpMem.getCollectionUsage());         System.out.println(""Peak Usage: "" + tmpMem.getPeakUsage());         System.out.println(""Type: "" + tmpMem.getType());         System.out.println(""Memory Manager Names: "") ;          String[] memManagerNames = tmpMem.getMemoryManagerNames();         for(String mmnTmp : memManagerNames){             System.out.println(""\t"" + mmnTmp);         }         System.out.println(""\n"");     }      MemoryUsage mu =ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();     MemoryUsage muNH =ManagementFactory.getMemoryMXBean().getNonHeapMemoryUsage();     System.out.println(             ""Init :""+mu.getInit()+             ""\nMax :""+mu.getMax()+             ""\nUsed :""+mu.getUsed()+             ""\nCommited :""+mu.getCommitted()+             ""\nInit NH :""+muNH.getInit()+             ""\nMax NH :""+muNH.getMax()+             ""\nUsed NH:""+muNH.getUsed()+             ""\nCommited NH:""+muNH.getCommitted());"
"OutputStream os = conn.getOutputStream(); os.write(input.getBytes()); // The input you need to pass to the webservice os.flush(); ... BufferedReader br = new BufferedReader(new InputStreamReader(         (conn.getInputStream()))); // Getting the response from the webservice  String output; System.out.println(""Output from Server .... \n""); while ((output = br.readLine()) != null) {     System.out.println(output); // Instead of this, you could append all your response to a StringBuffer and use `toString()` to get the entire JSON response as a String.     // This string json response can be parsed using any json library. Eg. GSON from Google. }"
"def uploadFile() =      Action( parse.multipartFormData(myPartHandler) )      {       request =&gt; Ok(""Done"")     }  def myPartHandler: BodyParsers.parse.Multipart.PartHandler[MultipartFormData.FilePart[Result]] = {         parse.Multipart.handleFilePart {           case parse.Multipart.FileInfo(partName, filename, contentType) =&gt;             //Still dirty: the path of the file is in the partName...             String path = partName;              //Set up the PipedOutputStream here, give the input stream to a worker thread             val pos:PipedOutputStream = new PipedOutputStream();             val pis:PipedInputStream  = new PipedInputStream(pos);             val worker:UploadFileWorker = new UploadFileWorker(path,pis);             worker.contentType = contentType.get;             worker.start();              //Read content to the POS             Iteratee.fold[Array[Byte], PipedOutputStream](pos) { (os, data) =&gt;               os.write(data)               os             }.mapDone { os =&gt;               os.close()               Ok(""upload done"")             }         }    }"
"DocumentBuilderFactory f = DocumentBuilderFactory.newInstance();     DocumentBuilder builder = f.newDocumentBuilder();      Document d = builder.newDocument();     Element root = d.createElement(""root"");     d.appendChild(root);     root.setTextContent(""this text contains the \u2227 character"");      Transformer t = TransformerFactory.newInstance().newTransformer();     t.setOutputProperty(OutputKeys.ENCODING, ""US-ASCII"");     t.setOutputProperty(OutputKeys.INDENT, ""yes"");     t.transform(new DOMSource(d), new StreamResult(System.out));"
"URL url = MyClass.class.getResource(""MyClass.class""); String scheme = url.getProtocol(); if (!""jar"".equals(scheme))   throw new IllegalArgumentException(""Unsupported scheme: "" + scheme); JarURLConnection con = (JarURLConnection) url.openConnection(); JarFile archive = con.getJarFile(); /* Search for the entries you care about. */ Enumeration&lt;JarEntry&gt; entries = archive.entries(); while (entries.hasMoreElements()) {   JarEntry entry = entries.nextElement();   if (entry.getName().startsWith(""com/y/app/"")) {     ...   } }"
"while ((lineContents = tempFileReader.readLine()) != null) {     String lineByLine = lineContents.replaceAll(""/\\."", System.getProperty(""line.separator"")); //for matching /. and replacing it by new line     changer.write(lineByLine);     Pattern pattern = Pattern.compile("".*\\r?\\n""); //Find new line     Matcher matcher = pattern.matcher(lineByLine);     while(matcher.find())     {         Pattern tagFinder = Pattern.compile(""word""); //Finding the word required         //matcher.group() returns the input subsequence matched by the previous match.         Matcher tagMatcher = tagFinder.matcher(matcher.group());         while(tagMatcher.find())         {             score++;         }         scoreTracker.add(score);             score = 0;     }    }"
"Git git = ... // you get it through a CloneCommand, InitCommand                // or through the file system  CheckoutCommand coCmd = git.checkout();  // Commands are part of the api module, which include git-like calls coCmd.setName(""master""); coCmd.setCreateBranch(false); // probably not needed, just to make sure coCmd.call(); // switch to ""master"" branch  MergeCommand mgCmd = git.merge(); mgCmd.include(""foo""); // ""foo"" is considered as a Ref to a branch MergeResult res = mgCmd.call(); // actually do the merge  if (res.getMergeStatus().equals(MergeResult.MergeStatus.CONFLICTING)){    System.out.println(res.getConflicts().toString());    // inform the user he has to handle the conflicts }"
"public String listToJsonString(List&lt;StyleAttribute&gt; attrs) {         JSONObject jObject = new JSONObject();         try {             JSONArray jArray = new JSONArray();             for (MyClass myObject: attrs) {                 JSONObject styleJSON = new JSONObject();                 styleJSON.put(""name"",myObject.getName());                 styleJSON.put(""rollNumber"", myObject.getRollNumber());                  jArray.add(styleJSON);             }             jObject.put(""keyName"", jArray);         } catch (Exception jse) {         }          return jObject.toString();     }"
"URL url = new URL(urlString);     URLConnection conn = url.openConnection();     conn.setDoOutput(true);     conn.setRequestProperty (""Authorization"", encodedCredentials);      OutputStreamWriter writer = new OutputStreamWriter(conn.getOutputStream());      writer.write(data);     writer.flush();     String line;     BufferedReader reader = new BufferedReader(new                                       InputStreamReader(conn.getInputStream()));     while ((line = reader.readLine()) != null) {       System.out.println(line);     }     writer.close();     reader.close();"
"Connection db = DriverManager.getConnection( jdbc:mysql://192.168.0.3:3306,&lt;user&gt;,&lt;password&gt;); Statement stmt = db.createStatement(); PreparedStatement psmt = con.prepareStatement(""SELECT * FROM DB""); ResultSet rs = psmt.executeQuery();  // get column names int len = rs.getMetaData().getColumnCount(); Vector cols= new Vector(len); for(int i=1; i&lt;=len; i++) // Note starting at 1     cols.add(rs.getMetaData().getColumnName(i));   // Add Data Vector data = new Vector(); while(rs.next()) {     Vector row; = new Vector(len);     for(int i=1; i&lt;=len; i++)     {         row.add(rs.getString(i));     }     data.add(row); }  // Now create the table JTable table = new JTable(data, cols);"
"String input = ""Lorem ipsum dolor sit amet, consectetur adipisicing #{key1}. "" +    ""Proin nibh augue, suscipit a, scelerisque #{key1},"" +     ""lacinia in, mi. Cras vel #{key2}. Etiam pellentesque aliquet tellus."" +     "" Phasellus pharetra nulla ac diam. Quisque semper #{key3} at risus.""; StringBuffer result = new StringBuffer();  Pattern p = Pattern.compile( ""#\\{([\\w\\.]+)\\}"" ); Matcher m = p.matcher( input );  while( m.find() ) {         //extract the message for key = m.group( 1 ) here   //i'll just mark the found keys    m.appendReplacement( result,  ""##"" + m.group( 1 ) + ""##"" );       } m.appendTail( result );  System.out.println(result); //output: ... consectetur adipisicing ##key1## ...  etc."
