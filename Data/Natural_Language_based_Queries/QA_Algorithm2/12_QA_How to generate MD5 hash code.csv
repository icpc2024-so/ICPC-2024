code
"algorithms.put(""MD2WITHRSAENCRYPTION"", PKCSObjectIdentifiers.md2WithRSAEncryption); algorithms.put(""MD2WITHRSA"", PKCSObjectIdentifiers.md2WithRSAEncryption); algorithms.put(""MD5WITHRSAENCRYPTION"", PKCSObjectIdentifiers.md5WithRSAEncryption); algorithms.put(""MD5WITHRSA"", PKCSObjectIdentifiers.md5WithRSAEncryption); algorithms.put(""SHA1WITHRSAENCRYPTION"", PKCSObjectIdentifiers.sha1WithRSAEncryption); algorithms.put(""SHA1WITHRSA"", PKCSObjectIdentifiers.sha1WithRSAEncryption); algorithms.put(""SHA224WITHRSAENCRYPTION"", PKCSObjectIdentifiers.sha224WithRSAEncryption); algorithms.put(""SHA224WITHRSA"", PKCSObjectIdentifiers.sha224WithRSAEncryption); algorithms.put(""SHA256WITHRSAENCRYPTION"", PKCSObjectIdentifiers.sha256WithRSAEncryption); algorithms.put(""SHA256WITHRSA"", PKCSObjectIdentifiers.sha256WithRSAEncryption); algorithms.put(""SHA384WITHRSAENCRYPTION"", PKCSObjectIdentifiers.sha384WithRSAEncryption); algorithms.put(""SHA384WITHRSA"", PKCSObjectIdentifiers.sha384WithRSAEncryption); algorithms.put(""SHA512WITHRSAENCRYPTION"", PKCSObjectIdentifiers.sha512WithRSAEncryption); algorithms.put(""SHA512WITHRSA"", PKCSObjectIdentifiers.sha512WithRSAEncryption); algorithms.put(""SHA1WITHRSAANDMGF1"", PKCSObjectIdentifiers.id_RSASSA_PSS); algorithms.put(""SHA224WITHRSAANDMGF1"", PKCSObjectIdentifiers.id_RSASSA_PSS); algorithms.put(""SHA256WITHRSAANDMGF1"", PKCSObjectIdentifiers.id_RSASSA_PSS); algorithms.put(""SHA384WITHRSAANDMGF1"", PKCSObjectIdentifiers.id_RSASSA_PSS); algorithms.put(""SHA512WITHRSAANDMGF1"", PKCSObjectIdentifiers.id_RSASSA_PSS); algorithms.put(""RIPEMD160WITHRSAENCRYPTION"", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd160); algorithms.put(""RIPEMD160WITHRSA"", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd160); algorithms.put(""RIPEMD128WITHRSAENCRYPTION"", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd128); algorithms.put(""RIPEMD128WITHRSA"", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd128); algorithms.put(""RIPEMD256WITHRSAENCRYPTION"", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd256); algorithms.put(""RIPEMD256WITHRSA"", TeleTrusTObjectIdentifiers.rsaSignatureWithripemd256); algorithms.put(""SHA1WITHDSA"", X9ObjectIdentifiers.id_dsa_with_sha1); algorithms.put(""DSAWITHSHA1"", X9ObjectIdentifiers.id_dsa_with_sha1); algorithms.put(""SHA224WITHDSA"", NISTObjectIdentifiers.dsa_with_sha224); algorithms.put(""SHA256WITHDSA"", NISTObjectIdentifiers.dsa_with_sha256); algorithms.put(""SHA384WITHDSA"", NISTObjectIdentifiers.dsa_with_sha384); algorithms.put(""SHA512WITHDSA"", NISTObjectIdentifiers.dsa_with_sha512); algorithms.put(""SHA1WITHECDSA"", X9ObjectIdentifiers.ecdsa_with_SHA1); algorithms.put(""ECDSAWITHSHA1"", X9ObjectIdentifiers.ecdsa_with_SHA1); algorithms.put(""SHA224WITHECDSA"", X9ObjectIdentifiers.ecdsa_with_SHA224); algorithms.put(""SHA256WITHECDSA"", X9ObjectIdentifiers.ecdsa_with_SHA256); algorithms.put(""SHA384WITHECDSA"", X9ObjectIdentifiers.ecdsa_with_SHA384); algorithms.put(""SHA512WITHECDSA"", X9ObjectIdentifiers.ecdsa_with_SHA512); algorithms.put(""GOST3411WITHGOST3410"", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_94); algorithms.put(""GOST3411WITHGOST3410-94"", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_94); algorithms.put(""GOST3411WITHECGOST3410"", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_2001); algorithms.put(""GOST3411WITHECGOST3410-2001"", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_2001); algorithms.put(""GOST3411WITHGOST3410-2001"", CryptoProObjectIdentifiers.gostR3411_94_with_gostR3410_2001);"
"public String md5(String s) {     try {         // Create MD5 Hash         MessageDigest digest = java.security.MessageDigest.getInstance(""MD5"");         digest.update(s.getBytes());         byte messageDigest[] = digest.digest();          // Create Hex String         StringBuffer hexString = new StringBuffer();         for (int i=0; i&lt;messageDigest.length; i++)             hexString.append(Integer.toHexString(0xFF &amp; messageDigest[i]));         return hexString.toString();      } catch (NoSuchAlgorithmException e) {         e.printStackTrace();     }     return """"; }"
"log4j.rootLogger=debug, stdout, R  log4j.appender.stdout=org.apache.log4j.ConsoleAppender log4j.appender.stdout.layout=org.apache.log4j.PatternLayout  # Pattern to output the caller's file name and line number. log4j.appender.stdout.layout.ConversionPattern=%5p [%t] (%F:%L) - %m%n  log4j.appender.R=org.apache.log4j.RollingFileAppender log4j.appender.R.File=example.log  log4j.appender.R.MaxFileSize=100KB # Keep one backup file log4j.appender.R.MaxBackupIndex=1  log4j.appender.R.layout=org.apache.log4j.PatternLayout log4j.appender.R.layout.ConversionPattern=%p %t %c - %m%n"
"String hashValue = MD5Hash(""URL or HTML"".getBytes());     /**      * MD5 implementation as Hash value       *       * @param a_sDataBytes - a original data as byte[] from String      * @return String as Hex value       * @throws NoSuchAlgorithmException       */      public static String MD5Hash(byte[] dataBytes) throws NoSuchAlgorithmException {         if( dataBytes == null) return """";          MessageDigest md = MessageDigest.getInstance(""MD5"");         md.update(dataBytes);         byte[] digest = md.digest();          // convert it to the hexadecimal          BigInteger bi = new BigInteger(digest);         String s = bi.toString(16);         if( s.length() %2 != 0)         {             s = ""0""+s;         }         return s;     }"
"String dbUri = System.getenv(""DATABASE_URL""); Class.forName(""org.postgresql.Driver""); String username = dbUri.getUserInfo().split("":"")[0]; String password = dbUri.getUserInfo().split("":"")[1]; String dbUrl = ""jdbc:postgresql://"" + dbUri.getHost() + dbUri.getPath() + ""?user="" + username + ""&amp;password="" + password; Connection connection = DriverManager.getConnection(dbUrl);  InputStreamReader inputStreamReader = new InputStreamReader(ClassLoader.getSystemResourceAsStream(sqlFile));  Reader reader = new BufferedReader(inputStreamReader);  ScriptRunner scriptRunner = new ScriptRunner(connection, false, true); scriptRunner.runScript(reader);"
"function encrypt($plaintext, $key) {     $plaintext = pkcs5_pad($plaintext, 16);     return bin2hex(mcrypt_encrypt(MCRYPT_RIJNDAEL_128, hex2bin($key), $plaintext, MCRYPT_MODE_ECB)); }  function decrypt($encrypted, $key) {     $decrypted = mcrypt_decrypt(MCRYPT_RIJNDAEL_128, hex2bin($key), hex2bin($encrypted), MCRYPT_MODE_ECB);     $padSize = ord(substr($decrypted, -1));     return substr($decrypted, 0, $padSize*-1); }  function pkcs5_pad ($text, $blocksize) {     $pad = $blocksize - (strlen($text) % $blocksize);     return $text . str_repeat(chr($pad), $pad); }"
"int number = 7; //just an example, here binary rep: 00111 =&gt; requested output will be 10011     System.out.println(""number = "" + Integer.toBinaryString(number));     int mask3Bit = 4;//binary rep: 0100     System.out.println(""mask3Bit = "" + Integer.toBinaryString(mask3Bit));      int mask5Bit = 16; //binary rep: 10000     System.out.println(""mask5Bit = "" + Integer.toBinaryString(mask5Bit));      // now we'll create a mask that has all the bits on except the 3rd and 5th bit:     int oppositeMask = -1;     oppositeMask ^= mask3Bit;     oppositeMask ^= mask5Bit;     System.out.println(""oppositeMask = "" + Integer.toBinaryString(oppositeMask));      //check if the 3rd bit is on:     mask3Bit = number &amp; mask3Bit;     //shift twice to the right     mask3Bit &lt;&lt;= 2;     System.out.println(""mask3Bit = "" + Integer.toBinaryString(mask3Bit));     //now do the same with the 5th bit     //check if the 5th bit is on:     mask5Bit = number &amp; mask5Bit;     //shift twice to the right     mask5Bit &gt;&gt;= 2;     System.out.println(""mask5Bit = "" + Integer.toBinaryString(mask5Bit));      //now we'll turn off the 3rd and 5th bits in the original number     number &amp;= oppositeMask;     System.out.println(""number = "" + Integer.toBinaryString(number));     //and use the masks to switch the bits     number |= mask3Bit;     number |= mask5Bit;     //let's check it out now:     System.out.println(""new number = "" + Integer.toBinaryString(number));"
"log4j.rootLogger = DEBUG, root   # Root log4j.appender.root=org.apache.log4j.RollingFileAppender log4j.appender.root.File=logs/mainLogInheritable.log log4j.appender.root.Threshold=DEBUG log4j.appender.root.layout=org.apache.log4j.PatternLayout log4j.appender.root.layout.ConversionPattern=%d{ISO8601} %-5p 0 %m%n   # A log4j.appender.myAppenderA=org.apache.log4j.RollingFileAppender log4j.appender.myAppenderA.File=logs/mylogfileA.log #log4j.appender.myAppenderA.additivity=false log4j.appender.myAppenderA.Threshold=DEBUG log4j.appender.myAppenderA.layout=org.apache.log4j.PatternLayout log4j.appender.myAppenderA.layout.ConversionPattern=%d{ISO8601} %-5p 0 %m%n   # perf log4j.appender.perf=org.apache.log4j.RollingFileAppender log4j.appender.perf.File=logs/perf.log #log4j.appender.perf.additivity=false log4j.appender.perf.Threshold=DEBUG log4j.appender.perf.layout=org.apache.log4j.PatternLayout log4j.appender.perf.layout.ConversionPattern=%d{ISO8601} %-5p 0 %m%n    log4j.logger.mypackage.MyClass = DEBUG, myAppenderA  log4j.logger.perf  = DEBUG, perf   log4j.additivity.perf = false  log4j.additivity.mypackage.MyClass = false"
"log4j.rootLogger=DEBUG, CA, FA   # Console Appender  log4j.appender.CA=org.apache.log4j.ConsoleAppender  log4j.appender.CA.layout=org.apache.log4j.PatternLayout  log4j.appender.CA.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n    Â   # File Appender  log4j.appender.FA=org.apache.log4j.FileAppender  log4j.appender.FA.File=sample.log  log4j.appender.FA.layout=org.apache.log4j.PatternLayout  log4j.appender.FA.layout.ConversionPattern=%-4r [%t] %-5p %c %x - %m%n   # Set the logger level of File Appender to WARN  log4j.appender.FA.Threshold = WARN"
"import java.security.MessageDigest; import java.security.NoSuchAlgorithmException; import java.nio.charset.StandardCharsets; import java.math.BigInteger;  public class CryptoHash {   public static void main(String[] args) throws NoSuchAlgorithmException {     MessageDigest md = MessageDigest.getInstance(""SHA-256"");     String text = ""Text to hash, cryptographically."";      // Change this to UTF-16 if needed     md.update(text.getBytes(StandardCharsets.UTF_8));     byte[] digest = md.digest();      String hex = String.format(""%064x"", new BigInteger(1, digest));     System.out.println(hex);   } }"
"Security.addProvider( new org.bouncycastle.jce.provider.BouncyCastleProvider() );  KeyPairGenerator keyPairGenerator = KeyPairGenerator.getInstance( ""ECGOST3410"", ""BC"" ); keyPairGenerator.initialize( new ECGenParameterSpec( ""GostR3410-2001-CryptoPro-A"" ) ); KeyPair keyPair = keyPairGenerator.generateKeyPair();  org.bouncycastle.asn1.x500.X500Name subject = new org.bouncycastle.asn1.x500.X500Name( ""CN=Me"" ); org.bouncycastle.asn1.x500.X500Name issuer = subject; // self-signed BigInteger serial = BigInteger.ONE; // serial number for self-signed does not matter a lot Date notBefore = new Date(); Date notAfter = new Date( notBefore.getTime() + TimeUnit.DAYS.toMillis( 365 ) );  org.bouncycastle.cert.X509v3CertificateBuilder certificateBuilder = new org.bouncycastle.cert.jcajce.JcaX509v3CertificateBuilder(         issuer, serial,         notBefore, notAfter,         subject, keyPair.getPublic() ); org.bouncycastle.cert.X509CertificateHolder certificateHolder = certificateBuilder.build(         new org.bouncycastle.operator.jcajce.JcaContentSignerBuilder( ""GOST3411withECGOST3410"" )                 .build( keyPair.getPrivate() ) ); org.bouncycastle.cert.jcajce.JcaX509CertificateConverter certificateConverter = new org.bouncycastle.cert.jcajce.JcaX509CertificateConverter(); X509Certificate certificate = certificateConverter.getCertificate( certificateHolder );  KeyStore keyStore = KeyStore.getInstance( ""JKS"" ); keyStore.load( null, null ); // initialize new keystore keyStore.setEntry(         ""alias"",         new KeyStore.PrivateKeyEntry(                 keyPair.getPrivate(),                 new Certificate[] { certificate }         ),         new KeyStore.PasswordProtection( ""entryPassword"".toCharArray() ) ); keyStore.store( new FileOutputStream( ""test.jks"" ), ""keystorePassword"".toCharArray() );"
"String userName = request.getParameter(""userName""); String passWord = request.getParameter(""password"");  String driver = ""com.mysql.jdbc.Driver""; String url = ""jdbc:mysql://localhost:3306/""; String dbName = ""userdb""; String user = ""root"";  String password = ""1234""; String sql = ""SELECT * FROM LOGIN WHERE USR_NAME = ? AND USR_PASS = ?""; // Not sure how the password column is named, you need to check/update it. You should leave those ? there! Those are preparedstatement placeholders.  Connection connection = null; PreparedStatement statement = null; ResultSet resultSet = null; boolean login = false;  try {     Class.forName(driver); // You don't need to call it EVERYTIME btw. Once during application's startup is more than enough.     connection = DriverManager.getConnection(url + dbName, user, password);     statement = connection.prepareStatement(sql);     statement.setString(1, userName);     statement.setString(2, password);     resultSet = statement.executeQuery();     login = resultSet.next(); } catch (Exception e) {     throw new ServletException(""Login failed"", e); } finally {     if (resultSet != null) try { resultSet.close(); } catch (SQLException ignore) {}     if (statement != null) try { statement.close(); } catch (SQLException ignore) {}     if (connection != null) try { connection.close(); } catch (SQLException ignore) {} }  if (login) {     request.getSession().setAttribute(""username"", userName); // I'd prefer the User object, which you get from DAO, but ala.     response.sendRedirect(""home.jsp""); // Redirect to home page. } else {     request.setAttribute(""message"", ""Unknown username/password, try again""); // This sets the ${message}     request.getRequestDispatcher(""login.jsp"").forward(request, response); // Redisplay JSP. }"
"log4j.rootLogger=DEBUG,DB log4j.appender.DB=org.apache.log4j.jdbc.JDBCAppender log4j.appender.DB.URL=jdbc:mysql://localhost:3306/test log4j.appender.DB.user=root log4j.appender.DB.password=root log4j.appender.DB.sql=INSERT INTO logs(date, user, message,class) VALUES ('%d{yyyy-MM-dd HH:mm:ss}', '%X{User}','%m','%c') log4j.appender.DB.layout=org.apache.log4j.PatternLayout log4j.appender.CA.layout.ConversionPattern=INSERT INTO logs (date, user,message,class) VALUES ('%d{yyyy-MM-dd HH:mm:ss}', '%X{User}','%m','%c')  log4j.category.ke.co=ERROR log4j.category.ke.co.appender-ref=DB"
"String insert = ""INSERT INTO queries (data_id, query, query_name,"" +         "" query_file_name, status) VALUES (?,?,?,?,?)"";  PreparedStatement stmt = dbconn.prepareStatement(insert, Statement.RETURN_GENERATED_KEYS); // Why do you set this if you want the DB to generate it? stmt.setInt(1, currentDataID); // or setLong() depending on data type stmt.setString(2, params[1]); // I assume params is a String[] stmt.setString(3, params[2]); stmt.setString(4, params[3]); stmt.setString(5, params[4]); stmt.execute();  ResultSet rs = stmt.getGeneratedKeys(); if (rs.next()) {     // if it's an int, avoid the cast and use rs.getInt(1) instead     currentDataID = (int) rs.getLong(1); }"
"QString encrypt(QByteArray r, const QString &amp;password)  { const char *sample = r.data(); string plain = password.toStdString(); string ciphertext; // Generate Cipher, Key, and CBC byte key[ AES::MAX_KEYLENGTH ], iv[ AES::BLOCKSIZE ]; //StringSource( reinterpret_cast&lt;const char *&gt;(sample), true, //              new HashFilter(*(new SHA256), new ArraySink(key, AES::MAX_KEYLENGTH)) ); for(int i=0; i&lt; AES::MAX_KEYLENGTH; ++i){     key[i] = reinterpret_cast&lt;const char *&gt;(decodedKey)[i]; } memset( iv, 0x00, AES::BLOCKSIZE ); CBC_Mode&lt;AES&gt;::Encryption Encryptor( key, sizeof(key), iv ); StringSource( plain, true, new StreamTransformationFilter( Encryptor,               new HexEncoder(new StringSink( ciphertext ) ) ) ); return QString::fromStdString(ciphertext); }"
"public class SQL {     private final static String DRIVER_CLASS_NAME = ""com.mysql.jdbc.Driver"";     private final static String USERNAME = ""secret"";     private final static String PASSWORD = ""secret"";     private final static String URL = ""secret"";      private final static DataSource dataSource;      static {         BasicDataSource basicDataSource = new BasicDataSource();         basicDataSource.setDriverClassName(DRIVER_CLASS_NAME);         basicDataSource.setUrl(URL);         basicDataSource.setUsername(USERNAME);         basicDataSource.setPassword(PASSWORD);          dataSource = basicDataSource;     }      public static DataSource getDataSource() {         return dataSource;     } }"
"Connection con = ....;  // turn on support for dbms_output CallableStatement cstmt = con.prepareCall(""{call dbms_output.enable(32000) }""); cstmt.execute();  // run your PL/SQL block Statement stmt = con.createStatement(); String sql =     ""declare  \n"" +     "" a number;  \n"" +     "" cursor c1 is select id from foo;  \n"" +     ""begin  \n"" +     ""  open c1; \n"" +     ""  loop \n"" +     ""    fetch c1 into a;  \n"" +     ""    exit when c1%notfound;  \n"" +     ""    dbms_output.put_line('ID: '||to_char(a)); \n"" +     ""  end loop; \n"" +     ""end;""; stmt.execute(sql);  // retrieve the messages written with dbms_output cstmt = con.prepareCall(""{call dbms_output.get_line(?,?)}""); cstmt.registerOutParameter(1,java.sql.Types.VARCHAR); cstmt.registerOutParameter(2,java.sql.Types.NUMERIC);  int status = 0; while (status == 0) {     cstmt.execute();     String line = cstmt.getString(1);     status = cstmt.getInt(2);     if (line != null &amp;&amp; status == 0)     {         System.out.println(line);     } }"
"Map &lt;String,Integer&gt; m = new HashMap&lt;String,Integer&gt;();  m.put(""A"", 1); m.put(""B"", 2); m.put(""C"", 3);  // Iterate over keys for (String key : m.keySet()) {     System.out.println(""Key=[""+key+""], value=[""+m.get(key)+""]""); }  // Iterate over values for (Integer value : m.values()) {     System.out.println(""Value=[""+value+""]""); }  // Iterate over entrySet for (Map.Entry&lt;String,Integer&gt; entry : m.entrySet()) {     System.out.println(""Key=[""+entry.getKey()+""], value=[""+entry.getValue()+""]""); }"
"try         {             Class.forName(""sun.jdbc.odbc.JdbcOdbcDriver"");             String connString=""jdbc:odbc:Driver={Microsoft dBASE Driver (*.dbf)};DefaultDir=E:\\db"";//DeafultDir indicates the location of the db             Connection connection=DriverManager.getConnection(connString);             String sql=""SELECT * FROM table_name where condition"";// usual sql query             Statement stmt=connection.createStatement();             ResultSet resultSet=stmt.executeQuery(sql);             while(resultSet.next())             {                 System.out.println();             }             System.out.println();         }         catch (ClassNotFoundException e)         {             e.printStackTrace();         }         catch (SQLException e)         {             e.printStackTrace();         }"
"import java.util.ArrayList; import java.util.List; import javax.swing.table.AbstractTableModel;  /** @see http://stackoverflow.com/questions/5438516 */ public class Nodes extends AbstractTableModel {      private List&lt;Node&gt; nodes = new ArrayList&lt;Node&gt;();      @Override     public int getRowCount() {         return nodes.size();     }      @Override     public int getColumnCount() {         return 5; // A Node has five members     }      @Override     public Object getValueAt(int row, int col) {         Node node = nodes.get(row);         switch (col) {             case 0:                 return node.name;             case 1:                 return node.value;             case 2:                 return node.first;             case 3:                 return node.second;             case 4:                 return node.values;             default:                 return null;         }     }      @Override     public Class getColumnClass(int c) {         return getValueAt(0, c).getClass();     }      private class Node {          private String name;         private double value;         private List&lt;Node&gt; first;         private List&lt;Node&gt; second;         private List&lt;Double&gt; values;     } }"
"ClassLoader cl = HCTest.class.getClassLoader(); URL url = cl.getResource(""test.keystore""); KeyStore keystore  = KeyStore.getInstance(""jks""); char[] pwd = ""nopassword"".toCharArray(); keystore.load(url.openStream(), pwd);  TrustManagerFactory tmf = TrustManagerFactory.getInstance(         TrustManagerFactory.getDefaultAlgorithm()); tmf.init(keystore); TrustManager[] tm = tmf.getTrustManagers();  KeyManagerFactory kmfactory = KeyManagerFactory.getInstance(         KeyManagerFactory.getDefaultAlgorithm()); kmfactory.init(keystore, pwd); KeyManager[] km = kmfactory.getKeyManagers();  SSLContext sslcontext = SSLContext.getInstance(""TLS""); sslcontext.init(km, tm, null);  LocalTestServer localServer = new LocalTestServer(sslcontext); localServer.registerDefaultHandlers();  localServer.start(); try {      DefaultHttpClient httpclient = new DefaultHttpClient();     TrustStrategy trustStrategy = new TrustStrategy() {          public boolean isTrusted(X509Certificate[] chain, String authType) throws CertificateException {             for (X509Certificate cert: chain) {                 System.err.println(cert);             }             return false;         }      };      SSLSocketFactory sslsf = new SSLSocketFactory(""TLS"", null, null, keystore, null,             trustStrategy, new AllowAllHostnameVerifier());     Scheme https = new Scheme(""https"", 443, sslsf);     httpclient.getConnectionManager().getSchemeRegistry().register(https);      InetSocketAddress address = localServer.getServiceAddress();     HttpHost target1 = new HttpHost(address.getHostName(), address.getPort(), ""https"");     HttpGet httpget1 = new HttpGet(""/random/100"");     HttpResponse response1 = httpclient.execute(target1, httpget1);     System.err.println(response1.getStatusLine());     HttpEntity entity1 = response1.getEntity();     EntityUtils.consume(entity1);     HttpHost target2 = new HttpHost(""www.verisign.com"", 443, ""https"");     HttpGet httpget2 = new HttpGet(""/"");     HttpResponse response2 = httpclient.execute(target2, httpget2);     System.err.println(response2.getStatusLine());     HttpEntity entity2 = response2.getEntity();     EntityUtils.consume(entity2); } finally {     localServer.stop(); }"
"try{         String dbName = t12.getText();//assuming dbName is t12.getText();         Class.forName(""com.mysql.jdbc.Driver"");         Connection con = DriverManager.getConnection(""jdbc:mysql://localhost/"",""root"","""");//use your username and password for connection         Statement statement = con.createStatement();         int resultset = statement.executeUpdate(""create database "" + dbName );     }catch(SQLException e){         e.printStackTrace();     }catch(ClassNotFoundException e){         e.printStackTrace();     }"
"public List&lt;MessageSummary&gt; getMessages(Object[] params) {   // mList is filled with objects created in MessageRowMapper,   // so the length of the list equal to the number of rows in the ResultSet   List&lt;MessageSummary&gt; mList = jdbcTemplate.query(sqlStr, new MessageRowMapper(),                                                   params);   return mList; }  private final class MessageRowMapper implements RowMapper&lt;MessageSummary&gt; {   @Override   public MessageSummary mapRow(ResultSet rs, int i) throws SQLException   {     MessageSummary ms = new MessageSummary();      ms.setId(rs.getInt(""id""));     ms.setMessage(rs.getString(""message""));      return ms;   } }"
"public class DBConnectionManager  {     public static final String DB_URL = ""jdbc/RSRC/my/connection/mydb""      public Connection getConnection (String jndiLookup)     {         DataSource ds = ServiceLocator.getInstance().getDataSource(jndiLookup);          return ds.getconnection();     }       public Connection getConnection(String driver, String url, String username, String password)         throws ClassNotFoundException, SQLException     {         Class.forName(driver);          return DriverManager.getConnection(url, username, password);     } }  public class MyDAO  {     private Connection connection;      public MyDao(Connection connection)     {         this.connection = connection;     }      public SomeBean getContents (String id)     {         CallableStatement cs = this.connection.prepareCall(""{call myStorProc(?)}"");         this.connection.setString(1, id);          //code to call resultset and retrieve SomeBean goes here          return someBean;                     } }"
"String sql = ""Select * from Activity""; Statement stmt = connection.createStatement(); ResultSet rs = stmt.executeQuery( sql ); ResultSetMetaData md = rs.getMetaData(); int columns = md.getColumnCount();  //  Get column names  for (int i = 1; i &lt;= columns; i++) {     columnNames.addElement( md.getColumnName(i) ); }  //  Get row data  while (rs.next()) {     Vector row = new Vector(columns);      for (int i = 1; i &lt;= columns; i++)     {         row.addElement( rs.getObject(i) );     }      data.addElement( row ); }"
"final String INSERT_SQL = ""insert into my_test (name) values(?)""; final String name = ""Rob"";  KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(     new PreparedStatementCreator() {         public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {             PreparedStatement ps =                 connection.prepareStatement(INSERT_SQL, new String[] {""id""});             ps.setString(1, name);             return ps;         }     },     keyHolder);  // keyHolder.getKey() now contains the generated key"
"final String INSERT_SQL = ""insert into my_test (name) values(?)""; final String name = ""Rob""; KeyHolder keyHolder = new GeneratedKeyHolder(); jdbcTemplate.update(     new PreparedStatementCreator() {         public PreparedStatement createPreparedStatement(Connection connection) throws SQLException {             PreparedStatement ps =                 connection.prepareStatement(INSERT_SQL, new String[] {""id""});             ps.setString(1, name);             return ps;         }     },     keyHolder); // keyHolder.getKey() now contains the generated key"
"MultigetSliceCounterQuery&lt;String, String&gt; query=HFactory.createMultigetSliceCounterQuery(keyspace, se, se); query.setColumnFamily(""MyCounters"").setKeys(list).setRange(null, null, false, 3); CounterRows&lt;String,String&gt; resultRows1 = query.execute().get();  for (CounterRow&lt;String, String&gt; row : resultRows1) {     System.out.println(""Row Key ""+ row.getKey());     for (HCounterColumn&lt;String&gt; col : row.getColumnSlice().getColumns())         System.out.println(""column Name ""+col.getName()+""column value ""+col.getValue());     } }"
"static final String LOGBACK_XML =      ""&lt;configuration debug='true'&gt;"" +      ""  &lt;appender name='FILE' class='ch.qos.logback.core.RollingFileAppender'&gt;"" +     ""    &lt;file&gt;foo.log&lt;/file&gt;"" +     ""    &lt;append&gt;true&lt;/append&gt;"" +     ""    &lt;encoder&gt;"" +     ""      &lt;pattern&gt;%-4relative [%thread] %-5level %logger{35} - %msg%n&lt;/pattern&gt;"" +     ""    &lt;/encoder&gt;"" +     ""  &lt;/appender&gt;"" +     ""  &lt;root level='INFO'&gt;"" +     ""    &lt;appender-ref ref='FILE' /&gt;"" +     ""  &lt;/root&gt;"" +     ""&lt;/configuration&gt;""     ;  static public void configLogback() {     LoggerContext lc = (LoggerContext) LoggerFactory.getILoggerFactory();             try {            JoranConfigurator configurator = new JoranConfigurator();            configurator.setContext(lc);            lc.reset();             configurator.doConfigure(new ByteArrayInputStream(LOGBACK_XML.getBytes()));        } catch (JoranException je) {            je.printStackTrace();        }         // you can also print the errors/warning explicitly (instead of debug='true' in xml)        //StatusPrinter.printInCaseOfErrorsOrWarnings(lc); }"
"public class DBConnect extends SQLiteOpenHelper  {     public String DB_PATH;     public String DB_NAME;     public final String DB_PART1_NAME=""Database.sqlite"";      public SQLiteDatabase db;     private final Context myContext;     private final String TAG=""DBConnect"";     private final static int DATABASE_VERSION = 1;      /**      * Constructor Takes and keeps a reference of the passed context in order to      * access to the application assets and resources.      *       * @param context      * @param db_name      */     public DBConnect(Context context,String db_name)      {         super(context, db_name, null, DATABASE_VERSION);         this.myContext = context;          DB_PATH = Global.DB_PATH;         DB_NAME = db_name;         try{             createDataBase();             openDataBase();         } catch (IOException e) {             e.printStackTrace();         } catch (Exception e) {             e.printStackTrace();         }     }      /**      * Creates a empty database on the system and rewrites it with your own      * database.      * */     public void createDataBase() throws Exception       {         boolean dbExist = checkDataBase();         if (dbExist){             System.out.println(""Database Exist"");         }         else         {             this.getReadableDatabase();             try{                 copyDataBase();             }catch (Exception e){                 throw new Error(e.getMessage());             }         }      }      /**      * Check if the database already exist to avoid re-copying the file each      * time you open the application.      *       * @return true if it exists, false if it doesn't      */     private boolean checkDataBase()       {         SQLiteDatabase checkDB = null;         try          {             String myPath = DB_PATH + DB_NAME;             checkDB = SQLiteDatabase.openDatabase(myPath, null, SQLiteDatabase.OPEN_READWRITE);         }catch (Exception e){             System.out.println(""database does't exist yet."");         }          if (checkDB != null){             checkDB.close();             System.out.println(""My db is:- "" + checkDB.isOpen());             return true;         }         else              return false;      }      public void copyCacheToMain(DBConnect objCache)throws IOException      {         // Open your local db as the input stream         String inFileName = objCache.DB_PATH + objCache.DB_NAME;         InputStream myInput = new FileInputStream(inFileName);          // Path to the just created empty db         String outFileName = DB_PATH + DB_NAME;          // Open the empty db as the output stream         OutputStream myOutput = new FileOutputStream(outFileName);          // transfer bytes from the inputfile to the outputfile         byte[] buffer = new byte[1024];         int length;         while ((length = myInput.read(buffer)) &gt; 0)           {             myOutput.write(buffer, 0, length);          }          // Close the streams         myOutput.flush();         myOutput.close();         myInput.close();         Log.d(""CTM"",""Cache To Main Database Copied !"");      }     /**      * Copies your database from your local assets-folder to the just created      * empty database in the system folder, from where it can be accessed and      * handled. This is done by transfering bytestream.      * */      private  void copyDataBase() throws Exception      {         try {             if(DB_NAME.equalsIgnoreCase(Global.DB_MAIN))             {                 InputStream myInput = myContext.getAssets().open(DB_PART1_NAME);                 String outFileName = DB_PATH + DB_NAME;                 OutputStream myOutput = new FileOutputStream(outFileName);                 byte[] buffer = new byte[1024];                 int length;                  while ((length = myInput.read(buffer)) &gt; 0){                     myOutput.write(buffer, 0, length);                 }                 myInput.close();                 myOutput.flush();                 myOutput.close();             }             else {                 InputStream myInput = myContext.getAssets().open(DB_NAME);                 String outFileName = DB_PATH + DB_NAME;                 OutputStream myOutput = new FileOutputStream(outFileName);                 byte[] buffer = new byte[1024];                 int length;                  while ((length = myInput.read(buffer)) &gt; 0){                     myOutput.write(buffer, 0, length);                 }                 myInput.close();                 myOutput.flush();                 myOutput.close();             }             System.out.println(DB_NAME+""Database Copied !"");         } catch (Exception e) {             e.printStackTrace();             throw e;         }     }      public void openDataBase() throws SQLException      {         // Open the database         String myPath = DB_PATH + DB_NAME;         db = SQLiteDatabase.openDatabase(myPath, null,SQLiteDatabase.OPEN_READWRITE);     }      @Override     public synchronized void close()      {         if (db != null)             db.close();         System.out.println(""My db is:- "" + db.isOpen());         super.close();     }      public synchronized void execNonQuery(String sql) {         try {             db.execSQL(sql);             Log.d(""SQL"",sql );                   } catch (Exception e) {             Log.e(""Err"",e.getMessage());                     } finally {             //closeDb();             }     }     public synchronized Cursor execQuery(String sql) {         Cursor cursor=null;         try {             cursor = db.rawQuery(sql, null);             Log.d(""SQL"",sql );                   } catch (Exception e) {             Log.e(""Err"",e.getMessage());                     } finally {             //closeDb();             }         return cursor;     }     public synchronized Cursor execQuery(String sql, String[] selectionArgs) {         Cursor cursor=null;         try {             cursor = db.rawQuery(sql, selectionArgs);             Log.d(""SQL"",sql );                   } catch (Exception e) {             Log.e(""Err"",e.getMessage());                     } finally {             //closeDb();             }         return cursor;     }     public long insert(String tblName, Object myObj)     {         ContentValues initialValues = new ContentValues();         long result = -1;          Field[] fields =  myObj.getClass().getFields();              try{                 for (Field field : fields){                     initialValues.put(field.getName(), (String) field.get(myObj)); //                  Log.i(TAG, field.getName()+"" = ""+initialValues.getAsString(field.getName()));                 }                 result = db.insertOrThrow(tblName, null, initialValues);             } catch (IllegalArgumentException e) {                               e.printStackTrace();             } catch (IllegalAccessException e) {                                 e.printStackTrace();             }catch (SQLException e) {                 e.printStackTrace();             }catch (Exception e) {                 e.printStackTrace();             }         return result;     }      /**      *       * @param sqlQuery SQL query to be fired      * @param myObj Object to be fetched      * @return Returns a Vector object containing raws fetched by the sqlQuery      */      public ArrayList&lt;Object&gt; fetchAllRows(String sqlQuery, Object myObj)     {         ArrayList&lt;Object&gt; records = new ArrayList&lt;Object&gt;();         Object newObj;         Cursor cursor = execQuery(sqlQuery);          if (cursor != null) {             while (cursor.moveToNext()) {                 //          System.out.println(""Test While"");                 newObj = ClassUtils.newObject(myObj);                 for (int i = 0; i &lt; cursor.getColumnCount(); i++) {                     String key = cursor.getColumnName(i);                     String value = cursor.getString(i);                     if (value == null) {                         value = """";                     }                     ClassUtils.objectMapping(newObj, key, value);                 }                 records.add(newObj);             }             cursor.close();         }         return records;     }      @Override     public void onCreate(SQLiteDatabase db)      {      }     @Override     public void onUpgrade(SQLiteDatabase db, int oldVersion, int newVersion)      {      } }"
