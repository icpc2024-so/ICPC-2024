code
"package acme.annotation.processing;  import java.util.HashSet; import java.util.Set;  import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.lang.model.element.TypeElement;  import acme.annotation.FooEntity;  @SupportedAnnotationTypes(""*"") public class FooEntityExtendedProcessor extends AbstractProcessor {      private void log(String msg) {         System.out.println(msg);     }      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         log(""Initially I was asked to process:"" + annotations.toString());          Set&lt;TypeElement&gt; fooAnnotations = new HashSet&lt;&gt;();         for (TypeElement elem : annotations) {             if (isFoo(elem)) fooAnnotations.add(elem);         }          if (fooAnnotations.size() &gt; 0) {             log(""... but I am now going to process:"" + fooAnnotations.toString());             processInternal(fooAnnotations, roundEnv);         } else {             log(""... but none of those was my business!"");         }          // always return false so that other processors get a chance to process the annotations not consumed here         return false;     }      private void processInternal(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         // TODO: do your foo processing here     }      private boolean isFoo(TypeElement elem) {         if (elem.getQualifiedName().toString().equals(""acme.annotation.FooEntity"")                 || elem.getAnnotation(FooEntity.class) != null) {             return true;                     } else {             return false;         }     }  }"
"import java.util.Comparator;  public class MyComparator implements Comparator&lt;String&gt; {      @Override     public int compare(String arg0, String arg1) {          int indexOf = arg0.indexOf(""-"");         String substring = arg0.substring(0, indexOf-1);         int indexOf1 = arg1.indexOf(""-"");         String substring1 = arg1.substring(0, indexOf1-1);         return Integer.valueOf(substring) - Integer.valueOf(substring1);     }  }   import java.util.ArrayList; import java.util.Collections; import java.util.Comparator; import java.util.List;  public class Runner {      /**      * @param args      */     public static void main(String[] args) {         // TODO Auto-generated method stub         List&lt;String&gt; entries = new ArrayList&lt;String&gt;();         entries.add(""0 - name1"");         entries.add(""1000 - name2"");         entries.add(""1004 - name4"");         entries.add(""1002 - name3"");         entries.add(""10000 - name5"");         entries.add(""2000 - name5"");          Comparator&lt;String&gt; comparator = new MyComparator();         Collections.sort(entries, comparator );          for (String e : entries){             System.out.println(e);         }      } }"
"import java.util.Hashtable; import javax.naming.Context; import javax.naming.NamingEnumeration; import javax.naming.NamingException; import javax.naming.directory.Attribute; import javax.naming.directory.Attributes; import javax.naming.directory.DirContext; import javax.naming.directory.InitialDirContext; import javax.naming.directory.SearchControls; import javax.naming.directory.SearchResult;  public class SampleLDAPSearch {    private Attribute getCertFromLdap() {       String targetDomain = ""localhost"";       String port = ""10389"";        Hashtable env = new Hashtable();       env.put(DirContext.INITIAL_CONTEXT_FACTORY, ""com.sun.jndi.ldap.LdapCtxFactory"");       SearchControls sc1 = new SearchControls();       sc1.setSearchScope(SearchControls.OBJECT_SCOPE);       sc1.setReturningAttributes(new String[] { ""namingContexts"" });        try {           env.put(DirContext.PROVIDER_URL, ""ldap://"" + targetDomain + "":"" + port);            System.out.println(""ldap://"" + targetDomain + "":"" + port);            DirContext dc = new InitialDirContext(env);           NamingEnumeration directoryNE = null;            System.out.println(""Got HERE!"");           directoryNE = dc.search("""", ""objectclass=*"", sc1);            System.out.println(""SC1 :"" + sc1);           while (directoryNE.hasMore()) {               SearchResult result1 = (SearchResult) directoryNE.next();                // print DN of entry               System.out.println(""Result.getNameInNamespace: "" + result1.getName());               Attributes attrs = result1.getAttributes();               Attribute attr = attrs.get(""namingContexts"");               System.out.println(attr);            }           dc.close();       } catch (NamingException e) {           System.out.println(""No Results for: "" + targetDomain + ""\nProblem: "" + e.getLocalizedMessage() + ""  ""                   + e.getCause());       }       return null;    }    public static void main(String[] args) {       SampleLDAPSearch sls = new SampleLDAPSearch();       sls.getCertFromLdap();   } }"
"char *concatenated; const jbyte *sx; jstring retval;  /* Get the UTF-8 characters that represent our java string */ sx = (*env)-&gt;GetStringUTFChars(env, s, NULL);  /* Concatenate the two strings. */ concatenated = malloc(strlen(""asd "") + strlen(sx) + 1); strcpy(concatenated, ""asd ""); strcat(concatenated, sx);  /* Create java string from our concatenated C string */ retval = (*env)-&gt;NewStringUTF(env, concatenated);  /* Free the memory in sx */ (*env)-&gt;ReleaseStringUTFChars(env, s, sx);  /* Free the memory in concatenated */ free(concatenated);  return retval;"
"import static java.util.Arrays.asList;  import java.util.Comparator; import java.util.Iterator; import java.util.List; import java.util.PriorityQueue;  public class MergingIterator&lt;T&gt; implements Iterator&lt;T&gt; {      public static class InputIter&lt;T&gt; {         final Iterator&lt;T&gt; source;         T data;          public InputIter(Iterable&lt;T&gt; list) {             source = list.iterator();             read();         }          public void read() {             if (source.hasNext()) {                 data = source.next();             } else {                 data = null;             }         }     }      final PriorityQueue&lt;InputIter&lt;T&gt;&gt; queue;      public MergingIterator(final Comparator&lt;? super T&gt; cmp, Iterable&lt;T&gt;... lists) {         queue = new PriorityQueue&lt;InputIter&lt;T&gt;&gt;(lists.length, new Comparator&lt;InputIter&lt;T&gt;&gt;() {             @Override             public int compare(InputIter&lt;T&gt; o1, InputIter&lt;T&gt; o2) {                 return cmp.compare(o1.data, o2.data);             }         });         for (Iterable&lt;T&gt; list : lists) {             InputIter&lt;T&gt; ii = new InputIter&lt;T&gt;(list);             if (ii.data != null) {                 queue.add(ii);             }         }     }      @Override     public boolean hasNext() {         return !queue.isEmpty();     }      @Override     public T next() {         InputIter&lt;T&gt; ii = queue.poll();         T next = ii.data;         ii.read();         if (ii.data != null) {             queue.add(ii);         }         return next;     }      @Override     public void remove() {         throw new UnsupportedOperationException();     } }"
"import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.TypeElement;  @SupportedSourceVersion(SourceVersion.RELEASE_7) @SupportedAnnotationTypes(""*"") public class Processor extends AbstractProcessor {      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         ImportScanner scanner = new ImportScanner();         scanner.scan(roundEnv.getRootElements(), null);          Set&lt;String&gt; importedTypes = scanner.getImportedTypes();         // do something with the types          return false;     }  }"
"import java.io.IOException; import java.io.StringReader;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException;  import org.w3c.dom.Document; import org.w3c.dom.Element; import org.xml.sax.InputSource; import org.xml.sax.SAXException;   public class GetNamedItemNSTester {     public static void main(String[] args)     {         new GetNamedItemNSTester();          }      String xml = ""&lt;xml xmlns:log=\""http://sample.com\""&gt;\n"" +             ""\n"" +             ""&lt;test log:writer=\""someWriter\"" /&gt;\n"" +             ""\n"" +             ""&lt;/xml&gt;"";       public GetNamedItemNSTester()     {         StringReader xmlReader = new StringReader(xml);         try         {             DocumentBuilderFactory factory =                 DocumentBuilderFactory.newInstance();             factory.setNamespaceAware(true);             DocumentBuilder builder = factory.newDocumentBuilder();             Document doc = builder.parse(new InputSource(xmlReader));              Element currentNode =                 (Element)doc.getElementsByTagName(""test"").item(0);             String attributeValue = currentNode.getAttributes()                 .getNamedItemNS(""http://sample.com"", ""writer"").getNodeValue();             System.out.println(""Attribute value is "" + attributeValue);         }         catch (ParserConfigurationException e)         {             e.printStackTrace();         }         catch (SAXException e)         {             e.printStackTrace();         }         catch (IOException e)         {             e.printStackTrace();         }         finally         {             xmlReader.close();         }     } }"
"public class javatesting.JavaTesting extends java.lang.Object{ public javatesting.JavaTesting();   Code:    0:   aload_0    1:   invokespecial   #1; //Method java/lang/Object.""&lt;init&gt;"":()V    4:   return  public static void main(java.lang.String[]);   Code:    0:   ldc     #2; //String 1;2;3    2:   astore_1    3:   aload_1    4:   ldc     #3; //String ;    6:   invokevirtual   #4; //Method java/lang/String.split:(Ljava/lang/String;) [Ljava/lang/String;    9:   astore_2    10:  aload_2    11:  astore_3    12:  aload_3    13:  arraylength    14:  istore  4    16:  iconst_0    17:  istore  5    19:  iload   5    21:  iload   4    23:  if_icmpge       41    26:  aload_3    27:  iload   5    29:  aaload    30:  astore  6    32:  aconst_null    33:  astore  6    35:  iinc    5, 1    38:  goto    19    41:  return  }"
"import java.util.ArrayList; import java.util.Enumeration; import java.util.List; import javax.jms.JMSException; import javax.jms.MessageConsumer; import javax.jms.MessageProducer; import javax.jms.Queue; import javax.jms.QueueBrowser; import javax.jms.QueueConnection; import javax.jms.QueueConnectionFactory; import javax.jms.Session; import javax.jms.TextMessage;  import oracle.AQ.AQQueueTable; import oracle.AQ.AQQueueTableProperty; import oracle.jms.AQjmsDestination; import oracle.jms.AQjmsDestinationProperty; import oracle.jms.AQjmsFactory; import oracle.jms.AQjmsSession;  public class OracleAQClient {  public static QueueConnection getConnection() {      String hostname = ""localhost"";     String oracle_sid = ""xe"";     int portno = 1521;     String userName = ""jmsuser"";     String password = ""jmsuser"";     String driver = ""thin"";     QueueConnectionFactory QFac = null;     QueueConnection QCon = null;     try {         // get connection factory , not going through JNDI here         QFac = AQjmsFactory.getQueueConnectionFactory(hostname, oracle_sid, portno, driver);         // create connection         QCon = QFac.createQueueConnection(userName, password);     } catch (Exception e) {         e.printStackTrace();     }     return QCon; }  public static void createQueue(String user, String qTable, String queueName) {     try {         /* Create Queue Tables */         System.out.println(""Creating Queue Table..."");         QueueConnection QCon = getConnection();         Session session = QCon.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);          AQQueueTableProperty qt_prop;         AQQueueTable q_table = null;         AQjmsDestinationProperty dest_prop;         Queue queue = null;         qt_prop = new AQQueueTableProperty(""SYS.AQ$_JMS_TEXT_MESSAGE"");          q_table = ((AQjmsSession) session).createQueueTable(user, qTable, qt_prop);          System.out.println(""Qtable created"");         dest_prop = new AQjmsDestinationProperty();         /* create a queue */         queue = ((AQjmsSession) session).createQueue(q_table, queueName, dest_prop);         System.out.println(""Queue created"");         /* start the queue */         ((AQjmsDestination) queue).start(session, true, true);      } catch (Exception e) {         e.printStackTrace();         return;     } }  public static void sendMessage(String user, String queueName,String message) {      try {         QueueConnection QCon = getConnection();         Session session = QCon.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);         QCon.start();         Queue queue = ((AQjmsSession) session).getQueue(user, queueName);         MessageProducer producer = session.createProducer(queue);         TextMessage tMsg = session.createTextMessage(message);          //set properties to msg since axis2 needs this parameters to find the operation         tMsg.setStringProperty(""SOAPAction"", ""getQuote"");         producer.send(tMsg);         System.out.println(""Sent message = "" + tMsg.getText());          session.close();         producer.close();         QCon.close();      } catch (JMSException e) {         e.printStackTrace();         return;     } }  public static void browseMessage(String user, String queueName) {     Queue queue;     try {         QueueConnection QCon = getConnection();         Session session = QCon.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);          QCon.start();         queue = ((AQjmsSession) session).getQueue(user, queueName);         QueueBrowser browser = session.createBrowser(queue);         Enumeration enu = browser.getEnumeration();         List list = new ArrayList();         while (enu.hasMoreElements()) {             TextMessage message = (TextMessage) enu.nextElement();             list.add(message.getText());         }         for (int i = 0; i &lt; list.size(); i++) {             System.out.println(""Browsed msg "" + list.get(i));         }         browser.close();         session.close();         QCon.close();      } catch (JMSException e) {         e.printStackTrace();     }  }  public static void consumeMessage(String user, String queueName) {     Queue queue;     try {         QueueConnection QCon = getConnection();         Session session = QCon.createQueueSession(false, Session.CLIENT_ACKNOWLEDGE);         QCon.start();         queue = ((AQjmsSession) session).getQueue(user, queueName);         MessageConsumer consumer = session.createConsumer(queue);         TextMessage msg = (TextMessage) consumer.receive();         System.out.println(""MESSAGE RECEIVED "" + msg.getText());          consumer.close();         session.close();         QCon.close();     } catch (JMSException e) {         e.printStackTrace();     } }  public static void main(String args[]) {     String userName = ""jmsuser"";     String queue = ""sample_aq"";     String qTable = ""sample_aqtbl"";     //createQueue(userName, qTable, queue);     //sendMessage(userName, queue,""&lt;user&gt;text&lt;/user&gt;"");     //browseMessage(userName, queue);     //consumeMessage(userName, queue); }"
"import java.io.BufferedReader; import java.io.IOException; import java.io.InputStreamReader; import java.util.Arrays;  final public class Main {     public static void main(String[] args) throws IOException     {         BufferedReader br=new BufferedReader(new InputStreamReader(System.in));          System.out.print(""Enter the strings:-&gt;"");         String str=br.readLine();          String strArr[]=str.split("" "");//your sentence will be split into words.         Arrays.sort(strArr);          for(int i=0;i&lt;strArr.length;i++)         {             System.out.println(strArr[i]);         }     } }"
"import java.io.File;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory;  import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.NodeList;  public final class LearninXmlDoc {     private static String getTagValue(final Element element)     {         System.out.println(element.getTagName() + "" has attributes: "" + element.hasAttributes());          if (element.getTagName().startsWith(""test""))         {             return element.getAttribute(""w"");          }         else         {             return element.getNodeValue();         }     }      public static void main(String[] args)     {         final String fileName = ""c:\\tmp\\test\\domXml.xml"";          readXML(fileName);     }      private static void readXML(String fileName)     {         Document document;         DocumentBuilder documentBuilder;         DocumentBuilderFactory documentBuilderFactory;         NodeList nodeList;         File xmlInputFile;          try         {             xmlInputFile = new File(fileName);             documentBuilderFactory = DocumentBuilderFactory.newInstance();             documentBuilder = documentBuilderFactory.newDocumentBuilder();             document = documentBuilder.parse(xmlInputFile);             nodeList = document.getElementsByTagName(""*"");              document.getDocumentElement().normalize();              for (int index = 0; index &lt; nodeList.getLength(); index++)             {                 Node node = nodeList.item(index);                 if (node.getNodeType() == Node.ELEMENT_NODE)                 {                     Element element = (Element) node;                      System.out.println(""\tcolour : "" + getTagValue(element));                     System.out.println(""\ttest : "" + getTagValue(element));                     System.out.println(""-----"");                 }             }         }         catch (Exception exception)         {             exception.printStackTrace();         }     } }"
"cmake_minimum_required (VERSION 3.0)  find_package(Java REQUIRED) find_package(JNI REQUIRED) include(UseJava)  enable_testing() project (JNIFoo)  # compile JNIFoo.java to class file set(CMAKE_JAVA_COMPILE_FLAGS ""-source"" ""1.6"" ""-target"" ""1.6"") add_jar(JNIFoo JNIFoo.java) get_target_property(_jarFile JNIFoo JAR_FILE) get_target_property(_classDir JNIFoo CLASSDIR)  # generate JNIFoo.h stub set (_stubDir ""${CMAKE_CURRENT_BINARY_DIR}"") add_custom_command(     OUTPUT JNIFoo.h     COMMAND ${Java_JAVAH_EXECUTABLE} -verbose         -classpath ${_classDir}         -d ${_stubDir}         -jni JNIFoo     DEPENDS JNIFoo     )  # generate libfoo.jnilib include_directories(${JNI_INCLUDE_DIRS} ${_classDir} ${_stubDir}) add_library(foo MODULE foo.c JNIFoo.h) set_target_properties(foo PROPERTIES SUFFIX "".jnilib"") target_link_libraries(foo ${JNI_LIBRARIES})  # add test to run JNIFoo add_test(NAME TestJNIFoo     COMMAND ${Java_JAVA_EXECUTABLE}     -Djava.library.path=${CMAKE_CURRENT_BINARY_DIR}     -cp ${_jarFile} JNIFoo)"
"import java.awt.Component;     import java.awt.event.ActionEvent;     import java.awt.event.ActionListener;      public class ActionListeners implements ActionListener {          public void actionPerformed(ActionEvent B) {              CodeGui Gui = new CodeGui();              if (Gui.num1.getName().equals(((Component) B.getSource()).getName())) {                 // LevelChanger.buttoncount++;                 LevelChanger.incButtonCount(1);             }             if (Gui.num2.getName().equals(((Component) B.getSource()).getName())) {                 // LevelChanger.buttoncount += 2;                 LevelChanger.incButtonCount(2);             }             if (Gui.num3.getName().equals(((Component) B.getSource()).getName())) {                 // LevelChanger.buttoncount += 3;                 LevelChanger.incButtonCount(3);             }             if (Gui.num4.getName().equals(((Component) B.getSource()).getName())) {                 // LevelChanger.buttoncount += 4;                 LevelChanger.incButtonCount(4);             }             if (Gui.num5.getName().equals(((Component) B.getSource()).getName())) {                 // LevelChanger.buttoncount += 5;                 LevelChanger.incButtonCount(5);                 // System.out.println(LevelChanger.buttoncount);             }          }     }       // ===== //       import java.awt.Color;     import java.awt.Font;      import javax.swing.*;     import javax.swing.border.EmptyBorder;      public class CodeGui extends JFrame {         private static final long serialVersionUID = 1L;          ActionListeners Al = new ActionListeners();          protected JPanel contentPane;          JTextArea questionArea, hintArea;         JLabel livesleft, lblLevel, Maxbutclick;         final JButton num1, num2, num3, num4, num5;          public CodeGui() {              setTitle(""The Code Game"");             setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);             setBounds(100, 100, 602, 411);             setResizable(false);             contentPane = new JPanel();             contentPane.setBackground(Color.BLACK);             contentPane.setBorder(new EmptyBorder(5, 5, 5, 5));             setContentPane(contentPane);             contentPane.setLayout(null);              livesleft = new JLabel(""Lives Left : "" + LevelChanger.lives);             livesleft.setFont(new Font(""Stencil Std"", Font.BOLD | Font.ITALIC, 14));             livesleft.setForeground(Color.WHITE);             livesleft.setBounds(10, 347, 126, 14);             contentPane.add(livesleft);              lblLevel = new JLabel(""level : "" + LevelChanger.level);             lblLevel.setFont(new Font(""Stencil Std"", Font.BOLD | Font.ITALIC, 14));             lblLevel.setForeground(Color.WHITE);             lblLevel.setBounds(468, 347, 108, 14);             contentPane.add(lblLevel);              ActionListeners buttonL = new ActionListeners();              num1 = new JButton(""1"");             num1.setBounds(10, 229, 89, 23);             num1.setName(""button1"");             num1.addActionListener(buttonL);             contentPane.add(num1);              num2 = new JButton(""2"");             num2.setBounds(128, 229, 89, 23);             num2.setName(""button2"");             num2.addActionListener(buttonL);             contentPane.add(num2);              num3 = new JButton(""3"");             num3.setBounds(248, 229, 89, 23);             num3.setName(""button3"");             num3.addActionListener(buttonL);             contentPane.add(num3);              num4 = new JButton(""4"");             num4.setBounds(374, 229, 89, 23);             num4.setName(""button4"");             num4.addActionListener(buttonL);             contentPane.add(num4);              num5 = new JButton(""5"");             num5.setBounds(487, 229, 89, 23);             num5.setName(""button5"");             num5.addActionListener(buttonL);             contentPane.add(num5);              questionArea = new JTextArea();             questionArea.setBackground(Color.BLACK);             questionArea.setForeground(Color.WHITE);             questionArea.setLineWrap(true);             questionArea.setFont(new Font(""Myriad Web Pro Condensed"", Font.PLAIN,                     14));             questionArea.setWrapStyleWord(true);             questionArea.setText(LevelChanger.Question);             questionArea.setRows(10);             questionArea.setColumns(5);             questionArea.setBounds(68, 21, 461, 159);             contentPane.add(questionArea);              hintArea = new JTextArea();             hintArea.setForeground(Color.WHITE);             hintArea.setBackground(Color.BLACK);             hintArea.setText(""Hint : "" + LevelChanger.Hint);             hintArea.setBounds(95, 278, 397, 58);             contentPane.add(hintArea);              Maxbutclick = new JLabel(""Max Button count for level : ""                     + LevelChanger.buttonlimit);             Maxbutclick                     .setFont(new Font(""Stencil Std"", Font.BOLD | Font.ITALIC, 11));             Maxbutclick.setBackground(Color.BLACK);             Maxbutclick.setForeground(Color.WHITE);             Maxbutclick.setBounds(321, 263, 255, 14);             contentPane.add(Maxbutclick);          }          public void update() {             livesleft.setText(""Lives Left : "" + LevelChanger.lives);             livesleft.repaint();         }      }       // ===== //       import java.awt.EventQueue;      public class LevelChanger {          private static int buttoncount = 0;         private static CodeGui frame = null;          protected static int buttonlimit = 20;         protected static int answer = 12;         protected static int level = 1;         protected static int lives = 10;         protected static String Hint = """";         protected static String Question = ""default text"";          public static void main(String[] args) {              EventQueue.invokeLater(new Runnable() {                 public void run() {                     try {                         CodeGui frame = new CodeGui();                         LevelChanger.frame = frame;                         frame.setVisible(true);                     } catch (Exception e) {                         e.printStackTrace();                     }                  }             });             checkbuttonlimitAndAnswer();          }          protected static void checkbuttonlimitAndAnswer() {             System.out.println(""1) buttoncount = "" + buttoncount + "" // lives = "" + lives  + "" // buttonlimit = "" + buttonlimit);              if (buttoncount &gt; buttonlimit) {                 lives--;                 buttoncount = 0;             }              System.out.println(""2) buttoncount = "" + buttoncount + "" // lives = "" + lives  + "" // buttonlimit = "" + buttonlimit);              if (frame != null) {                 frame.update();             }          }          protected static void incButtonCount(int val) {             buttoncount += val;             checkbuttonlimitAndAnswer();         }      }       // ===== //"
"import java.util.ArrayList; import java.util.List; import java.util.concurrent.Callable; import java.util.concurrent.ExecutionException; import java.util.concurrent.ExecutorService; import java.util.concurrent.Executors; import java.util.concurrent.Future;  public class ThreadOrdering {      static int NUM_THREADS = 10;      public static void main(String[] args) {         ExecutorService exec = Executors.newFixedThreadPool(NUM_THREADS);         class MyCallable implements Callable&lt;Integer&gt; {             private final int threadnumber;              MyCallable(int threadnumber){                 this.threadnumber = threadnumber;             }              public Integer call() {                 System.out.println(""Running thread #"" + threadnumber);                 return threadnumber;             }         }          List&lt;Callable&lt;Integer&gt;&gt; callables =             new ArrayList&lt;Callable&lt;Integer&gt;&gt;();         for(int i=1; i&lt;=NUM_THREADS; i++) {             callables.add(new MyCallable(i));         }         try {             List&lt;Future&lt;Integer&gt;&gt; results =                 exec.invokeAll(callables);             for(Future&lt;Integer&gt; result: results) {                 System.out.println(""Got result of thread #"" + result.get());             }         } catch (InterruptedException ex) {             ex.printStackTrace();         } catch (ExecutionException ex) {             ex.printStackTrace();         } finally {             exec.shutdownNow();         }     }  }"
import java.util.ArrayList; import java.util.List;  import javax.xml.bind.annotation.XmlAccessType; import javax.xml.bind.annotation.XmlAccessorType; import javax.xml.bind.annotation.XmlAttribute; import javax.xml.bind.annotation.XmlElementRef; import javax.xml.bind.annotation.XmlRootElement;  @XmlRootElement @XmlAccessorType(XmlAccessType.FIELD) public class Project {      @XmlAttribute     private String name;      @XmlElementRef     private List&lt;Fruit&gt; fruitList = new ArrayList&lt;Fruit&gt;();  }
"JNIEXPORT jint JNICALL Java__Names1_GetMyNames(JNIEnv *env, jobject obj) { jfieldID myNamesID; /* store the field ID */ int i=0; jstring myStr; jobjectArray dev; char* myNames[] = {""Hello "", ""world!""};  // Get a reference to obj’s class  jclass cls = env-&gt;GetObjectClass(obj); // Get static field ID myNamesID = env-&gt;GetStaticFieldID(cls, ""myDevNames"", ""[Ljava/lang/String;""); // Get the object field dev = static_cast&lt;jobjectArray&gt;(env-&gt;GetStaticObjectField(cls,myNamesID));  for (i=0; i&lt;2; i++) { myStr = env-&gt;NewStringUTF(myNames[i]); env-&gt;SetObjectArrayElement(dev,i,myStr); } return 0; }"
"import java.io.IOException; import java.io.StringReader;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException;  import org.w3c.dom.Document; import org.w3c.dom.NodeList; import org.xml.sax.InputSource; import org.xml.sax.SAXException;  public class Test {     public static void main(String[] args) {         String xml= ""&lt;?xml version=\""1.0\"" encoding=\""UTF-8\""?&gt;&lt;response status=\""ok\""&gt;&lt;sessionID&gt;lo8mdn7bientr71b5kn1kote90&lt;/sessionID&gt;&lt;/response&gt;"";         DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();         DocumentBuilder builder;         InputSource is;         try {             builder = factory.newDocumentBuilder();             is = new InputSource(new StringReader(xml));             Document doc = builder.parse(is);             NodeList list = doc.getElementsByTagName(""sessionID"");             System.out.println(list.item(0).getTextContent());         } catch (ParserConfigurationException e) {         } catch (SAXException e) {         } catch (IOException e) {         }     } }"
"import javax.servlet.ServletException; import java.io.IOException;  import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse;  public class SomeServlet extends HttpServlet {      protected void doGet(HttpServletRequest request, HttpServletResponse response)                     throws ServletException, IOException {         // some code here          response.setHeader(""Cache-Control"", ""private"");          // some code here     } }"
"import javax.jms.Connection; import javax.jms.Destination; import javax.jms.JMSException; import javax.jms.MessageProducer; import javax.jms.Session; import javax.servlet.ServletContext; import javax.servlet.ServletContextEvent; import javax.servlet.ServletContextListener;  import org.apache.activemq.ActiveMQConnectionFactory; import org.apache.log4j.Logger;  public class MyContextListener implements ServletContextListener {     public final static String ACTIVE_MQ_SESSION = ""ActiveMQSession"";     public final static String ACTIVE_MQ_PRODUCER = ""ActiveMQProducer"";      Logger logger = Logger.getLogger(this.getClass());     private static final int ackMode = Session.AUTO_ACKNOWLEDGE;     private static final boolean transacted = false;      private static final String brokerUrl = ""vm://localhost:61616"";      private Connection connection;     private Session session;     private MessageProducer producer;      @Override     public void contextDestroyed(ServletContextEvent sce) {         try {             this.producer.close();             this.session.close();             this.connection.close();         } catch (JMSException e) {             logger.warn(""tearDown()"", e);         }      }      @Override     public void contextInitialized(ServletContextEvent sce) {         ActiveMQConnectionFactory connectionFactory = new ActiveMQConnectionFactory(                 brokerUrl);          try {             connection = connectionFactory.createConnection();             connection.start();             session = connection.createSession(transacted, ackMode);             Destination destination = session.createQueue(""queue"");             producer = session.createProducer(destination);              ServletContext sc = sce.getServletContext();             sc.setAttribute(ACTIVE_MQ_SESSION, session);             sc.setAttribute(ACTIVE_MQ_PRODUCER, producer);         } catch (JMSException e) {             logger.warn(""setup() failed to setup connection brokerUrl=""                     + brokerUrl);         }     }  }"
"package wsdlvalidation;   import java.io.File; import java.util.ArrayList; import java.util.HashSet; import java.util.Iterator; import java.util.List; import java.util.Map; import java.util.Set; import java.util.StringTokenizer; import java.util.Map.Entry;  import javax.wsdl.Definition; import javax.wsdl.Fault; import javax.wsdl.Message; import javax.wsdl.Operation; import javax.wsdl.Part; import javax.wsdl.PortType; import javax.wsdl.WSDLException; import javax.wsdl.factory.WSDLFactory; import javax.wsdl.xml.WSDLReader; import javax.xml.namespace.QName;  import org.apache.tools.ant.BuildException; import org.apache.tools.ant.taskdefs.MatchingTask; import org.apache.tools.ant.types.FileSet;  /**  * Ant Task to validate a WDSL for an Axis1 bug.  * */ public class WSDLValidationTask extends MatchingTask {     private FileSet configuredWsdl;      public void execute() throws BuildException     {         super.execute();          try {             WSDLFactory wsdlFactory = WSDLFactory.newInstance();             WSDLReader reader = wsdlFactory.newWSDLReader();              Iterator it = getWSDLFileNamesList().iterator();             while (it.hasNext()) {                 String wsdl = (String) it.next();                  Definition theWSDL = reader.readWSDL(wsdl);                   // This is a Bag of all Messages in the WSDL that are used in some &lt;wsdl:fault&gt; of any Operation of any PortType                 Set faultMessages = new HashSet();                 Map allPortTypes = theWSDL.getPortTypes();                 Iterator portTypeIt = allPortTypes.entrySet().iterator();                 while (portTypeIt.hasNext()) {                     Map.Entry entry = (Entry) portTypeIt.next();                     PortType portType = (PortType) entry.getValue();                     List allOperations = portType.getOperations();                     Iterator listIt = allOperations.iterator();                     while (listIt.hasNext()) {                         Operation operation = (Operation)listIt.next();                         Iterator faultIt = operation.getFaults().values().iterator();                         while (faultIt.hasNext()) {                             Fault fault = (Fault) faultIt.next();                                 faultMessages.add(fault.getMessage());                                             }                     }                 }                  Map allMessages = theWSDL.getMessages();                 Iterator messageIt = allMessages.entrySet().iterator();                 while (messageIt.hasNext()) {                     Map.Entry entry = (Entry) messageIt.next();                     QName messageNameQName = (QName) entry.getKey();                     String messageName = messageNameQName.getLocalPart();                      Message message = (Message) entry.getValue();                     Map parts = message.getParts();                     validate(parts.size() == 1, wsdl,                             ""wsdl:message has more than one part: "" + messageNameQName.toString());                     Part messagePart = (Part) parts.values().iterator().next();                     validate(messagePart.getTypeName() == null, wsdl, ""wsdl:part should not have a 'type' attribute: "" + messagePart.getName());                      // Only for Messages that are used in Fault:                     if (faultMessages.contains(message)) {                         validate(!messagePart.getElementName().getLocalPart().equals(messageName), wsdl,                                 ""Due to an Axis1 bug, please do NOT use the same name for &lt;wsdl:message name=\"""" + messageName + ""\""&gt; and &lt;xsd:element name=\"""" + messagePart.getElementName().getLocalPart()+""\""&gt;"");                     }                 }              }         } catch (WSDLException e) {             throw new BuildException(e);         }     }      private void validate(boolean condition, String wsdlFilename, String failureMessage) throws BuildException {         if (!condition) {             throw new BuildException(wsdlFilename + "": "" + failureMessage);         }     }      // TODO Doesn't code like this already exist in ant??     private List getWSDLFileNamesList() {         List/*&lt;String&gt;*/ wsdlList = new ArrayList/*&lt;String&gt;*/();         File dir = configuredWsdl.getDir(configuredWsdl.getProject());         StringTokenizer tokenizer = new StringTokenizer(configuredWsdl.toString(), "";"");         while (tokenizer.hasMoreTokens()) {             String token = tokenizer.nextToken();             wsdlList.add(new File(dir, token).toString());         }         return wsdlList;     }      public void addConfiguredWsdl(FileSet fileSet) {         configuredWsdl = fileSet;     } }"
"import java.lang.reflect.InvocationTargetException; import java.lang.reflect.Method; import java.util.Arrays;  public class InvokeMain {     public static void main(String... args) {     try {         Class&lt;?&gt; c = Class.forName(args[0]);         Class[] argTypes = new Class[] { String[].class };         Method main = c.getDeclaredMethod(""main"", argTypes);         String[] mainArgs = Arrays.copyOfRange(args, 1, args.length);         System.out.format(""invoking %s.main()%n"", c.getName());         main.invoke(null, (Object)mainArgs);          // production code should handle these exceptions more gracefully     } catch (ClassNotFoundException x) {         x.printStackTrace();     } catch (NoSuchMethodException x) {         x.printStackTrace();     } catch (IllegalAccessException x) {         x.printStackTrace();     } catch (InvocationTargetException x) {         x.printStackTrace();     }     } }"
"import java.io.File; import java.io.FileWriter; import java.util.ArrayList; import java.util.List; import java.util.Map; import opennlp.addons.modelbuilder.DefaultModelBuilderUtil; import opennlp.tools.entitylinker.EntityLinkerProperties; import opennlp.tools.namefind.NameFinderME; import opennlp.tools.namefind.TokenNameFinderModel; import opennlp.tools.util.Span;  public class ModelBuilderAddonUse { //fill this method in with however you are going to get your data into a list of sentences..for me I am hitting a MySQL database   private static List&lt;String&gt; getSentencesFromSomewhere() throws Exception {     List&lt;String&gt; sentences = new ArrayList&lt;&gt;();     int counter = 0;     DocProvider dp = new DocProvider();     String modelPath = ""c:\\apache\\entitylinker\\"";     EntityLinkerProperties properties = new EntityLinkerProperties(new File(modelPath + ""entitylinker.properties""));     Map&lt;Long, List&lt;String&gt;&gt; docs = dp.getDocs(properties);     for (Long key : docs.keySet()) {       counter++;       System.out.println(""\t\tDOC: "" + key + ""\n\n"");       String docu = """";       sentences.addAll(docs.get(key));       counter++;       if(counter &gt; 1000){         break;       }     }     return sentences;   }    public static void main(String[] args) throws Exception {     /**      * establish a file to put sentences in      */     File sentences = new File(""C:\\temp\\modelbuilder\\sentences.text"");      /**      * establish a file to put your NER hits in (the ones you want to keep based      * on prob)      */     File knownEntities = new File(""C:\\temp\\modelbuilder\\knownentities.txt"");      /**      * establish a BLACKLIST file to put your bad NER hits in (also can be based      * on prob)      */     File blacklistedentities = new File(""C:\\temp\\modelbuilder\\blentities.txt"");      /**      * establish a file to write your annotated sentences to      */     File annotatedSentences = new File(""C:\\temp\\modelbuilder\\annotatedSentences.txt"");      /**      * establish a file to write your model to      */     File theModel = new File(""C:\\temp\\modelbuilder\\theModel"");   //------------create a bunch of file writers to write your results and sentences to a file      FileWriter sentenceWriter = new FileWriter(sentences, true);     FileWriter blacklistWriter = new FileWriter(blacklistedentities, true);     FileWriter knownEntityWriter = new FileWriter(knownEntities, true);  //set some thresholds to decide where to write hits, you don't have to use these at all...     double keeperThresh = .95;     double blacklistThresh = .7;       /**      * Load your model as normal      */     TokenNameFinderModel personModel = new TokenNameFinderModel(new File(""c:\\temp\\opennlpmodels\\en-ner-person.zip""));     NameFinderME personFinder = new NameFinderME(personModel);     /**      * do your normal NER on the sentences you have      */     for (String s : getSentencesFromSomewhere()) {       sentenceWriter.write(s.trim() + ""\n"");       sentenceWriter.flush();        String[] tokens = s.split("" "");//better to use a tokenizer really       Span[] find = personFinder.find(tokens);       double[] probs = personFinder.probs();       String[] names = Span.spansToStrings(find, tokens);       for (int i = 0; i &lt; names.length; i++) {         //YOU PROBABLY HAVE BETTER HEURISTICS THAN THIS TO MAKE SURE YOU GET GOOD HITS OUT OF THE DEFAULT MODEL         if (probs[i] &gt; keeperThresh) {           knownEntityWriter.write(names[i].trim() + ""\n"");         }         if (probs[i] &lt; blacklistThresh) {           blacklistWriter.write(names[i].trim() + ""\n"");         }       }       personFinder.clearAdaptiveData();       blacklistWriter.flush();       knownEntityWriter.flush();     }     //flush and close all the writers     knownEntityWriter.flush();     knownEntityWriter.close();     sentenceWriter.flush();     sentenceWriter.close();     blacklistWriter.flush();     blacklistWriter.close();      /**      * THIS IS WHERE THE ADDON IS GOING TO USE THE FILES (AS IS) TO CREATE A NEW MODEL. YOU SHOULD NOT HAVE TO RUN THE FIRST PART AGAIN AFTER THIS RUNS, JUST NOW PLAY WITH THE      * KNOWN ENTITIES AND BLACKLIST FILES AND RUN THE METHOD BELOW AGAIN UNTIL YOU GET SOME DECENT RESULTS (A DECENT MODEL OUT OF IT).      */     DefaultModelBuilderUtil.generateModel(sentences, knownEntities, blacklistedentities,             theModel, annotatedSentences, ""person"", 3);     } }"
"Uri uri = Uri.parse(path); Map&lt;String, String&gt; headers = new HashMap&lt;String, String&gt;(); headers.put(&quot;key1&quot;, &quot;value1&quot;); headers.put(&quot;key2&quot;, &quot;value2&quot;);          mMediaPlayer = new MediaPlayer(); // Use java reflection call the hide API: Method method = mMediaPlayer.getClass().getMethod(&quot;setDataSource&quot;, new Class[] { Context.class, Uri.class, Map.class }); method.invoke(mMediaPlayer, new Object[] {this, uri, headers}); mMediaPlayer.setAudioStreamType(AudioManager.STREAM_MUSIC); mMediaPlayer.prepareAsync();  ... ..."
import java.awt.event.FocusEvent; import java.awt.event.FocusListener;  import javax.swing.JTextField;  public class Main {      public static void main(String args[]) {         final JTextField textField = new JTextField();         textField.addFocusListener(new FocusListener() {              @Override             public void focusGained(FocusEvent e) {                 //Your code here             }              @Override             public void focusLost(FocusEvent e) {                 //Your code here             }         });      } }
"import java.util.Arrays; import java.util.ArrayDeque; import java.util.Queue; import java.util.concurrent.ConcurrentLinkedQueue; import java.util.concurrent.LinkedBlockingDeque; import java.util.concurrent.Callable; import java.util.concurrent.ExecutorService; import java.util.concurrent.ThreadPoolExecutor; import java.util.concurrent.TimeUnit;  public class MixedParallel {     // pre-requisite: sorted values !!     private static final int[] data = new int[] { 5, 10, 20, 25, 40, 50 };      // Context to store intermediate computation or a solution     static class Context {         int k;         int sum;         int[] coeff;         Context(int k, int sum, int[] coeff) {             this.k = k;             this.sum = sum;             this.coeff = coeff;         }     }      // Thread pool for parallel execution     private static ExecutorService executor;     // Queue to collect solutions     private static Queue&lt;Context&gt; solutions;      static {         final int numberOfThreads = 2;         executor =             new ThreadPoolExecutor(numberOfThreads, numberOfThreads, 1000, TimeUnit.SECONDS,                                    new LinkedBlockingDeque&lt;Runnable&gt;());         // concurrent because of multi-threaded insertions         solutions = new ConcurrentLinkedQueue&lt;Context&gt;();     }       public static void main(String[] args)     {         int target_sum = 100;         // result vector, init to 0         int[] coeff = new int[data.length];         Arrays.fill(coeff, 0);         mixedPartialSum(data.length - 1, target_sum, coeff);          executor.shutdown();         // System.out.println(""Over. Dumping results"");         while(!solutions.isEmpty()) {             Context s = solutions.poll();             printResult(s.coeff);         }     }      private static void printResult(int[] coeff) {         StringBuffer sb = new StringBuffer();         for (int i = coeff.length - 1; i &gt;= 0; i--) {             if (coeff[i] &gt; 0) {                 sb.append(data[i]).append("" * "").append(coeff[i]).append(""   "");             }         }         System.out.println(sb.append(""from "").append(Thread.currentThread()));     }      private static void mixedPartialSum(int k, int sum, int[] coeff) {         int x_k = data[k];         for (int c = sum / x_k; c &gt;= 0; c--) {             coeff[k] = c;             int[] newcoeff = Arrays.copyOf(coeff, coeff.length);             if (c * x_k == sum) {                 //printResult(newcoeff);                 solutions.add(new Context(0, 0, newcoeff));                 continue;             } else if (k &gt; 0) {                 if (data.length - k &lt; 2) {                     mixedPartialSum(k - 1, sum - c * x_k, newcoeff);                     // for loop on ""c"" goes on with previous coeff content                 } else {                     // no longer recursive. delegate to thread pool                     executor.submit(new ComputePartialSum(new Context(k - 1, sum - c * x_k, newcoeff)));                 }             }         }     }      static class ComputePartialSum implements Callable&lt;Void&gt; {         // queue with contexts to process         private Queue&lt;Context&gt; contexts;          ComputePartialSum(Context request) {             contexts = new ArrayDeque&lt;Context&gt;();             contexts.add(request);         }          public Void call() {             while(!contexts.isEmpty()) {                 Context current = contexts.poll();                 int x_k = data[current.k];                 for (int c = current.sum / x_k; c &gt;= 0; c--) {                     current.coeff[current.k] = c;                     int[] newcoeff = Arrays.copyOf(current.coeff, current.coeff.length);                     if (c * x_k == current.sum) {                         //printResult(newcoeff);                         solutions.add(new Context(0, 0, newcoeff));                         continue;                     } else if (current.k &gt; 0) {                         contexts.add(new Context(current.k - 1, current.sum - c * x_k, newcoeff));                     }                 }             }             return null;         }     } }"
"import java.io.FileInputStream; import java.io.FileNotFoundException; import java.io.IOException; import java.io.StringWriter;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Document; import org.w3c.dom.Node; import org.xml.sax.SAXException;  public class FormatXml {      public static void main(String[] args) throws ParserConfigurationException,             FileNotFoundException, SAXException, IOException,             TransformerException {         DocumentBuilderFactory docBuilderFactory = DocumentBuilderFactory                 .newInstance();         DocumentBuilder documentBuilder = docBuilderFactory                 .newDocumentBuilder();         Document node = documentBuilder.parse(new FileInputStream(""data.xml""));         System.out.println(format(node, 4));     }      public static String format(Node node, int indent)             throws TransformerException {         cleanEmptyTextNodes(node);         StreamResult result = new StreamResult(new StringWriter());         getTransformer(indent).transform(new DOMSource(node), result);         return result.getWriter().toString();     }      private static Transformer getTransformer(int indent) {         Transformer transformer;         try {             transformer = TransformerFactory.newInstance().newTransformer();         } catch (Exception e) {             throw new RuntimeException(""Failed to create the Transformer"", e);         }         transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");         transformer.setOutputProperty(                 ""{http://xml.apache.org/xslt}indent-amount"",                 Integer.toString(indent));         return transformer;     }      /**      * Removes text nodes that only contains whitespace. The conditions for      * removing text nodes, besides only containing whitespace, are: If the      * parent node has at least one child of any of the following types, all      * whitespace-only text-node children will be removed: - ELEMENT child -      * CDATA child - COMMENT child      *       * The purpose of this is to make the format() method (that use a      * Transformer for formatting) more consistent regarding indenting and line      * breaks.      */     private static void cleanEmptyTextNodes(Node parentNode) {         boolean removeEmptyTextNodes = false;         Node childNode = parentNode.getFirstChild();         while (childNode != null) {             removeEmptyTextNodes |= checkNodeTypes(childNode);             childNode = childNode.getNextSibling();         }          if (removeEmptyTextNodes) {             removeEmptyTextNodes(parentNode);         }     }      private static void removeEmptyTextNodes(Node parentNode) {         Node childNode = parentNode.getFirstChild();         while (childNode != null) {             // grab the ""nextSibling"" before the child node is removed             Node nextChild = childNode.getNextSibling();              short nodeType = childNode.getNodeType();             if (nodeType == Node.TEXT_NODE) {                 boolean containsOnlyWhitespace = childNode.getNodeValue()                         .trim().isEmpty();                 if (containsOnlyWhitespace) {                     parentNode.removeChild(childNode);                 }             }             childNode = nextChild;         }     }      private static boolean checkNodeTypes(Node childNode) {         short nodeType = childNode.getNodeType();          if (nodeType == Node.ELEMENT_NODE) {             cleanEmptyTextNodes(childNode); // recurse into subtree         }          if (nodeType == Node.ELEMENT_NODE                 || nodeType == Node.CDATA_SECTION_NODE                 || nodeType == Node.COMMENT_NODE) {             return true;         } else {             return false;         }     }  }"
"import javax.servlet.http.HttpSessionActivationListener; import javax.servlet.http.HttpSessionAttributeListener; import javax.servlet.http.HttpSessionBindingEvent; import javax.servlet.http.HttpSessionBindingListener; import javax.servlet.http.HttpSessionEvent; import javax.servlet.http.HttpSessionListener;  public class SessionListener implements HttpSessionListener, HttpSessionAttributeListener, HttpSessionBindingListener, HttpSessionActivationListener {  public void valueBound(HttpSessionBindingEvent event) {     System.out.println(""valueBound: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void valueUnbound(HttpSessionBindingEvent event) {     System.out.println(""valueUnbound: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void attributeAdded(HttpSessionBindingEvent event) {     System.out.println(""attributeAdded: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void attributeRemoved(HttpSessionBindingEvent event) {     System.out.println(""attributeRemoved: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void attributeReplaced(HttpSessionBindingEvent event) {     System.out.println(""attributeReplaced: "" + event.getName() + "" : "" + event.getValue());     System.out.println(""  session: "" + event.getSession().getId());     this.printStackTrace(); }  public void sessionCreated(HttpSessionEvent event) {     System.out.println(""sessionCreated: "" + event.getSession().getId());     this.printStackTrace(); }  public void sessionDestroyed(HttpSessionEvent event) {     System.out.println(""sessionDestroyed: "" + event.getSession().getId());     this.printStackTrace(); }  public void sessionDidActivate(HttpSessionEvent event) {     System.out.println(""sessionDidActivate: "" + event.getSession().getId());     this.printStackTrace(); }  @Override public void sessionWillPassivate(HttpSessionEvent event) {     System.out.println(""sessionWillPassivate: "" + event.getSession().getId());     this.printStackTrace(); }  private void printStackTrace() {     try {         if (true) {             throw new Exception();         }     } catch (Exception e) {         e.printStackTrace();     } } }"
"package com.ekanathk;  import java.io.BufferedReader; import java.io.InputStream; import java.io.InputStreamReader; import java.util.ArrayList; import java.util.Arrays; import java.util.List; import java.util.Stack; import java.util.logging.Logger;  import org.junit.Test;  class Entry {     private String input;     private int level;     public Entry(String input, int level) {         this.input = input;         this.level = level;     }     public String getInput() {         return input;     }     public int getLevel() {         return level;     }     @Override     public String toString() {         return ""Entry [input="" + input + "", level="" + level + ""]"";     } }  public class Tester {      private static final Logger logger = Logger.getLogger(Tester.class.getName());      @SuppressWarnings(""unchecked"")     @Test     public void testSomething() throws Exception {          InputStream is = Thread.currentThread().getContextClassLoader().getResourceAsStream(""samplecsv.txt"");         BufferedReader b = new BufferedReader(new InputStreamReader(is));         String input = null;         List entries = new ArrayList();         Stack&lt;Entry&gt; stack = new Stack&lt;Entry&gt;();         stack.push(new Entry(""ROOT"", -1));         while((input = b.readLine()) != null){             int level = whatIsTheLevel(input);             input = input.trim();             logger.info(""input = "" + input + "" at level "" + level);              Entry entry = new Entry(input, level);             if(level == 1) {                 //periodically clear out the map and write it to another excel sheet             }             if (stack.peek().getLevel() == entry.getLevel()) {                 stack.pop();             }             Entry parent = stack.peek();             logger.info(""parent = "" + parent);             entries.add(new String[]{parent.getInput(), entry.getInput()});             stack.push(entry);         }         for(Object entry : entries) {             System.out.println(Arrays.toString((String[])entry));         }     }      private int whatIsTheLevel(String input) {         int numberOfSpaces = 0;         for(int i = 0 ; i &lt; input.length(); i++) {             if(input.charAt(i) != ' ') {                 return numberOfSpaces/4;             } else {                 numberOfSpaces++;             }         }         return numberOfSpaces/4;     } }"
"package forum7104810;  import java.util.Set; import java.util.TreeSet;  import javax.xml.bind.annotation.XmlElement; import javax.xml.bind.annotation.XmlElementWrapper; import javax.xml.bind.annotation.XmlRootElement;  @XmlRootElement(name=""root"") class MyParentClass {    // Initialize this property with an instance of the desired type.   private Set&lt;MyFieldItem&gt; items = new TreeSet&lt;MyFieldItem&gt;();    public void setItems(Set&lt;MyFieldItem&gt; items) {     this.items = items;   }    @XmlElementWrapper(name=""mylist"")    @XmlElement(name=""item"")   public Set&lt;MyFieldItem&gt; getItems() {     return items;   }  }"
"import static org.junit.Assert.assertTrue;  import java.io.StringWriter;  import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.TransformerFactoryConfigurationError; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.junit.Test; import org.w3c.dom.DOMImplementation; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Text;  public class DomTest {      @Test     public void testDom() throws Exception {         Document document = createEmptyDocument();          Element root = document.getDocumentElement();         Element child = document.createElement(""child"");         Element childOfTheChild = document.createElement(""childOfTheChild"");         Text st = document.createTextNode(""Some text"");         childOfTheChild.appendChild(st);         child.appendChild(childOfTheChild);         root.appendChild(child);          assertTrue(serialise(document).contains(""Some text""));     }      private Document createEmptyDocument() throws ParserConfigurationException {         DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();         DOMImplementation domImpl = dbf.newDocumentBuilder()                 .getDOMImplementation();         Document document = domImpl.createDocument(null, ""root"", null);         return document;     }      private String serialise(Document document)             throws TransformerFactoryConfigurationError,             TransformerConfigurationException, TransformerException {         TransformerFactory xff = TransformerFactory.newInstance();         Transformer xf = xff.newTransformer();         StringWriter sw = new StringWriter();         xf.transform(new DOMSource(document), new StreamResult(sw));         return sw.toString();     } }"
