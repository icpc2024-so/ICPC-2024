code
"package com.akonizo.examples;  import java.io.ByteArrayInputStream; import java.io.StringWriter;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Node; import org.w3c.dom.Text;  public class XmlInsertExample {      /**      * @param args      */     public static void main(String[] args) {         String initial = ""&lt;root&gt;&lt;param value=\""abc\""/&gt;&lt;param value=\""bc\""/&gt;&lt;/root&gt;"";          try {             // Parse the initial document             ByteArrayInputStream is = new ByteArrayInputStream(initial.getBytes());             DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();             DocumentBuilder db = dbf.newDocumentBuilder();             Document doc = db.parse(is);              // Create the new xml fragment             Text a = doc.createTextNode(""afds"");             Node p = doc.createElement(""parameterDesc"");             p.appendChild(a);             Node i = doc.createElement(""insert"");             i.appendChild(p);             Element r = doc.getDocumentElement();             r.insertBefore(i, r.getFirstChild());             r.normalize();              // Format the xml for output             Transformer transformer = TransformerFactory.newInstance().newTransformer();             transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");              // initialize StreamResult with File object to save to file             StreamResult result = new StreamResult(new StringWriter());             DOMSource source = new DOMSource(doc);             transformer.transform(source, result);              System.out.println(result.getWriter().toString());          } catch (Exception e) {             e.printStackTrace();         }     } }"
"package jaxb.test;  import java.io.StringReader; import javax.xml.XMLConstants; import javax.xml.parsers.SAXParser; import javax.xml.parsers.SAXParserFactory; import javax.xml.transform.Source; import javax.xml.transform.stream.StreamSource; import javax.xml.validation.Schema; import javax.xml.validation.SchemaFactory; import org.xml.sax.Attributes; import org.xml.sax.InputSource; import org.xml.sax.SAXException; import org.xml.sax.SAXParseException; import org.xml.sax.helpers.DefaultHandler;  public class ValidationTest {      public static void main(String[] args) throws Exception {          //Test XML and schema         final String xml = ""&lt;?xml version=\""1.0\""?&gt;&lt;test&gt;&lt;test2&gt;&lt;/test2&gt;&lt;/test&gt;"";         final String schemaString =             ""&lt;?xml version=\""1.0\""?&gt;""             + ""&lt;xsd:schema xmlns:xsd=\""http://www.w3.org/2001/XMLSchema\"" elementFormDefault=\""unqualified\"" attributeFormDefault=\""unqualified\""&gt;""             + ""&lt;xsd:element name=\""test\"" type=\""Test\""/&gt;""             + ""&lt;xsd:element name=\""test2\"" type=\""Test2\""/&gt;""             + ""&lt;xsd:complexType name=\""Test\""&gt;""             + ""&lt;xsd:sequence&gt;""             + ""&lt;xsd:element ref=\""test2\"" minOccurs=\""1\"" maxOccurs=\""unbounded\""/&gt;""             + ""&lt;/xsd:sequence&gt;""             + ""&lt;/xsd:complexType&gt;""             + ""&lt;xsd:simpleType name=\""Test2\""&gt;""             + ""&lt;xsd:restriction base=\""xsd:string\""&gt;&lt;xsd:minLength value=\""1\""/&gt;&lt;/xsd:restriction&gt;""             + ""&lt;/xsd:simpleType&gt;""             + ""&lt;/xsd:schema&gt;"";          //Building a Schema instance         final Source schemaSource =             new StreamSource(new StringReader(schemaString));         final Schema schema =             SchemaFactory.newInstance(XMLConstants.W3C_XML_SCHEMA_NS_URI).newSchema(schemaSource);          //Creating a SAXParser for our input XML         //First the factory         final SAXParserFactory factory = SAXParserFactory.newInstance();         //Must be namespace aware to receive element names         factory.setNamespaceAware(true);         //Setting the Schema for validation         factory.setSchema(schema);         //Now the parser itself         final SAXParser parser = factory.newSAXParser();          //Creating an instance of our special handler         final MyContentHandler handler = new MyContentHandler();          //Parsing         parser.parse(new InputSource(new StringReader(xml)), handler);      }      private static class MyContentHandler extends DefaultHandler {          private String element = """";          @Override         public void startElement(String uri, String localName, String qName,                 Attributes attributes) throws SAXException {              if(localName != null &amp;&amp; !localName.isEmpty())                 element = localName;             else                 element = qName;          }          @Override         public void warning(SAXParseException exception) throws SAXException {             System.out.println(element + "": "" + exception.getMessage());         }          @Override         public void error(SAXParseException exception) throws SAXException {             System.out.println(element + "": "" + exception.getMessage());         }          @Override         public void fatalError(SAXParseException exception) throws SAXException {             System.out.println(element + "": "" + exception.getMessage());         }          public String getElement() {             return element;         }      }  }"
"import java.awt.*; import java.awt.event.*; import javax.swing.*;  /**  * A flow layout arranges components in a directional flow, much  * like lines of text in a paragraph. The flow direction is  * determined by the container's &lt;code&gt;componentOrientation&lt;/code&gt;  * property and may be one of two values:  * &lt;ul&gt;  * &lt;li&gt;&lt;code&gt;ComponentOrientation.TOP_TO_BOTTOM&lt;/code&gt;  * &lt;li&gt;&lt;code&gt;ComponentOrientation.BOTTOM_TO_TOP&lt;/code&gt;  * &lt;/ul&gt;  * Flow layouts are typically used  * to arrange buttons in a panel. It arranges buttons  * horizontally until no more buttons fit on the same line.  * The line alignment is determined by the &lt;code&gt;align&lt;/code&gt;  * property. The possible values are:  * &lt;ul&gt;  * &lt;li&gt;{@link #TOP TOP}  * &lt;li&gt;{@link #BOTTOM BOTTOM}  * &lt;li&gt;{@link #CENTER CENTER}  * &lt;li&gt;{@link #LEADING LEADING}  * &lt;li&gt;{@link #TRAILING TRAILING}  * &lt;/ul&gt;  * &lt;p&gt;  */ public class VerticalFlowLayout implements LayoutManager, java.io.Serializable {     /**      * This value indicates that each row of components      * should be left-justified.      */     public static final int TOP     = 0;      /**      * This value indicates that each row of components      * should be centered.      */     public static final int CENTER    = 1;      /**      * This value indicates that each row of components      * should be right-justified.      */     public static final int BOTTOM     = 2;      /**      * &lt;code&gt;align&lt;/code&gt; is the property that determines      * how each column distributes empty space.      * It can be one of the following three values:      * &lt;ul&gt;      * &lt;code&gt;TOP&lt;/code&gt;      * &lt;code&gt;BOTTOM&lt;/code&gt;      * &lt;code&gt;CENTER&lt;/code&gt;      * &lt;/ul&gt;      *      * @see #getAlignment      * @see #setAlignment      */     int align;     // This is the one we actually use      /**      * The flow layout manager allows a seperation of      * components with gaps.  The horizontal gap will      * specify the space between components and between      * the components and the borders of the      * &lt;code&gt;Container&lt;/code&gt;.      *      * @see #getHgap()      * @see #setHgap(int)      */     int hgap;      /**      * The flow layout manager allows a seperation of      * components with gaps.  The vertical gap will      * specify the space between rows and between the      * the rows and the borders of the &lt;code&gt;Container&lt;/code&gt;.      *      * @see #getHgap()      * @see #setHgap(int)      */     int vgap;      /**      * Constructs a new &lt;code&gt;VerticalFlowLayout&lt;/code&gt; with a centered alignment and a      * default 5-unit horizontal and vertical gap.      */     public VerticalFlowLayout()     {         this(CENTER, 5, 5);     }      /**      * Constructs a new &lt;code&gt;VerticalFlowLayout&lt;/code&gt; with the specified      * alignment and a default 5-unit horizontal and vertical gap.      * The value of the alignment argument must be one of      * &lt;code&gt;VerticalFlowLayout.TOP&lt;/code&gt;, &lt;code&gt;VerticalFlowLayout.BOTTOM&lt;/code&gt;,      * or &lt;code&gt;VerticalFlowLayout.CENTER&lt;/code&gt;      * @param align the alignment value      */     public VerticalFlowLayout(int align)     {         this(align, 5, 5);     }      /**      * Creates a new flow layout manager with the indicated alignment      * and the indicated horizontal and vertical gaps.      * &lt;p&gt;      * The value of the alignment argument must be one of      * &lt;code&gt;VerticalFlowLayout.TOP&lt;/code&gt;, &lt;code&gt;VerticalFlowLayout.BOTTOM&lt;/code&gt;,      * or &lt;code&gt;VerticalFlowLayout.CENTER&lt;/code&gt;.      * @param     align   the alignment value      * @param     hgap  the horizontal gap between components      *                   and between the components and the      *                   borders of the &lt;code&gt;Container&lt;/code&gt;      * @param     vgap  the vertical gap between components      *                   and between the components and the      *                   borders of the &lt;code&gt;Container&lt;/code&gt;      */     public VerticalFlowLayout(int align, int hgap, int vgap)     {         this.hgap = hgap;         this.vgap = vgap;         setAlignment(align);     }      /**      * Gets the alignment for this layout.      * Possible values are &lt;code&gt;VerticalFlowLayout.TOP&lt;/code&gt;,      * &lt;code&gt;VerticalFlowLayout.BOTTOM&lt;/code&gt; or &lt;code&gt;VerticalFlowLayout.CENTER&lt;/code&gt;,      * @return   the alignment value for this layout      * @see     java.awt.VerticalFlowLayout#setAlignment      * @since     JDK1.1      */     public int getAlignment()     {         return align;     }      /**      * Sets the alignment for this layout. Possible values are      * &lt;ul&gt;      * &lt;li&gt;&lt;code&gt;VerticalFlowLayout.TOP&lt;/code&gt;      * &lt;li&gt;&lt;code&gt;VerticalFlowLayout.BOTTOM&lt;/code&gt;      * &lt;li&gt;&lt;code&gt;VerticalFlowLayout.CENTER&lt;/code&gt;      * &lt;/ul&gt;      * @param     align one of the alignment values shown above      * @see     #getAlignment()      * @since     JDK1.1      */     public void setAlignment(int align)     {         this.align = align;     }      /**      * Gets the horizontal gap between components      * and between the components and the borders      * of the &lt;code&gt;Container&lt;/code&gt;      *      * @return   the horizontal gap between components      *           and between the components and the borders      *           of the &lt;code&gt;Container&lt;/code&gt;      * @see     java.awt.VerticalFlowLayout#setHgap      * @since     JDK1.1      */     public int getHgap() {         return hgap;     }      /**      * Sets the horizontal gap between components and      * between the components and the borders of the      * &lt;code&gt;Container&lt;/code&gt;.      *      * @param hgap the horizontal gap between components      *           and between the components and the borders      *           of the &lt;code&gt;Container&lt;/code&gt;      * @see     java.awt.VerticalFlowLayout#getHgap      * @since     JDK1.1      */     public void setHgap(int hgap) {         this.hgap = hgap;     }      /**      * Gets the vertical gap between components and      * between the components and the borders of the      * &lt;code&gt;Container&lt;/code&gt;.      *      * @return   the vertical gap between components      *           and between the components and the borders      *           of the &lt;code&gt;Container&lt;/code&gt;      * @see     java.awt.VerticalFlowLayout#setVgap      * @since     JDK1.1      */     public int getVgap() {         return vgap;     }      /**      * Sets the vertical gap between components and between      * the components and the borders of the &lt;code&gt;Container&lt;/code&gt;.      *      * @param vgap the vertical gap between components      *           and between the components and the borders      *           of the &lt;code&gt;Container&lt;/code&gt;      * @see     java.awt.VerticalFlowLayout#getVgap      */     public void setVgap(int vgap) {         this.vgap = vgap;     }      /**      * Adds the specified component to the layout.      * Not used by this class.      * @param name the name of the component      * @param comp the component to be added      */     public void addLayoutComponent(String name, Component comp) {     }      /**      * Removes the specified component from the layout.      * Not used by this class.      * @param comp the component to remove      * @see    java.awt.Container#removeAll      */     public void removeLayoutComponent(Component comp) {     }      /**      * Returns the preferred dimensions for this layout given the      * &lt;i&gt;visible&lt;/i&gt; components in the specified target container.      *      * @param target the container that needs to be laid out      * @return  the preferred dimensions to lay out the      *          subcomponents of the specified container      * @see Container      * @see #minimumLayoutSize      * @see    java.awt.Container#getPreferredSize      */     public Dimension preferredLayoutSize(Container target)     {     synchronized (target.getTreeLock())     {         Dimension dim = new Dimension(0, 0);         int nmembers = target.getComponentCount();         boolean firstVisibleComponent = true;          for (int i = 0 ; i &lt; nmembers ; i++)         {             Component m = target.getComponent(i);              if (m.isVisible())             {                 Dimension d = m.getPreferredSize();                 dim.width = Math.max(dim.width, d.width);                  if (firstVisibleComponent)                 {                     firstVisibleComponent = false;                 }                 else                 {                     dim.height += vgap;                 }                  dim.height += d.height;             }         }          Insets insets = target.getInsets();         dim.width += insets.left + insets.right + hgap*2;         dim.height += insets.top + insets.bottom + vgap*2;         return dim;     }     }      /**      * Returns the minimum dimensions needed to layout the &lt;i&gt;visible&lt;/i&gt;      * components contained in the specified target container.      * @param target the container that needs to be laid out      * @return  the minimum dimensions to lay out the      *          subcomponents of the specified container      * @see #preferredLayoutSize      * @see    java.awt.Container      * @see    java.awt.Container#doLayout      */     public Dimension minimumLayoutSize(Container target)     {     synchronized (target.getTreeLock())     {         Dimension dim = new Dimension(0, 0);         int nmembers = target.getComponentCount();         boolean firstVisibleComponent = true;          for (int i = 0 ; i &lt; nmembers ; i++)         {             Component m = target.getComponent(i);             if (m.isVisible())             {                 Dimension d = m.getMinimumSize();                 dim.width = Math.max(dim.width, d.width);                  if (firstVisibleComponent)                 {                     firstVisibleComponent = false;                 }                 else                 {                     dim.height += vgap;                 }                  dim.height += d.height;             }         }           Insets insets = target.getInsets();         dim.width += insets.left + insets.right + hgap*2;         dim.height += insets.top + insets.bottom + vgap*2;         return dim;     }     }      /**      * Lays out the container. This method lets each      * &lt;i&gt;visible&lt;/i&gt; component take      * its preferred size by reshaping the components in the      * target container in order to satisfy the alignment of      * this &lt;code&gt;VerticalFlowLayout&lt;/code&gt; object.      *      * @param target the specified component being laid out      * @see Container      * @see    java.awt.Container#doLayout      */     public void layoutContainer(Container target)     {     synchronized (target.getTreeLock())     {         Insets insets = target.getInsets();         int maxHeight = target.getSize().height - (insets.top + insets.bottom + vgap*2);         int nmembers = target.getComponentCount();         int x = insets.left + hgap;         int y = 0;         int columnWidth = 0;         int start = 0;          boolean ttb = target.getComponentOrientation().isLeftToRight();          for (int i = 0 ; i &lt; nmembers ; i++)         {             Component m = target.getComponent(i);              if (m.isVisible())             {                 Dimension d = m.getPreferredSize();                 m.setSize(d.width, d.height);                  if ((y == 0) || ((y + d.height) &lt;= maxHeight))                 {                     if (y &gt; 0)                     {                         y += vgap;                     }                      y += d.height;                     columnWidth = Math.max(columnWidth, d.width);                 }                 else                 {                     moveComponents(target, x, insets.top + vgap, columnWidth, maxHeight - y, start, i, ttb);                     y = d.height;                     x += hgap + columnWidth;                     columnWidth = d.width;                     start = i;                 }             }         }          moveComponents(target, x, insets.top + vgap, columnWidth, maxHeight - y, start, nmembers, ttb);     }     }      /**      * Centers the elements in the specified row, if there is any slack.      * @param target the component which needs to be moved      * @param x the x coordinate      * @param y the y coordinate      * @param width the width dimensions      * @param height the height dimensions      * @param columnStart the beginning of the column      * @param columnEnd the the ending of the column      */     private void moveComponents(         Container target, int x, int y, int width, int height, int columnStart, int columnEnd, boolean ttb)     {         switch (align)         {             case TOP:                 y += ttb ? 0 : height;                 break;             case CENTER:                 y += height / 2;                 break;             case BOTTOM:                 y += ttb ? height : 0;                 break;         }          for (int i = columnStart ; i &lt; columnEnd ; i++)         {             Component m = target.getComponent(i);              if (m.isVisible())             {                 int cx;                 cx = x + (width - m.getSize().width) / 2;                  if (ttb)                 {                     m.setLocation(cx, y);                 }                 else                 {                     m.setLocation(cx, target.getSize().height - y - m.getSize().height);                 }                  y += m.getSize().height + vgap;             }         }     }      /**      * Returns a string representation of this &lt;code&gt;VerticalFlowLayout&lt;/code&gt;      * object and its values.      * @return   a string representation of this layout      */     public String toString()     {         String str = """";          switch (align)         {             case TOP:    str = "",align=top""; break;             case CENTER: str = "",align=center""; break;             case BOTTOM: str = "",align=bottom""; break;         }          return getClass().getName() + ""[hgap="" + hgap + "",vgap="" + vgap + str + ""]"";     }       public static void main(String[] args)     {         JPanel main = new JPanel( new BorderLayout() );          final JPanel buttons = new JPanel(new VerticalFlowLayout() ); //      buttons.setComponentOrientation(ComponentOrientation.RIGHT_TO_LEFT);         main.add(buttons, BorderLayout.CENTER);          for (int i = 0; i &lt; 7; i++)         {             buttons.add( new JRadioButton(""button "" + i) );         }          JButton button = new JButton(""Add Radio Button"");         main.add(button, BorderLayout.SOUTH);         button.addActionListener( new ActionListener()         {             private int i = 8;              public void actionPerformed(ActionEvent e)             {                 buttons.add( new JRadioButton(""button R Us"" + i++) );                 buttons.revalidate(); //              pack();             }         });          JFrame frame = new JFrame();         frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);         frame.add(main);         frame.setSize(300, 300);         frame.setLocationRelativeTo(null);         frame.setVisible(true);     }   }"
"class IntroRenderer implements GLSurfaceView.Renderer {      private boolean textureReady = false;      public void onDrawFrame(GL10 gl) {          if (!this.textureReady) {             this.prepareTexture(gl); // only initialize once         }                     gl.glClearColor(0, 0.4f, 0.4f, 1.0f);         gl.glClear(GL10.GL_COLOR_BUFFER_BIT);          float positions[] = {                        0.0f, 1.0f, 0.0f,                        0.0f, 0.0f, 0.0f,                        1.0f, 1.0f, 0.0f,           0.0f, 0.0f, 0.0f,                        1.0f, 1.0f, 0.0f,                        1.0f, 0.0f, 0.0f };          float texCoords[] = {  // define texture coordinates                       0.0f, 1.0f,                        0.0f, 0.0f,                        1.0f, 1.0f,                        0.0f, 0.0f,                        1.0f, 1.0f,                        1.0f, 0.0f };          ByteBuffer bb = ByteBuffer.allocateDirect(positions.length * 4);         bb.order(ByteOrder.nativeOrder());          FloatBuffer fb = bb.asFloatBuffer();         fb.put(positions);         fb.position(0);          // create buffer for texture coordinates         ByteBuffer texCoordByteBuffer = ByteBuffer.allocateDirect(texCoords.length * 4);         texCoordByteBuffer.order(ByteOrder.nativeOrder());          FloatBuffer texCoordBuffer = texCoordByteBuffer.asFloatBuffer();         texCoordBuffer.put(texCoords);         texCoordBuffer.position(0);          gl.glEnableClientState(GL10.GL_VERTEX_ARRAY);         gl.glVertexPointer(3, GL10.GL_FLOAT, 0, fb);          // enable texture buffer         gl.glEnableClientState(GL10.GL_TEXTURE_COORD_ARRAY);         gl.glTexCoordPointer(2, GL10.GL_FLOAT, 0, texCoordBuffer);          gl.glDrawArrays(GL10.GL_TRIANGLES, 0, 3 * 2);       }      private void prepareTexture(GL10 gl) {         int[] buffers = new int[1];         gl.glGenTextures(1, buffers, 0);         int texture = buffers[0];          // enable texturing and bind texture         gl.glEnable(GL10.GL_TEXTURE_2D);         gl.glBindTexture(GL10.GL_TEXTURE_2D, texture);          Bitmap bmp = BitmapFactory.decodeResource(IntroActivity.this.getResources(), R.drawable.rect2985);         Bitmap bmp256 = Bitmap.createScaledBitmap(bmp, 256, 256, false);          GLUtils.texImage2D(GL10.GL_TEXTURE_2D, 0, bmp256, 0);          // setup filters         gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MIN_FILTER, GL10.GL_NEAREST);         gl.glTexParameterf(GL10.GL_TEXTURE_2D, GL10.GL_TEXTURE_MAG_FILTER, GL10.GL_NEAREST);          bmp.recycle();         this.textureReady = true;     }      public void onSurfaceChanged(GL10 gl, int width, int height) {         gl.glViewport(0, 0, width, height);     }      public void onSurfaceCreated(GL10 gl, EGLConfig config) {         // TODO Auto-generated method stub     }  }"
"List&lt;byte[]&gt; list = new ArrayList&lt;byte[]&gt;();     list.add(""HI"".getBytes());     list.add(""BYE"".getBytes());      ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(             ""test.txt""));     out.writeObject(list);      ObjectInputStream in = new ObjectInputStream(new FileInputStream(             ""test.txt""));     List&lt;byte[]&gt; byteList = (List&lt;byte[]&gt;) in.readObject();      //if you want to add to list you will need to add to byteList and write it again     for (byte[] bytes : byteList) {         System.out.println(new String(bytes));     }"
"PreparedStatement pstmt = null; Connection conn = null;  try{      //if you have a method that creates a connection for you.      conn = getConnection();      pstmt = conn.prepareStatement(""INSERT INTO tops(id, title, elements, size, entity, timeStamp) VALUES(?,?,?,?,?,?)"");      pstmt.setInt(1,item.getID());       //Assuming that title is a String data type      pstmt.setString(2,item.getTitle());      pstmt.setString(3,this.elements);      pstmt.setDouble(4,item.getSize()); // &lt;--- JDBC will make sure this works       //assuming Entity data type is String      pstmt.setString(5,item.getEntity());       //if your timestamp's string format is       //well formed, you may insert as a string.      pstmt.setString(6,timestamp.toString());      pstmt.executeUpdate(); }catch(Exception e){      e.printStackTrace(); }finally{        try{          pstmt.close();      }catch(Exception e){}       try{          conn.close();      }catch(Exception e){}  }"
"import javafx.application.Application; import javafx.event.EventHandler; import javafx.scene.Group; import javafx.scene.Scene; import javafx.scene.control.TableCell; import javafx.scene.control.TableColumn; import javafx.scene.control.TableView; import javafx.scene.control.cell.PropertyValueFactory; import javafx.scene.control.cell.TextFieldTableCell; import javafx.scene.input.MouseEvent; import javafx.stage.Stage; import javafx.util.Callback;  public class TableClickListener extends Application {    public static void main(String[] args) {     launch(args);   }    class FTPTableCell&lt;S, T&gt; extends TextFieldTableCell&lt;S, T&gt; {     FTPTableCell() {       super();       addEventFilter(MouseEvent.MOUSE_CLICKED, new EventHandler&lt;MouseEvent&gt;() {         @Override         public void handle(MouseEvent event) {           if (event.getClickCount() &gt; 1 &amp;&amp; getItem() != null) {             System.out.println(""Sending "" + getTableRow().getItem() + "" to the FTP client"");           }         }       });     }   }    final Callback&lt;TableColumn&lt;MyFTPFile, String&gt;, TableCell&lt;MyFTPFile, String&gt;&gt; FTP_TABLE_CELL_FACTORY =       new Callback&lt;TableColumn&lt;MyFTPFile, String&gt;, TableCell&lt;MyFTPFile, String&gt;&gt;() {         public TableCell&lt;MyFTPFile, String&gt; call(TableColumn&lt;MyFTPFile, String&gt; p) {           return new FTPTableCell&lt;&gt;();         }       };    @Override   public void start(final Stage stage) {     final TableView&lt;MyFTPFile&gt; table = new TableView&lt;&gt;();      final TableColumn&lt;MyFTPFile, String&gt; filenameColumn = new TableColumn&lt;&gt;(""Filename"");     filenameColumn.setCellValueFactory(new PropertyValueFactory&lt;MyFTPFile, String&gt;(""filename""));     filenameColumn.setCellFactory(FTP_TABLE_CELL_FACTORY);     filenameColumn.setMinWidth(150);      final TableColumn&lt;MyFTPFile, String&gt; ratingColumn = new TableColumn&lt;&gt;(""Rating"");     ratingColumn.setCellValueFactory(new PropertyValueFactory&lt;MyFTPFile, String&gt;(""rating""));     ratingColumn.setCellFactory(FTP_TABLE_CELL_FACTORY);     ratingColumn.setMinWidth(20);      table.getColumns().setAll(filenameColumn, ratingColumn);      table.getItems().setAll(         new MyFTPFile(""xyzzy.txt"", 10),         new MyFTPFile(""management_report.doc"", 1),         new MyFTPFile(""flower.png"", 7)     );      table.setColumnResizePolicy(TableView.CONSTRAINED_RESIZE_POLICY);      stage.setScene(new Scene(new Group(table)));     stage.show();   }    public class MyFTPFile {     private final String filename;     private final int rating;      MyFTPFile(String filename, int rating) {       this.filename = filename;       this.rating = rating;     }      public String getFilename() {       return filename;     }      public int getRating() {       return rating;     }      @Override     public String toString() {       return ""MyFTPFile{"" +           ""filename='"" + filename + '\'' +           "", rating="" + rating +           '}';     }   }  }"
"try {         String orderID = get();          // Update some GUI elements using the orderID      } catch(ExecutionException e) {         Throwable cause = e.getCause( );         if ( cause instanceof PlaceOrderException )         {             JOptionPane.showMessageDialog(               this,               ""Please review your order"",               cause.getMessage(),               JOptionPane.ERROR_MESSAGE,               null             );         }         else         {           LOGGER.error(""Error placing order"", e);         }     } catch (Exception e) {         LOGGER.error(""Error placing order"", e);     }"
"VersionHistory history = session.getWorkspace().getVersionManager().getVersionHistory(""/my/node/path""); // To iterate over all versions VersionIterator versions = history.getAllVersions(); while (versions.hasNext()) {   Version version = versions.nextVersion(); } // Obtain version per name Version mySpecificVersion = history.getVersion(""myVersion""); //Obtain version per label Version labelisedVersion = history.getVersionByLabel(""myLabel""); String myVersionPropertyValue = labelisedVersion.getFrozenNode().getProperty(""myProperty"").getString();"
Executor executor = Executors.newFixedThreadPool(4); CompletionService&lt;SomeResult&gt; completionService =         new ExecutorCompletionService&lt;SomeResult&gt;(executor);  //4 tasks for(int i = 0; i &lt; 4; i++) {    completionService.submit(new Callable&lt;SomeResult&gt;() {        public SomeResult call() {            ...            return result;        }    }); }  int received = 0; boolean errors = false;  while(received &lt; 4 &amp;&amp; !errors) {       Future&lt;SomeResult&gt; resultFuture = completionService.take(); //blocks if none available       try {          SomeResult result = resultFuture.get();          received ++;          ... // do something with the result       }       catch(Exception e) {              //log          errors = true;       } }
"import java.io.File; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Attr; import org.w3c.dom.Document; import org.w3c.dom.Element;  public class WriteXMLFile {  public static void main(String argv[]) {    try {      DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();     DocumentBuilder docBuilder = docFactory.newDocumentBuilder();      // root elements     Document doc = docBuilder.newDocument();     Element rootElement = doc.createElement(""company"");     doc.appendChild(rootElement);      // staff elements     Element staff = doc.createElement(""Staff"");     rootElement.appendChild(staff);      // set attribute to staff element     Attr attr = doc.createAttribute(""id"");     attr.setValue(""1"");     staff.setAttributeNode(attr);      // shorten way     // staff.setAttribute(""id"", ""1"");      // firstname elements     Element firstname = doc.createElement(""firstname"");     firstname.appendChild(doc.createTextNode(""yong""));     staff.appendChild(firstname);      // lastname elements     Element lastname = doc.createElement(""lastname"");     lastname.appendChild(doc.createTextNode(""mook kim""));     staff.appendChild(lastname);      // nickname elements     Element nickname = doc.createElement(""nickname"");     nickname.appendChild(doc.createTextNode(""mkyong""));     staff.appendChild(nickname);      // salary elements     Element salary = doc.createElement(""salary"");     salary.appendChild(doc.createTextNode(""100000""));     staff.appendChild(salary);      // write the content into xml file     TransformerFactory transformerFactory = TransformerFactory.newInstance();     Transformer transformer = transformerFactory.newTransformer();     DOMSource source = new DOMSource(doc);     StreamResult result = new StreamResult(new File(""C:\\file.xml""));      // Output to console for testing     // StreamResult result = new StreamResult(System.out);      transformer.transform(source, result);      System.out.println(""File saved!"");    } catch (ParserConfigurationException pce) {     pce.printStackTrace();   } catch (TransformerException tfe) {     tfe.printStackTrace();   } } }"
"import java.io.File; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Attr; import org.w3c.dom.Document; import org.w3c.dom.Element;  public class WriteXMLFile {  public static void main(String argv[]) {    try {      DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();     DocumentBuilder docBuilder = docFactory.newDocumentBuilder();      // root elements     Document doc = docBuilder.newDocument();     Element rootElement = doc.createElement(""company"");     doc.appendChild(rootElement);      // staff elements     Element staff = doc.createElement(""Staff"");     rootElement.appendChild(staff);      // set attribute to staff element     Attr attr = doc.createAttribute(""id"");     attr.setValue(""1"");     staff.setAttributeNode(attr);      // shorten way     // staff.setAttribute(""id"", ""1"");      // firstname elements     Element firstname = doc.createElement(""firstname"");     firstname.appendChild(doc.createTextNode(""yong""));     staff.appendChild(firstname);      // lastname elements     Element lastname = doc.createElement(""lastname"");     lastname.appendChild(doc.createTextNode(""mook kim""));     staff.appendChild(lastname);      // nickname elements     Element nickname = doc.createElement(""nickname"");     nickname.appendChild(doc.createTextNode(""mkyong""));     staff.appendChild(nickname);      // salary elements     Element salary = doc.createElement(""salary"");     salary.appendChild(doc.createTextNode(""100000""));     staff.appendChild(salary);      // write the content into xml file     TransformerFactory transformerFactory = TransformerFactory.newInstance();     Transformer transformer = transformerFactory.newTransformer();     DOMSource source = new DOMSource(doc);     StreamResult result = new StreamResult(new File(""C:\\file.xml""));      // Output to console for testing     // StreamResult result = new StreamResult(System.out);      transformer.transform(source, result);      System.out.println(""File saved!"");    } catch (ParserConfigurationException pce) {     pce.printStackTrace();   } catch (TransformerException tfe) {     tfe.printStackTrace();   } } }"
"import java.util.Comparator; import java.util.Map; import java.util.LinkedHashMap; import java.util.List;  class FloatEntryComparator implements Comparator&lt;Map.Entry&gt; {   public int compare(Map.Entry e1, Map.Entry e2) {     return ((Float)e2.getValue()).intValue() - ((Float)e1.getValue()).intValue();   } }  void setup() {   Map&lt;Float,Float&gt; hm = new HashMap&lt;Float,Float&gt;();    // Putting key-value pairs in the HashMap   for (int i = 0; i &lt; 100; i++) {     float pos = random(-50, 50);     float time = random(0, 50);     hm.put(time, pos);   }    println(""ALL ENTRIES, UNSORTED:"");     for (Map.Entry me : hm.entrySet()) {     print(""key is "" + me.getKey());     println("" value is "" + me.getValue());   }    List&lt;Map.Entry&gt; entries = new ArrayList&lt;Map.Entry&gt;(hm.entrySet());    java.util.Collections.sort(entries, new FloatEntryComparator());    hm = new LinkedHashMap&lt;Float, Float&gt;();   for(Map.Entry e : entries)     hm.put((Float)e.getKey(), (Float)e.getValue());    println(""5 LARGEST ENTRIES:"");     int shownCount = 0;   for (Map.Entry me : hm.entrySet()) {     if(shownCount == 5)       break;     print(""key is "" + me.getKey());     println("" value is "" + me.getValue());     ++shownCount;   } }"
while (cursor.moveToNext()) {         ProductCategoryDatabaseRetrieve prodCatDB = new ProductCategoryDatabaseRetrieve();//Instantiate here with each iteration.         prodCatDB.set_tid(cursor.getInt(cursor.getColumnIndex(DatabaseHandler._TID)));         prodCatDB.setTid(String.valueOf(cursor.getInt(cursor                 .getColumnIndex(DatabaseHandler.TID))));         prodCatDB.setProductCategoryName(cursor.getString(cursor                 .getColumnIndex(DatabaseHandler.PRODUCT_CATEGORY_NAME)));         prodCatDB.setProductCategoryImage(cursor.getBlob(cursor                 .getColumnIndex(DatabaseHandler.PRODUCT_CATEGORY_IMAGE)));         productCategoryDatabaseRetrieve.add(prodCatDB); }
"JNIEnv * env; jclass loadedJavaClass; jmethodID loadedJavaMethod;  //assume JVM, class, and method are already loaded at this point.  //Get c string from std::string object pointer const char * c_string = ((std::string*) pPin-&gt;GetUserData())-&gt;c_str();  //Create jstring from string jstring stuff = env-&gt;NewStringUTF( c_string );  //pass jstring to Java function env-&gt;CallStaticVoidMethod( loadedJavaClass, loadedJavaMethod, stuff );  //remove local reference to jstring JavaEnvironment::getEnvironment()-&gt;DeleteLocalRef(stuff);"
"import java.io.File;  import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.transform.Result; import javax.xml.transform.Source; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult; import javax.xml.transform.stream.StreamSource;  import org.w3c.dom.Document;  class Xml2Csv {      public static void main(String args[]) throws Exception {         File stylesheet = new File(""src/main/resources/style.xsl"");         File xmlSource = new File(""src/main/resources/data.xml"");          DocumentBuilderFactory factory = DocumentBuilderFactory.newInstance();         DocumentBuilder builder = factory.newDocumentBuilder();         Document document = builder.parse(xmlSource);          StreamSource stylesource = new StreamSource(stylesheet);         Transformer transformer = TransformerFactory.newInstance()                 .newTransformer(stylesource);         Source source = new DOMSource(document);         Result outputTarget = new StreamResult(new File(""/tmp/x.csv""));         transformer.transform(source, outputTarget);     } }"
"import ca.odell.glazedlists.BasicEventList; import ca.odell.glazedlists.EventList; import ca.odell.glazedlists.GlazedLists; import ca.odell.glazedlists.SortedList; import ca.odell.glazedlists.swing.AutoCompleteSupport; import ca.odell.glazedlists.swing.EventComboBoxModel; import ca.odell.glazedlists.swing.EventListModel; import ca.odell.glazedlists.swing.EventSelectionModel; import java.awt.BorderLayout; import java.awt.event.ActionEvent; import java.awt.event.ActionListener; import java.util.Comparator; import javax.swing.JButton; import javax.swing.JComboBox; import javax.swing.JFrame; import javax.swing.JList; import javax.swing.JPanel;  /**  *  * @author Andrew Roberts  */ public class GlazedListsAutocompleteTest {      private JFrame mainFrame;     private JComboBox availableItems;     private EventList&lt;Book&gt; books = new BasicEventList&lt;Book&gt;();     private EventList&lt;Book&gt; selectedBooks;      public GlazedListsAutocompleteTest() {         populateAvailableBooks();         createGui();         mainFrame.setVisible(true);     }      private void populateAvailableBooks() {         books.add(new Book(""A Tale of Two Cities""));         books.add(new Book(""The Lord of the Rings""));         books.add(new Book(""The Hobbit""));         books.add(new Book(""And Then There Were None""));     }      private void createGui() {          mainFrame = new JFrame(""GlazedLists Autocomplete Example"");         mainFrame.setSize(600, 400);         mainFrame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);          //EventComboBoxModel&lt;Book&gt; comboModel = new EventComboBoxModel&lt;Book&gt;(books);         availableItems = new JComboBox();         final SortedList&lt;Book&gt; availableBooks = new SortedList&lt;Book&gt;((BasicEventList&lt;Book&gt;) GlazedLists.eventList(books), new BookComparitor());          selectedBooks = new SortedList&lt;Book&gt;(new BasicEventList&lt;Book&gt;(), new BookComparitor());          AutoCompleteSupport autocomplete = AutoCompleteSupport.install(availableItems, availableBooks);          JButton addButton = new JButton(""+"");         addButton.addActionListener(new ActionListener() {              @Override             public void actionPerformed(ActionEvent e) {                 EventComboBoxModel&lt;Book&gt; comboModel = (EventComboBoxModel&lt;Book&gt;) availableItems.getModel();                 try {                     Book book = (Book) comboModel.getSelectedItem();                     selectedBooks.add(book);                     availableBooks.remove(book);                 } catch (ClassCastException ex) {                     System.err.println(""Invalid item: cannot be added."");                 }              }         });          final EventListModel listModel = new EventListModel(selectedBooks);         final EventSelectionModel selectionModel = new EventSelectionModel(selectedBooks);          JButton removeButton = new JButton(""Remove"");         removeButton.addActionListener(new ActionListener() {              @Override             public void actionPerformed(ActionEvent e) {                 EventList&lt;Book&gt; selectedListItems = selectionModel.getSelected();                 for (Book book : selectedListItems) {                     selectedBooks.remove(book);                     availableBooks.add(book);                 }             }         });          JPanel panel = new JPanel(new BorderLayout());         panel.add(availableItems, BorderLayout.CENTER);         panel.add(addButton, BorderLayout.EAST);           JList selectedItemsList = new JList(listModel);         selectedItemsList.setSelectionModel(selectionModel);         mainFrame.setLayout(new BorderLayout());         mainFrame.getContentPane().add(panel, BorderLayout.NORTH);         mainFrame.getContentPane().add(selectedItemsList, BorderLayout.CENTER);         mainFrame.getContentPane().add(removeButton, BorderLayout.SOUTH);     }      /**      * @param args the command line arguments      */     public static void main(String[] args) {         javax.swing.SwingUtilities.invokeLater(new Runnable() {         @Override         public void run() {           new GlazedListsAutocompleteTest();         }     });     }      class Book {         private String title;          public Book() {         }          public Book(String title) {             this.title = title;         }          public String getTitle() {             return title;         }          public void setTitle(String title) {             this.title = title;         }          @Override         public String toString() {             return getTitle();         }        }      class BookComparitor implements Comparator&lt;Book&gt; {          @Override         public int compare(Book b1, Book b2) {             return b1.getTitle().compareToIgnoreCase(b2.getTitle());         }     } }"
"import java.util.Comparator; import java.util.List; import java.util.stream.Collectors; import java.util.stream.Stream;  Stream&lt;Integer&gt; ranges = Stream.iterate(1, i -&gt; i + 1).limit(15); List&lt;Integer&gt; collect = ranges     .sorted(Comparator.reverseOrder()) // sort the stream from the highest to the smallest     .skip(1)                           // discards 1 element from the beginning     .sorted()                          // sort the stream from the smallest to the highest     .skip(1)                           // discards 1 element from the beginning     .collect(Collectors.toList())          ;"
"import static org.junit.Assert.assertTrue;  import java.io.StringWriter;  import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerConfigurationException; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.TransformerFactoryConfigurationError; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.junit.Test; import org.w3c.dom.DOMImplementation; import org.w3c.dom.Document; import org.w3c.dom.Element; import org.w3c.dom.Text;  public class DomTest {      @Test     public void testDom() throws Exception {         Document document = createEmptyDocument();          Element root = document.getDocumentElement();         Element child = document.createElement(""child"");         Element childOfTheChild = document.createElement(""childOfTheChild"");         Text st = document.createTextNode(""Some text"");         childOfTheChild.appendChild(st);         child.appendChild(childOfTheChild);         root.appendChild(child);          assertTrue(serialise(document).contains(""Some text""));     }      private Document createEmptyDocument() throws ParserConfigurationException {         DocumentBuilderFactory dbf = DocumentBuilderFactory.newInstance();         DOMImplementation domImpl = dbf.newDocumentBuilder()                 .getDOMImplementation();         Document document = domImpl.createDocument(null, ""root"", null);         return document;     }      private String serialise(Document document)             throws TransformerFactoryConfigurationError,             TransformerConfigurationException, TransformerException {         TransformerFactory xff = TransformerFactory.newInstance();         Transformer xf = xff.newTransformer();         StringWriter sw = new StringWriter();         xf.transform(new DOMSource(document), new StreamResult(sw));         return sw.toString();     } }"
"public enum myEnum {     BASIC(1, ""An error occurred""),     WITH_ERRORID(2, ""Error id: {0}""),     DETAILED(3, ""Problem in record {0} with index {1}"");     private int key = 0;     private String format = null;      private myEnum(int aKey, String aFormat) {         this.key=aKey;         this.format=aFormat;     }      /**      * This will take whatever input you provide and use the enum instance format      * string to generate a message.      */     public String getMessage(Object... someContents) {         return MessageFormat.format(this.format, someContents);     } }"
"public class LockExample {     private static synchronized void methodOne(int depth) {         if (depth == 0) {             return;         } else {             System.out.println(Thread.currentThread().getName() + "" methodOne (in), depth "" + depth);             methodTwo(depth - 1);             System.out.println(Thread.currentThread().getName() + "" methodOne (out), depth "" + depth);         }     }      private static synchronized void methodTwo(int depth) {         if (depth == 0) {             return;         } else {             System.out.println(Thread.currentThread().getName() + "" methodTwo (in), depth "" + depth);             methodOne(depth - 1);             System.out.println(Thread.currentThread().getName() + "" methodTwo (out), depth "" + depth);         }     }      public static void main(String[] args) {         for (int i = 0; i &lt; 5; i++) {             Thread t = new Thread(new Runnable() {                 @Override                 public void run() {                     methodOne(10);                 }             });             t.setName(""Thread"" + i);             t.start();         }     } }"
"public Vector sort(Vector sort) {         Vector v = new Vector();         for(int count = 0; count &lt; e.length; count++) {             String s = sort.elementAt(count).toString();             int i = 0;             for (i = 0; i &lt; v.size(); i++) {                 int c = s.compareTo((String) v.elementAt(i));                 if (c &lt; 0) {                     v.insertElementAt(s, i);                     break;                 } else if (c == 0) {                     break;                 }             }             if (i &gt;= v.size()) {                 v.addElement(s);             }         }         return v;     }"
"import java.awt.Color; import java.awt.Dimension; import java.util.*; import org.jfree.chart.*; import org.jfree.chart.axis.NumberAxis; import org.jfree.chart.plot.PlotOrientation; import org.jfree.chart.plot.XYPlot; import org.jfree.chart.renderer.xy.XYItemRenderer; import org.jfree.data.xy.XYDataset; import org.jfree.data.xy.XYSeries; import org.jfree.data.xy.XYSeriesCollection; import org.jfree.ui.ApplicationFrame; import org.jfree.ui.RefineryUtilities;  /**  * @see https://stackoverflow.com/questions/7208657  * @see https://stackoverflow.com/questions/7071057  */ public class ScatterTickLabels extends ApplicationFrame {      public ScatterTickLabels(String s) {         super(s);         final ChartPanel chartPanel = createDemoPanel();         chartPanel.setPreferredSize(new Dimension(640, 480));         this.add(chartPanel);     }      public static ChartPanel createDemoPanel() {         JFreeChart jfreechart = ChartFactory.createScatterPlot(             ""Scatter Plot Demo"", ""X"", ""Y"", samplexydataset(),             PlotOrientation.VERTICAL, true, true, false);         XYPlot xyPlot = (XYPlot) jfreechart.getPlot();         xyPlot.setDomainCrosshairVisible(true);         xyPlot.setRangeCrosshairVisible(true);         XYItemRenderer renderer = xyPlot.getRenderer();         renderer.setSeriesPaint(0, Color.blue);         NumberAxis domain = (NumberAxis) xyPlot.getDomainAxis();         domain.setVerticalTickLabels(true);         return new ChartPanel(jfreechart);     }      private static XYDataset samplexydataset() {         int cols = 20;         int rows = 20;         XYSeriesCollection xySeriesCollection = new XYSeriesCollection();         XYSeries series = new XYSeries(""Random"");         Random rand = new Random();         for (int i = 0; i &lt; rows; i++) {             for (int j = 0; j &lt; cols; j++) {                 double x = rand.nextGaussian();                 double y = rand.nextGaussian();                 series.add(x, y);             }         }         xySeriesCollection.addSeries(series);         return xySeriesCollection;     }      public static void main(String args[]) {         ScatterTickLabels demo = new ScatterTickLabels(""Scatter Plot Demo"");         demo.pack();         RefineryUtilities.centerFrameOnScreen(demo);         demo.setVisible(true);     } }"
"int[][] map = {     {1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0},     {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}  };"
"interface Interface&lt;T&gt; {     public void processData(); }  class MyClass&lt;T&gt; implements Interface&lt;T&gt; {     private final Collection&lt;? extends T&gt; data;     MyClass(Comparator&lt;T&gt; comparator, Collection&lt;? extends T&gt; data) {         this.data = data;     }     public void processData() {         // ...     } }  class MyCompClass&lt;T extends Comparable&lt;T&gt;&gt; implements Interface&lt;T&gt; {     private final Collection&lt;? extends T&gt; data;     MyCompClass(Collection&lt;? extends T&gt; data) {         this.data = data;     }     public void processData() {         // ...     } }  class Factory {     static &lt;T extends Comparable&lt;T&gt;&gt; Interface&lt;T&gt; create(Collection&lt;? extends T&gt; data) {         return new MyCompClass&lt;T&gt;(data);     }     static &lt;T&gt; Interface&lt;T&gt; create(Comparator&lt;T&gt; comparator, Collection&lt;? extends T&gt; data) {         return new MyClass&lt;T&gt;(comparator, data);     } }"
"import java.io.File; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Attr; import org.w3c.dom.Document; import org.w3c.dom.Element;  public class WriteXMLFile {      public static void main(String argv[]) {        try {          DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();         DocumentBuilder docBuilder = docFactory.newDocumentBuilder();          // root elements         Document doc = docBuilder.newDocument();         Element rootElement = doc.createElement(""company"");         doc.appendChild(rootElement);          // staff elements         Element staff = doc.createElement(""Staff"");         rootElement.appendChild(staff);          // set attribute to staff element         Attr attr = doc.createAttribute(""id"");         attr.setValue(""1"");         staff.setAttributeNode(attr);          // shorten way         // staff.setAttribute(""id"", ""1"");          // firstname elements         Element firstname = doc.createElement(""firstname"");         firstname.appendChild(doc.createTextNode(""yong""));         staff.appendChild(firstname);          // lastname elements         Element lastname = doc.createElement(""lastname"");         lastname.appendChild(doc.createTextNode(""mook kim""));         staff.appendChild(lastname);          // nickname elements         Element nickname = doc.createElement(""nickname"");         nickname.appendChild(doc.createTextNode(""mkyong""));         staff.appendChild(nickname);          // salary elements         Element salary = doc.createElement(""salary"");         salary.appendChild(doc.createTextNode(""100000""));         staff.appendChild(salary);          // write the content into xml file         TransformerFactory transformerFactory = TransformerFactory.newInstance();         Transformer transformer = transformerFactory.newTransformer();         DOMSource source = new DOMSource(doc);         StreamResult result = new StreamResult(new File(""C:\\file.xml""));          // Output to console for testing         // StreamResult result = new StreamResult(System.out);          transformer.transform(source, result);          System.out.println(""File saved!"");        } catch (ParserConfigurationException pce) {         pce.printStackTrace();       } catch (TransformerException tfe) {         tfe.printStackTrace();       }     } }"
"import java.io.File; import javax.xml.parsers.DocumentBuilder; import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Attr; import org.w3c.dom.Document; import org.w3c.dom.Element;  public class WriteXMLFile {      public static void main(String argv[]) {        try {          DocumentBuilderFactory docFactory = DocumentBuilderFactory.newInstance();         DocumentBuilder docBuilder = docFactory.newDocumentBuilder();          // root elements         Document doc = docBuilder.newDocument();         Element rootElement = doc.createElement(""company"");         doc.appendChild(rootElement);          // staff elements         Element staff = doc.createElement(""Staff"");         rootElement.appendChild(staff);          // set attribute to staff element         Attr attr = doc.createAttribute(""id"");         attr.setValue(""1"");         staff.setAttributeNode(attr);          // shorten way         // staff.setAttribute(""id"", ""1"");          // firstname elements         Element firstname = doc.createElement(""firstname"");         firstname.appendChild(doc.createTextNode(""yong""));         staff.appendChild(firstname);          // lastname elements         Element lastname = doc.createElement(""lastname"");         lastname.appendChild(doc.createTextNode(""mook kim""));         staff.appendChild(lastname);          // nickname elements         Element nickname = doc.createElement(""nickname"");         nickname.appendChild(doc.createTextNode(""mkyong""));         staff.appendChild(nickname);          // salary elements         Element salary = doc.createElement(""salary"");         salary.appendChild(doc.createTextNode(""100000""));         staff.appendChild(salary);          // write the content into xml file         TransformerFactory transformerFactory = TransformerFactory.newInstance();         Transformer transformer = transformerFactory.newTransformer();         DOMSource source = new DOMSource(doc);         StreamResult result = new StreamResult(new File(""C:\\file.xml""));          // Output to console for testing         // StreamResult result = new StreamResult(System.out);          transformer.transform(source, result);          System.out.println(""File saved!"");        } catch (ParserConfigurationException pce) {         pce.printStackTrace();       } catch (TransformerException tfe) {         tfe.printStackTrace();       }     } }"
"public static int GiveBackAverageID(Vector&lt;DMatch&gt; lista){      ArrayList&lt;CMatch&gt; workingList = new ArrayList&lt;CMatch&gt;();      for (DMatch t : lista){         if(t.imgIdx &gt;= workingList.size() || t.imgIdx &lt; 0)         {             // do something with wrong indices.         }         else         {             if(workingList.get(t.imgIdx) == null){                 workingList.add(t.imgIdx, new CMatch(t.imgIdx,t.distance,1));             }else{                 CMatch pom = workingList.get(t.imgIdx);                 pom.setSummaDist(pom.getSummaDist()+t.distance);                 pom.setCount(pom.getCount()+1);                 workingList.set(t.imgIdx, pom);             }         }     } }"
"import java.awt.*; import javax.swing.*; public class BaselineTest {   public JComponent makeUI() {     JLabel label1 = makeLabel();     JLabel label2 = makeLabel();     String s = ""For detailed infomation refer: "";     JTextPane textPane = new JTextPane();     textPane.replaceSelection(s);     textPane.insertComponent(label1);      Dimension d = label2.getPreferredSize();     int baseline = label2.getBaseline(d.width, d.height);     label2.setAlignmentY(baseline/(float)d.height);     textPane.replaceSelection(""\n\n""+s);     textPane.insertComponent(label2);      return new JScrollPane(textPane);   }   private static JLabel makeLabel() {     JLabel label = new JLabel(""2012-10-05"");     label.setForeground(Color.BLUE);     label.setOpaque(false);     return label;   }   public static void main(String[] args) {     EventQueue.invokeLater(new Runnable() {       @Override public void run() {         createAndShowGUI();       }     });   }   public static void createAndShowGUI() {     JFrame f = new JFrame();     f.setDefaultCloseOperation(WindowConstants.EXIT_ON_CLOSE);     f.getContentPane().add(new BaselineTest().makeUI());     f.setSize(320, 240);     f.setLocationRelativeTo(null);     f.setVisible(true);   } }"
"if (!config.isOnlyMemory() &amp;&amp; dataHead.inMemory &gt;= config.memoryThreshold) {          try {              String prefix = config.getTempFilePrefix();              String suffix = config.getTempFileSuffix();              File dir = config.getTempDir();              File tempFile = (dir == null)                      ? File.createTempFile(prefix, suffix) // here your code crashes                      : File.createTempFile(prefix, suffix, dir);              LOGGER.fine(""Created temp file = ""+tempFile);              dataHead.dataFile = new DataFile(tempFile);          } catch(IOException ioe) {              throw new MIMEParsingException(ioe);          }"
"import java.io.File;  import javax.xml.parsers.DocumentBuilderFactory; import javax.xml.parsers.ParserConfigurationException; import javax.xml.transform.OutputKeys; import javax.xml.transform.Transformer; import javax.xml.transform.TransformerException; import javax.xml.transform.TransformerFactory; import javax.xml.transform.TransformerFactoryConfigurationError; import javax.xml.transform.dom.DOMSource; import javax.xml.transform.stream.StreamResult;  import org.w3c.dom.Document; import org.w3c.dom.Element;  public class XmlGenerator {      Document document = null;     Element root = null;      private void generateXml() {          try {              DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();              document = documentBuilderFactory.newDocumentBuilder().newDocument();              root = document.createElement(""FlyBoy"");             document.appendChild(root);              Element learJet = document.createElement(""learJet"");             learJet.setTextContent(""CL-215"");             root.appendChild(learJet);              Element rank = document.createElement(""rank"");             rank.setTextContent(""2"");             root.appendChild(rank);              Element flyBoy1 = renderFlyBoy(root, ""Mark II"", ""1"");             Element flyBoy2 = renderFlyBoy(flyBoy1, ""Mark II4455"", ""2"");             Element flyBoy3 = renderFlyBoy(flyBoy2, ""Mark II56666"", ""3"");              DOMSource domSource = new DOMSource(document);             Transformer transformer = TransformerFactory.newInstance().newTransformer();             transformer.setOutputProperty(OutputKeys.INDENT, ""yes"");             transformer.setOutputProperty(OutputKeys.METHOD, ""xml"");             StreamResult result = new StreamResult(new File(""my.xml""));             transformer.transform(domSource, result);          } catch (ParserConfigurationException | TransformerFactoryConfigurationError | TransformerException e) {             e.printStackTrace();         }     }      /**      * Render flyboy      *       */     private Element renderFlyBoy(Element parent, String viper, String rank) {          Element flyBoyEl = document.createElement(""FlyBoy"");         parent.appendChild(flyBoyEl);          Element viperEl = document.createElement(""viper"");         viperEl.setTextContent(viper);         flyBoyEl.appendChild(viperEl);          Element rankEl = document.createElement(""rank"");         rankEl.setTextContent(rank);         flyBoyEl.appendChild(rankEl);          return flyBoyEl;      }      // Test     public static void main(String[] args) {         XmlGenerator ob = new XmlGenerator();         try {             ob.generateXml();             System.out.println(""done..."");          } catch (Exception e) {             e.printStackTrace();         }     }  }"
"import java.util.List; import java.util.Set;  import javax.annotation.processing.AbstractProcessor; import javax.annotation.processing.RoundEnvironment; import javax.annotation.processing.SupportedAnnotationTypes; import javax.annotation.processing.SupportedSourceVersion; import javax.lang.model.SourceVersion; import javax.lang.model.element.Element; import javax.lang.model.element.ElementKind; import javax.lang.model.element.TypeElement; import javax.tools.Diagnostic.Kind;  @SupportedSourceVersion(SourceVersion.RELEASE_7) @SupportedAnnotationTypes(""*"") public class Test extends AbstractProcessor {     public int shit;     public int foo;      @Override     public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {         Set&lt;? extends Element&gt; rootElements = roundEnv.getRootElements();          for (Element element : rootElements) {             if (element.getKind() == ElementKind.CLASS) {                 List&lt;? extends Element&gt; classElements = element.getEnclosedElements();                  for (Element classElement : classElements) {                     if (classElement.getKind() == ElementKind.FIELD) {                         if (classElement.getSimpleName().contentEquals(""shit"")) {                             processingEnv.getMessager().printMessage(                                 Kind.WARNING,                                 ""How dare you to swear in the source code?!"",                                 classElement                             );                         }                     }                 }             }         }          return false;     }      public static void main(String[] args) {         //     } }"
