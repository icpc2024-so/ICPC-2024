code
"SAXTransformerFactory stf = (SAXTransformerFactory)TransformerFactory.newInstance();  // These templates objects could be reused and obtained from elsewhere. Templates templates1 = stf.newTemplates(new StreamSource(   getClass().getResourceAsStream(""MyStylesheet1.xslt""))); Templates templates2 = stf.newTemplates(new StreamSource(   getClass().getResourceAsStream(""MyStylesheet1.xslt"")));  TransformerHandler th1 = stf.newTransformerHandler(templates1); TransformerHandler th2 = stf.newTransformerHandler(templates2);  th1.setResult(new SAXResult(th2)); th2.setResult(new StreamResult(System.out));  Transformer t = stf.newTransformer(); t.transform(new StreamSource(System.in), new SAXResult(th1));  // th1 feeds th2, which in turn feeds System.out."
"package name.seller.rich.maven.plugins.bootstrap;  import java.util.List;  import org.apache.maven.artifact.Artifact; import org.apache.maven.artifact.factory.ArtifactFactory; import org.apache.maven.artifact.repository.ArtifactRepository; import org.apache.maven.artifact.resolver.ArtifactNotFoundException; import org.apache.maven.artifact.resolver.ArtifactResolutionException; import org.apache.maven.artifact.resolver.ArtifactResolver; import org.apache.maven.plugin.AbstractMojo; import org.apache.maven.plugin.MojoExecutionException; import org.apache.maven.plugin.MojoFailureException;  /**  * Obtain the artifact defined by the groupId, artifactId, and version  * from the remote repository.  *   * @goal bootstrap  */ public class BootstrapAppMojo extends AbstractMojo {      /**      * Used to look up Artifacts in the remote repository.      *       * @parameter expression=      *  ""${component.org.apache.maven.artifact.factory.ArtifactFactory}""      * @required      * @readonly      */     protected ArtifactFactory factory;      /**      * Used to look up Artifacts in the remote repository.      *       * @parameter expression=      *  ""${component.org.apache.maven.artifact.resolver.ArtifactResolver}""      * @required      * @readonly      */     protected ArtifactResolver artifactResolver;      /**      * List of Remote Repositories used by the resolver      *       * @parameter expression=""${project.remoteArtifactRepositories}""      * @readonly      * @required      */     protected List remoteRepositories;      /**      * Location of the local repository.      *       * @parameter expression=""${localRepository}""      * @readonly      * @required      */     protected ArtifactRepository localRepository;      /**      * The target pom's artifactId      *       * @parameter expression=""${bootstrapArtifactId}""      * @required      */     private String bootstrapArtifactId;      /**      * The target pom's groupId      *       * @parameter expression=""${bootstrapGroupId}""      * @required      */     private String bootstrapGroupId;      /**      * The target pom's type      *       * @parameter expression=""${bootstrapType}""      * @required      */     private String bootstrapType;      /**      * The target pom's version      *       * @parameter expression=""${bootstrapVersion}""      * @required      */     private String bootstrapVersion;      public void execute() throws MojoExecutionException, MojoFailureException {         try {             Artifact pomArtifact = this.factory.createArtifact(                 bootstrapGroupId, bootstrapArtifactId, bootstrapVersion,                 """", bootstrapType);              artifactResolver.resolve(pomArtifact, this.remoteRepositories,                 this.localRepository);         } catch (ArtifactResolutionException e) {             getLog().error(""can't resolve parent pom"", e);         } catch (ArtifactNotFoundException e) {             getLog().error(""can't resolve parent pom"", e);         }     } }"
"List&lt;string&gt; termSet = fieldQuery.getTermSet(fieldName);         VectorHighlightMapper tfv = new VectorHighlightMapper(termSet);             reader.GetTermFreqVector(docId, fieldName, tfv);  // &lt;-- look at this line          string[] terms = tfv.GetTerms();         foreach (String term in terms)         {             if (!termSet.Contains(term)) continue;             int index = tfv.IndexOf(term);             TermVectorOffsetInfo[] tvois = tfv.GetOffsets(index);             if (tvois == null) return; // just return to make null snippets             int[] poss = tfv.GetTermPositions(index);             if (poss == null) return; // just return to make null snippets             for (int i = 0; i &lt; tvois.Length; i++)                 termList.AddLast(new TermInfo(term, tvois[i].GetStartOffset(), tvois[i].GetEndOffset(), poss[i]));"
"import com.xuggle.xuggler.Configuration; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IContainerFormat; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IPixelFormat; import com.xuggle.xuggler.IRational; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture; import com.xuggle.xuggler.video.ConverterFactory; import com.xuggle.xuggler.video.IConverter; import java.awt.AWTException; import java.awt.Rectangle; import java.awt.Robot; import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.util.Properties;  public class XugglerRtmpReferenceImpl {     private static String url = ""rtmp://your.test.server/screen/"";    private static String fileName = ""test/teststream"";    private static int framesToEncode = 60;    private static int x = 0;    private static int y = 0;    private static int height = 480;    private static int width = 640;     public static void main(String[] args) {        IContainer container = IContainer.make();        IContainerFormat containerFormat_live = IContainerFormat.make();        containerFormat_live.setOutputFormat(""flv"", url + fileName, null);        container.setInputBufferLength(0);        int retVal = container.open(url + fileName, IContainer.Type.WRITE, containerFormat_live);        if (retVal &lt; 0) {            System.err.println(""Could not open output container for live stream"");            System.exit(1);        }        IStream stream = container.addNewStream(0);        IStreamCoder coder = stream.getStreamCoder();        ICodec codec = ICodec.findEncodingCodec(ICodec.ID.CODEC_ID_H264);        coder.setNumPicturesInGroupOfPictures(5);        coder.setCodec(codec);        coder.setBitRate(200000);        coder.setPixelType(IPixelFormat.Type.YUV420P);        coder.setHeight(height);        coder.setWidth(width);        System.out.println(""[ENCODER] video size is "" + width + ""x"" + height);        coder.setFlag(IStreamCoder.Flags.FLAG_QSCALE, true);        coder.setGlobalQuality(0);        IRational frameRate = IRational.make(5, 1);        coder.setFrameRate(frameRate);        coder.setTimeBase(IRational.make(frameRate.getDenominator(), frameRate.getNumerator()));        Properties props = new Properties();        InputStream is = XugglerRtmpReferenceImpl.class.getResourceAsStream(""/libx264-normal.ffpreset"");        try {            props.load(is);        } catch (IOException e) {            System.err.println(""You need the libx264-normal.ffpreset file from the Xuggle distribution in your classpath."");            System.exit(1);        }        Configuration.configure(props, coder);        coder.open();        container.writeHeader();        long firstTimeStamp = System.currentTimeMillis();        long lastTimeStamp = -1;        int i = 0;        try {            Robot robot = new Robot();            while (i &lt; framesToEncode) {                //long iterationStartTime = System.currentTimeMillis();                long now = System.currentTimeMillis();                //grab the screenshot                BufferedImage image = robot.createScreenCapture(new Rectangle(x, y, width, height));                //convert it for Xuggler                BufferedImage currentScreenshot = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);                currentScreenshot.getGraphics().drawImage(image, 0, 0, null);                //start the encoding process                IPacket packet = IPacket.make();                IConverter converter = ConverterFactory.createConverter(currentScreenshot, IPixelFormat.Type.YUV420P);                long timeStamp = (now - firstTimeStamp) * 1000;                 IVideoPicture outFrame = converter.toPicture(currentScreenshot, timeStamp);                if (i == 0) {                    //make first frame keyframe                    outFrame.setKeyFrame(true);                }                outFrame.setQuality(0);                coder.encodeVideo(packet, outFrame, 0);                outFrame.delete();                if (packet.isComplete()) {                    container.writePacket(packet);                    System.out.println(""[ENCODER] writing packet of size "" + packet.getSize() + "" for elapsed time "" + ((timeStamp - lastTimeStamp) / 1000));                    lastTimeStamp = timeStamp;                }                System.out.println(""[ENCODER] encoded image "" + i + "" in "" + (System.currentTimeMillis() - now));                i++;                try {                    Thread.sleep(Math.max((long) (1000 / frameRate.getDouble()) - (System.currentTimeMillis() - now), 0));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        } catch (AWTException e) {            e.printStackTrace();        }        container.writeTrailer();     } }"
"public class AddHttpHeaderInterceptor implements ClientInterceptor {  public boolean handleFault(MessageContext messageContext)         throws WebServiceClientException {     return true; }  public boolean handleRequest(MessageContext messageContext)         throws WebServiceClientException {      TransportContext context = TransportContextHolder.getTransportContext();      HttpComponentsConnection connection =(HttpComponentsConnection) context.getConnection();      connection.addRequestHeader(""name"", ""suman"");      return true; }  public boolean handleResponse(MessageContext messageContext)         throws WebServiceClientException {     return true; }  }"
"String proxyUser = """"; String proxyPassword = """"; String proxyAddress = """"; int proxyPort = 8080; InetSocketAddress sa = new InetSocketAddress(proxyAddress, proxyPort); Proxy proxy = new Proxy(Proxy.Type.HTTP, sa); URLConnection conn = url.openConnection(proxy); sun.misc.BASE64Encoder encoder = new sun.misc.BASE64Encoder(); String encodedUserPwd = encoder.encode((proxyUser + "":"" + proxyPassword).getBytes()); conn.setRequestProperty(""Accept-Charset"", ""UTF-8""); conn.setRequestProperty(""Proxy-Authorization"", ""Basic "" + encodedUserPwd);"
"HttpResponse response = httpclient.execute(httppost); HttpEntity entity = response.getEntity(); InputStream is = entity.getContent();  try {      BufferedReader reader = new BufferedReader(new InputStreamReader(is, ""utf-8""), 256);  StringBuilder sb = new StringBuilder();  String line = null;  while ((line = reader.readLine()) != null)  sb.append(line);       result = sb.toString();  is.close(); } catch (Exception e) {}   JSONArray jArray = new JSONArray(result);  for(int i = 0; i &lt; jArray.length(); i++) { JSONObject json_data = jArray.getJSONObject(i); String url= json_data.getString(""url"");     String expires= json_data.getString(""expires"");  }"
"if (new File(destination).listFiles().length &lt;= 1) {     return ""/GUI/printServerSide.xhtml""; } else if(""txt"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""jpeg"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""jpg"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""png"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""gif"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""pdf"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else if (""html"".equalsIgnoreCase(extension)) {     return ""/GUI/submittedFilePreview.xhtml""; } else {     return ""/GUI/printServerSide.xhtml""; }"
"try {      utx.begin();      Query q3 = em.createQuery(""DELETE FROM ItemModuleConnection"");     Query q4 = em.createQuery(""DELETE FROM ModuleConnection"");     Query q1 = em.createQuery(""DELETE FROM BomModule"");     Query q2 = em.createQuery(""DELETE FROM BomItem"");      q1.executeUpdate();     q2.executeUpdate();     q3.executeUpdate();     q4.executeUpdate();      utx.commit(); } catch (NotSupportedException | SystemException | SecurityException | IllegalStateException | RollbackException | HeuristicMixedException | HeuristicRollbackException e) {     e.printStackTrace(); }"
"final ClientConfig config = new DefaultClientConfig(); config.getFeatures().put(JSONConfiguration.FEATURE_POJO_MAPPING,         Boolean.TRUE); final Client client = Client.create(config);  final WebResource resource = client         .resource(URL_HERE); final MimeMultipart response = resource.get(MimeMultipart.class);  // This will iterate the individual parts of the multipart response for (int i = 0; i &lt; response.getCount(); i++) {     final BodyPart part = response.getBodyPart(i);     System.out.printf(             ""Embedded Body Part [Mime Type: %s, Length: %s]\n"",             part.getContentType(), part.getSize()); }"
"public TestKeyBindings02() {     JPanel panel = new JPanel();     InputMap im = panel.getInputMap(JPanel.WHEN_IN_FOCUSED_WINDOW);     ActionMap am = panel.getActionMap();      im.put(KeyStroke.getKeyStroke(KeyEvent.VK_RIGHT, 0), ""RightArrow"");     im.put(KeyStroke.getKeyStroke(KeyEvent.VK_LEFT, 0), ""LeftArrow"");     im.put(KeyStroke.getKeyStroke(KeyEvent.VK_UP, 0), ""UpArrow"");     im.put(KeyStroke.getKeyStroke(KeyEvent.VK_DOWN, 0), ""DownArrow"");      am.put(""RightArrow"", new ArrowAction(""RightArrow""));     am.put(""LeftArrow"", new ArrowAction(""LeftArrow""));     am.put(""UpArrow"", new ArrowAction(""UpArrow""));     am.put(""DownArrow"", new ArrowAction(""DownArrow"")); }  public class ArrowAction extends AbstractAction {      private String cmd;      public ArrowAction(String cmd) {         this.cmd = cmd;     }      @Override     public void actionPerformed(ActionEvent e) {         if (cmd.equalsIgnoreCase(""LeftArrow"")) {             System.out.println(""The left arrow was pressed!"");         } else if (cmd.equalsIgnoreCase(""RightArrow"")) {             System.out.println(""The right arrow was pressed!"");         } else if (cmd.equalsIgnoreCase(""UpArrow"")) {             System.out.println(""The up arrow was pressed!"");         } else if (cmd.equalsIgnoreCase(""DownArrow"")) {             System.out.println(""The down arrow was pressed!"");         }     } }"
"public class ServerThread extends Thread {     public void run() {         String sDataFromPOS="""";         //Get Some Value in sDataFromPOS         SAXHandler handler = new SAXHandler();         byte[] bSendToPOS = handler.parseXMLToString(sDataFromPOS.toString().substring(2));         handler.sTerminalId .... // access instance variables     } }  public class SAXHandler extends DefaultHandler {     String sTerminalId = """";     String sTransactionId = """";      public byte[] parseXMLToString(String sXMLData) throws Throwable {         /* Do Some Operation on String sXMLData &amp; extarct value of sTerminalId &amp; sTransactionId*/     } }"
"List&lt;String&gt; delimList = new ArrayList&lt;String&gt;(); List&lt;String&gt; sectionList = new ArrayList&lt;String&gt;(); Pattern regex = Pattern.compile(     ""(&lt;:==[\\]}]:&gt;)     # Match a delimiter, capture it in group 1.\n"" +     ""(                  # Match and capture in group 2:\n"" +     "" (?:               # the following group which matches...\n"" +     ""  (?!&lt;:==[\\]}]:&gt;) # (unless we're at the start of another delimiter)\n"" +     ""  .                # any character\n"" +     "" )*                # any number of times.\n"" +     "")                  # End of group 2"",      Pattern.COMMENTS | Pattern.DOTALL); Matcher regexMatcher = regex.matcher(subjectString); while (regexMatcher.find()) {     delimList.add(regexMatcher.group(1));     sectionList.add(regexMatcher.group(2)); }"
"private final String ENCODED_PART_REGEX_PATTERN=""=\\?([^?]+)\\?([^?]+)\\?([^?]+)\\?="";  private String decode(String s) {     Pattern pattern=Pattern.compile(ENCODED_PART_REGEX_PATTERN);      Matcher m=pattern.matcher(s);      ArrayList&lt;String&gt; encodedParts=new ArrayList&lt;String&gt;();      while(m.find())     {         encodedParts.add(m.group(0));      }      if(encodedParts.size()&gt;0)     {         try         {             for(String encoded:encodedParts)             {                 s=s.replace(encoded, MimeUtility.decodeText(encoded));             }              return s;          } catch(Exception ex)         {             return s;         }     }     else         return s;  }"
"public String getMessage(final Locale locale, final String key) {     PlatformResourceBundleLocator bundleLocator = new PlatformResourceBundleLocator(&quot;org.hibernate.validator.ValidationMessages&quot;);     ResourceBundle resourceBundle = bundleLocator.getResourceBundle(locale);      try {        final String k = key.replace(&quot;{&quot;, &quot;&quot;).replace(&quot;}&quot;, &quot;&quot;);        return resourceBundle.getString(k);     }     catch (MissingResourceException e) {        return key;     } }"
"private void instantiateNestedProperties(Object obj, String fieldName) {     try {         String[] fieldNames = fieldName.split(""\\."");         if (fieldNames.length &gt; 1) {             StringBuffer nestedProperty = new StringBuffer();             for (int i = 0; i &lt; fieldNames.length - 1; i++) {                 String fn = fieldNames[i];                 if (i != 0) {                     nestedProperty.append(""."");                 }                 nestedProperty.append(fn);                  Object value = PropertyUtils.getProperty(obj, nestedProperty.toString());                  if (value == null) {                     PropertyDescriptor propertyDescriptor = PropertyUtils.getPropertyDescriptor(obj, nestedProperty.toString());                     Class&lt;?&gt; propertyType = propertyDescriptor.getPropertyType();                     Object newInstance = propertyType.newInstance();                     PropertyUtils.setProperty(obj, nestedProperty.toString(), newInstance);                 }             }         }     } catch (IllegalAccessException e) {         throw new RuntimeException(e);     } catch (InvocationTargetException e) {         throw new RuntimeException(e);     } catch (NoSuchMethodException e) {         throw new RuntimeException(e);     } catch (InstantiationException e) {         throw new RuntimeException(e);     } }"
"when(mockTransactionTemplate.execute(Mockito.&lt;TransactionCallback&gt;any())).thenAnswer(new Answer() {          public Object answer(InvocationOnMock invocation) {              Object[] args = invocation.getArguments();            TransactionCallback arg = (TransactionCallback)args[0];              return arg.doInTransaction(new SimpleTransactionStatus());          }      });          when(mockResourceService.callReserve(any(ReserveDetails.class))).thenReturn(reserveInfo);     when(mockResourceService.callRelease(eq(id))).thenReturn(releaseInfo);      //Call the exe method     someService.exe();      verify(mockResourceService, times(1)).callReserve(any(ReserveDetails.class));     verify(mockSomeOtherService, times(1)).doSomthing());     verify(mockMemberResourceService, times(1)).callRelease(eq(id));"
"package com.bullethq.jawr.postprocessor;  import net.jawr.web.resource.FileNameUtils; import net.jawr.web.resource.bundle.factory.util.PathNormalizer; import net.jawr.web.resource.bundle.postprocess.BundleProcessingStatus; import net.jawr.web.resource.bundle.postprocess.impl.CSSURLPathRewriterPostProcessor; import net.jawr.web.resource.bundle.postprocess.impl.PostProcessorCssImageUrlRewriter;  import java.io.IOException;  public class CustomCssUrlPathRewriterPostProcessor extends CSSURLPathRewriterPostProcessor {      public static final String CUSTOM_URL_PATH_REWRITER = ""customcsspathrewriter"";      public CustomCssUrlPathRewriterPostProcessor() {         super(CUSTOM_URL_PATH_REWRITER);     }      // ========================================================================     // ========================================================================     // ========================================================================     @Override     protected PostProcessorCssImageUrlRewriter createImageUrlRewriter(BundleProcessingStatus status) {         return new CustomPostProcessorCssImageUrlRewriter(status);     }      // ========================================================================     // ========================================================================     // ========================================================================     public class CustomPostProcessorCssImageUrlRewriter extends PostProcessorCssImageUrlRewriter {          public CustomPostProcessorCssImageUrlRewriter(BundleProcessingStatus status) {             super(status);         }          // ========================================================================         // ========================================================================         // ========================================================================         @Override         protected String getUrlPath(String match, String originalPath, String newCssPath) throws IOException {             String url = match.substring(match.indexOf('(') + 1, match.lastIndexOf(')')).trim();              // Remove any quotes if necessary.             String quoteStr = """";             if (url.startsWith(""'"") || url.startsWith(""\"""")) {                 quoteStr = String.valueOf(url.charAt(0));                 url = url.substring(1, url.length() - 1);             }              // We now check if the url ends in a known image file extension             // If not, the url is ignored.             if (FileNameUtils.hasImageExtension(url)) {                 return super.getUrlPath(match, originalPath, newCssPath);             } else {                 // We need to rewrite the path, as any relative URLs will                 // not resolve correctly if Jawr has changed the CSS path.                 url = PathNormalizer.concatWebPath(originalPath, url);                 url = PathNormalizer.getRelativeWebPath(PathNormalizer.getParentPath(newCssPath), url);                 return ""url("" + quoteStr + url + quoteStr + "")"";             }         }     } }"
public void comboFilter(String enteredText) {     if (!this.isPopupVisible()) {         this.showPopup();     }      List&lt;String&gt; filterArray= new ArrayList&lt;String&gt;();     for (int i = 0; i &lt; array.size(); i++) {         if (array.get(i).toLowerCase().contains(enteredText.toLowerCase())) {             filterArray.add(array.get(i));         }     }     if (filterArray.size() &gt; 0) {         DefaultComboBoxModel model = (DefaultComboBoxModel) this.getModel();         model.removeAllElements();         for (String s: filterArray)             model.addElement(s);          JTextField textfield = (JTextField) this.getEditor().getEditorComponent();         textfield.setText(enteredText);     } }
"public JMenuItem createMenuItemWithListener(String text,                                              char mnemonic,                                              ActionListener action) {     JMenuItem result = new JMenuItem(text);     result.setMnemonic(mnemonic);     result.addActionListener(action);     return result; }  public JMenuItem createMenuItemWithAction(char mnemonic,                                            Action action) {     JMenuItem result = new JMenuItem(action);     result.setMnemonic(mnemonic);     return result; }"
"import com.xuggle.mediatool.IMediaWriter; import com.xuggle.mediatool.ToolFactory; import com.xuggle.xuggler.IAudioSamples; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture;    /**  * This class is used to merge audio and video file.  *  * @author Arslaan Ejaz  */ public class DecodeAndSaveAudioVideo {   public static void main(String[] args)   {      String filenamevideo = ""f:/testvidfol/video.mp4""; //this is the input file for video. you can change extension     String filenameaudio = ""f:/testvidfol/audio.wav""; //this is the input file for audio. you can change extension       IMediaWriter mWriter = ToolFactory.makeWriter(""f:/testvidfol/audiovideooutput.flv""); //output file      IContainer containerVideo = IContainer.make();     IContainer containerAudio = IContainer.make();      if (containerVideo.open(filenamevideo, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenamevideo);      if (containerAudio.open(filenameaudio, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenameaudio);      int numStreamVideo = containerVideo.getNumStreams();     int numStreamAudio = containerAudio.getNumStreams();      System.out.println(""Number of video streams: ""+numStreamVideo + ""\n"" + ""Number of audio streams: ""+numStreamAudio );  int videostreamt = -1; //this is the video stream id int audiostreamt = -1;  IStreamCoder  videocoder = null;      for(int i=0; i&lt;numStreamVideo; i++){         IStream stream = containerVideo.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO)         {             videostreamt = i;             videocoder = code;             break;         }      }      for(int i=0; i&lt;numStreamAudio; i++){         IStream stream = containerAudio.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO)         {             audiostreamt = i;             break;         }      }      if (videostreamt == -1) throw new RuntimeException(""No video steam found"");     if (audiostreamt == -1) throw new RuntimeException(""No audio steam found"");      if(videocoder.open()&lt;0 ) throw new RuntimeException(""Cant open video coder"");     IPacket packetvideo = IPacket.make();      IStreamCoder audioCoder = containerAudio.getStream(audiostreamt).getStreamCoder();      if(audioCoder.open()&lt;0 ) throw new RuntimeException(""Cant open audio coder"");     mWriter.addAudioStream(1, 1, audioCoder.getChannels(), audioCoder.getSampleRate());      mWriter.addVideoStream(0, 0, videocoder.getWidth(), videocoder.getHeight());      IPacket packetaudio = IPacket.make();      while(containerVideo.readNextPacket(packetvideo) &gt;= 0 ||             containerAudio.readNextPacket(packetaudio) &gt;= 0){          if(packetvideo.getStreamIndex() == videostreamt){              //video packet             IVideoPicture picture = IVideoPicture.make(videocoder.getPixelType(),                     videocoder.getWidth(),                     videocoder.getHeight());             int offset = 0;             while (offset &lt; packetvideo.getSize()){                 int bytesDecoded = videocoder.decodeVideo(picture,                          packetvideo,                          offset);                 if(bytesDecoded &lt; 0) throw new RuntimeException(""bytesDecoded not working"");                 offset += bytesDecoded;                  if(picture.isComplete()){                     System.out.println(picture.getPixelType());                     mWriter.encodeVideo(0, picture);                  }             }         }           if(packetaudio.getStreamIndex() == audiostreamt){            //audio packet              IAudioSamples samples = IAudioSamples.make(512,                      audioCoder.getChannels(),                     IAudioSamples.Format.FMT_S32);               int offset = 0;             while(offset&lt;packetaudio.getSize())             {                 int bytesDecodedaudio = audioCoder.decodeAudio(samples,                          packetaudio,                         offset);                 if (bytesDecodedaudio &lt; 0)                     throw new RuntimeException(""could not detect audio"");                 offset += bytesDecodedaudio;                  if (samples.isComplete()){                      mWriter.encodeAudio(1, samples);          }             }      }    } } }"
"Document doc = Jsoup.parseBodyFragment(aText); Elements el = doc.getAllElements(); for (Element e : el) {     List&lt;String&gt;  attToRemove = new ArrayList&lt;&gt;();     Attributes at = e.attributes();     for (Attribute a : at) {         // transfer it into a list -         // to be sure ALL data-attributes will be removed!!!         attToRemove.add(a.getKey());     }      for(String att : attToRemove) {         e.removeAttr(att);    } }   return Jsoup.isValid(doc.body().html(), theLegalWhitelist);"
"public class UserDaoImpl extends HibernateDaoSupport implements UserDao {     @Override     public void addUser(UserMap userMap) {         getHibernateTemplate().save(userMap);     }     @Override     public List&lt;User&gt; findAllUser() {         return getHibernateTemplate().find(""from User"");     }     @Override     public void deleteUser(UserMap user) {         getHibernateTemplate().delete(user);     }     @Override     public void updateUser(UserMap user) {         getHibernateTemplate().update(user);     } }"
"public void parse(String json)  {        JsonFactory factory = new JsonFactory();         ObjectMapper mapper = new ObjectMapper(factory);        JsonNode rootNode = mapper.readTree(json);           Iterator&lt;Map.Entry&lt;String,JsonNode&gt;&gt; fieldsIterator = rootNode.fields();        while (fieldsIterator.hasNext()) {             Map.Entry&lt;String,JsonNode&gt; field = fieldsIterator.next();            System.out.println(""Key: "" + field.getKey() + ""\tValue:"" + field.getValue());        } }"
"public class TryJsonStringSerializer extends JsonSerializer&lt;String&gt; {      private RawSerializer&lt;String&gt; rawSerializer = new RawSerializer&lt;String&gt;(String.class);     private ToStringSerializer stringSerializer = ToStringSerializer.instance;      @Override     public void serialize(String value, JsonGenerator jsonGenerator, SerializerProvider serializerProvider)              throws IOException, JsonProcessingException {         if (value == null) {             return;         }         value = value.trim();         if (value.startsWith(""{"") &amp;&amp; value.endsWith(""}"")) {             rawSerializer.serialize(value, jsonGenerator, serializerProvider);         } else {             stringSerializer.serialize(value, jsonGenerator, serializerProvider);         }     }  }"
"ShapeDrawable sd1 = new ShapeDrawable(new RectShape());                         sd1.getPaint().setColor(CommonUtilities.color);                         sd1.getPaint().setStyle(Style.STROKE);                         sd1.getPaint().setStrokeWidth(CommonUtilities.stroke);                         sd1.setPadding(15, 10, 15, 10);                          sd1.getPaint().setPathEffect(                                 new CornerPathEffect(CommonUtilities.corner));                         ln_back.setBackgroundDrawable(sd1);"
"mButton.setOnClickListener( new View.OnClickListener()          {             public void onClick(View view)              {                 collectionID = mEdit.getText().toString();                  Log.d(""EditText"", collectionID);                  // save value here in SharedPreferences                  SharedPreferences settings =                              ConfigPage.this.getSharedPreferences(PREFS_NAME, 0);                  SharedPreferences.Editor editor = settings.edit();                  editor.putString(collectionID, collectionID);                  editor.commit();                }          });"
"Pixmap pixmap;      void getScreenShot(){         Gdx.gl.glPixelStorei(GL10.GL_PACK_ALIGNMENT, 1);         pixmap = new Pixmap(Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), Pixmap.Format.RGBA8888);         Gdx.gl.glReadPixels(0,0, Gdx.graphics.getWidth(), Gdx.graphics.getHeight(), GL10.GL_RGBA, GL10.GL_UNSIGNED_BYTE, pixmap.getPixels());     }      /**  * Gets the RGB values of the clicked pixel  *   * @param screenX  *            X clicked position  * @param screenY  *            Y clicked position  * @return Vector3f of the RGB values.  */ private Vector3 getRGBValues(int screenX, int screenY) {     float newY = Gdx.graphics.getHeight() - screenY; //if using y up, you need to convert it to y up from a y down since by default all of the clicked cordinates are in a y down system     int value = colorMap.getPixel((int) screenX, (int) newY);     int R = ((value &amp; 0xff000000) &gt;&gt;&gt; 24);     int G = ((value &amp; 0x00ff0000) &gt;&gt;&gt; 16);     int B = ((value &amp; 0x0000ff00) &gt;&gt;&gt; 8);      return new Vector3(R, G, B); }"
"public List&lt;String&gt; sendCommand(String command) throws JSchException, IOException {         List&lt;String&gt; lines = new LinkedList&lt;String&gt;();         Channel channel = sesConnection.openChannel(""exec"");         ((ChannelExec) channel).setCommand(command);         channel.connect();          InputStream commandOutput = channel.getInputStream();         result = new BufferedReader(new InputStreamReader(commandOutput));                     String line = null;          while ((line = result.readLine()) != null) {            lines.add(line);         }          channel.disconnect();         return lines;         }"
"ExecutorService executor = Executors.newFixedThreadPool(2);     CompletionService&lt;String&gt; compService = new ExecutorCompletionService&lt;&gt;(executor);      for (int i = 0; i &lt; 2; i++) {         compService.submit(new Task(i));     }      for (int i = 0; i &lt; 2; i++) {         try {             String result = compService.take().get();             System.out.println(""RESULT: "" + result);         } catch (ExecutionException | InterruptedException e) {             e.printStackTrace();         }     }      executor.shutdownNow();"
