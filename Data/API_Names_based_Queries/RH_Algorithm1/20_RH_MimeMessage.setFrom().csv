code
"private boolean isAdmin() {     Authentication currentAuthObj = SecurityContextHolder.getContext().getAuthentication();     List&lt;GrantedAuthority&gt; authorities = Arrays.asList(currentAuthObj.getAuthorites());     for (GrantedAuthority auth : authorities) {         if (""ROLE_ADMIN"".equals(auth.getAuthority())) {             return true;         }     }     return false; }  boolean currentUserIsAuthor = ...;  modelAndView.addObject(""canEditPost"",      Boolean.valueOf(currentUserIsAuthor || isAdmin());"
"BufferedReader bufferedReader; try {     bufferedReader = request.getReader(); } catch (IllegalStateException e) {     InputStream inputStream = request.getInputStream();      // As per BalusC's comment:     String charsetName = request.getCharacterEncoding();     if (charsetName == null) {         charsetName = ""UTF-8"";     }      InputStreamReader inputStreamReader = new InputStreamReader(inputStream, charsetName);     bufferedReader = new BufferedReader(inputStreamReader); }  bufferedReader.readLine();"
"protected Context createVelocityContext(Map &lt;String, Object&gt; model,                                          HttpServletRequest request,                                         HttpServletRespsone response)                                          throws Exception {      initVelocityContext();  //Still keep toolContext static                             //will need to also add this to                              //the servletContext -- left as an exercise     prepareToolboxes(request, response);     Context context =          new ViewToolContext(getVelocityEngine(), request,                                  response, getServletContext());     //Set model attrs to context     ....     return context; }  private void prepareToolboxes(final HttpServletRequest request,                                final HttpServletResponse response) {     String key = Toolbox.class.getName();     if (factory.hasTools(Scope.REQUEST &amp;&amp; request.getAttribute(key) == null) {         Toolbox requestTools = factory.createToolbox(Scope.REQUEST);         request.setAttribute(key, requestTools);     }     if (factory.hasTools(Scope.SESSION) {        HttpSession session = request.getSession();        synchronized(factory) {            //Follow pattern from above        }     } }"
"public void test() {     DomainInterface mock = EasyMock.create(""mock"", DomainInterface.class);      // Expect that the subject will call setAnswer with an argument of ""VALID""     mock.setAnswer(""VALID"");      EasyMock.replay();      Subject subject = new Subject();     subject.setDomainInterface(mock);      DomainInterface domain = subject.process();         assertEquals(""Not the same instance"", mock, domain);      // No need to assert the result of calling getAnswer - we've already asserted     // that setAnswer will be called. }"
"for(Iterator&lt;Map.Entry&lt;String, Entity&gt;&gt; iterator = entities.entrySet().iterator(); iterator.hasNext(); ){     Map.Entry&lt;String, Entity&gt; entry = iterator.next();     String key = entry.getKey();     Entity item = entry.getValue();     if (item.isDestroyed()){         //Notice using an iterator to remove          iterator.remove();         ViewManager.getInstance().removeItem(key);         //INSTRUCT THE ENTITY TO PERFORM IT'S DESTROYED BEHAVIOR item.Destroyed()                         } else {         item.update(1);         ConsoleItem ci = new ConsoleItemImpl(item.getIdentifier(), item.getLocation(), ColorStringConverter.getInstance().StringToColor(item.getSide()), item.getAngle(), item.getShape(), item.toString(), item.isDestroyed(), item.isDamaged());         ViewManager.getInstance().updateItem(ci);                         }      item.update(1);  }"
"ComboBox accountStatusChoice = new ComboBox();  accountStatusChoice.setCaption(MessageResource.getLocalizedString(""caption.accountStatus"")); accountStatusChoice.setRequired(true); accountStatusChoice.setRequiredError(MessageResource.getLocalizedString(""error.required.accountStatus"")); accountStatusChoice.setImmediate(true);  for (AccountStatus accountStatus : AccountStatus.values()) {     accountStatusChoice.addItem(accountStatus);     accountStatusChoice.setItemCaption(accountStatus, MessageResource.getLocalizedString(accountStatus.name())); }  return accountStatusChoice;"
"SecretKeyFactory factory = SecretKeyFactory.getInstance(""PBKDF2WithHmacSHA1""); KeySpec spec = new PBEKeySpec(password, salt, 65536, 256); SecretKey tmp = factory.generateSecret(spec); SecretKey secret = new SecretKeySpec(tmp.getEncoded(), ""AES"");  Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); cipher.init(Cipher.ENCRYPT_MODE, secret);  byte[] iv = cipher.getParameters().getParameterSpec(IvParameterSpec.class).getIV(); byte[] ciphertext = cipher.doFinal(""Hello, World!"".getBytes(""UTF-8""));  // reinit cypher using param spec Cipher cipher = Cipher.getInstance(""AES/CBC/PKCS5Padding""); cipher.init(Cipher.DECRYPT_MODE, secret, new IvParameterSpec(iv));"
"Map&lt;Pair,Integer&gt; histogram = new HashMap&lt;Pair,Integer&gt;(); for(Task task : tasksByGroupAndUser) {    if (task.isSuccessful() == false) continue; //just skip unseccessful tasks.    Pair current = new Pair(task.getUser(),task.getGroup());    Integer value = histogram.get(current);    histogram.put(current, value == null? 1 : value + 1); //update the histogram } for (Entry&lt;Pair,Integer&gt; entry : histogram.entrySet()) {     updateUser(entry.getKey().getUser(),entry.getKey().getGroup(),entry.getValue()); }"
"CommonsHttpOAuthConsumer consumer = null;     consumer = new CommonsHttpOAuthConsumer(CONSUMER_KEY,CONSUMER_SECRET);     consumer.setTokenWithSecret(oaut_token, tokenSecret);     // Use the apache method instead - probably should make this part persistent until    // you are done issuing API calls        HttpParams parameters = new BasicHttpParams();    HttpProtocolParams.setVersion(parameters, HttpVersion.HTTP_1_1);    HttpProtocolParams.setContentCharset(parameters, HTTP.DEFAULT_CONTENT_CHARSET);    HttpProtocolParams.setUseExpectContinue(parameters, false);    HttpConnectionParams.setTcpNoDelay(parameters, true);    HttpConnectionParams.setSocketBufferSize(parameters, 8192);     HttpClient httpClient = new DefaultHttpClient();     SchemeRegistry schReg = new SchemeRegistry();    schReg.register(new Scheme(""http"", PlainSocketFactory.getSocketFactory(), 80));    ClientConnectionManager tsccm = new ThreadSafeClientConnManager(parameters, schReg);     httpClient = new DefaultHttpClient(tsccm, parameters);     HttpGet get = new HttpGet(targetURL);       // sign the request     consumer.sign(get);      // send the request &amp; get the response (probably a json object, but whatever)     String response = httpClient.execute(get, new BasicResponseHandler());      // shutdown the connection manager - last bit of the apache code      httpClient.getConnectionManager().shutdown();      //Do whatever you want with the returned info      JSONObject jsonObject = new JSONObject(response);"
"ExecuteWatchdog watchdog = new ExecuteWatchdog(EXECUTION_TIMEOUT_IN_MS);     DefaultExecutor executor = new DefaultExecutor();      executor.setWatchdog(watchdog);     executor.setExitValue(0);      ByteArrayOutputStream outputStream = new ByteArrayOutputStream();     ByteArrayOutputStream errorStream = new ByteArrayOutputStream();      executor.setStreamHandler(new PumpStreamHandler(outputStream, errorStream));      try {         log.info(commandLine.toString());          int exitCode = executor.execute(commandLine, (Map&lt;?, ?&gt;) null);          if (exitCode != 0)             throw new BusinessException(""Process exited with non-zero exit code."");          return outputStream.toString();     } catch (ExecuteException e) {         String errorStreamStr = null;          if (errorStream.size() != 0)             errorStreamStr = errorStream.toString();          StringBuilder errorMessageBuilder = new StringBuilder();          errorMessageBuilder.append(""main.error"").append("":\n"").append(                 e.getMessage()).append(""\n\n"");          if (errorStreamStr != null) {             errorMessageBuilder.append(""additional.error"").append("":\n"").append(errorStreamStr).append(""\n\n"");         }          errorMessageBuilder.append(""command.line"").append("":\n"").append(commandLine.toString());          if (log.isDebugEnabled())             log.debug(errorMessageBuilder.toString());          throw new BusinessException(errorMessageBuilder.toString());     } catch (IOException e) {         throw new IllegalStateException(e);     } finally {         StreamUtil.closeQuietly(outputStream, errorStream);     }"
"public class VimeoServiceConcept {  public static void main(String[] args) {      String apikey=""api key"";     String apisecret=""secret"";     String accessToken=""access token"";     String accessTokenSecret=""access token secret"";      OAuthService service = new ServiceBuilder().provider(VimeoApi.class).apiKey(apiKey).apiSecret(apiSecret).build();      OAuthRequest request;     Response response;      accessToken = new Token(""your_token"", ""your_tokens_secret"");      accessToken = checkToken(vimeoAPIURL, accessToken, service);     if (accessToken == null) {       return;     }      // Get Quota     request = new OAuthRequest(Verb.GET, vimeoAPIURL);     request.addQuerystringParameter(""method"", ""vimeo.videos.upload.getQuota"");     signAndSendToVimeo(request, ""getQuota"", true);      // Get Ticket     request = new OAuthRequest(Verb.GET, vimeoAPIURL);     request.addQuerystringParameter(""method"", ""vimeo.videos.upload.getTicket"");     request.addQuerystringParameter(""upload_method"", ""streaming"");     response = signAndSendToVimeo(request, ""getTicket"", true);     //... the rest of your code...     } }"
"public enum APIErrorCode {      APIErrorOne(1),     APIErrorTwo(27),     APIErrorThree(42),     APIErrorFour(54);      private final int code;      private APIErrorCode(int code) {         this.code = code;     }      public int getCode() {         return this.code;     }      public static APIErrorCode getAPIErrorCodeByCode(int error) {        if(Util.errorMap.containsKey(error)) {          return  Util.errorMap.get(error);        }        //Or create some default code        throw new IllegalStateException(""Error code not found, code:"" + error);     }      //We need a inner class because enum are  initialized even before static block     private static class Util {          private static final Map&lt;Integer,APIErrorCode&gt; errorMap = new HashMap&lt;Integer,APIErrorCode&gt;();          static {              for(APIErrorCode code : APIErrorCode.values()){                 errorMap.put(code.getCode(), code);             }         }      } }"
"final SettableFuture&lt;Boolean&gt; verify = new SettableFuture&lt;Boolean&gt;();  p.lookup(lookupKey, new Continuation&lt;PastContent, Exception&gt;() {   public void receiveResult(PastContent result)   {     P2PPKIContent content = (P2PPKIContent) result;     if(content !=null){        verify.set(true);     }   }   public void receiveException(Exception result)   {     System.out.println(""Error looking up "" + lookupKey);     verify.set(false);   } });  return verificationQueue.get(); //this will block until verify has been set!"
com.sun.jersey.core.impl.provider.entity.FormProvider com.sun.jersey.core.impl.provider.entity.MimeMultipartProvider com.sun.jersey.core.impl.provider.entity.StringProvider com.sun.jersey.core.impl.provider.entity.ByteArrayProvider com.sun.jersey.core.impl.provider.entity.FileProvider com.sun.jersey.core.impl.provider.entity.InputStreamProvider com.sun.jersey.core.impl.provider.entity.DataSourceProvider com.sun.jersey.core.impl.provider.entity.XMLJAXBElementProvider$General com.sun.jersey.core.impl.provider.entity.ReaderProvider com.sun.jersey.core.impl.provider.entity.DocumentProvider com.sun.jersey.core.impl.provider.entity.StreamingOutputProvider com.sun.jersey.core.impl.provider.entity.SourceProvider$SourceWriter
"try {   connection con.setAutoCommit(false);           PreparedStatement prepStmt = con.prepareStatement(         ""insert into product(code,name,price,available) values (?,?,?,?"");   Iterator&lt;Product&gt; it = li.iterator();   while(it.hasNext()){      Product p = it.next();     prepStmt.setString(1,p.getCode());                 prepStmt.setString(2,p.getCode());     prepStmt.setInt(3,p.getPrice());     prepStmt.setBoolean(4,p.isAvailable());     prepStmt.addBatch();                          }         int [] numUpdates=prepStmt.executeBatch();   for (int i=0; i &lt; numUpdates.length; i++) {     if (numUpdates[i] == -2)       System.out.println(""Execution "" + i +          "": unknown number of rows updated"");     else       System.out.println(""Execution "" + i +          ""successful: "" + numUpdates[i] + "" rows updated"");   }   con.commit(); } catch(BatchUpdateException b) {   // process BatchUpdateException }"
"List&lt;String&gt; optionList = new ArrayList&lt;String&gt;(); optionList.add(""1""); optionList.add(""2"");  Object[] options = optionList.toArray(); int value = JOptionPane.showOptionDialog(                 null,                 ""Please select your encryption Algorithm:(1 or 2)\n 1. Data Encryption       Standard(DES) \n 2. Advanced Encryption Standard(AES)"",                 ""Pick"",                 JOptionPane.YES_NO_OPTION,                 JOptionPane.QUESTION_MESSAGE,                 null,                 options,                 optionList.get(0));  String opt = optionList.get(value); System.out.println(""You picked "" + opt);"
"update moneydeals      set mask = substr(mask,0,?)||'1'||substr(mask,?,32),          ITI=?,         UTI=?,         idCONTROPARTE=?,         '',    -- Missing column name         SDR=?,         USI=?,         CONFIRMATIONTIME=?,         CONFIRMATIONMETHOD=?,         EVENTDATE=?,         CONFIRMATIONDATE=?,         codicemessaggio=?,         '',    --Missing column name         PARENTCODICECONTRATTO=?,         'I',   --Missing column name         RESEND=1    where CODINTORD=?      and CODICEMESSAGGIO=?      and EVENTCODE=?      and EVENTDATE=?"
"public class TokenAuthenticationProcessingFilter extends     AbstractAuthenticationProcessingFilter {  public TokenAuthenticationProcessingFilter(         RequestMatcher requiresAuthenticationRequestMatcher) {     super(requiresAuthenticationRequestMatcher); }  @Override public Authentication attemptAuthentication(HttpServletRequest request,         HttpServletResponse response) throws AuthenticationException,         IOException, ServletException {     Authentication auth = new TokenAuthentication(""-1"");     try {         Map&lt;String, String[]&gt; params = request.getParameterMap();         if (!params.isEmpty() &amp;&amp; params.containsKey(""auth_token"")) {             String token = params.get(""auth_token"")[0];             if (token != null) {                 auth = new TokenAuthentication(token);             }         }         return this.getAuthenticationManager().authenticate(auth);     } catch (AuthenticationException ae) {         unsuccessfulAuthentication(request, response, ae);     }     return auth; }}"
public class FormattedTextFieldVerifier extends InputVerifier {     public boolean verify(JComponent input) {      if (input instanceof JFormattedTextField) {          JFormattedTextField ftf = (JFormattedTextField)input;          AbstractFormatter formatter = ftf.getFormatter();          if (formatter != null) {              String text = ftf.getText();              try {                   formatter.stringToValue(text);                   return true;               } catch (ParseException pe) {                   return false;               }           }       }       return true;   }   public boolean shouldYieldFocus(JComponent input) {       return verify(input);   }
"Options options = new BitmapFactory.Options();   options.inJustDecodeBounds = true;    BitmapFactory.decodeStream(is, null, options);    Boolean scaleByHeight = Math.abs(options.outHeight - TARGET_HEIGHT) &gt;= Math.abs(options.outWidth - TARGET_WIDTH);    if(options.outHeight * options.outWidth * 2 &gt;= 200*200*2){          // Load, scaling to smallest power of 2 that'll get it &lt;= desired dimensions         double sampleSize = scaleByHeight               ? options.outHeight / TARGET_HEIGHT               : options.outWidth / TARGET_WIDTH;         options.inSampleSize =                (int)Math.pow(2d, Math.floor(               Math.log(sampleSize)/Math.log(2d)));      }          // Do the actual decoding         options.inJustDecodeBounds = false;          is.close();         is = getHTTPConnectionInputStream(sUrl);         Bitmap img = BitmapFactory.decodeStream(is, null, options);         is.close();"
"re = shoppingListStore.enumerateRecords(null, null, false);  while (re.hasNextElement()) {     int id = re.nextRecordId();     // read current values of item     byte [] itemRecord = shoppingListStore.getRecord(id);     // deserialise byte array     newItemObject.fromByteArray(itemRecord);     // set item status to purchased     newItemObject.setItemStatus(""Purchased"");     // create new bytearray and call newitemobject . tobytearray method to return a byte array of the object (using UTF8 encoded strings~)     byte[] itemData = newItemObject.toByteArray();      // update shoppinglist store record with new byte array     shoppingListStore.setRecord(id, itemData, 0, itemData.length); }"
"public class PatchedTextField extends JFormattedTextField {      public PatchedTextField() {         super();          final Action originalDeleteAction =             getActionMap().get(DefaultEditorKit.deletePrevCharAction);          getActionMap().put(DefaultEditorKit.deletePrevCharAction,             new AbstractAction() {                 ActionEvent previousEvent;                  public void actionPerformed(ActionEvent e) {                 // Filter out events that happen within 1 millisecond from each other                 if (previousEvent == null || e.getWhen() - previousEvent.getWhen() &gt; 1) {                     originalDeleteAction.actionPerformed(e);                 }                 previousEvent = e;             }         });     } }"
"private ModelAndView getModelAndView(Method handlerMethod, Object returnValue, ServletWebRequest webRequest)         throws Exception {      ResponseStatus responseStatusAnn = AnnotationUtils.findAnnotation(handlerMethod, ResponseStatus.class);     if (responseStatusAnn != null) {         HttpStatus responseStatus = responseStatusAnn.value();         String reason = responseStatusAnn.reason();         if (!StringUtils.hasText(reason)) {             // this doesn't commit the response             webRequest.getResponse().setStatus(responseStatus.value());         }         else {             // this commits the response such that any more calls to write to the              // response are ignored             webRequest.getResponse().sendError(responseStatus.value(), reason);         }     }     /// snip }"
"Method         = ""OPTIONS""                ; Section 9.2                   | ""GET""                    ; Section 9.3                   | ""HEAD""                   ; Section 9.4                   | ""POST""                   ; Section 9.5                   | ""PUT""                    ; Section 9.6                   | ""DELETE""                 ; Section 9.7                   | ""TRACE""                  ; Section 9.8                   | ""CONNECT""                ; Section 9.9                   | extension-method    extension-method = token"
private void countAdjacentMines() {             for (int i = 0; i &lt; mineField.length; i++)     {         for (int j = 0; j &lt; mineField.length; j++)         {             if (!(mineField[i][j].getIsMine()))             {                 int count = 0;                  for (int p = i - 1; p &lt;= i + 1; p++)                 {                     for (int q = j - 1; q &lt;= j + 1; q++)                     {                         if (0 &lt;= p &amp;&amp; p &lt; mineField.length &amp;&amp; 0 &lt;= q &amp;&amp; q &lt; mineField.length)                         {                             if (mineField[p][q].getIsMine())                                 ++count;                         }                     }                 }                  mineField[i][j].setAdjacentMines(count);             }         } // end for loop rows     } // end for loop columns } // end countAdjacentMines
"new JSONDeserializer().use(""some.path.to.bar"", new EnhancedStringObjectFactory() ).deserialize( json, new SomeObject() );    public class EnhancedStringObjectFactory implements ObjectFactory {     public Object instantiate(ObjectBinder context, Object value, Type targetType, Class targetClass) {         if( value instanceof String ) {             return value;         } else if( value instanceof Number ) {             return ((Number)value).toString();         } else {            throw context.cannotConvertValueToTargetType(value, String.class);         }    } }"
"model.read(...); StmtIterator si = model.listStatements(         model.getResource(""required property uri""), RDFS.range, (RDFNode) null); while (si.hasNext()) {     Statement stmt = si.next();     Resource range = stmt.getObject().asResource();     // get restrictions collection     Resource nextNode = range.getPropertyResourceValue(OWL2.withRestrictions);     for (;;) {         Resource restr = nextNode.getPropertyResourceValue(RDF.first);         if (restr == null)             break;          StmtIterator pi = restr.listProperties();         while (pi.hasNext()) {             Statement restrStmt = pi.next();             Property restrType = restrStmt.getPredicate();             Literal value = restrStmt.getObject().asLiteral();             // print type and value for each restriction             System.out.println(restrType + "" = "" + value);         }         // go to the next element of collection         nextNode = nextNode.getPropertyResourceValue(RDF.rest);     } }"
com.sun.jersey.json.impl.provider.entity.JSONRootElementProvider$Wadl com.sun.jersey.json.impl.provider.entity.JSONRootElementProvider$App com.sun.jersey.json.impl.provider.entity.JSONRootElementProvider$General com.sun.jersey.json.impl.provider.entity.JSONJAXBElementProvider$App com.sun.jersey.json.impl.provider.entity.JSONJAXBElementProvider$General com.sun.jersey.json.impl.provider.entity.JSONListElementProvider$App com.sun.jersey.json.impl.provider.entity.JSONListElementProvider$General com.sun.jersey.json.impl.provider.entity.JSONArrayProvider$App com.sun.jersey.json.impl.provider.entity.JSONArrayProvider$General com.sun.jersey.json.impl.provider.entity.JSONObjectProvider$App com.sun.jersey.json.impl.provider.entity.JSONObjectProvider$General com.sun.jersey.json.impl.provider.entity.JSONWithPaddingProvider com.sun.jersey.json.impl.provider.entity.JacksonProviderProxy
public class TransactionTemplate {      public &lt;T&gt; T execute(Callable&lt;T&gt; doInTransaction) throws Exception {         EntityManager em = EntityManagerFactory.get();         EntityTransaction transaction = em.getTransaction();         transaction.begin();          try {             T result = doInTransaction.call();             transaction.commit();             return result;         } catch(/* Some exception that causes a rollback */ e) {            transaction.rollback();            throw e;         } finally {            em.close();         }     } }
"Condition hashKeyCondition = new Condition(); hashKeyCondition.withComparisonOperator(ComparisonOperator.EQ).withAttributeValueList(new AttributeValue().withS(hashKeyAttributeValue));  Condition rangeKeyCondition = new Condition(); rangeKeyCondition.withComparisonOperator(ComparisonOperator.GT).withAttributeValueList(new AttributeValue().withN(timestamp.toString()));  Map&lt;String, Condition&gt; keyConditions = new HashMap&lt;String, Condition&gt;(); keyConditions.put(MappedItem.INDEXED_ATTRIBUTE_NAME, hashKeyCondition); keyConditions.put(MappedItem.TIMESTAMP, rangeKeyCondition);   QueryRequest queryRequest = new QueryRequest(); queryRequest.withTableName(tableName); queryRequest.withIndexName(MappedItem.INDEX_NAME); queryRequest.withKeyConditions(keyConditions);  QueryResult result = amazonDynamoDBClient.query(queryRequest);  List&lt;MappedItem&gt; mappedItems = new ArrayList&lt;MappedItem&gt;();  for(Map&lt;String, AttributeValue&gt; item : result.getItems()) {     MappedItem mappedItem = dynamoDBMapper.marshallIntoObject(MappedItem.class, item);     mappedItems.add(mappedItem); }  return mappedItems;"
