code
"package com.mobinet.snmp;  import org.snmp4j.CommunityTarget; import org.snmp4j.PDU; import org.snmp4j.Snmp; import org.snmp4j.TransportMapping; import org.snmp4j.event.ResponseEvent; import org.snmp4j.mp.SnmpConstants; import org.snmp4j.smi.Address; import org.snmp4j.smi.GenericAddress; import org.snmp4j.smi.Integer32; import org.snmp4j.smi.OID; import org.snmp4j.smi.OctetString; import org.snmp4j.smi.VariableBinding; import org.snmp4j.transport.DefaultTcpTransportMapping;  /**  *  * @author batbayar  */ public class SnmpTest {     private String address = ""192.168.1.254/161""; // switch address and snmp port     private String writeCommunity = ""myCommunityWrite""; // write community name      private Snmp snmp;     private CommunityTarget target;      public SnmpTest() {         try {             TransportMapping transport = new DefaultTcpTransportMapping();             snmp = new Snmp(transport);              Address targetAddress = GenericAddress.parse(address);             target = new CommunityTarget();             target.setCommunity(new OctetString(writeCommunity));             target.setAddress(targetAddress);             target.setRetries(2);             target.setTimeout(1500);             target.setVersion(SnmpConstants.version2c);              PDU command = new PDU();             command.setType(PDU.SET);             command.add(new VariableBinding(new OID(""1.3.6.1.2.1.2.2.1.7.1""), new Integer32(2))); // port 1 down             command.add(new VariableBinding(new OID(""1.3.6.1.2.1.2.2.1.7.6""), new Integer32(1))); // port 6 up             ResponseEvent response = snmp.send(command, target);             System.out.println(""response: "" + response);         } catch(Exception e) {             e.printStackTrace();         }     }      public static void main(String[] args) {         SnmpTest test = new SnmpTest();     } }"
"ParcelFileDescriptor fileDescriptor = this.getContentResolver().openFileDescriptor(uri, &quot;r&quot;);             InputStream in = this.getContentResolver().openInputStream(uri);              CountingInputStreamEntity entity = new CountingInputStreamEntity(in, fileDescriptor.getStatSize());             entity.setUploadListener(this);             entity.setContentType(&quot;binary/octet-stream&quot;);             entity.setChunked(true);                       BufferedHttpEntity myEntity = null;             try {                 myEntity = new BufferedHttpEntity(entity);             } catch (IOException e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }                          put.setEntity(myEntity);"
"String sourceUrl = ""http://www.example.com/mysite/whatever/somefolder/bar/unsecure!+?#whätyöühäv€it/site.html""; // your current site     String targetUrl = ""http://www.example.com/mysite/whatever/otherfolder/other.html""; // the link target     String expectedTarget = ""../../../otherfolder/other.html"";     String[] sourceElements = sourceUrl.split(""/"");     String[] targetElements = targetUrl.split(""/""); // keep in mind that the arrays are of different length!     StringBuilder uniquePart = new StringBuilder();     StringBuilder relativePart = new StringBuilder();     boolean stillSame = true;     for(int ii = 0; ii &lt; sourceElements.length || ii &lt; targetElements.length; ii++) {         if(ii &lt; targetElements.length &amp;&amp; ii &lt; sourceElements.length &amp;&amp;                  stillSame &amp;&amp; sourceElements[ii].equals(targetElements[ii]) &amp;&amp; stillSame) continue;         stillSame = false;         if(targetElements.length &gt; ii)           uniquePart.append(""/"").append(targetElements[ii]);         if(sourceElements.length &gt; ii +1)             relativePart.append(""../"");     }      String result = relativePart.toString().substring(0, relativePart.length() -1) + uniquePart.toString();     System.out.println(""result: "" + result);"
"List&lt;GarbageCollectorMXBean&gt; gcList = ManagementFactory.getGarbageCollectorMXBeans();     for(GarbageCollectorMXBean tmpGC : gcList){          System.out.println(""\nName: "" + tmpGC.getName());         System.out.println(""Collection count: "" + tmpGC.getCollectionCount());         System.out.println(""Collection time: "" + tmpGC.getCollectionTime());         System.out.println(""Memory Pools: "");          String[] memoryPoolNames = tmpGC.getMemoryPoolNames();         for(String mpnTmp : memoryPoolNames){             System.out.println(""\t"" + mpnTmp);         }      }      System.out.println( ""Memory Pools Info"" );     List&lt;MemoryPoolMXBean&gt; memoryList = ManagementFactory.getMemoryPoolMXBeans();     for(MemoryPoolMXBean tmpMem : memoryList){          System.out.println(""\nName: "" + tmpMem.getName());         System.out.println(""Usage: "" + tmpMem.getUsage());         System.out.println(""Collection Usage: "" + tmpMem.getCollectionUsage());         System.out.println(""Peak Usage: "" + tmpMem.getPeakUsage());         System.out.println(""Type: "" + tmpMem.getType());         System.out.println(""Memory Manager Names: "") ;          String[] memManagerNames = tmpMem.getMemoryManagerNames();         for(String mmnTmp : memManagerNames){             System.out.println(""\t"" + mmnTmp);         }         System.out.println(""\n"");     }      MemoryUsage mu =ManagementFactory.getMemoryMXBean().getHeapMemoryUsage();     MemoryUsage muNH =ManagementFactory.getMemoryMXBean().getNonHeapMemoryUsage();     System.out.println(             ""Init :""+mu.getInit()+             ""\nMax :""+mu.getMax()+             ""\nUsed :""+mu.getUsed()+             ""\nCommited :""+mu.getCommitted()+             ""\nInit NH :""+muNH.getInit()+             ""\nMax NH :""+muNH.getMax()+             ""\nUsed NH:""+muNH.getUsed()+             ""\nCommited NH:""+muNH.getCommitted());"
"try {     OutputStream servletOutputStream = httpServletResponse.getOutputStream(); // retrieve OutputStream from HttpServletResponse     ZipOutputStream zos = new ZipOutputStream(servletOutputStream); // create a ZipOutputStream from servletOutputStream      List&lt;String[]&gt; csvFileContents  = getContentToZIP(); // get the list of csv contents. I am assuming the CSV content is generated programmatically     int count = 0;     for (String[] entries : csvFileContents) {         String filename = ""file-"" + ++count  + "".csv"";         ZipEntry entry = new ZipEntry(filename); // create a zip entry and add it to ZipOutputStream         zos.putNextEntry(entry);          CSVWriter writer = new CSVWriter(new OutputStreamWriter(zos));  // There is no need for staging the CSV on filesystem or reading bytes into memory. Directly write bytes to the output stream.         writer.writeNext(entries);  // write the contents         writer.flush(); // flush the writer. Very important!         zos.closeEntry(); // close the entry. Note : we are not closing the zos just yet as we need to add more files to our ZIP     }      zos.close(); // finally closing the ZipOutputStream to mark completion of ZIP file } catch (Exception e) {     log.error(e); // handle error }"
"WifiManager wifi = (WifiManager) getSystemService(Context.WIFI_SERVICE); Method[] wmMethods = wifi.getClass().getDeclaredMethods(); for(Method method: wmMethods){   if(method.getName().equals(""setWifiApEnabled"")){     WifiConfiguration netConfig = new WifiConfiguration();     netConfig.SSID = ""\""PROVAAP\"""";     netConfig.allowedAuthAlgorithms.set(WifiConfiguration.AuthAlgorithm.OPEN);     netConfig.allowedProtocols.set(WifiConfiguration.Protocol.RSN);     netConfig.allowedProtocols.set(WifiConfiguration.Protocol.WPA);     netConfig.allowedKeyManagement.set(WifiConfiguration.KeyMgmt.WPA_PSK);    netConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.CCMP);     netConfig.allowedPairwiseCiphers.set(WifiConfiguration.PairwiseCipher.TKIP);     netConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.CCMP);     netConfig.allowedGroupCiphers.set(WifiConfiguration.GroupCipher.TKIP);        try {       method.invoke(wifi, netConfig,true);     } catch (IllegalArgumentException e) {       e.printStackTrace();     } catch (IllegalAccessException e) {       e.printStackTrace();     } catch (InvocationTargetException e) {       e.printStackTrace();     }   } }"
"package your.package;  public class CORSFilter implements ContainerResponseFilter {      @Override     public ContainerResponse filter(ContainerRequest creq, ContainerResponse cresp) {          cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Origin"", ""*"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Credentials"", ""true"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Methods"", ""GET, POST, DELETE, PUT, OPTIONS, HEAD"");         cresp.getHttpHeaders().putSingle(""Access-Control-Allow-Headers"", ""Content-Type, Accept, X-Requested-With"");          return cresp;     } }"
"import com.xuggle.xuggler.Configuration; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IContainerFormat; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IPixelFormat; import com.xuggle.xuggler.IRational; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture; import com.xuggle.xuggler.video.ConverterFactory; import com.xuggle.xuggler.video.IConverter; import java.awt.AWTException; import java.awt.Rectangle; import java.awt.Robot; import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.util.Properties;  public class XugglerRtmpReferenceImpl {     private static String url = ""rtmp://your.test.server/screen/"";    private static String fileName = ""test/teststream"";    private static int framesToEncode = 60;    private static int x = 0;    private static int y = 0;    private static int height = 480;    private static int width = 640;     public static void main(String[] args) {        IContainer container = IContainer.make();        IContainerFormat containerFormat_live = IContainerFormat.make();        containerFormat_live.setOutputFormat(""flv"", url + fileName, null);        container.setInputBufferLength(0);        int retVal = container.open(url + fileName, IContainer.Type.WRITE, containerFormat_live);        if (retVal &lt; 0) {            System.err.println(""Could not open output container for live stream"");            System.exit(1);        }        IStream stream = container.addNewStream(0);        IStreamCoder coder = stream.getStreamCoder();        ICodec codec = ICodec.findEncodingCodec(ICodec.ID.CODEC_ID_H264);        coder.setNumPicturesInGroupOfPictures(5);        coder.setCodec(codec);        coder.setBitRate(200000);        coder.setPixelType(IPixelFormat.Type.YUV420P);        coder.setHeight(height);        coder.setWidth(width);        System.out.println(""[ENCODER] video size is "" + width + ""x"" + height);        coder.setFlag(IStreamCoder.Flags.FLAG_QSCALE, true);        coder.setGlobalQuality(0);        IRational frameRate = IRational.make(5, 1);        coder.setFrameRate(frameRate);        coder.setTimeBase(IRational.make(frameRate.getDenominator(), frameRate.getNumerator()));        Properties props = new Properties();        InputStream is = XugglerRtmpReferenceImpl.class.getResourceAsStream(""/libx264-normal.ffpreset"");        try {            props.load(is);        } catch (IOException e) {            System.err.println(""You need the libx264-normal.ffpreset file from the Xuggle distribution in your classpath."");            System.exit(1);        }        Configuration.configure(props, coder);        coder.open();        container.writeHeader();        long firstTimeStamp = System.currentTimeMillis();        long lastTimeStamp = -1;        int i = 0;        try {            Robot robot = new Robot();            while (i &lt; framesToEncode) {                //long iterationStartTime = System.currentTimeMillis();                long now = System.currentTimeMillis();                //grab the screenshot                BufferedImage image = robot.createScreenCapture(new Rectangle(x, y, width, height));                //convert it for Xuggler                BufferedImage currentScreenshot = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);                currentScreenshot.getGraphics().drawImage(image, 0, 0, null);                //start the encoding process                IPacket packet = IPacket.make();                IConverter converter = ConverterFactory.createConverter(currentScreenshot, IPixelFormat.Type.YUV420P);                long timeStamp = (now - firstTimeStamp) * 1000;                 IVideoPicture outFrame = converter.toPicture(currentScreenshot, timeStamp);                if (i == 0) {                    //make first frame keyframe                    outFrame.setKeyFrame(true);                }                outFrame.setQuality(0);                coder.encodeVideo(packet, outFrame, 0);                outFrame.delete();                if (packet.isComplete()) {                    container.writePacket(packet);                    System.out.println(""[ENCODER] writing packet of size "" + packet.getSize() + "" for elapsed time "" + ((timeStamp - lastTimeStamp) / 1000));                    lastTimeStamp = timeStamp;                }                System.out.println(""[ENCODER] encoded image "" + i + "" in "" + (System.currentTimeMillis() - now));                i++;                try {                    Thread.sleep(Math.max((long) (1000 / frameRate.getDouble()) - (System.currentTimeMillis() - now), 0));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        } catch (AWTException e) {            e.printStackTrace();        }        container.writeTrailer();     } }"
"IExtensionRegistry registry = Platform.getExtensionRegistry();     IExtensionPoint extensionPoint = registry             .getExtensionPoint(""myplugin.myextension"");     IConfigurationElement points[] = extensionPoint             .getConfigurationElements();     for (IConfigurationElement point : points) {         if (""myextensionFactory"".equals(point.getName())) {             Object impl = point.createExecutableExtension(""class"");             if (impl instanceof IMyExtension) {                 ((IMyExtension) impl).foo();             }         }     } }"
"import net.sourceforge.pmd.cpd.Tokens import net.sourceforge.pmd.cpd.TokenEntry import net.sourceforge.pmd.cpd.Tokenizer import net.sourceforge.pmd.cpd.CPDNullListener import net.sourceforge.pmd.cpd.MatchAlgorithm import net.sourceforge.pmd.cpd.SourceCode import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader import net.sourceforge.pmd.cpd.SimpleRenderer  // Prepare empty token data. TokenEntry.clearImages() def tokens = new Tokens()  // List all source files with text. def source = new TreeMap&lt;String, SourceCode&gt;() new File('.').eachFile { file -&gt;   if (file.isFile() &amp;&amp; file.name.endsWith('.txt')) {     def analyzedText = file.text     def sourceCode = new SourceCode(new StringCodeLoader(analyzedText, file.name))     source.put(sourceCode.fileName, sourceCode)     analyzedText.eachLine { line, lineNumber -&gt;       line.split('[\\W\\s\\t\\f]+').each { token -&gt;         token = token.trim()         if (token) {           tokens.add(new TokenEntry(token, sourceCode.fileName, lineNumber + 1))         }       }     }     tokens.add(TokenEntry.getEOF())   } }  // Run matching algorithm. def maxTokenChain = 15 def matchAlgorithm = new MatchAlgorithm(source, tokens, maxTokenChain, new CPDNullListener()) matchAlgorithm.findMatches()  // Produce report. matchAlgorithm.matches().each { match -&gt;   println ""  ========================================""   match.iterator().each { mark -&gt;     println ""  DUPLICATION ERROR: &lt;${mark.tokenSrcID}:${mark.beginLine}&gt; [DUPLICATION] Found a ${match.lineCount} line (${match.tokenCount} tokens) duplication!""   }   def indentedTextSlice = """"   match.sourceCodeSlice.eachLine { line -&gt;     indentedTextSlice += ""  $line\n""   }   println ""  ----------------------------------------""   println indentedTextSlice   println ""  ========================================"" }"
"package com.bullethq.jawr.postprocessor;  import net.jawr.web.resource.FileNameUtils; import net.jawr.web.resource.bundle.factory.util.PathNormalizer; import net.jawr.web.resource.bundle.postprocess.BundleProcessingStatus; import net.jawr.web.resource.bundle.postprocess.impl.CSSURLPathRewriterPostProcessor; import net.jawr.web.resource.bundle.postprocess.impl.PostProcessorCssImageUrlRewriter;  import java.io.IOException;  public class CustomCssUrlPathRewriterPostProcessor extends CSSURLPathRewriterPostProcessor {      public static final String CUSTOM_URL_PATH_REWRITER = ""customcsspathrewriter"";      public CustomCssUrlPathRewriterPostProcessor() {         super(CUSTOM_URL_PATH_REWRITER);     }      // ========================================================================     // ========================================================================     // ========================================================================     @Override     protected PostProcessorCssImageUrlRewriter createImageUrlRewriter(BundleProcessingStatus status) {         return new CustomPostProcessorCssImageUrlRewriter(status);     }      // ========================================================================     // ========================================================================     // ========================================================================     public class CustomPostProcessorCssImageUrlRewriter extends PostProcessorCssImageUrlRewriter {          public CustomPostProcessorCssImageUrlRewriter(BundleProcessingStatus status) {             super(status);         }          // ========================================================================         // ========================================================================         // ========================================================================         @Override         protected String getUrlPath(String match, String originalPath, String newCssPath) throws IOException {             String url = match.substring(match.indexOf('(') + 1, match.lastIndexOf(')')).trim();              // Remove any quotes if necessary.             String quoteStr = """";             if (url.startsWith(""'"") || url.startsWith(""\"""")) {                 quoteStr = String.valueOf(url.charAt(0));                 url = url.substring(1, url.length() - 1);             }              // We now check if the url ends in a known image file extension             // If not, the url is ignored.             if (FileNameUtils.hasImageExtension(url)) {                 return super.getUrlPath(match, originalPath, newCssPath);             } else {                 // We need to rewrite the path, as any relative URLs will                 // not resolve correctly if Jawr has changed the CSS path.                 url = PathNormalizer.concatWebPath(originalPath, url);                 url = PathNormalizer.getRelativeWebPath(PathNormalizer.getParentPath(newCssPath), url);                 return ""url("" + quoteStr + url + quoteStr + "")"";             }         }     } }"
"HttpURLConnection connection = (HttpURLConnection) url.openConnection();     if(ISSUE_DOWNLOAD_STATUS.intValue()==ECMConstant.ECM_DOWNLOADING){         File file=new File(DESTINATION_PATH);         if(file.exists()){              downloaded = (int) file.length();              connection.setRequestProperty(""Range"", ""bytes=""+(file.length())+""-"");         }     }else{         connection.setRequestProperty(""Range"", ""bytes="" + downloaded + ""-"");     }     connection.setDoInput(true);     connection.setDoOutput(true);     progressBar.setMax(connection.getContentLength());      in = new BufferedInputStream(connection.getInputStream());      fos=(downloaded==0)? new FileOutputStream(DESTINATION_PATH): new FileOutputStream(DESTINATION_PATH,true);      bout = new BufferedOutputStream(fos, 1024);     byte[] data = new byte[1024];     int x = 0;     while ((x = in.read(data, 0, 1024)) &gt;= 0) {         bout.write(data, 0, x);          downloaded += x;          progressBar.setProgress(downloaded);     }"
"Path file = ...; BasicFileAttributes attr = Files.readAttributes(file, BasicFileAttributes.class);  System.out.println(""creationTime: "" + attr.creationTime()); System.out.println(""lastAccessTime: "" + attr.lastAccessTime()); System.out.println(""lastModifiedTime: "" + attr.lastModifiedTime());  System.out.println(""isDirectory: "" + attr.isDirectory()); System.out.println(""isOther: "" + attr.isOther()); System.out.println(""isRegularFile: "" + attr.isRegularFile()); System.out.println(""isSymbolicLink: "" + attr.isSymbolicLink()); System.out.println(""size: "" + attr.size());"
package org.camunda.bpm;  import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.RuntimeService; import org.camunda.bpm.engine.repository.ProcessDefinition; import org.camunda.bpm.engine.runtime.ProcessInstance; import java.util.List;  public class AllRunningProcessInstances {    public List&lt;ProcessInstance&gt; getAllRunningProcessInstances(String processDefinitionName) {     // get process engine and services     ProcessEngine processEngine = BpmPlatform.getDefaultProcessEngine();     RuntimeService runtimeService = processEngine.getRuntimeService();     RepositoryService repositoryService = processEngine.getRepositoryService();      // query for latest process definition with given name     ProcessDefinition myProcessDefinition =         repositoryService.createProcessDefinitionQuery()             .processDefinitionName(processDefinitionName)             .latestVersion()             .singleResult();      // list all running/unsuspended instances of the process     List&lt;ProcessInstance&gt; processInstances =         runtimeService.createProcessInstanceQuery()             .processDefinitionId(myProcessDefinition.getId())             .active() // we only want the unsuspended process instances             .list();      return processInstances;   }  }
"public String getLocalIpAddress() {     try {         for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface.getNetworkInterfaces(); en.hasMoreElements();) {             NetworkInterface intf = en.nextElement();             for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf.getInetAddresses(); enumIpAddr.hasMoreElements();) {                 InetAddress inetAddress = enumIpAddr.nextElement();                 if (!inetAddress.isLoopbackAddress()) {                     return inetAddress.getHostAddress().toString();                 }             }         }     } catch (SocketException ex) {         Log.e(LOG_TAG, ex.toString());     }     return null; }"
"public String getLocalIpAddress() {         try {             for (Enumeration&lt;NetworkInterface&gt; en = NetworkInterface                     .getNetworkInterfaces(); en.hasMoreElements();) {                 NetworkInterface intf = en.nextElement();                 for (Enumeration&lt;InetAddress&gt; enumIpAddr = intf                         .getInetAddresses(); enumIpAddr.hasMoreElements();) {                     InetAddress inetAddress = enumIpAddr.nextElement();                     if (!inetAddress.isLoopbackAddress()) {                         return inetAddress.getHostAddress().toString();                     }                 }             }         } catch (SocketException ex) {             Log.e(tag, ex.toString());         }         return """";     }"
"OperatingSystemMXBean operatingSystemMXBean =      ManagementFactory.getOperatingSystemMXBean();  for (Method method: operatingSystemMXBean.getClass ().getMethods ())  {     method.setAccessible (true);     String methodName = method.getName ();     if (methodName.startsWith (""get"")         &amp;&amp; Modifier.isPublic (method.getModifiers ())         &amp;&amp; OperatingSystemMXBean.class.isAssignableFrom (             method.getDeclaringClass ())) {         try         {             System.out.println (                 methodName.substring (3) + "": "" +                  method.invoke (operatingSystemMXBean));         }         catch (Throwable ex)         {             // Ignore         }     } }"
import org.codehaus.groovy.grails.web.servlet.GrailsApplicationAttributes import org.codehaus.groovy.grails.web.context.ServletContextHolder import org.springframework.context.ApplicationContext  public class SpringUtils {      static getSpringBean(String name) {         getApplicationContext().getBean(name);     }      static ApplicationContext getApplicationContext() {         return ServletContextHolder.getServletContext().getAttribute(GrailsApplicationAttributes.APPLICATION_CONTEXT);     }     }
"query.from(catalog) .innerJoin(qe).on(catalog.id.eq(qe.itemId)) .innerJoin(enterprise).on(enterprise.id.eq(qe.enterpriseId)) .leftJoin(catalogPerson).on(catalogPerson.catalogId.eq(catalog.id)) .where(catalog.deletionDate.isNull(), qe.enterpriseId.eq(org)) .orderBy(catalog.creationDate.desc()) .limit(limit) .offset(offset) .groupBy(catalog.id) .list(Projections.constructor(Catalog.class,                             catalog.id,                             catalog.name,                             catalog.code,                             catalogPerson.count()));"
"String data = ""temp/*.jpg, usr/*.pdf, var/lib/*.so, tmp/*, usr/*, usr/*.*"";  Pattern p = Pattern         .compile(""(?&lt;path&gt;(\\w+/)+)((?&lt;name&gt;\\w+|[*]))?([.](?&lt;extension&gt;\\w+|[*]))?"");  Matcher m = p.matcher(data); while (m.find()) {     System.out.println(""data="" + m.group());     System.out.println(""path="" + m.group(""path""));     System.out.println(""name="" + m.group(""name""));     System.out.println(""extension="" + m.group(""extension""));     System.out.println(""------------""); }"
"DrawPageElement drawPageElement = slide.getOdfElement(); DrawFrameElement drawFrame = OdfElement.findFirstChildNode(DrawFrameElement.class, drawPageElement); DrawImageElement image = drawFrame.newDrawImageElement(); OdfPackage mOdfPackage = odp.getPackage(); String imageRef = ""/some/path/to/chart.png"";  String packagePath = odp.getDocumentPath() + OdfPackage.OdfFile.IMAGE_DIRECTORY.getPath() + ""/"" + someMethodToCreateRandomString();  mOdfPackage.insert(new URI(imageRef), packagePath, OdfFileEntry.getMediaTypeString(imageRef)); packagePath = packagePath.replaceFirst(odp.getDocumentPath(), """"); URI uri = new URI(AnyURI.encodePath(packagePath).toString()); image.setXlinkHrefAttribute(AnyURI.decodePath(uri.toString())); image.setXlinkActuateAttribute(""onLoad""); image.setXlinkShowAttribute(""embed""); image.setXlinkTypeAttribute(""simple"");"
"import com.xuggle.mediatool.IMediaWriter; import com.xuggle.mediatool.ToolFactory; import com.xuggle.xuggler.IAudioSamples; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture;    /**  * This class is used to merge audio and video file.  *  * @author Arslaan Ejaz  */ public class DecodeAndSaveAudioVideo {   public static void main(String[] args)   {      String filenamevideo = ""f:/testvidfol/video.mp4""; //this is the input file for video. you can change extension     String filenameaudio = ""f:/testvidfol/audio.wav""; //this is the input file for audio. you can change extension       IMediaWriter mWriter = ToolFactory.makeWriter(""f:/testvidfol/audiovideooutput.flv""); //output file      IContainer containerVideo = IContainer.make();     IContainer containerAudio = IContainer.make();      if (containerVideo.open(filenamevideo, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenamevideo);      if (containerAudio.open(filenameaudio, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenameaudio);      int numStreamVideo = containerVideo.getNumStreams();     int numStreamAudio = containerAudio.getNumStreams();      System.out.println(""Number of video streams: ""+numStreamVideo + ""\n"" + ""Number of audio streams: ""+numStreamAudio );  int videostreamt = -1; //this is the video stream id int audiostreamt = -1;  IStreamCoder  videocoder = null;      for(int i=0; i&lt;numStreamVideo; i++){         IStream stream = containerVideo.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO)         {             videostreamt = i;             videocoder = code;             break;         }      }      for(int i=0; i&lt;numStreamAudio; i++){         IStream stream = containerAudio.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO)         {             audiostreamt = i;             break;         }      }      if (videostreamt == -1) throw new RuntimeException(""No video steam found"");     if (audiostreamt == -1) throw new RuntimeException(""No audio steam found"");      if(videocoder.open()&lt;0 ) throw new RuntimeException(""Cant open video coder"");     IPacket packetvideo = IPacket.make();      IStreamCoder audioCoder = containerAudio.getStream(audiostreamt).getStreamCoder();      if(audioCoder.open()&lt;0 ) throw new RuntimeException(""Cant open audio coder"");     mWriter.addAudioStream(1, 1, audioCoder.getChannels(), audioCoder.getSampleRate());      mWriter.addVideoStream(0, 0, videocoder.getWidth(), videocoder.getHeight());      IPacket packetaudio = IPacket.make();      while(containerVideo.readNextPacket(packetvideo) &gt;= 0 ||             containerAudio.readNextPacket(packetaudio) &gt;= 0){          if(packetvideo.getStreamIndex() == videostreamt){              //video packet             IVideoPicture picture = IVideoPicture.make(videocoder.getPixelType(),                     videocoder.getWidth(),                     videocoder.getHeight());             int offset = 0;             while (offset &lt; packetvideo.getSize()){                 int bytesDecoded = videocoder.decodeVideo(picture,                          packetvideo,                          offset);                 if(bytesDecoded &lt; 0) throw new RuntimeException(""bytesDecoded not working"");                 offset += bytesDecoded;                  if(picture.isComplete()){                     System.out.println(picture.getPixelType());                     mWriter.encodeVideo(0, picture);                  }             }         }           if(packetaudio.getStreamIndex() == audiostreamt){            //audio packet              IAudioSamples samples = IAudioSamples.make(512,                      audioCoder.getChannels(),                     IAudioSamples.Format.FMT_S32);               int offset = 0;             while(offset&lt;packetaudio.getSize())             {                 int bytesDecodedaudio = audioCoder.decodeAudio(samples,                          packetaudio,                         offset);                 if (bytesDecodedaudio &lt; 0)                     throw new RuntimeException(""could not detect audio"");                 offset += bytesDecodedaudio;                  if (samples.isComplete()){                      mWriter.encodeAudio(1, samples);          }             }      }    } } }"
"Path folder = Paths.get(System.getProperty(&quot;upload.location&quot;)); String filename = FilenameUtils.getBaseName(uploadedFile.getName());  String extension = FilenameUtils.getExtension(uploadedFile.getName()); Path file = Files.createTempFile(folder, filename + &quot;-&quot;, &quot;.&quot; + extension);  try (InputStream input = uploadedFile.getInputStream()) {     Files.copy(input, file, StandardCopyOption.REPLACE_EXISTING); }  String uploadedFileName = file.getFileName().toString(); // Now store it in DB."
"public Bitmap getBitmapFromView(RelativeLayout v) {         v.setLayoutParams(new LayoutParams(RelativeLayout.LayoutParams.WRAP_CONTENT, RelativeLayout.LayoutParams.WRAP_CONTENT));         v.measure(MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED), MeasureSpec.makeMeasureSpec(0, MeasureSpec.UNSPECIFIED));         v.layout(0, 0, v.getMeasuredWidth(), v.getMeasuredHeight());         Bitmap b = Bitmap.createBitmap(v.getMeasuredWidth(), v.getMeasuredHeight(), Bitmap.Config.ARGB_8888);          Canvas c = new Canvas(b);         v.draw(c);         return b;     }"
package namepackage;  import com.panayotis.gnuplot.JavaPlot; import com.panayotis.gnuplot.plot.DataSetPlot; import com.panayotis.gnuplot.style.PlotStyle; import com.panayotis.gnuplot.style.Style;  /**  * on NetBeans add library -&gt; jar -&gt;   * package namepackage;  *  * import com.panayotis.gnuplot.JavaPlot;  * import com.panayotis.gnuplot.plot.DataSetPlot;  * import com.panayotis.gnuplot.style.PlotStyle;  * import com.panayotis.gnuplot.style.Style;  * @author mkwest  *  */ public class Main {      /**      * @param args the command line arguments      */     public static void main(String[] args) {         // TODO code application logic here         JavaPlot p = new JavaPlot();         double tab[][];          tab = new double[2][2];         tab[0][0] = 0.0000;         tab[0][1] = 2.0000;         tab[1][0] = 1.0000;         tab[1][1] = 6.0000;         PlotStyle myPlotStyle = new PlotStyle();         myPlotStyle.setStyle(Style.LINES);         DataSetPlot s = new DataSetPlot(tab);         myPlotStyle.setLineWidth(1);         DataSetPlot testDataSetPlot = new DataSetPlot(tab);         //DataSetPlot.setPlotStyle(myPlotStyle);         s.setPlotStyle(myPlotStyle);         //p.newGraph();         p.addPlot(s);         p.newGraph();         p.plot();     } }
"package com.spmsoftware.plugin.listeners;  import com.atlassian.event.api.EventListener; import com.atlassian.event.api.EventPublisher; import com.atlassian.jira.component.ComponentAccessor; import com.atlassian.jira.event.issue.IssueEvent; import com.atlassian.jira.event.type.EventType; import com.atlassian.jira.issue.Issue; import com.atlassian.jira.issue.MutableIssue; import com.atlassian.jira.issue.customfields.manager.OptionsManager; import com.atlassian.jira.issue.customfields.option.Option; import com.atlassian.jira.issue.customfields.option.Options; import com.atlassian.jira.issue.fields.CustomField; import com.atlassian.jira.issue.fields.config.FieldConfig; import com.atlassian.jira.issue.fields.config.FieldConfigScheme; import org.apache.log4j.Logger; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean;  import java.util.List; import java.util.Map;  /**  * User: adnan  * Date: 5/4/14  * Time: 4:49 PM  */ public class IssueUpdateListener  implements InitializingBean, DisposableBean {      private static final Logger LOGGER = Logger.getLogger(IssueUpdateListener.class);      private final EventPublisher eventPublisher;    // private final JiraAuthenticationContext authenticationContext;      public IssueUpdateListener(EventPublisher eventPublisher) {         this.eventPublisher = eventPublisher;        // this.authenticationContext = ComponentAccessor.getJiraAuthenticationContext();     }      @Override     public void afterPropertiesSet() throws Exception {         eventPublisher.register(this);     }      @Override     public void destroy() throws Exception {         eventPublisher.unregister(this);     }      @EventListener     public void onIssueEvent(IssueEvent issueEvent) {         Long eventTypeId = issueEvent.getEventTypeId();         Issue issue = issueEvent.getIssue();         if (eventTypeId.equals(EventType.ISSUE_RESOLVED_ID)) {             MutableIssue mutableIssue = getMutableIssue(issue);             CustomField customerNameCF = ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName(""Customer Name"");             CustomField allCustomersCF = ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName(""All Customers"");             Object customerNameVal = mutableIssue.getCustomFieldValue(customerNameCF);             Option newOptions = addOptionToCustomField(allCustomersCF, customerNameVal.toString());             LOGGER.info(""New updated option {}"" + newOptions);         }     }      private MutableIssue getMutableIssue(Issue issue) {         MutableIssue mutableIssue;         if (issue instanceof MutableIssue)   {             mutableIssue = (MutableIssue)issue;         } else {             mutableIssue = ComponentAccessor.getIssueManager().getIssueObject(issue.getKey());         }         return mutableIssue;     }       public Option addOptionToCustomField(CustomField customField, String value) {         Option newOption = null;         if (customField != null) {             List&lt;FieldConfigScheme&gt; schemes = customField.getConfigurationSchemes();             if (schemes != null &amp;&amp; !schemes.isEmpty()) {                 FieldConfigScheme sc = schemes.get(0);                 Map configs = sc.getConfigsByConfig();                 if (configs != null &amp;&amp; !configs.isEmpty()) {                     FieldConfig config = (FieldConfig) configs.keySet().iterator().next();                     OptionsManager optionsManager = ComponentAccessor.getOptionsManager();                     Options l = optionsManager.getOptions(config);                     int nextSequence = l.isEmpty() ? 1 : l.getRootOptions().size() + 1;                     newOption = optionsManager.createOption(config, null, (long) nextSequence, value);                 }             }         }          return newOption;     }  }"
"import java.util.concurrent.ConcurrentMap; import org.restlet.data.Form; import org.restlet.engine.header.Header; import org.restlet.engine.header.HeaderConstants; import org.restlet.resource.ClientResource; import org.restlet.util.Series;   ...  clientResource = new ClientResource(""http://someurl.com""); ConcurrentMap&lt;String, Object&gt; attrs = clientResource.getRequest().getAttributes(); Series&lt;Header&gt; headers = (Series&lt;Header&gt;) attrs.get(HeaderConstants.ATTRIBUTE_HEADERS); if (headers == null) {     headers = new Series&lt;Header&gt;(Header.class);     Series&lt;Header&gt; prev = (Series&lt;Header&gt;)          attrs.putIfAbsent(HeaderConstants.ATTRIBUTE_HEADERS, headers);     if (prev != null) { headers = prev; } } headers.add(""myHeaderName"", ""myHeaderValue"");"
"public aspect ValidationAspect {      pointcut serviceMethodCall() : execution(public * com.yourcompany.**.*(..));      Object around(final Object[] args) : serviceMethodCall() &amp;&amp; args(args){         Signature signature = thisJoinPointStaticPart.getSignature();         if(signature instanceof MethodSignature){             MethodSignature ms = (MethodSignature) signature;             Method method = ms.getMethod();             Annotation[][] parameterAnnotations =                  method.getParameterAnnotations();             String[] parameterNames = ms.getParameterNames();             for(int i = 0; i &lt; parameterAnnotations.length; i++){                 Annotation[] annotations = parameterAnnotations[i];                 validateParameter(parameterNames[i], args[i],annotations);             }         }         return proceed(args);     }      private void validateParameter(String paramName, Object object,         Annotation[] annotations){          // validate object against the annotations         // throw a RuntimeException if validation fails     }  }"
"private Tbl getSampleTable(WordprocessingMLPackage wPMLpackage) {      ObjectFactory factory = Context.getWmlObjectFactory();     int writableWidthTwips = wPMLpackage.getDocumentModel().getSections()                                         .get(0).getPageDimensions()                                         .getWritableWidthTwips();     List&lt;Map&lt;String, String&gt;&gt; data = getSampleTableData();     TableDefinition tableDef = getSampleTableDef();     int cols = tableDef.getColumns().size();     int cellWidthTwips = new Double(             Math.floor((writableWidthTwips / cols))         ).intValue();      Tbl table = TblFactory.createTable((data.size() + 1), cols, cellWidthTwips);      Tr headerRow = (Tr) table.getContent().get(0);      int f = 0;     for (Column column : tableDef.getColumns()) {         Tc column = (Tc) headerRow.getContent().get(f);         P columnPara = (P) column.getContent().get(0);         f++;         Text text = factory.createText();         text.setValue(column.getName());         R run = factory.createR();         run.getContent().add(text);         columnPara.getContent().add(run);     }     int i = 1;      for (Map&lt;String, String&gt; entry : data) {         Tr row = (Tr) table.getContent().get(i);         i++;         int d = 0;         for (String key : entry.keySet()) {             Tc column = (Tc) row.getContent().get(d);             P columnPara = (P) column.getContent().get(0);             d++;             Text tx = factory.createText();             R run = factory.createR();             tx.setValue(entry.get(key));             run.getContent().add(tx);             columnPara.getContent().add(run);         }     }     return table; }"
package org.camunda.bpm;  import org.camunda.bpm.engine.HistoryService; import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.history.HistoricProcessInstance; import org.camunda.bpm.engine.repository.ProcessDefinition; import java.util.List;  public class AllFinishedProcessInstances {    public List&lt;HistoricProcessInstance&gt; getAllFinishedProcessInstances(String processDefinitionName) {     ProcessEngine processEngine = BpmPlatform.getDefaultProcessEngine();     HistoryService historyService = processEngine.getHistoryService();;     RepositoryService repositoryService = processEngine.getRepositoryService();      ProcessDefinition myProcessDefinition =         repositoryService.createProcessDefinitionQuery()             .processDefinitionName(processDefinitionName)             .latestVersion() // we are only interested in the latest version             .singleResult();      List&lt;HistoricProcessInstance&gt; processInstances =         historyService.createHistoricProcessInstanceQuery()             .processDefinitionId(myProcessDefinition.getId())             .finished() // we only want the finished process instances             .list();      return processInstances;   }  }
