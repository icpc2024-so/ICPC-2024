code
"public String center (String s, int length) {     if (s.length() &gt; length) {         return s.substring(0, length);     } else if (s.length() == length) {         return s;     } else {         int leftPadding = (length - s.length()) / 2;          StringBuilder leftBuilder = new StringBuilder();         for (int i = 0; i &lt; leftPadding; i++) {             leftBuilder.append("" "");         }          int rightPadding = length - s.length() - leftPadding;         StringBuilder rightBuilder = new StringBuilder();         for (int i = 0; i &lt; rightPadding; i++)              rightBuilder.append("" "");          return leftBuilder.toString() + s                  + rightBuilder.toString();     } }"
"private String getURL() {     Enumeration&lt;String&gt; lParameters;     String sParameter;     StringBuilder sbURL = new StringBuilder();     Object oRequest = FacesContext.getCurrentInstance().getExternalContext().getRequest();      try     {         if(oRequest instanceof HttpServletRequest)         {             sbURL.append(((HttpServletRequest)oRequest).getRequestURL().toString());              lParameters = ((HttpServletRequest)oRequest).getParameterNames();              if(lParameters.hasMoreElements())             {                 if(!sbURL.toString().contains(""?""))                 {                     sbURL.append(""?"");                 }                 else                 {                     sbURL.append(""&amp;"");                 }             }              while(lParameters.hasMoreElements())             {                 sParameter = lParameters.nextElement();                  sbURL.append(sParameter);                 sbURL.append(""="");                 sbURL.append(URLEncoder.encode(((HttpServletRequest)oRequest).getParameter(sParameter),""UTF-8""));                  if(lParameters.hasMoreElements())                 {                     sbURL.append(""&amp;"");                 }             }         }     }     catch(Exception e)     {         // Do nothing     }      return sbURL.toString(); }"
"ConfigureForm form = new ConfigureForm(FormType.submit); form.setPersistentItems(false); form.setDeliverPayloads(true); form.setAccessModel(AccessModel.open);  PubSubManager manager        = new PubSubManager(connection, ""pubsub.communitivity.com""); Node myNode = manager.createNode(""http://jabber.org/protocol/geoloc"", form);  StringBuilder body = new StringBuilder(); //ws for readability body.append(""&lt;geoloc xmlns='http://jabber.org/protocol/geoloc' xml:lang='en'&gt;""); body.append(""   &lt;country&gt;Italy&lt;/country&gt;""); body.append(""   &lt;lat&gt;45.44&lt;/lat&gt;""); body.append(""   &lt;locality&gt;Venice&lt;/locality&gt;""); body.append(""   &lt;lon&gt;12.33&lt;/lon&gt;""); body.append(""   &lt;accuracy&gt;20&lt;/accuracy&gt;""); body.append(""&lt;/geoloc&gt;"");  SimplePayload payload = new SimplePayload(                               ""geoloc"",                               ""http://jabber.org/protocol/geoloc"",                                body.toString()); String itemId = ""zz234""; Item&lt;SimplePayload&gt; item = new Item&lt;SimplePayload&gt;(itemId, payload);  // Required to recieve the events being published myNode.addItemEventListener(myEventHandler);  // Publish item myNode.publish(item);"
"String cronAttribute = taskElement.getAttribute(""cron""); if (StringUtils.hasText(cronAttribute)) {     cronTaskMap.put(runnableBeanRef, cronAttribute); } else {     String fixedDelayAttribute = taskElement.getAttribute(""fixed-delay"");     if (StringUtils.hasText(fixedDelayAttribute)) {         fixedDelayTaskMap.put(runnableBeanRef, fixedDelayAttribute);     }     else {         String fixedRateAttribute = taskElement.getAttribute(""fixed-rate"");         if (!StringUtils.hasText(fixedRateAttribute)) {             parserContext.getReaderContext().error(                     ""One of 'cron', 'fixed-delay', or 'fixed-rate' is required"",                     taskElement);             // Continue with the possible next task element             continue;         }         fixedRateTaskMap.put(runnableBeanRef, fixedRateAttribute);     } }"
"package com.bullethq.jawr.postprocessor;  import net.jawr.web.resource.FileNameUtils; import net.jawr.web.resource.bundle.factory.util.PathNormalizer; import net.jawr.web.resource.bundle.postprocess.BundleProcessingStatus; import net.jawr.web.resource.bundle.postprocess.impl.CSSURLPathRewriterPostProcessor; import net.jawr.web.resource.bundle.postprocess.impl.PostProcessorCssImageUrlRewriter;  import java.io.IOException;  public class CustomCssUrlPathRewriterPostProcessor extends CSSURLPathRewriterPostProcessor {      public static final String CUSTOM_URL_PATH_REWRITER = ""customcsspathrewriter"";      public CustomCssUrlPathRewriterPostProcessor() {         super(CUSTOM_URL_PATH_REWRITER);     }      // ========================================================================     // ========================================================================     // ========================================================================     @Override     protected PostProcessorCssImageUrlRewriter createImageUrlRewriter(BundleProcessingStatus status) {         return new CustomPostProcessorCssImageUrlRewriter(status);     }      // ========================================================================     // ========================================================================     // ========================================================================     public class CustomPostProcessorCssImageUrlRewriter extends PostProcessorCssImageUrlRewriter {          public CustomPostProcessorCssImageUrlRewriter(BundleProcessingStatus status) {             super(status);         }          // ========================================================================         // ========================================================================         // ========================================================================         @Override         protected String getUrlPath(String match, String originalPath, String newCssPath) throws IOException {             String url = match.substring(match.indexOf('(') + 1, match.lastIndexOf(')')).trim();              // Remove any quotes if necessary.             String quoteStr = """";             if (url.startsWith(""'"") || url.startsWith(""\"""")) {                 quoteStr = String.valueOf(url.charAt(0));                 url = url.substring(1, url.length() - 1);             }              // We now check if the url ends in a known image file extension             // If not, the url is ignored.             if (FileNameUtils.hasImageExtension(url)) {                 return super.getUrlPath(match, originalPath, newCssPath);             } else {                 // We need to rewrite the path, as any relative URLs will                 // not resolve correctly if Jawr has changed the CSS path.                 url = PathNormalizer.concatWebPath(originalPath, url);                 url = PathNormalizer.getRelativeWebPath(PathNormalizer.getParentPath(newCssPath), url);                 return ""url("" + quoteStr + url + quoteStr + "")"";             }         }     } }"
"public class RuleTuple implements Comparable&lt;RuleTuple&gt; {     String head;     String[] rhs;     public String toString() {         StringBuilder b = new StringBuilder();         b.append(head+"":"");          for( String t: rhs )             b.append("" ""+t);          return b.toString();     }     public int compareTo(RuleTuple src) {         int cmp = head.compareTo(src.head);         if( cmp!=0 )             return cmp;         if( rhs.length != src.rhs.length )             return rhs.length - src.rhs.length;         for( int i=0; i&lt;rhs.length; i++ ) {             int diff = rhs[i].compareTo(src.rhs[i]);             if(diff != 0)                 return diff;         }         return 0;     }     ... }"
"String str = ""kushal,mayurv,narendra,dhrumil,mark, ,,,, "";         String splitted[] = str.split("","");         StringBuffer sb = new StringBuffer();         String retrieveData = """";         for(int i =0; i&lt;splitted.length; i++){             retrieveData = splitted[i];             if((retrieveData.trim()).length()&gt;0){                  if(i!=0){                     sb.append("","");                 }                 sb.append(retrieveData);              }         }      str = sb.toString();     System.out.println(str);"
"public void populate(Bundle bundle) {     String localisation = (String) bundle.getHeaders().get(""Bundle-Localization"");     Locale locale = Locale.getDefault();      populate(bundle.getEntry(getFileName(localisation)));     populate(bundle.getEntry(getFileName(localisation, locale.getLanguage())));     populate(bundle.getEntry(getFileName(localisation, locale.getLanguage(), locale.getCountry())));     populate(bundle.getResource(getFileName(""fragment"")));     populate(bundle.getResource(getFileName(""fragment"", locale.getLanguage())));     populate(bundle.getResource(getFileName(""fragment"", locale.getLanguage(), locale.getCountry()))); }"
"private String printPhone(Long phoneNum) {     StringBuilder sb = new StringBuilder(15);     StringBuilder temp = new StringBuilder(phoneNum.toString());      while (temp.length() &lt; 10)         temp.insert(0, ""0"");      char[] chars = temp.toString().toCharArray();      sb.append(""("");     for (int i = 0; i &lt; chars.length; i++) {         if (i == 3)             sb.append("") "");         else if (i == 6)             sb.append(""-"");         sb.append(chars[i]);     }      return sb.toString(); }"
"package com.acme;  import org.mule.DefaultMuleEvent; import org.mule.DefaultMuleMessage; import org.mule.MessageExchangePattern; import org.mule.api.MuleException; import org.mule.api.MuleRuntimeException; import org.mule.api.context.notification.MuleContextNotificationListener; import org.mule.config.i18n.MessageFactory; import org.mule.construct.Flow; import org.mule.context.notification.MuleContextNotification;  public class FlowInvokingContextListener implements MuleContextNotificationListener&lt;MuleContextNotification&gt; {     private Flow startingFlow;     private Flow stoppingFlow;      public void onNotification(final MuleContextNotification notification)     {         if (notification.getAction() == MuleContextNotification.CONTEXT_STARTED)         {             sendNotificationToFlow(notification, startingFlow);         }         else if (notification.getAction() == MuleContextNotification.CONTEXT_STOPPING)         {             sendNotificationToFlow(notification, stoppingFlow);         }     }      private void sendNotificationToFlow(final MuleContextNotification notification, final Flow flow)     {         try         {             final DefaultMuleEvent event = new DefaultMuleEvent(new DefaultMuleMessage(notification,                 notification.getMuleContext()), MessageExchangePattern.REQUEST_RESPONSE, startingFlow);             flow.process(event);         }         catch (final MuleException me)         {             throw new MuleRuntimeException(MessageFactory.createStaticMessage(""Failed to invoke: ""                                                                               + startingFlow), me);         }     }      public void setStartingFlow(final Flow startingFlow)     {         this.startingFlow = startingFlow;     }      public void setStoppingFlow(final Flow stoppingFlow)     {         this.stoppingFlow = stoppingFlow;     } }"
"public static void printSheetData(List&lt;List&lt;HSSFCell&gt;&gt; sheetData) {     StringBuilder strBuilder = new StringBuilder();     for (int i = 0; i &lt; sheetData.size(); i++) {         List&lt;HSSFCell&gt; list = (List&lt;HSSFCell&gt;) sheetData.get(i);         for (int j = 0; j &lt; list.size(); j++) {             HSSFCell cell = (HSSFCell) list.get(j);             // System.out.print(cell.toString());             strBuilder.append(cell.toString());             if (j &lt; list.size() - 1) {                 // System.out.print("", "");                 strBuilder.append("", "");             }         }         // System.out.println("""");         strBuilder.append(""\n"");          // consider testing strBuilder size here and printing it out if         // it is greater than some pre-set, then re-initializing the          // strBuilder variable.     }     System.out.println(strBuilder.toString()); }"
"while (inFile.hasNext()){         for (int i = 0; i &lt; 20; i++){             for (int j = 0; j&lt;5; j++){                 if (j == 2) {                      StringBuilder temp = new StringBuilder(inFile.next());                       while(!inFile.hasNextInt()){                          temp.append("" "" + inFile.next());                      }                      cities[i][j]=temp.toString();                      continue;                 }                 cities[i][j]=inFile.next();             }         }     }"
"public String getBrokenWordsForPdfGeneration(String longString, int cutIndex){        StringBuffer mainStringBuffer = new StringBuffer(longString);        String returnString = """";        while(mainStringBuffer != null &amp;&amp; mainString.length()&gt;0 &amp;&amp;                               mainString.subString(0,mainString.length()&gt;cutIndex?cutIndex:mainString.length()) != null){            if(mainStrig.subString(0,mainString.length()&gt;cutIndex:mainString.length()).trim().contains("" "")){                returnString += mainStrig.subString(0,mainString.length()&gt;cutIndex:mainString.length()).trim();                mainStringBuffer.delete(0,mainString.length()&gt;cutIndex:mainString.length());           }else{               returnString += mainStrig.subString(0,mainString.length()&gt;cutIndex:mainString.length()).trim()+ "" "";               mainStringBuffer.delete(0,mainString.length()&gt;cutIndex:mainString.length());           }     }     return returnString; }"
"BufferedReader reader = new BufferedReader(new StringReader(""1,2,0\n3,4,5\n6,7,8""));      StringBuilder sb = new StringBuilder();     String line = reader.readLine();      StringBuilder currentLine = new StringBuilder();      while (line != null)     {         currentLine.delete(0, currentLine.capacity());         currentLine.append(line);         currentLine.deleteCharAt(1);          sb.append(currentLine.toString());         sb.append(""\n"");          line = reader.readLine();      }     System.out.println(sb.toString());"
"public static&lt;A, B, C&gt; Stream&lt;C&gt; zip(Stream&lt;? extends A&gt; a,                                      Stream&lt;? extends B&gt; b,                                      BiFunction&lt;? super A, ? super B, ? extends C&gt; zipper) {     Objects.requireNonNull(zipper);     Spliterator&lt;? extends A&gt; aSpliterator = Objects.requireNonNull(a).spliterator();     Spliterator&lt;? extends B&gt; bSpliterator = Objects.requireNonNull(b).spliterator();      // Zipping looses DISTINCT and SORTED characteristics     int characteristics = aSpliterator.characteristics() &amp; bSpliterator.characteristics() &amp;             ~(Spliterator.DISTINCT | Spliterator.SORTED);      long zipSize = ((characteristics &amp; Spliterator.SIZED) != 0)             ? Math.min(aSpliterator.getExactSizeIfKnown(), bSpliterator.getExactSizeIfKnown())             : -1;      Iterator&lt;A&gt; aIterator = Spliterators.iterator(aSpliterator);     Iterator&lt;B&gt; bIterator = Spliterators.iterator(bSpliterator);     Iterator&lt;C&gt; cIterator = new Iterator&lt;C&gt;() {         @Override         public boolean hasNext() {             return aIterator.hasNext() &amp;&amp; bIterator.hasNext();         }          @Override         public C next() {             return zipper.apply(aIterator.next(), bIterator.next());         }     };      Spliterator&lt;C&gt; split = Spliterators.spliterator(cIterator, zipSize, characteristics);     return (a.isParallel() || b.isParallel())            ? StreamSupport.stream(split, true)            : StreamSupport.stream(split, false); }"
"boolean isPattern(String givenPattern, String stringToMatch) {     if (givenPattern.empty)         return stringToMatch.isEmpty();     char patternCh = givenPatter.charAt(0);     boolean atEnd = stringToMatch.isEmpty();     if (patternCh == '*') {         return isPattenn(givenPattern.substring(1), stringToMatch)             || (!atEnd &amp;&amp; isPattern(givenPattern, stringToMatch.substring(1)));     } else if (patternCh == '?') {         return !atEnd &amp;&amp; isPattern(givenPattern.substring(1),              stringToMatch.substring(1));     }     return !atEnd &amp;&amp; patternCh == stringToMatch.charAt(0)           &amp;&amp; isPattern(givenPattern.substring(1), stringToNatch.subtring(1); }"
"String input = ""Lorem ipsum dolor sit amet, consectetur adipisicing #{key1}. "" +    ""Proin nibh augue, suscipit a, scelerisque #{key1},"" +     ""lacinia in, mi. Cras vel #{key2}. Etiam pellentesque aliquet tellus."" +     "" Phasellus pharetra nulla ac diam. Quisque semper #{key3} at risus.""; StringBuffer result = new StringBuffer();  Pattern p = Pattern.compile( ""#\\{([\\w\\.]+)\\}"" ); Matcher m = p.matcher( input );  while( m.find() ) {         //extract the message for key = m.group( 1 ) here   //i'll just mark the found keys    m.appendReplacement( result,  ""##"" + m.group( 1 ) + ""##"" );       } m.appendTail( result );  System.out.println(result); //output: ... consectetur adipisicing ##key1## ...  etc."
"public class ExampleHandler extends DefaultHandler{   // ===========================================================  // Fields  // ===========================================================   private StringBuilder mStringBuilder = new StringBuilder();   private ParsedExampleDataSet mParsedExampleDataSet = new ParsedExampleDataSet();  private List&lt;ParsedExampleDataSet&gt; mParsedDataSetList = new ArrayList&lt;ParsedExampleDataSet&gt;();   // ===========================================================  // Getter &amp; Setter  // ===========================================================   public List&lt;ParsedExampleDataSet&gt; getParsedData() {       return this.mParsedDataSetList;  }   // ===========================================================  // Methods  // ===========================================================   /** Gets be called on opening tags like:   * &lt;tag&gt;   * Can provide attribute(s), when xml was like:   * &lt;tag attribute=""attributeValue""&gt;*/  @Override  public void startElement(String namespaceURI, String localName, String qName, Attributes atts) throws SAXException {     if (localName.equals(""PhonebookEntry"")) {         this.mParsedExampleDataSet = new ParsedExampleDataSet();     }   }   /** Gets be called on closing tags like:   * &lt;/tag&gt; */  @Override  public void endElement(String namespaceURI, String localName, String qName)            throws SAXException {       if (localName.equals(""PhonebookEntry"")) {            this.mParsedDataSetList.add(mParsedExampleDataSet);       }else if (localName.equals(""firstname"")) {            mParsedExampleDataSet.setfirstname(mStringBuilder.toString().trim());       }else if (localName.equals(""lastname""))  {           mParsedExampleDataSet.setlastname(mStringBuilder.toString().trim());       }else if(localName.equals(""Address""))  {           mParsedExampleDataSet.setAddress(mStringBuilder.toString().trim());       }       mStringBuilder.setLength(0);  }   /** Gets be called on the following structure:   * &lt;tag&gt;characters&lt;/tag&gt; */  @Override public void characters(char ch[], int start, int length) {       mStringBuilder.append(ch, start, length); } }"
"public class CoordTest {      private static String  coords = ""N 39° 28.941 W 0° 23.275"";      public static void main(String[] args) {         String[] cArray = coords.split("" "");         String latSign = cArray[0];         String latDegrees = cArray[1].substring(0, cArray[1].length()-1);         String latSubdegrees = cArray[2];         String lonSign = cArray[3];         String lonDegrees = cArray[4].substring(0, cArray[4].length()-1);         String lonSubdegrees = cArray[5];         double lat = getSign(latSign) * (Integer.valueOf(latDegrees) + convertFromDegreesToDecimal(Double.valueOf(latSubdegrees)));         double lon = getSign(lonSign) * (Integer.valueOf(lonDegrees) + convertFromDegreesToDecimal(Double.valueOf(lonSubdegrees)));     }       private static int getSign(String c){         if (c.equals(""N"") || c.equals(""E"")){             return 1;         }         return -1;     }      private static double convertFromDegreesToDecimal(Double value){         double result = value/60d;         return result;     } }"
public class Pojo {      private String field1;     private String field2;     private String field3;     private String field4;     private String field5;      public Pojo(PojoBuilder pojoBuilder) {         this.field1 = pojoBuilder.field1;         this.field2 = pojoBuilder.field2;         this.field3 = pojoBuilder.field3;         this.field4 = pojoBuilder.field4;         this.field5 = pojoBuilder.field5;     }      public static class PojoBuilder {         String field1;         String field2;         String field3;         String field4;         String field5;          public PojoBuilder field1(String field1) {             this.field1 = field1;             return this;         }          public PojoBuilder field2(String field2) {             this.field2 = field2;             return this;         }         public PojoBuilder field3(String field3) {             this.field3 = field3;             return this;         }         public PojoBuilder field4(String field4) {             this.field4 = field4;             return this;         }         public PojoBuilder field5(String field5) {             this.field5 = field5;             return this;         }          public Pojo build() {             return new Pojo(this);         }      }      public String getField1() {         return field1;     }      public String getField2() {         return field2;     }      public String getField3() {         return field3;     }      public String getField4() {         return field4;     }      public String getField5() {         return field5;     }   }
"import net.sf.saxon.expr.StaticProperty; import net.sf.saxon.expr.StringLiteral; import net.sf.saxon.sxpath.IndependentContext; import net.sf.saxon.trans.XPathException; import net.sf.saxon.om.StructuredQName; import net.sf.saxon.expr.Expression; import net.sf.saxon.expr.ExpressionParser;  public boolean dependsOnContext(final String expression) {   final ExpressionParser expressionParser = new ExpressionParser();   final IndependentContext context = new IndependentContext() {      @Override     public Expression bindVariable(final StructuredQName qName) throws XPathException {       try {         return super.bindVariable(qName);       }       catch (XPathException e) {         //This assumes no variables are bound since no configuration is supplied to IndependentContext         return new StringLiteral(""Dummy"");       }     }   };   try {     Expression parsedExpression = expressionParser.parse(expression, 0, Token.EOF, -1, context);     return ((parsedExpression.getDependencies() &amp; (StaticProperty.DEPENDS_ON_CONTEXT_DOCUMENT | StaticProperty.DEPENDS_ON_CONTEXT_ITEM)) == 0);   }   catch (XPathException e) {     //Handle XPath exception if expression is malformed   } }"
"StringBuilder sb = new StringBuilder(); for (int i = 100000; i &lt; 100000 + 60; i++)     sb.append(i).append(' '); String sample = sb.toString();  int runs = 100000; for (int i = 0; i &lt; 5; i++) {     {         long start = System.nanoTime();         for (int r = 0; r &lt; runs; r++) {             StringTokenizer st = new StringTokenizer(sample);             List&lt;String&gt; list = new ArrayList&lt;String&gt;();             while (st.hasMoreTokens())                 list.add(st.nextToken());         }         long time = System.nanoTime() - start;         System.out.printf(""StringTokenizer took an average of %.1f us%n"", time / runs / 1000.0);     }     {         long start = System.nanoTime();         Pattern spacePattern = Pattern.compile("" "");         for (int r = 0; r &lt; runs; r++) {             List&lt;String&gt; list = Arrays.asList(spacePattern.split(sample, 0));         }         long time = System.nanoTime() - start;         System.out.printf(""Pattern.split took an average of %.1f us%n"", time / runs / 1000.0);     }     {         long start = System.nanoTime();         for (int r = 0; r &lt; runs; r++) {             List&lt;String&gt; list = new ArrayList&lt;String&gt;();             int pos = 0, end;             while ((end = sample.indexOf(' ', pos)) &gt;= 0) {                 list.add(sample.substring(pos, end));                 pos = end + 1;             }         }         long time = System.nanoTime() - start;         System.out.printf(""indexOf loop took an average of %.1f us%n"", time / runs / 1000.0);     }  }"
"public String addLinebreaks(String input, int maxLineLength) {     StringTokenizer tok = new StringTokenizer(input, "" "");     StringBuilder output = new StringBuilder(input.length());     int lineLen = 0;     while (tok.hasMoreTokens()) {         String word = tok.nextToken();          if (lineLen + word.length() &gt; maxLineLength) {             output.append(""\n"");             lineLen = 0;         }         output.append(word);         lineLen += word.length();     }     return output.toString(); }"
"ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.autocomplete_item,options);  // R.layout.autocomplete_item is custom spinner item xml file.you can use default spinner item also. autoComplete.setAdapter(adapter);  autoComplete.setThreshold(1); autoComplete.setOnItemClickListener(new OnItemClickListener() {      @Override     public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int position,                     long arg3) {          Intent intent;         int index=999;         for(int i=0;i&lt;options.length;i++)         {             if(options[i].equals(autoComplete.getText().toString().trim()))             {                 index=i;                 break;             }         }         switch(index)         {             case 0:                 intent=new Intent(ThisActivity.this,ActivityZero.class);                 startActivity(intent);                 break;             case 1:                 intent=new Intent(ThisActivity.this,ActivityOne.class);                 startActivity(intent);                    break;                  ...                  }     } });"
"private String replace(String needle, String replacement, String haystack) {     String result = """";     int index = haystack.indexOf(needle);     if(index==0) {         result = replacement+haystack.substring(needle.length());         return replace(needle, replacement, result);     }else if(index&gt;0) {         result = haystack.substring(0,index)+ replacement +haystack.substring(index+needle.length());         return replace(needle, replacement, result);     }else {         return haystack;     } }"
"private String replace(String needle, String replacement, String haystack) {     String result = """";     int index = haystack.indexOf(needle);     if(index==0) {         result = replacement+haystack.substring(needle.length());         return replace(needle, replacement, result);     }else if(index&gt;0) {         result = haystack.substring(0,index)+ replacement +haystack.substring(index+needle.length());         return replace(needle, replacement, result);     }else {         return haystack;     } }"
"String dFormat = ""EEEE, MMMM d, yyyy"",        tFormat = ""KK:mm a"";  public String formatInterval(Date from, Date to) {     SimpleDateFormat dateFormat = new SimpleDateFormat(dFormat),                      timeFormat = new SimpleDateFormat(tFormat);      StringBuilder s = new StringBuilder();     // Day     s.append(dateFormat.format(from));     s.append(' ');     // Start time     s.append(timeFormat.format(from));     s.append("" - "");     // End time     s.append(timeFormat.format(to));     return s.toString(); }  public String formatInterval(Calendar from, Calendar to) {     return formatInterval(from.getTime(), to.getTime()); }"
"fbo = GL30.glGenFramebuffers(); GL30.glBindFramebuffer(GL30.GL_FRAMEBUFFER, fbo);  rbo = GL30.glGenRenderbuffers(); GL30.glBindRenderbuffer(GL30.GL_RENDERBUFFER, rbo); GL30.glRenderbufferStorage(GL30.GL_RENDERBUFFER, GL11.GL_RGBA8, 640, 480); GL30.glFramebufferRenderbuffer(GL30.GL_FRAMEBUFFER, GL30.GL_COLOR_ATTACHMENT0, GL30.GL_RENDERBUFFER, rbo);  assert(GL30.glCheckFramebufferStatus(GL30.GL_FRAMEBUFFER) == GL30.GL_FRAMEBUFFER_COMPLETE);  GL30.glBindFramebuffer(GL30.GL_DRAW_FRAMEBUFFER, fbo); GL20.glDrawBuffers(GL30.GL_COLOR_ATTACHMENT0); GL11.glClear(GL11.GL_COLOR_BUFFER_BIT);  drawScene(); //draw here"
"OperatingSystemMXBean operatingSystemMXBean =      ManagementFactory.getOperatingSystemMXBean();  for (Method method: operatingSystemMXBean.getClass ().getMethods ())  {     method.setAccessible (true);     String methodName = method.getName ();     if (methodName.startsWith (""get"")         &amp;&amp; Modifier.isPublic (method.getModifiers ())         &amp;&amp; OperatingSystemMXBean.class.isAssignableFrom (             method.getDeclaringClass ())) {         try         {             System.out.println (                 methodName.substring (3) + "": "" +                  method.invoke (operatingSystemMXBean));         }         catch (Throwable ex)         {             // Ignore         }     } }"
"String link = ""www.thisisalink.com/tick1=@tick1@&amp;tick2=@tick2@&amp;tick3=@tick3@&amp;tick4=@tick4@"";  StringBuffer sb = new StringBuffer();  Pattern p = Pattern.compile(""(.+)=@\\1@""); Matcher m = p.matcher(link); List&lt;String&gt; replaced = new ArrayList&lt;&gt;();  while (m.find()) {     m.appendReplacement(sb, """");     replaced.add(m.group()); } m.appendTail(sb); //to replace link with String stored in sb use link=sb.toString(); //otherwise link will be unchanged System.out.println(sb); System.out.println(replaced);"
