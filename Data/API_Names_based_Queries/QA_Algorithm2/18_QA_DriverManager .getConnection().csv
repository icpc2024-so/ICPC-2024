code
"public List&lt;DriversLicence&gt; findDriversLicencesWith(List&lt;LicenceClass&gt; licenceClasses) {     String hqlString = ""select dl from DriversLicenceImpl dl where 1=1 "";     for (int i = 0; i &lt; licenceClasses.size(); i++) {         hqlString += "" and :licenceClass"" + i + "" = some elements(dl.licenceClasses)"";     }      Query query = getSession().createQuery(hqlString);     for (int i = 0; i &lt; licenceClasses.size(); i++) {         query.setParameter(""licenceClass"" + i, licenceClasses.get(i));     }     return query.list(); }"
"abstract class Vehicle {     Object vehicleSpecificField1, vehicleSpecificField2; }  class Car extends Vehicle {     Object carSpecificField;      Car(final Object vehicleSpecificField1, final Object vehicleSpecificField2, final Object carSpecificField) {         this.vehicleSpecificField1 = vehicleSpecificField1;         this.vehicleSpecificField2 = vehicleSpecificField2;         this.carSpecificField = carSpecificField;     } }  abstract class VehicleBuilder&lt;E extends Vehicle&gt; {     Object vehicleSpecificField1, vehicleSpecificField2;      public VehicleBuilder&lt;E&gt; vehicleSpecificField1(final Object vehicleSpecificField1) {         this.vehicleSpecificField1 = vehicleSpecificField1;         return this;     }      public VehicleBuilder&lt;E&gt; vehicleSpecificField2(final Object vehicleSpecificField2) {         this.vehicleSpecificField2 = vehicleSpecificField2;         return this;     }      abstract E create();  }  class CarBuilder extends VehicleBuilder&lt;Car&gt; {     Object carSpecificField;      public CarBuilder carSpecificField(final Object carSpecificField) {         this.carSpecificField = carSpecificField;         return this;     }      @Override     Car create() {         return new Car(vehicleSpecificField1, vehicleSpecificField2, carSpecificField);     } }  public static void main(String[] args) {     Car car = new CarBuilder().carSpecificField(""car"").vehicleSpecificField1(""foo"").vehicleSpecificField2(""bar"").create(); }"
"try{    Class.forName(""com.mysql.jdbc.Driver"").newInstance();    Connection con=DriverManager.getConnection(""jdbc:mysql://localhost:8888/atmlivedetails"",""root"",""root"");               Statement st=con.createStatement();             ResultSet rs=st.executeQuery(""select atmbrno, atmbrname  from location_stat where act_brname='""+br_id+""'"");             int i=0;             JSONArray jArray = new JSONArray();             while(rs.next()){          String s = rs.getString(""atmbrno"");         String t = rs.getString(""atmbrname"");          JSONObject arrayObj = new JSONObject();          arrayObj.put(""atmbrno"",s);         arrayObj.put(""atmbrname"",t);          jArray.add(i,arrayObj);         i++;         }         rs.close ();         st.close ();         out.print(jArray);     }"
"IndexQuery iq = new BinValueQuery(BinIndex.named(""field1""),         ""bucketName"", ""car""); Function mapFunction = new JSSourceFunction(         ""function(v) {"" +             ""var range = v.values[0].metadata.index.field2;"" +             ""if (range &lt;= 4 &amp;&amp; range &gt;= 2) {"" +                 ""return [v.values[0]];"" +             ""}"" +             ""return [];"" +         ""}""); Function reduceFunction = new JSSourceFunction(         ""function(v) {"" +             ""return [v.sort(function(a, b) {"" +                                  ""return a.metadata.index.field2 - b.metadata.index.field2;"" +                             ""}"" +                      "")];"" +          ""}""); MapReduceResult result = RiakUtils.getClient().mapReduce(iq)                             .addMapPhase(mapFunction)                             .addReducePhase(reduceFunction)                             .execute();  // Print the results System.out.println(result.getResultRaw());"
"package com.mobinet.snmp;  import org.snmp4j.CommunityTarget; import org.snmp4j.PDU; import org.snmp4j.Snmp; import org.snmp4j.TransportMapping; import org.snmp4j.event.ResponseEvent; import org.snmp4j.mp.SnmpConstants; import org.snmp4j.smi.Address; import org.snmp4j.smi.GenericAddress; import org.snmp4j.smi.Integer32; import org.snmp4j.smi.OID; import org.snmp4j.smi.OctetString; import org.snmp4j.smi.VariableBinding; import org.snmp4j.transport.DefaultTcpTransportMapping;  /**  *  * @author batbayar  */ public class SnmpTest {     private String address = ""192.168.1.254/161""; // switch address and snmp port     private String writeCommunity = ""myCommunityWrite""; // write community name      private Snmp snmp;     private CommunityTarget target;      public SnmpTest() {         try {             TransportMapping transport = new DefaultTcpTransportMapping();             snmp = new Snmp(transport);              Address targetAddress = GenericAddress.parse(address);             target = new CommunityTarget();             target.setCommunity(new OctetString(writeCommunity));             target.setAddress(targetAddress);             target.setRetries(2);             target.setTimeout(1500);             target.setVersion(SnmpConstants.version2c);              PDU command = new PDU();             command.setType(PDU.SET);             command.add(new VariableBinding(new OID(""1.3.6.1.2.1.2.2.1.7.1""), new Integer32(2))); // port 1 down             command.add(new VariableBinding(new OID(""1.3.6.1.2.1.2.2.1.7.6""), new Integer32(1))); // port 6 up             ResponseEvent response = snmp.send(command, target);             System.out.println(""response: "" + response);         } catch(Exception e) {             e.printStackTrace();         }     }      public static void main(String[] args) {         SnmpTest test = new SnmpTest();     } }"
"package com.spmsoftware.plugin.listeners;  import com.atlassian.event.api.EventListener; import com.atlassian.event.api.EventPublisher; import com.atlassian.jira.component.ComponentAccessor; import com.atlassian.jira.event.issue.IssueEvent; import com.atlassian.jira.event.type.EventType; import com.atlassian.jira.issue.Issue; import com.atlassian.jira.issue.MutableIssue; import com.atlassian.jira.issue.customfields.manager.OptionsManager; import com.atlassian.jira.issue.customfields.option.Option; import com.atlassian.jira.issue.customfields.option.Options; import com.atlassian.jira.issue.fields.CustomField; import com.atlassian.jira.issue.fields.config.FieldConfig; import com.atlassian.jira.issue.fields.config.FieldConfigScheme; import org.apache.log4j.Logger; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean;  import java.util.List; import java.util.Map;  /**  * User: adnan  * Date: 5/4/14  * Time: 4:49 PM  */ public class IssueUpdateListener  implements InitializingBean, DisposableBean {      private static final Logger LOGGER = Logger.getLogger(IssueUpdateListener.class);      private final EventPublisher eventPublisher;    // private final JiraAuthenticationContext authenticationContext;      public IssueUpdateListener(EventPublisher eventPublisher) {         this.eventPublisher = eventPublisher;        // this.authenticationContext = ComponentAccessor.getJiraAuthenticationContext();     }      @Override     public void afterPropertiesSet() throws Exception {         eventPublisher.register(this);     }      @Override     public void destroy() throws Exception {         eventPublisher.unregister(this);     }      @EventListener     public void onIssueEvent(IssueEvent issueEvent) {         Long eventTypeId = issueEvent.getEventTypeId();         Issue issue = issueEvent.getIssue();         if (eventTypeId.equals(EventType.ISSUE_RESOLVED_ID)) {             MutableIssue mutableIssue = getMutableIssue(issue);             CustomField customerNameCF = ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName(""Customer Name"");             CustomField allCustomersCF = ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName(""All Customers"");             Object customerNameVal = mutableIssue.getCustomFieldValue(customerNameCF);             Option newOptions = addOptionToCustomField(allCustomersCF, customerNameVal.toString());             LOGGER.info(""New updated option {}"" + newOptions);         }     }      private MutableIssue getMutableIssue(Issue issue) {         MutableIssue mutableIssue;         if (issue instanceof MutableIssue)   {             mutableIssue = (MutableIssue)issue;         } else {             mutableIssue = ComponentAccessor.getIssueManager().getIssueObject(issue.getKey());         }         return mutableIssue;     }       public Option addOptionToCustomField(CustomField customField, String value) {         Option newOption = null;         if (customField != null) {             List&lt;FieldConfigScheme&gt; schemes = customField.getConfigurationSchemes();             if (schemes != null &amp;&amp; !schemes.isEmpty()) {                 FieldConfigScheme sc = schemes.get(0);                 Map configs = sc.getConfigsByConfig();                 if (configs != null &amp;&amp; !configs.isEmpty()) {                     FieldConfig config = (FieldConfig) configs.keySet().iterator().next();                     OptionsManager optionsManager = ComponentAccessor.getOptionsManager();                     Options l = optionsManager.getOptions(config);                     int nextSequence = l.isEmpty() ? 1 : l.getRootOptions().size() + 1;                     newOption = optionsManager.createOption(config, null, (long) nextSequence, value);                 }             }         }          return newOption;     }  }"
"public List&lt;Date&gt; getTime(){       List&lt;Date&gt; dates = new ArrayList&lt;Date&gt;();       DateFormat format;        try {            Class.forName(""com.mysql.jdbc.Driver"");           Connection con = DriverManager.getConnection(url, ""root"", """");            Statement stmt = con.createStatement();            ResultSet result = stmt.executeQuery(""SELECT * FROM error_log WHERE service_source = 'Billbox' "");            while (result.next()) {  //retrieve data               String ds = result.getString(""error_date"");               format = new SimpleDateFormat(""M/d/yyyy H:m:s a"");                dates.add((Date)format.parse(ds));              }           con.close();        } catch (Exception ex) {           Logger.getLogger(LogDB.class.getName()).log(                          Level.SEVERE, null, ex);       }       return dates;   }"
"import org.camunda.bpm.ProcessEngineService; import org.camunda.bpm.container.RuntimeContainerDelegate; import org.camunda.bpm.engine.ManagementService; import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.management.JobDefinition; import org.camunda.bpm.engine.repository.ProcessDefinition; import org.camunda.bpm.engine.runtime.Job;  import java.util.HashMap; import java.util.List;  public class StackOverflow {    public HashMap&lt;ProcessDefinition, List&lt;Job&gt;&gt; queryNextScheduledExecutionOfTimers() {     ProcessEngineService processEngineService =      RuntimeContainerDelegate.INSTANCE.get().getProcessEngineService();     ProcessEngine defaultProcessEngine = processEngineService.getDefaultProcessEngine();      // optional step - get all active process definitions     RepositoryService repositoryService = defaultProcessEngine.getRepositoryService();     List&lt;ProcessDefinition&gt; processDefinitions =         repositoryService.createProcessDefinitionQuery().active().list();      ManagementService managementService = defaultProcessEngine.getManagementService();      HashMap&lt;ProcessDefinition,List&lt;Job&gt;&gt; timerJobsByProcessDefinition = new HashMap&lt;ProcessDefinition, List&lt;Job&gt;&gt;();     for (ProcessDefinition processDefinition : processDefinitions) {       List&lt;JobDefinition&gt; jobDefinitions =           managementService.createJobDefinitionQuery()               .active()               .processDefinitionId(processDefinition.getId())               .list();        for (JobDefinition jobDefinition : jobDefinitions) {         // if you want to lookup the activity to highlight it inside the process diagram for example         String activityId = jobDefinition.getActivityId();         // if you want to display the configured expression / date / cron expression when the timer should fire         String jobConfiguration = jobDefinition.getJobConfiguration();         // if you want to distinguish between timer start event / catching timer intermediate event / boundary timer event         String timerType = jobDefinition.getJobType();          List&lt;Job&gt; jobs = managementService.createJobQuery()             .active()             .timers()             .jobDefinitionId(jobDefinition.getId())             .orderByJobDuedate()             .list();          timerJobsByProcessDefinition.put(processDefinition, jobs);       }     }      return timerJobsByProcessDefinition;   } }"
"SybDriver sybDriver = (SybDriver) Class.forName(""com.sybase.jdbc3.jdbc.SybDriver"").newInstance(); sybDriver.setVersion(com.sybase.jdbcx.SybDriver.VERSION_6); DriverManager.registerDriver(sybDriver);  //DBProps (after including normal login/password etc. props.put(""ENABLE_BULK_LOAD"",""true"");  //open connection here for  sybDriver  dbConn.setAutoCommit(false);     String SQLString = ""insert into batch_inserts (row_id, colname1, colname2)\n values (?,?,?) \n"";  PreparedStatement   pstmt; try {    pstmt = dbConn.prepareStatement(SQLString);       } catch (SQLException sqle) {    displaySQLEx(""Couldn't prepare statement"",sqle);    return; }  for (String[] val : valuesToInsert) {    pstmt.setString(1, val[0]);  //row_id    varchar(30)    pstmt.setString(2, val[1]);//logical_server varchar(30)    pstmt.setString(3, val[2]);  //client_host varchar(30)     try    {       pstmt.addBatch();    }    catch (SQLException sqle)    {       displaySQLEx(""Failed to build batch"",sqle);       break;    } }  try {    pstmt.executeBatch();    dbConn.commit();    pstmt.close(); } catch (SQLException sqle) {    //handle }  try {    if (dbConn != null)       dbConn.close(); } catch (Exception e) {    //handle }"
"public class YourModule extends AbstractModule {     protected void configure() {       Multibinder&lt;Vehicle&gt; multibinder          = Multibinder.newSetBinder(binder(), Vehicle.class);       multibinder.addBinding().to(Buick.class);       multibinder.addBinding().to(Chevy.class);       multibinder.addBinding().to(Ferrari.class);    }  }   public class YourInterestingClass {    private final Set&lt;Vehicle&gt; vehicles;     @Inject    public YourInterestingClass(Set&lt;Vehicles&gt; vehicles){      this.vehicles = vehicles;    }     public void doSomethingWithVehicles(){      for(Vehicle vehicle: vehicles){        // do something      }    }  }"
"import com.xuggle.mediatool.IMediaWriter; import com.xuggle.mediatool.ToolFactory; import com.xuggle.xuggler.IAudioSamples; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture;    /**  * This class is used to merge audio and video file.  *  * @author Arslaan Ejaz  */ public class DecodeAndSaveAudioVideo {   public static void main(String[] args)   {      String filenamevideo = ""f:/testvidfol/video.mp4""; //this is the input file for video. you can change extension     String filenameaudio = ""f:/testvidfol/audio.wav""; //this is the input file for audio. you can change extension       IMediaWriter mWriter = ToolFactory.makeWriter(""f:/testvidfol/audiovideooutput.flv""); //output file      IContainer containerVideo = IContainer.make();     IContainer containerAudio = IContainer.make();      if (containerVideo.open(filenamevideo, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenamevideo);      if (containerAudio.open(filenameaudio, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenameaudio);      int numStreamVideo = containerVideo.getNumStreams();     int numStreamAudio = containerAudio.getNumStreams();      System.out.println(""Number of video streams: ""+numStreamVideo + ""\n"" + ""Number of audio streams: ""+numStreamAudio );  int videostreamt = -1; //this is the video stream id int audiostreamt = -1;  IStreamCoder  videocoder = null;      for(int i=0; i&lt;numStreamVideo; i++){         IStream stream = containerVideo.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO)         {             videostreamt = i;             videocoder = code;             break;         }      }      for(int i=0; i&lt;numStreamAudio; i++){         IStream stream = containerAudio.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO)         {             audiostreamt = i;             break;         }      }      if (videostreamt == -1) throw new RuntimeException(""No video steam found"");     if (audiostreamt == -1) throw new RuntimeException(""No audio steam found"");      if(videocoder.open()&lt;0 ) throw new RuntimeException(""Cant open video coder"");     IPacket packetvideo = IPacket.make();      IStreamCoder audioCoder = containerAudio.getStream(audiostreamt).getStreamCoder();      if(audioCoder.open()&lt;0 ) throw new RuntimeException(""Cant open audio coder"");     mWriter.addAudioStream(1, 1, audioCoder.getChannels(), audioCoder.getSampleRate());      mWriter.addVideoStream(0, 0, videocoder.getWidth(), videocoder.getHeight());      IPacket packetaudio = IPacket.make();      while(containerVideo.readNextPacket(packetvideo) &gt;= 0 ||             containerAudio.readNextPacket(packetaudio) &gt;= 0){          if(packetvideo.getStreamIndex() == videostreamt){              //video packet             IVideoPicture picture = IVideoPicture.make(videocoder.getPixelType(),                     videocoder.getWidth(),                     videocoder.getHeight());             int offset = 0;             while (offset &lt; packetvideo.getSize()){                 int bytesDecoded = videocoder.decodeVideo(picture,                          packetvideo,                          offset);                 if(bytesDecoded &lt; 0) throw new RuntimeException(""bytesDecoded not working"");                 offset += bytesDecoded;                  if(picture.isComplete()){                     System.out.println(picture.getPixelType());                     mWriter.encodeVideo(0, picture);                  }             }         }           if(packetaudio.getStreamIndex() == audiostreamt){            //audio packet              IAudioSamples samples = IAudioSamples.make(512,                      audioCoder.getChannels(),                     IAudioSamples.Format.FMT_S32);               int offset = 0;             while(offset&lt;packetaudio.getSize())             {                 int bytesDecodedaudio = audioCoder.decodeAudio(samples,                          packetaudio,                         offset);                 if (bytesDecodedaudio &lt; 0)                     throw new RuntimeException(""could not detect audio"");                 offset += bytesDecodedaudio;                  if (samples.isComplete()){                      mWriter.encodeAudio(1, samples);          }             }      }    } } }"
"ArrayAdapter&lt;String&gt; adapter = new ArrayAdapter&lt;String&gt;(this, R.layout.autocomplete_item,options);  // R.layout.autocomplete_item is custom spinner item xml file.you can use default spinner item also. autoComplete.setAdapter(adapter);  autoComplete.setThreshold(1); autoComplete.setOnItemClickListener(new OnItemClickListener() {      @Override     public void onItemClick(AdapterView&lt;?&gt; arg0, View arg1, int position,                     long arg3) {          Intent intent;         int index=999;         for(int i=0;i&lt;options.length;i++)         {             if(options[i].equals(autoComplete.getText().toString().trim()))             {                 index=i;                 break;             }         }         switch(index)         {             case 0:                 intent=new Intent(ThisActivity.this,ActivityZero.class);                 startActivity(intent);                 break;             case 1:                 intent=new Intent(ThisActivity.this,ActivityOne.class);                 startActivity(intent);                    break;                  ...                  }     } });"
"import java.util.Comparator; import java.util.PriorityQueue;  public class StackOverflow {     public static void main(String[] args)     {          FuelPriority strategy = new FuelPriority();         PriorityQueue&lt;Vehicle&gt; incoming = new PriorityQueue&lt;Vehicle&gt;(4, strategy);         incoming.add(new Vehicle(""car1"", 10));         incoming.add(new Vehicle(""car2"", 20));         incoming.add(new Vehicle(""car3"", 15));         incoming.add(new Vehicle(""car4"", 1));          // to retrieve the elements in order         while (!incoming.isEmpty()) {             System.out.println(incoming.poll());         }      }  }  class FuelPriority     implements Comparator&lt;Object&gt; {      public int compare(Object o1, Object o2)     {          Vehicle a1 = (Vehicle)o1;         Vehicle a2 = (Vehicle)o2;          return Integer.compare(a1.getFuelLevel(), a2.getFuelLevel());     } }  class Vehicle {      private String name;     private int fuelLevel;      public Vehicle(String name, int fuelLevel)     {         this.name = name;         this.fuelLevel = fuelLevel;     }     public int getFuelLevel()     {         return fuelLevel;     }      @Override     public String toString()     {         return name + ""="" + fuelLevel;     } }"
"public final class SupplierUtils {     private SupplierUtils() {     }      public static &lt;T&gt; Supplier&lt;T&gt; wrap(Callable&lt;T&gt; callable) {         return () -&gt; {             try {                 return callable.call();             }             catch (RuntimeException e) {                 throw e;             }             catch (Exception e) {                 throw new RuntimeException(e);             }         };     } }  public class JdbcConnectionPool extends ObjectPool&lt;Connection&gt; {      public JdbcConnectionPool(int maxConnections, String url) {         super(SupplierUtils.wrap(() -&gt; DriverManager.getConnection(url)), maxConnections);     } }"
"import com.xuggle.xuggler.Configuration; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IContainerFormat; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IPixelFormat; import com.xuggle.xuggler.IRational; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture; import com.xuggle.xuggler.video.ConverterFactory; import com.xuggle.xuggler.video.IConverter; import java.awt.AWTException; import java.awt.Rectangle; import java.awt.Robot; import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.util.Properties;  public class XugglerRtmpReferenceImpl {     private static String url = ""rtmp://your.test.server/screen/"";    private static String fileName = ""test/teststream"";    private static int framesToEncode = 60;    private static int x = 0;    private static int y = 0;    private static int height = 480;    private static int width = 640;     public static void main(String[] args) {        IContainer container = IContainer.make();        IContainerFormat containerFormat_live = IContainerFormat.make();        containerFormat_live.setOutputFormat(""flv"", url + fileName, null);        container.setInputBufferLength(0);        int retVal = container.open(url + fileName, IContainer.Type.WRITE, containerFormat_live);        if (retVal &lt; 0) {            System.err.println(""Could not open output container for live stream"");            System.exit(1);        }        IStream stream = container.addNewStream(0);        IStreamCoder coder = stream.getStreamCoder();        ICodec codec = ICodec.findEncodingCodec(ICodec.ID.CODEC_ID_H264);        coder.setNumPicturesInGroupOfPictures(5);        coder.setCodec(codec);        coder.setBitRate(200000);        coder.setPixelType(IPixelFormat.Type.YUV420P);        coder.setHeight(height);        coder.setWidth(width);        System.out.println(""[ENCODER] video size is "" + width + ""x"" + height);        coder.setFlag(IStreamCoder.Flags.FLAG_QSCALE, true);        coder.setGlobalQuality(0);        IRational frameRate = IRational.make(5, 1);        coder.setFrameRate(frameRate);        coder.setTimeBase(IRational.make(frameRate.getDenominator(), frameRate.getNumerator()));        Properties props = new Properties();        InputStream is = XugglerRtmpReferenceImpl.class.getResourceAsStream(""/libx264-normal.ffpreset"");        try {            props.load(is);        } catch (IOException e) {            System.err.println(""You need the libx264-normal.ffpreset file from the Xuggle distribution in your classpath."");            System.exit(1);        }        Configuration.configure(props, coder);        coder.open();        container.writeHeader();        long firstTimeStamp = System.currentTimeMillis();        long lastTimeStamp = -1;        int i = 0;        try {            Robot robot = new Robot();            while (i &lt; framesToEncode) {                //long iterationStartTime = System.currentTimeMillis();                long now = System.currentTimeMillis();                //grab the screenshot                BufferedImage image = robot.createScreenCapture(new Rectangle(x, y, width, height));                //convert it for Xuggler                BufferedImage currentScreenshot = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);                currentScreenshot.getGraphics().drawImage(image, 0, 0, null);                //start the encoding process                IPacket packet = IPacket.make();                IConverter converter = ConverterFactory.createConverter(currentScreenshot, IPixelFormat.Type.YUV420P);                long timeStamp = (now - firstTimeStamp) * 1000;                 IVideoPicture outFrame = converter.toPicture(currentScreenshot, timeStamp);                if (i == 0) {                    //make first frame keyframe                    outFrame.setKeyFrame(true);                }                outFrame.setQuality(0);                coder.encodeVideo(packet, outFrame, 0);                outFrame.delete();                if (packet.isComplete()) {                    container.writePacket(packet);                    System.out.println(""[ENCODER] writing packet of size "" + packet.getSize() + "" for elapsed time "" + ((timeStamp - lastTimeStamp) / 1000));                    lastTimeStamp = timeStamp;                }                System.out.println(""[ENCODER] encoded image "" + i + "" in "" + (System.currentTimeMillis() - now));                i++;                try {                    Thread.sleep(Math.max((long) (1000 / frameRate.getDouble()) - (System.currentTimeMillis() - now), 0));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        } catch (AWTException e) {            e.printStackTrace();        }        container.writeTrailer();     } }"
"ArrayList&lt;BuisnessObject&gt; episodes;         episodes = new ArrayList&lt;BuisnessObject&gt;();         String url = ""jdbc:mysql://localhost:3306/sons_of_anarchy"";         String driver = ""com.mysql.jdbc.Driver"";         Class.forName(driver);                   Connection connection = DriverManager.getConnection(url,""root"",""password"");           BuisnessObject newEpisode;          // Takes the date from the form in String and converts it java.util.date which is how the buisness object is written         java.util.Date date = new SimpleDateFormat(""yyyy-MM-dd"").parse(rq.getParameter(""origionalAirDate""));           // Creates an instance of the buisness object         episodes.add(newEpisode = new BuisnessObject(Integer.parseInt(rq.getParameter(""seasonNumber"")), Integer.parseInt(rq.getParameter(""seasonEpisodeNumber"")), Integer.parseInt(rq.getParameter(""seriesEpisodeNumber"")), rq.getParameter(""title""), rq.getParameter(""directedBy""), rq.getParameter(""writtenBy""), date, Float.parseFloat(rq.getParameter(""viewingFigures""))));         PreparedStatement editStatement = connection.prepareStatement(""INSERT into episode_guide VALUES (null,?,?,?,?,?,?,?,?)"");          // Takes date from java.util.date and converts it to java.sql.date         java.sql.Date mySqlDate = new java.sql.Date(newEpisode.origionalAirDate.getTime());           editStatement.setInt(1, newEpisode.getSeasonNumber());         editStatement.setInt(2, newEpisode.getSeasonEpisodeNumber());         editStatement.setInt(3, newEpisode.getSeriesEpisodeNumber());         editStatement.setString(4, newEpisode.getTitle());                   editStatement.setString(5, newEpisode.getDirectedBy());         editStatement.setString(6, newEpisode.getWrittenBy());         editStatement.setDate(7, mySqlDate);         editStatement.setFloat(8, (float) newEpisode.getViewingFigures());          editStatement.executeUpdate();         editStatement.close();         connection.close();"
interface Renderable {    void render(); }  interface RenderDelegator {    Renderable getRenderable();    void setRenderable(Renderable renderable); }  abstract class Vehicle implements RenderDelegator {    private Renderable renderable;     @Override    public Renderable getRenderable() {       return renderable;    }     @Override    public void setRenderable(Renderable renderable) {       this.renderable = renderable;    }     public abstract void drive(); }  class Car extends Vehicle {    @Override    public void drive() {       // TODO finish!    }  }
"import java.io.StringReader; import javax.xml.xpath.XPath; import javax.xml.xpath.XPathFactory; import org.xml.sax.InputSource;  public class Demo {      public static void main(String[] args) throws Exception {         String xml = ""&lt;car&gt;&lt;manufacturer&gt;toyota&lt;/manufacturer&gt;&lt;/car&gt;"";         String xpath = ""/car/manufacturer"";         XPath xPath = XPathFactory.newInstance().newXPath();         assertEquals(""toyota"",xPath.evaluate(xpath, new InputSource(new StringReader(xml))));     }  }"
"import org.apache.commons.httpclient.HttpClient; import org.jboss.resteasy.client.ClientRequest; import org.jboss.resteasy.client.ClientResponse; import org.jboss.resteasy.client.ProxyFactory; import org.jboss.resteasy.client.core.executors.ApacheHttpClientExecutor; import org.jboss.resteasy.plugins.providers.RegisterBuiltin; import org.jboss.resteasy.spi.ResteasyProviderFactory;  RegisterBuiltin.register(ResteasyProviderFactory.getInstance()); HttpClient httpClient = new HttpClient(); ApacheHttpClientExecutor executor = new ApacheHttpClientExecutor(httpClient) {     @Override     public ClientResponse execute(ClientRequest request) throws Exception {         request.header(""X-My-Header"", ""value"");         return super.execute(request);     }            };  SimpleClient client = ProxyFactory.create(SimpleClient.class, ""http://localhost:8081"", executor); client.putBasic(""hello world"");"
"public static void main(String[] args) throws Exception {     List&lt;Class&lt;Driver&gt;&gt; drivers = findClassesImplementing(Driver.class);     System.out.println(drivers); }          public static &lt;T extends Object&gt; List&lt;Class&lt;T&gt;&gt; findClassesImplementing(Class&lt;T&gt; cls) throws IOException {     List&lt;Class&lt;T&gt;&gt; classes = new ArrayList&lt;Class&lt;T&gt;&gt;();      for (URL root : Collections.list(Thread.currentThread().getContextClassLoader().getResources(""""))) {         for (File file : findFiles(new File(root.getFile()), "".+\\.jar$"")) {             JarFile jarFile = new JarFile(file);             for (JarEntry jarEntry : Collections.list(jarFile.entries())) {                 String name = jarEntry.getName();                 if (name.endsWith("".class"")) try {                     Class&lt;?&gt; found = Class.forName(name.replace(""/"", ""."").replaceAll(""\\.class$"", """"));                     if (cls.isAssignableFrom(found)) {                         classes.add((Class&lt;T&gt;) found);                     }                 } catch (Throwable ignore) {                     // No real class file, or JAR not in classpath, or missing links.                 }             }         }     }      return classes; }  public static List&lt;File&gt; findFiles(File directory, final String pattern) throws IOException {     File[] files = directory.listFiles(new FileFilter() {         public boolean accept(File file) {             return file.isDirectory() || file.getName().matches(pattern);         }     });      List&lt;File&gt; found = new ArrayList&lt;File&gt;(files.length);      for (File file : files) {         if (file.isDirectory()) {             found.addAll(findFiles(file, pattern));         } else {             found.add(file);         }     }      return found; }"
"curl -XDELETE localhost:9200/test curl -XPUT localhost:9200/test -d '{     ""settings"": {         ""index.number_of_shards"": 1,         ""index.number_of_replicas"": 0     },     ""mappings"": {             ""car"": {                 ""properties"": {                     ""creators"" : {                         ""type"": ""nested"",                         ""properties"": {                             ""name"": {""type"":""string""}                         }                     }                 }             }         }     } } ' curl -XPOST localhost:9200/test/car/1 -d '{     ""creators"": {         ""name"": ""Steve""     } } ' curl -X POST 'http://localhost:9200/test/_refresh' echo curl -X GET 'http://localhost:9200/test/car/_search?pretty' -d '    {     ""query"": {         ""nested"": {             ""path"": ""creators"",             ""query"": {                 ""bool"": {                     ""must"": [{                         ""match"": {                             ""creators.name"": ""Steve""                         }                     }],                     ""must_not"": [],                     ""should"": []                 }             }         }     },     ""from"": 0,     ""size"": 50,     ""sort"": [],     ""facets"": {} } '"
package org.camunda.bpm;  import org.camunda.bpm.engine.HistoryService; import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.history.HistoricProcessInstance; import org.camunda.bpm.engine.repository.ProcessDefinition; import java.util.List;  public class AllFinishedProcessInstances {    public List&lt;HistoricProcessInstance&gt; getAllFinishedProcessInstances(String processDefinitionName) {     ProcessEngine processEngine = BpmPlatform.getDefaultProcessEngine();     HistoryService historyService = processEngine.getHistoryService();;     RepositoryService repositoryService = processEngine.getRepositoryService();      ProcessDefinition myProcessDefinition =         repositoryService.createProcessDefinitionQuery()             .processDefinitionName(processDefinitionName)             .latestVersion() // we are only interested in the latest version             .singleResult();      List&lt;HistoricProcessInstance&gt; processInstances =         historyService.createHistoricProcessInstanceQuery()             .processDefinitionId(myProcessDefinition.getId())             .finished() // we only want the finished process instances             .list();      return processInstances;   }  }
"package fibonacci.bench;  import fibonacci.mdl.ExplicitLocking; import fibonacci.mdl.FibonacciGenerator; import fibonacci.mdl.IntrinsicLocking; import fibonacci.mdl.LockFree; import fibonacci.mdl.STM; import org.openjdk.jmh.annotations.BenchmarkMode; import org.openjdk.jmh.annotations.GenerateMicroBenchmark; import org.openjdk.jmh.annotations.Level; import org.openjdk.jmh.annotations.Measurement; import org.openjdk.jmh.annotations.Mode; import org.openjdk.jmh.annotations.Scope; import org.openjdk.jmh.annotations.Setup; import org.openjdk.jmh.annotations.State; import org.openjdk.jmh.annotations.Warmup;  import java.math.BigInteger;  /*    Implementation notes:     * This benchmark does not exhibit a steady state, which means      we can not do timed runs. Instead, we have to time single      invocations; therefore preset benchmark mode.     * Each iteration should start from the pristine state,      therefore we reinitialize in @Setup(Iteration).     * Since we are interested in performance beyond the first      invocation, we have to call several times and aggregate      the time; this is why we have batchSize &gt; 1. Note the      performance might be different depending on given batch      size.     * Since we have to provide warmup, we do many iterations.     * The performance is different run to run, because we are       measuring sometimes undeterministic thread allocations.      JMH does it for us, hence multiple forks.     * We don't want the profiles for difference FibonacciGenerator      to mix up. JMH already takes care of that for us by forking      each test.      */  @BenchmarkMode(Mode.SingleShotTime) @Warmup(iterations = 100, batchSize = JmhBench.BATCH_SIZE) @Measurement(iterations = 100, batchSize = JmhBench.BATCH_SIZE) @State(Scope.Benchmark) public class JmhBench {      public static final int BATCH_SIZE = 50000;      private FibonacciGenerator explicitLock;     private IntrinsicLocking intrinsicLock;     private LockFree lockFree;     private STM stm;      @Setup(Level.Iteration)     public void setup() {         explicitLock = new ExplicitLocking();         intrinsicLock = new IntrinsicLocking();         lockFree = new LockFree();         stm = new STM();     }      @GenerateMicroBenchmark     public BigInteger stm() {         return stm.next();     }      @GenerateMicroBenchmark     public BigInteger explicitLock() {         return explicitLock.next();     }      @GenerateMicroBenchmark     public BigInteger intrinsicLock() {         return intrinsicLock.next();     }      @GenerateMicroBenchmark     public BigInteger lockFree() {         return lockFree.next();     }  }"
"Validator validator = Validation.buildDefaultValidatorFactory().getValidator(); Set&lt;ConstraintViolation&lt;Car&gt;&gt; constraintViolations = validator.validate(myCar);  if (constraintViolations.size() &gt; 0) {     Set&lt;String&gt; violationMessages = new HashSet&lt;String&gt;();      for (ConstraintViolation&lt;T&gt; constraintViolation : constraintViolations) {         violationMessages.add(constraintViolation.getPropertyPath() + "": "" + constraintViolation.getMessage());     }      throw new RuntimeException(""Car is not valid:\n"" + StringUtils.join(violationMessages, ""\n"")); }"
"import com.thoughtworks.xstream.converters.Converter; import com.thoughtworks.xstream.converters.MarshallingContext; import com.thoughtworks.xstream.converters.UnmarshallingContext; import com.thoughtworks.xstream.io.HierarchicalStreamReader; import com.thoughtworks.xstream.io.HierarchicalStreamWriter;  public class UserConverter implements Converter {      @Override     public boolean canConvert(Class clazz) {         return clazz.equals(User.class);     }      @Override     public void marshal(Object value, HierarchicalStreamWriter writer,             MarshallingContext context)      {      }      @Override     public Object unmarshal(HierarchicalStreamReader reader,             UnmarshallingContext context)      {         User user = new User();          reader.moveDown();         if (""fullName"".equals(reader.getNodeName()))         {             String[] name = reader.getValue().split(""\\s"");             user.setFirstName(name[0]);             user.setLastName(name[1]);         }         reader.moveUp();          return user;     } }"
"public void actionPerformed(ActionEvent ae) {     if (ae.equals(save))     {         String sqlInsert1 = ""INSERT INTO Drivers (IDNumber, FirstName, LastName) VALUES "" + Id +"","" + FirstName+"","" + Surname;         String sqlInsert2 = ""INSERT INTO Offences(IDNumber, SpeedLimit, DriverSpeed, SeatBelt, DrunkenDriving, DriversLicense) VALUES"" + Id + SpeedLimit + DriversSpeed + Seatbelt + DrunkenDriving + License;         String sqlInsert3 = ""INSERT INTO DriverPoints(IDNumber, Points) VALUES"" + Id + Points;          database.writeToDB(sqlInsert1,sqlInsert2,sqlInsert3);     }"
"public class DelegatingDriver implements Driver {     private final Driver driver;      public DelegatingDriver(Driver driver)     {         if (driver == null)         {             throw new IllegalArgumentException(""Driver must not be null."");         }         this.driver = driver;     }      public Connection connect(String url, Properties info) throws SQLException     {        return driver.connect(url, info);     }      public boolean acceptsURL(String url) throws SQLException     {        return driver.acceptsURL(url);     }      public DriverPropertyInfo[] getPropertyInfo(String url, Properties info) throws SQLException     {         return driver.getPropertyInfo(url, info);     }      public int getMajorVersion()     {         return driver.getMajorVersion();     }      public int getMinorVersion()     {         return driver.getMinorVersion();     }      public boolean jdbcCompliant()     {          return driver.jdbcCompliant();     } }"
"import org.apache.hadoop.conf.Configuration; import org.apache.hadoop.fs.Path; import org.apache.hadoop.mapreduce.InputFormat; import org.apache.hadoop.mapreduce.RecordReader; import org.apache.hadoop.mapreduce.TaskAttemptContext; import org.apache.hadoop.mapreduce.TaskAttemptID; import org.apache.hadoop.mapreduce.lib.input.FileSplit; import org.apache.hadoop.mapreduce.task.TaskAttemptContextImpl; import org.apache.hadoop.util.ReflectionUtils; import java.io.File;  Configuration conf = new Configuration(false); conf.set(""fs.default.name"", ""file:///"");  File testFile = new File(""path/to/file""); Path path = new Path(testFile.getAbsoluteFile().toURI()); FileSplit split = new FileSplit(path, 0, testFile.length(), null);  InputFormat inputFormat = ReflectionUtils.newInstance(MyInputFormat.class, conf); TaskAttemptContext context = new TaskAttemptContextImpl(conf, new TaskAttemptID()); RecordReader reader = inputFormat.createRecordReader(split, context);  reader.initialize(split, context);"
"package org.hibernate.envers.test.integration.basic;  import org.hibernate.Session; import org.hibernate.action.spi.AfterTransactionCompletionProcess; import org.hibernate.action.spi.BeforeTransactionCompletionProcess; import org.hibernate.engine.spi.SessionImplementor; import org.hibernate.envers.internal.tools.MutableInteger; import org.hibernate.envers.test.BaseEnversFunctionalTestCase; import org.hibernate.envers.test.entities.StrTestEntity; import org.hibernate.event.service.spi.EventListenerRegistry; import org.hibernate.event.spi.EventType; import org.hibernate.event.spi.PostInsertEvent; import org.hibernate.event.spi.PostInsertEventListener; import org.hibernate.persister.entity.EntityPersister;  import org.junit.Assert; import org.junit.Test;  import org.hibernate.testing.TestForIssue;  /**  * @author Lukasz Antoniak (lukasz dot antoniak at gmail dot com)  */ public class RegisterUserEventListenersTest extends BaseEnversFunctionalTestCase {     @Override     protected Class&lt;?&gt;[] getAnnotatedClasses() {         return new Class&lt;?&gt;[] {StrTestEntity.class};     }      @Test     @TestForIssue(jiraKey = ""HHH-7478"")     public void testTransactionProcessSynchronization() {         final EventListenerRegistry registry = sessionFactory().getServiceRegistry()                 .getService( EventListenerRegistry.class );         final CountingPostInsertTransactionBoundaryListener listener = new CountingPostInsertTransactionBoundaryListener();          registry.getEventListenerGroup( EventType.POST_INSERT ).appendListener( listener );          Session session = openSession();         session.getTransaction().begin();         StrTestEntity entity = new StrTestEntity( ""str1"" );         session.save( entity );         session.getTransaction().commit();         session.close();          // Post insert listener invoked three times - before/after insertion of original data,         // revision entity and audit row.         Assert.assertEquals( 3, listener.getBeforeCount() );         Assert.assertEquals( 3, listener.getAfterCount() );     }      private static class CountingPostInsertTransactionBoundaryListener implements PostInsertEventListener {         private final MutableInteger beforeCounter = new MutableInteger();         private final MutableInteger afterCounter = new MutableInteger();          @Override         public void onPostInsert(PostInsertEvent event) {             event.getSession().getActionQueue().registerProcess(                     new BeforeTransactionCompletionProcess() {                         @Override                         public void doBeforeTransactionCompletion(SessionImplementor session) {                             beforeCounter.increase();                         }                     }             );             event.getSession().getActionQueue().registerProcess(                     new AfterTransactionCompletionProcess() {                         @Override                         public void doAfterTransactionCompletion(boolean success, SessionImplementor session) {                             afterCounter.increase();                         }                     }             );         }          @Override         public boolean requiresPostCommitHanding(EntityPersister persister) {             return true;         }          public int getBeforeCount() {             return beforeCounter.get();         }          public int getAfterCount() {             return afterCounter.get();         }     } }"
"private class InfoSerializer implements JsonSerializer&lt;Info&gt; {     @Override     public JsonElement serialize(Info src, Type typeOfSrc,             JsonSerializationContext context)     {          JsonObject obj = new JsonObject();          obj.addProperty(""details"", src.getDetails());          obj.addProperty(""hostId"", src.getHostId());          obj.addProperty(""dateCreated"", src.getDateCreated().toString());          obj.addProperty(""expiryDate"", src.getExpiryDate().toString());          obj.add(""alternativeInfo"", getGsonInstance().toJsonTree(src.getAlternativeInfo()));          obj.add(""alternativeTimes"", getGsonInstance().toJsonTree(src.getAlternativeTimes()));          return obj;     }    }"
