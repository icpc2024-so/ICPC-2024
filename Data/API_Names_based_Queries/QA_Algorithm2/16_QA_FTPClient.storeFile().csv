code
"query.from(catalog) .innerJoin(qe).on(catalog.id.eq(qe.itemId)) .innerJoin(enterprise).on(enterprise.id.eq(qe.enterpriseId)) .leftJoin(catalogPerson).on(catalogPerson.catalogId.eq(catalog.id)) .where(catalog.deletionDate.isNull(), qe.enterpriseId.eq(org)) .orderBy(catalog.creationDate.desc()) .limit(limit) .offset(offset) .groupBy(catalog.id) .list(Projections.constructor(Catalog.class,                             catalog.id,                             catalog.name,                             catalog.code,                             catalogPerson.count()));"
"package com.bullethq.jawr.postprocessor;  import net.jawr.web.resource.FileNameUtils; import net.jawr.web.resource.bundle.factory.util.PathNormalizer; import net.jawr.web.resource.bundle.postprocess.BundleProcessingStatus; import net.jawr.web.resource.bundle.postprocess.impl.CSSURLPathRewriterPostProcessor; import net.jawr.web.resource.bundle.postprocess.impl.PostProcessorCssImageUrlRewriter;  import java.io.IOException;  public class CustomCssUrlPathRewriterPostProcessor extends CSSURLPathRewriterPostProcessor {      public static final String CUSTOM_URL_PATH_REWRITER = ""customcsspathrewriter"";      public CustomCssUrlPathRewriterPostProcessor() {         super(CUSTOM_URL_PATH_REWRITER);     }      // ========================================================================     // ========================================================================     // ========================================================================     @Override     protected PostProcessorCssImageUrlRewriter createImageUrlRewriter(BundleProcessingStatus status) {         return new CustomPostProcessorCssImageUrlRewriter(status);     }      // ========================================================================     // ========================================================================     // ========================================================================     public class CustomPostProcessorCssImageUrlRewriter extends PostProcessorCssImageUrlRewriter {          public CustomPostProcessorCssImageUrlRewriter(BundleProcessingStatus status) {             super(status);         }          // ========================================================================         // ========================================================================         // ========================================================================         @Override         protected String getUrlPath(String match, String originalPath, String newCssPath) throws IOException {             String url = match.substring(match.indexOf('(') + 1, match.lastIndexOf(')')).trim();              // Remove any quotes if necessary.             String quoteStr = """";             if (url.startsWith(""'"") || url.startsWith(""\"""")) {                 quoteStr = String.valueOf(url.charAt(0));                 url = url.substring(1, url.length() - 1);             }              // We now check if the url ends in a known image file extension             // If not, the url is ignored.             if (FileNameUtils.hasImageExtension(url)) {                 return super.getUrlPath(match, originalPath, newCssPath);             } else {                 // We need to rewrite the path, as any relative URLs will                 // not resolve correctly if Jawr has changed the CSS path.                 url = PathNormalizer.concatWebPath(originalPath, url);                 url = PathNormalizer.getRelativeWebPath(PathNormalizer.getParentPath(newCssPath), url);                 return ""url("" + quoteStr + url + quoteStr + "")"";             }         }     } }"
"protected Object loadFromDatasource(         final LoadEvent event,         final EntityPersister persister,         final EntityKey keyToLoad,         final LoadEventListener.LoadType options) {     final SessionImplementor source = event.getSession();     Object entity = persister.load(             event.getEntityId(),             event.getInstanceToLoad(),             event.getLockMode(),             source     );      if ( event.isAssociationFetch() &amp;&amp; source.getFactory().getStatistics().isStatisticsEnabled() ) {         source.getFactory().getStatisticsImplementor().fetchEntity( event.getEntityClassName() );     }      return entity; }"
"ParcelFileDescriptor fileDescriptor = this.getContentResolver().openFileDescriptor(uri, &quot;r&quot;);             InputStream in = this.getContentResolver().openInputStream(uri);              CountingInputStreamEntity entity = new CountingInputStreamEntity(in, fileDescriptor.getStatSize());             entity.setUploadListener(this);             entity.setContentType(&quot;binary/octet-stream&quot;);             entity.setChunked(true);                       BufferedHttpEntity myEntity = null;             try {                 myEntity = new BufferedHttpEntity(entity);             } catch (IOException e) {                 // TODO Auto-generated catch block                 e.printStackTrace();             }                          put.setEntity(myEntity);"
"import com.xuggle.mediatool.IMediaWriter; import com.xuggle.mediatool.ToolFactory; import com.xuggle.xuggler.IAudioSamples; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture;    /**  * This class is used to merge audio and video file.  *  * @author Arslaan Ejaz  */ public class DecodeAndSaveAudioVideo {   public static void main(String[] args)   {      String filenamevideo = ""f:/testvidfol/video.mp4""; //this is the input file for video. you can change extension     String filenameaudio = ""f:/testvidfol/audio.wav""; //this is the input file for audio. you can change extension       IMediaWriter mWriter = ToolFactory.makeWriter(""f:/testvidfol/audiovideooutput.flv""); //output file      IContainer containerVideo = IContainer.make();     IContainer containerAudio = IContainer.make();      if (containerVideo.open(filenamevideo, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenamevideo);      if (containerAudio.open(filenameaudio, IContainer.Type.READ, null) &lt; 0)         throw new IllegalArgumentException(""Cant find "" + filenameaudio);      int numStreamVideo = containerVideo.getNumStreams();     int numStreamAudio = containerAudio.getNumStreams();      System.out.println(""Number of video streams: ""+numStreamVideo + ""\n"" + ""Number of audio streams: ""+numStreamAudio );  int videostreamt = -1; //this is the video stream id int audiostreamt = -1;  IStreamCoder  videocoder = null;      for(int i=0; i&lt;numStreamVideo; i++){         IStream stream = containerVideo.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_VIDEO)         {             videostreamt = i;             videocoder = code;             break;         }      }      for(int i=0; i&lt;numStreamAudio; i++){         IStream stream = containerAudio.getStream(i);         IStreamCoder code = stream.getStreamCoder();          if(code.getCodecType() == ICodec.Type.CODEC_TYPE_AUDIO)         {             audiostreamt = i;             break;         }      }      if (videostreamt == -1) throw new RuntimeException(""No video steam found"");     if (audiostreamt == -1) throw new RuntimeException(""No audio steam found"");      if(videocoder.open()&lt;0 ) throw new RuntimeException(""Cant open video coder"");     IPacket packetvideo = IPacket.make();      IStreamCoder audioCoder = containerAudio.getStream(audiostreamt).getStreamCoder();      if(audioCoder.open()&lt;0 ) throw new RuntimeException(""Cant open audio coder"");     mWriter.addAudioStream(1, 1, audioCoder.getChannels(), audioCoder.getSampleRate());      mWriter.addVideoStream(0, 0, videocoder.getWidth(), videocoder.getHeight());      IPacket packetaudio = IPacket.make();      while(containerVideo.readNextPacket(packetvideo) &gt;= 0 ||             containerAudio.readNextPacket(packetaudio) &gt;= 0){          if(packetvideo.getStreamIndex() == videostreamt){              //video packet             IVideoPicture picture = IVideoPicture.make(videocoder.getPixelType(),                     videocoder.getWidth(),                     videocoder.getHeight());             int offset = 0;             while (offset &lt; packetvideo.getSize()){                 int bytesDecoded = videocoder.decodeVideo(picture,                          packetvideo,                          offset);                 if(bytesDecoded &lt; 0) throw new RuntimeException(""bytesDecoded not working"");                 offset += bytesDecoded;                  if(picture.isComplete()){                     System.out.println(picture.getPixelType());                     mWriter.encodeVideo(0, picture);                  }             }         }           if(packetaudio.getStreamIndex() == audiostreamt){            //audio packet              IAudioSamples samples = IAudioSamples.make(512,                      audioCoder.getChannels(),                     IAudioSamples.Format.FMT_S32);               int offset = 0;             while(offset&lt;packetaudio.getSize())             {                 int bytesDecodedaudio = audioCoder.decodeAudio(samples,                          packetaudio,                         offset);                 if (bytesDecodedaudio &lt; 0)                     throw new RuntimeException(""could not detect audio"");                 offset += bytesDecodedaudio;                  if (samples.isComplete()){                      mWriter.encodeAudio(1, samples);          }             }      }    } } }"
"package com.mobinet.snmp;  import org.snmp4j.CommunityTarget; import org.snmp4j.PDU; import org.snmp4j.Snmp; import org.snmp4j.TransportMapping; import org.snmp4j.event.ResponseEvent; import org.snmp4j.mp.SnmpConstants; import org.snmp4j.smi.Address; import org.snmp4j.smi.GenericAddress; import org.snmp4j.smi.Integer32; import org.snmp4j.smi.OID; import org.snmp4j.smi.OctetString; import org.snmp4j.smi.VariableBinding; import org.snmp4j.transport.DefaultTcpTransportMapping;  /**  *  * @author batbayar  */ public class SnmpTest {     private String address = ""192.168.1.254/161""; // switch address and snmp port     private String writeCommunity = ""myCommunityWrite""; // write community name      private Snmp snmp;     private CommunityTarget target;      public SnmpTest() {         try {             TransportMapping transport = new DefaultTcpTransportMapping();             snmp = new Snmp(transport);              Address targetAddress = GenericAddress.parse(address);             target = new CommunityTarget();             target.setCommunity(new OctetString(writeCommunity));             target.setAddress(targetAddress);             target.setRetries(2);             target.setTimeout(1500);             target.setVersion(SnmpConstants.version2c);              PDU command = new PDU();             command.setType(PDU.SET);             command.add(new VariableBinding(new OID(""1.3.6.1.2.1.2.2.1.7.1""), new Integer32(2))); // port 1 down             command.add(new VariableBinding(new OID(""1.3.6.1.2.1.2.2.1.7.6""), new Integer32(1))); // port 6 up             ResponseEvent response = snmp.send(command, target);             System.out.println(""response: "" + response);         } catch(Exception e) {             e.printStackTrace();         }     }      public static void main(String[] args) {         SnmpTest test = new SnmpTest();     } }"
"SMIMEEnvelopedGenerator gen = new SMIMEEnvelopedGenerator(); JceKeyAgreeRecipientInfoGenerator rig = new JceKeyAgreeRecipientInfoGenerator(CMSAlgorithm.ECDH_SHA1KDF, senderPrivateKey, senderPublicKey, CMSAlgorithm.AES128_WRAP); rig.setProvider(BouncyCastleProvider.PROVIDER_NAME); rig.addRecipient(recipientX509Certificate); gen.addRecipientInfoGenerator(rig);  MimeBodyPart msg = new MimeBodyPart(); msg.setText(&quot;This is a secret message&quot;);  MimeBodyPart mp = gen.generate(msg, new JceCMSContentEncryptorBuilder(CMSAlgorithm.AES128_CBC).setProvider(&quot;BC&quot;).build());  Properties props = System.getProperties(); Session session = Session.getDefaultInstance(props, null);  String to = &quot;bob@example.com&quot;;  Address fromUser = new InternetAddress(&quot;alice@example.com&quot;); Address toUser = new InternetAddress(to);  MimeMessage body = new MimeMessage(session); body.setFrom(fromUser); body.setRecipient(Message.RecipientType.TO, toUser); body.setSubject(&quot;example encrypted message&quot;); body.setContent(mp.getContent(), mp.getContentType()); body.saveChanges();  body.writeTo(new FileOutputStream(&quot;/tmp/encrypted.msg&quot;));"
"Criteria criteria = hibernetSession.createCriteria(WishList.class); criteria.createAlias(""item"", ""itemAlias"") .setProjection(Projections.projectionList() .add(Projections.property(""id""),""id"") .add(Projections.property(""itemAlias.id""),""itemAlias.id"") .add(Projections.property(""itemAlias.productCategory""),""itemAlias.productCategory"") .add(Projections.property(""itemAlias.productName""),""itemAlias.productName"") .add(Projections.groupProperty(""itemAlias.productName""))) .setResultTransformer(Transformers.aliasToBean(WishList.class)); List&lt;WishList&gt; itemList = criteria.list();"
"SSLcontext sslContext = SSLContext.getDefault();  KeyStore trustSt = KeyStore.getInstance(""BKS""); TrustManagerFactory trustManagerFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm()); InputStream trustStoreStream = this.getResources().openRawResource(R.raw.truststore); trustSt.load(trustStoreStream, ""&lt;yourpassword&gt;"".toCharArray()); trustManagerFactory.init(trustStre);  KeyStore keyStore = KeyStore.getInstance(""BKS""); KeyManagerFactory keyManagerFactory = KeyManagerFactory.getInstance(KeyManagerFactory.getDefaultAlgorithm()); InputStream keyStoreStream = this.getResources().openRawResource(R.raw.keystore); keyStore.load(keyStoreStream, ""&lt;yourpassword&gt;"".toCharArray()); keyManagerFactory.init(keyStore, ""&lt;yourpassword&gt;"".toCharArray());  sslContext.init(keyManagerFactory.getKeyManagers(), trustManagerFactory.getTrustManagers(), null);"
protected void onCreate(Bundle savedInstanceState) {     super.onCreate(savedInstanceState);     setContentView(R.layout.activity_main);      map = ((SupportMapFragment) getSupportFragmentManager().findFragmentById(R.id.map)).getMap();      // Add this line     map.setMyLocationEnabled(true);      locManager = (LocationManager)getSystemService(LOCATION_SERVICE);     providersList = locManager.getAllProviders();     provider =locManager.getProvider(providersList.get(0));     precision = provider.getAccuracy();     req = new Criteria();     req.setAccuracy(Criteria.ACCURACY_FINE);             inside = false;      //map.getUiSettings().setMyLocationButtonEnabled(true);      buildPolygon();     drawPolygon();     startLocalization(); }
"tempEditText = (EditText) addView.findViewById(R.id.nrOfSharesInPortfolioEdit); tempEditText = (EditText) addView.findViewById(R.id.nrOfSharesInPortfolioEdit); tempEditText.setText(Portfolio.getPortfolio().getShareHolding(positionList).getNrOfSharesInPortfolio()); System.out.println(Portfolio.getPortfolio().getShareHolding(positionList).getNrOfSharesInPortfolio()); tempEditText = (EditText) addView.findViewById(R.id.currentCourseEdit); tempEditText.setText(Double.toString(Portfolio.getPortfolio().getShareHolding(positionList).getCurrentRate()));  new AlertDialog.Builder(DetailShareHoldingActivity.this)     .setTitle(""Köp "" + Portfolio.getPortfolio().getShareHolding(positionList).getName() +  "" Aktier"")     .setView(addView)     .setPositiveButton(""Köp"", new DialogInterface.OnClickListener() {         public void onClick(DialogInterface dialog, int whichButton) {             System.out.println(""Button pressed köp "");         }     })     .setNegativeButton(""Avbryt"", null)     .show();"
"import com.xuggle.xuggler.Configuration; import com.xuggle.xuggler.ICodec; import com.xuggle.xuggler.IContainer; import com.xuggle.xuggler.IContainerFormat; import com.xuggle.xuggler.IPacket; import com.xuggle.xuggler.IPixelFormat; import com.xuggle.xuggler.IRational; import com.xuggle.xuggler.IStream; import com.xuggle.xuggler.IStreamCoder; import com.xuggle.xuggler.IVideoPicture; import com.xuggle.xuggler.video.ConverterFactory; import com.xuggle.xuggler.video.IConverter; import java.awt.AWTException; import java.awt.Rectangle; import java.awt.Robot; import java.awt.image.BufferedImage; import java.io.IOException; import java.io.InputStream; import java.util.Properties;  public class XugglerRtmpReferenceImpl {     private static String url = ""rtmp://your.test.server/screen/"";    private static String fileName = ""test/teststream"";    private static int framesToEncode = 60;    private static int x = 0;    private static int y = 0;    private static int height = 480;    private static int width = 640;     public static void main(String[] args) {        IContainer container = IContainer.make();        IContainerFormat containerFormat_live = IContainerFormat.make();        containerFormat_live.setOutputFormat(""flv"", url + fileName, null);        container.setInputBufferLength(0);        int retVal = container.open(url + fileName, IContainer.Type.WRITE, containerFormat_live);        if (retVal &lt; 0) {            System.err.println(""Could not open output container for live stream"");            System.exit(1);        }        IStream stream = container.addNewStream(0);        IStreamCoder coder = stream.getStreamCoder();        ICodec codec = ICodec.findEncodingCodec(ICodec.ID.CODEC_ID_H264);        coder.setNumPicturesInGroupOfPictures(5);        coder.setCodec(codec);        coder.setBitRate(200000);        coder.setPixelType(IPixelFormat.Type.YUV420P);        coder.setHeight(height);        coder.setWidth(width);        System.out.println(""[ENCODER] video size is "" + width + ""x"" + height);        coder.setFlag(IStreamCoder.Flags.FLAG_QSCALE, true);        coder.setGlobalQuality(0);        IRational frameRate = IRational.make(5, 1);        coder.setFrameRate(frameRate);        coder.setTimeBase(IRational.make(frameRate.getDenominator(), frameRate.getNumerator()));        Properties props = new Properties();        InputStream is = XugglerRtmpReferenceImpl.class.getResourceAsStream(""/libx264-normal.ffpreset"");        try {            props.load(is);        } catch (IOException e) {            System.err.println(""You need the libx264-normal.ffpreset file from the Xuggle distribution in your classpath."");            System.exit(1);        }        Configuration.configure(props, coder);        coder.open();        container.writeHeader();        long firstTimeStamp = System.currentTimeMillis();        long lastTimeStamp = -1;        int i = 0;        try {            Robot robot = new Robot();            while (i &lt; framesToEncode) {                //long iterationStartTime = System.currentTimeMillis();                long now = System.currentTimeMillis();                //grab the screenshot                BufferedImage image = robot.createScreenCapture(new Rectangle(x, y, width, height));                //convert it for Xuggler                BufferedImage currentScreenshot = new BufferedImage(image.getWidth(), image.getHeight(), BufferedImage.TYPE_3BYTE_BGR);                currentScreenshot.getGraphics().drawImage(image, 0, 0, null);                //start the encoding process                IPacket packet = IPacket.make();                IConverter converter = ConverterFactory.createConverter(currentScreenshot, IPixelFormat.Type.YUV420P);                long timeStamp = (now - firstTimeStamp) * 1000;                 IVideoPicture outFrame = converter.toPicture(currentScreenshot, timeStamp);                if (i == 0) {                    //make first frame keyframe                    outFrame.setKeyFrame(true);                }                outFrame.setQuality(0);                coder.encodeVideo(packet, outFrame, 0);                outFrame.delete();                if (packet.isComplete()) {                    container.writePacket(packet);                    System.out.println(""[ENCODER] writing packet of size "" + packet.getSize() + "" for elapsed time "" + ((timeStamp - lastTimeStamp) / 1000));                    lastTimeStamp = timeStamp;                }                System.out.println(""[ENCODER] encoded image "" + i + "" in "" + (System.currentTimeMillis() - now));                i++;                try {                    Thread.sleep(Math.max((long) (1000 / frameRate.getDouble()) - (System.currentTimeMillis() - now), 0));                } catch (InterruptedException e) {                    e.printStackTrace();                }            }        } catch (AWTException e) {            e.printStackTrace();        }        container.writeTrailer();     } }"
"import net.sourceforge.pmd.cpd.Tokens import net.sourceforge.pmd.cpd.TokenEntry import net.sourceforge.pmd.cpd.Tokenizer import net.sourceforge.pmd.cpd.CPDNullListener import net.sourceforge.pmd.cpd.MatchAlgorithm import net.sourceforge.pmd.cpd.SourceCode import net.sourceforge.pmd.cpd.SourceCode.StringCodeLoader import net.sourceforge.pmd.cpd.SimpleRenderer  // Prepare empty token data. TokenEntry.clearImages() def tokens = new Tokens()  // List all source files with text. def source = new TreeMap&lt;String, SourceCode&gt;() new File('.').eachFile { file -&gt;   if (file.isFile() &amp;&amp; file.name.endsWith('.txt')) {     def analyzedText = file.text     def sourceCode = new SourceCode(new StringCodeLoader(analyzedText, file.name))     source.put(sourceCode.fileName, sourceCode)     analyzedText.eachLine { line, lineNumber -&gt;       line.split('[\\W\\s\\t\\f]+').each { token -&gt;         token = token.trim()         if (token) {           tokens.add(new TokenEntry(token, sourceCode.fileName, lineNumber + 1))         }       }     }     tokens.add(TokenEntry.getEOF())   } }  // Run matching algorithm. def maxTokenChain = 15 def matchAlgorithm = new MatchAlgorithm(source, tokens, maxTokenChain, new CPDNullListener()) matchAlgorithm.findMatches()  // Produce report. matchAlgorithm.matches().each { match -&gt;   println ""  ========================================""   match.iterator().each { mark -&gt;     println ""  DUPLICATION ERROR: &lt;${mark.tokenSrcID}:${mark.beginLine}&gt; [DUPLICATION] Found a ${match.lineCount} line (${match.tokenCount} tokens) duplication!""   }   def indentedTextSlice = """"   match.sourceCodeSlice.eachLine { line -&gt;     indentedTextSlice += ""  $line\n""   }   println ""  ----------------------------------------""   println indentedTextSlice   println ""  ========================================"" }"
"package com.spmsoftware.plugin.listeners;  import com.atlassian.event.api.EventListener; import com.atlassian.event.api.EventPublisher; import com.atlassian.jira.component.ComponentAccessor; import com.atlassian.jira.event.issue.IssueEvent; import com.atlassian.jira.event.type.EventType; import com.atlassian.jira.issue.Issue; import com.atlassian.jira.issue.MutableIssue; import com.atlassian.jira.issue.customfields.manager.OptionsManager; import com.atlassian.jira.issue.customfields.option.Option; import com.atlassian.jira.issue.customfields.option.Options; import com.atlassian.jira.issue.fields.CustomField; import com.atlassian.jira.issue.fields.config.FieldConfig; import com.atlassian.jira.issue.fields.config.FieldConfigScheme; import org.apache.log4j.Logger; import org.springframework.beans.factory.DisposableBean; import org.springframework.beans.factory.InitializingBean;  import java.util.List; import java.util.Map;  /**  * User: adnan  * Date: 5/4/14  * Time: 4:49 PM  */ public class IssueUpdateListener  implements InitializingBean, DisposableBean {      private static final Logger LOGGER = Logger.getLogger(IssueUpdateListener.class);      private final EventPublisher eventPublisher;    // private final JiraAuthenticationContext authenticationContext;      public IssueUpdateListener(EventPublisher eventPublisher) {         this.eventPublisher = eventPublisher;        // this.authenticationContext = ComponentAccessor.getJiraAuthenticationContext();     }      @Override     public void afterPropertiesSet() throws Exception {         eventPublisher.register(this);     }      @Override     public void destroy() throws Exception {         eventPublisher.unregister(this);     }      @EventListener     public void onIssueEvent(IssueEvent issueEvent) {         Long eventTypeId = issueEvent.getEventTypeId();         Issue issue = issueEvent.getIssue();         if (eventTypeId.equals(EventType.ISSUE_RESOLVED_ID)) {             MutableIssue mutableIssue = getMutableIssue(issue);             CustomField customerNameCF = ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName(""Customer Name"");             CustomField allCustomersCF = ComponentAccessor.getCustomFieldManager().getCustomFieldObjectByName(""All Customers"");             Object customerNameVal = mutableIssue.getCustomFieldValue(customerNameCF);             Option newOptions = addOptionToCustomField(allCustomersCF, customerNameVal.toString());             LOGGER.info(""New updated option {}"" + newOptions);         }     }      private MutableIssue getMutableIssue(Issue issue) {         MutableIssue mutableIssue;         if (issue instanceof MutableIssue)   {             mutableIssue = (MutableIssue)issue;         } else {             mutableIssue = ComponentAccessor.getIssueManager().getIssueObject(issue.getKey());         }         return mutableIssue;     }       public Option addOptionToCustomField(CustomField customField, String value) {         Option newOption = null;         if (customField != null) {             List&lt;FieldConfigScheme&gt; schemes = customField.getConfigurationSchemes();             if (schemes != null &amp;&amp; !schemes.isEmpty()) {                 FieldConfigScheme sc = schemes.get(0);                 Map configs = sc.getConfigsByConfig();                 if (configs != null &amp;&amp; !configs.isEmpty()) {                     FieldConfig config = (FieldConfig) configs.keySet().iterator().next();                     OptionsManager optionsManager = ComponentAccessor.getOptionsManager();                     Options l = optionsManager.getOptions(config);                     int nextSequence = l.isEmpty() ? 1 : l.getRootOptions().size() + 1;                     newOption = optionsManager.createOption(config, null, (long) nextSequence, value);                 }             }         }          return newOption;     }  }"
"IplImage img=cvLoadImage(""pathtosourceimage"");     CvSize cvSize = cvSize(img.width(), img.height());     IplImage gry=cvCreateImage(cvSize, img.depth(), 1);     cvCvtColor(img, gry, CV_BGR2GRAY);     cvThreshold(gry, gry, 200, 255, CV_THRESH_BINARY);     cvAdaptiveThreshold(gry, gry, 255, CV_ADAPTIVE_THRESH_MEAN_C, CV_THRESH_BINARY_INV, 11, 5);      CvMemStorage storage = CvMemStorage.create();     CvSeq contours = new CvContour(null);      int noOfContors = cvFindContours(gry, storage, contours, Loader.sizeof(CvContour.class), CV_RETR_CCOMP, CV_CHAIN_APPROX_NONE, new CvPoint(0,0));      CvSeq ptr = new CvSeq();      int count =1;     CvPoint p1 = new CvPoint(0,0),p2 = new CvPoint(0,0);      for (ptr = contours; ptr != null; ptr = ptr.h_next()) {          CvScalar color = CvScalar.BLUE;         CvRect sq = cvBoundingRect(ptr, 0);              System.out.println(""Contour No =""+count);             System.out.println(""X =""+ sq.x()+"" Y=""+ sq.y());             System.out.println(""Height =""+sq.height()+"" Width =""+sq.width());             System.out.println("""");              p1.x(sq.x());             p2.x(sq.x()+sq.width());             p1.y(sq.y());             p2.y(sq.y()+sq.height());             cvRectangle(img, p1,p2, CV_RGB(255, 0, 0), 2, 8, 0);             cvDrawContours(img, ptr, color, CV_RGB(0,0,0), -1, CV_FILLED, 8, cvPoint(0,0));             count++;      }      cvShowImage(""contures"",img);     cvWaitKey(0);"
"ComboBox accountStatusChoice = new ComboBox();  accountStatusChoice.setCaption(MessageResource.getLocalizedString(""caption.accountStatus"")); accountStatusChoice.setRequired(true); accountStatusChoice.setRequiredError(MessageResource.getLocalizedString(""error.required.accountStatus"")); accountStatusChoice.setImmediate(true);  for (AccountStatus accountStatus : AccountStatus.values()) {     accountStatusChoice.addItem(accountStatus);     accountStatusChoice.setItemCaption(accountStatus, MessageResource.getLocalizedString(accountStatus.name())); }  return accountStatusChoice;"
"String sourceUrl = ""http://www.example.com/mysite/whatever/somefolder/bar/unsecure!+?#whätyöühäv€it/site.html""; // your current site     String targetUrl = ""http://www.example.com/mysite/whatever/otherfolder/other.html""; // the link target     String expectedTarget = ""../../../otherfolder/other.html"";     String[] sourceElements = sourceUrl.split(""/"");     String[] targetElements = targetUrl.split(""/""); // keep in mind that the arrays are of different length!     StringBuilder uniquePart = new StringBuilder();     StringBuilder relativePart = new StringBuilder();     boolean stillSame = true;     for(int ii = 0; ii &lt; sourceElements.length || ii &lt; targetElements.length; ii++) {         if(ii &lt; targetElements.length &amp;&amp; ii &lt; sourceElements.length &amp;&amp;                  stillSame &amp;&amp; sourceElements[ii].equals(targetElements[ii]) &amp;&amp; stillSame) continue;         stillSame = false;         if(targetElements.length &gt; ii)           uniquePart.append(""/"").append(targetElements[ii]);         if(sourceElements.length &gt; ii +1)             relativePart.append(""../"");     }      String result = relativePart.toString().substring(0, relativePart.length() -1) + uniquePart.toString();     System.out.println(""result: "" + result);"
"SSLContext ssl = SSLContext.getInstance(""TLS"");  KeyManagerFactory keyFactory = KeyManagerFactory                    .getInstance(KeyManagerFactory.getDefaultAlgorithm()); KeyStore store = KeyStore.getInstance(""JKS"");  store.load(new FileInputStream(keystoreFile),keyPass.toCharArray());  keyFactory.init(store, keyPass.toCharArray());   TrustManagerFactory trustFactory = TrustManagerFactory.getInstance(TrustManagerFactory.getDefaultAlgorithm());  trustFactory.init(store);  ssl.init(keyFactory.getKeyManagers(), trustFactory.getTrustManagers(), new SecureRandom());  HttpsConfigurator configurator = new HttpsConfigurator(ssl);  HttpsServer httpsServer = HttpsServer.create(new InetSocketAddress(hostname, port), port);  httpsServer.setHttpsConfigurator(configurator);  HttpContext httpContext = httpsServer.createContext(uri);  httpsServer.start();  endpoint.publish(httpContext);"
"for (Task tempTask : TasksListAppObj.getInstance().tasksRepository.getTasksRepository())                 {                     LatLng latlng = new LatLng(tempTask.getLatitude(), tempTask.getLongtitude());                     if (tempTask.getStatus().contentEquals(TasksListActivity.STATUS_WAITING))                     {                         newmarker = map.addMarker(new MarkerOptions().position(latlng).title(tempTask.getTitle()).icon(BitmapDescriptorFactory.fromResource(R.drawable.marker_for_map_blue)));                     }                     else if (tempTask.getStatus().contentEquals(TasksListActivity.STATUS_IN_PROGRESS))                     {                         newmarker = map.addMarker(new MarkerOptions().position(latlng).title(tempTask.getTitle()).icon(BitmapDescriptorFactory.fromResource(R.drawable.marker_for_map_bordo)));                     }                     else if (tempTask.getStatus().contentEquals(TasksListActivity.STATUS_ON_THE_WAY))                     {                         newmarker = map.addMarker(new MarkerOptions().position(latlng).title(tempTask.getTitle()).icon(BitmapDescriptorFactory.fromResource(R.drawable.marker_for_map_turkiz)));                     }                     else if (tempTask.getStatus().contentEquals(TasksListActivity.STATUS_COMPLETE))                     {                         newmarker = map.addMarker(new MarkerOptions().position(latlng).title(tempTask.getTitle()).icon(BitmapDescriptorFactory.fromResource(R.drawable.marker_for_map_orange)));                     }                     else if (tempTask.getStatus().contentEquals(TasksListActivity.STATUS_FAILED))                     {                         newmarker = map.addMarker(new MarkerOptions().position(latlng).title(tempTask.getTitle()).icon(BitmapDescriptorFactory.fromResource(R.drawable.marker_for_map_purpul)));                     } }"
"{     ""entry"": ""132456"",     ""product"":      {         ""item"": ""123456"",         ""prompts"":          [             {                 ""promptId"": ""1"",                 ""promptNumber"": ""109"",                 ""promptType"": 4,                 ""promptTypeDesc"": ""desc1"",                 ""validations"":                 [                     {                         ""minLen"": 10,                         ""maxLen"": 10,                         ""required"": true                      }                  ]              }          ]      } }"
"IExtensionRegistry registry = Platform.getExtensionRegistry();     IExtensionPoint extensionPoint = registry             .getExtensionPoint(""myplugin.myextension"");     IConfigurationElement points[] = extensionPoint             .getConfigurationElements();     for (IConfigurationElement point : points) {         if (""myextensionFactory"".equals(point.getName())) {             Object impl = point.createExecutableExtension(""class"");             if (impl instanceof IMyExtension) {                 ((IMyExtension) impl).foo();             }         }     } }"
com.sun.jersey.json.impl.provider.entity.JSONRootElementProvider$Wadl com.sun.jersey.json.impl.provider.entity.JSONRootElementProvider$App com.sun.jersey.json.impl.provider.entity.JSONRootElementProvider$General com.sun.jersey.json.impl.provider.entity.JSONJAXBElementProvider$App com.sun.jersey.json.impl.provider.entity.JSONJAXBElementProvider$General com.sun.jersey.json.impl.provider.entity.JSONListElementProvider$App com.sun.jersey.json.impl.provider.entity.JSONListElementProvider$General com.sun.jersey.json.impl.provider.entity.JSONArrayProvider$App com.sun.jersey.json.impl.provider.entity.JSONArrayProvider$General com.sun.jersey.json.impl.provider.entity.JSONObjectProvider$App com.sun.jersey.json.impl.provider.entity.JSONObjectProvider$General com.sun.jersey.json.impl.provider.entity.JSONWithPaddingProvider com.sun.jersey.json.impl.provider.entity.JacksonProviderProxy
List memBeans = ManagementFactory.getMemoryPoolMXBeans();            for (Iterator i = memBeans.iterator(); i.hasNext(); ) {      MemoryPoolMXBean mpool = (MemoryPoolMXBean)i.next();     MemoryUsage usage = mpool.getUsage();      String name = mpool.getName();           float init = usage.getInit()/1000;     float used = usage.getUsed()/1000;     float committed = usage.getCommitted()/1000;     float max = usage.getMax()/1000;     float pctUsed = (used / max)*100;     float pctCommitted = (committed / max)*100;  }
"import org.camunda.bpm.ProcessEngineService; import org.camunda.bpm.container.RuntimeContainerDelegate; import org.camunda.bpm.engine.ManagementService; import org.camunda.bpm.engine.ProcessEngine; import org.camunda.bpm.engine.RepositoryService; import org.camunda.bpm.engine.management.JobDefinition; import org.camunda.bpm.engine.repository.ProcessDefinition; import org.camunda.bpm.engine.runtime.Job;  import java.util.HashMap; import java.util.List;  public class StackOverflow {    public HashMap&lt;ProcessDefinition, List&lt;Job&gt;&gt; queryNextScheduledExecutionOfTimers() {     ProcessEngineService processEngineService =      RuntimeContainerDelegate.INSTANCE.get().getProcessEngineService();     ProcessEngine defaultProcessEngine = processEngineService.getDefaultProcessEngine();      // optional step - get all active process definitions     RepositoryService repositoryService = defaultProcessEngine.getRepositoryService();     List&lt;ProcessDefinition&gt; processDefinitions =         repositoryService.createProcessDefinitionQuery().active().list();      ManagementService managementService = defaultProcessEngine.getManagementService();      HashMap&lt;ProcessDefinition,List&lt;Job&gt;&gt; timerJobsByProcessDefinition = new HashMap&lt;ProcessDefinition, List&lt;Job&gt;&gt;();     for (ProcessDefinition processDefinition : processDefinitions) {       List&lt;JobDefinition&gt; jobDefinitions =           managementService.createJobDefinitionQuery()               .active()               .processDefinitionId(processDefinition.getId())               .list();        for (JobDefinition jobDefinition : jobDefinitions) {         // if you want to lookup the activity to highlight it inside the process diagram for example         String activityId = jobDefinition.getActivityId();         // if you want to display the configured expression / date / cron expression when the timer should fire         String jobConfiguration = jobDefinition.getJobConfiguration();         // if you want to distinguish between timer start event / catching timer intermediate event / boundary timer event         String timerType = jobDefinition.getJobType();          List&lt;Job&gt; jobs = managementService.createJobQuery()             .active()             .timers()             .jobDefinitionId(jobDefinition.getId())             .orderByJobDuedate()             .list();          timerJobsByProcessDefinition.put(processDefinition, jobs);       }     }      return timerJobsByProcessDefinition;   } }"
"Button btnBuy,btnSell; @Override  public View onCreateView(LayoutInflater inflater, ViewGroup container,             Bundle savedInstanceState) {         View rootView = inflater.inflate(R.layout.fragment_sales,                 container, false);         btnBuy = (Button)rootView.findViewById(R.id.btn_buy);         btnSell = (Button)rootView.findViewById(R.id.btn_sell);          btnBuy.setOnClickListener(new View.OnClickListener() {          @Override         public void onClick(View v) {             Intent intent = new Intent(getActivity(), Buy.class);             startActivity(intent);                   finish();         }         });          return rootView;  }"
"MultiSelectListPreference listPreference = new MultiSelectListPreference(context);     listPreference.setTitle(R.string.configure_category_title);     listPreference.setDialogTitle(R.string.configure_category_title);     listPreference.setSummary(R.string.configure_category_summary);     listPreference.setEntries(R.array.configure_category_array);     listPreference.setEntryValues(new CharSequence[]{             ProcessList.PREF_SERVICES + mAppWidgetId,             ProcessList.PREF_INACTIVE + mAppWidgetId,             ProcessList.PREF_INTERNAL + mAppWidgetId     });      //Create a Set&lt;String&gt; with list items that should be selected     SharedPreferences sharedPref = PreferenceManager.getDefaultSharedPreferences(context);     boolean showServices = sharedPref.getBoolean(ProcessList.PREF_SERVICES + mAppWidgetId, true);     boolean showInactive = sharedPref.getBoolean(ProcessList.PREF_INACTIVE + mAppWidgetId, true);     boolean showInternal = sharedPref.getBoolean(ProcessList.PREF_INTERNAL + mAppWidgetId, true);      String[] strings = new String[3];     int cnt = 0;     if (showServices)         strings[cnt++] = ProcessList.PREF_SERVICES + mAppWidgetId;     if (showInactive)         strings[cnt++] = ProcessList.PREF_INACTIVE + mAppWidgetId;     if (showInternal)         strings[cnt] = ProcessList.PREF_INTERNAL + mAppWidgetId;      Set&lt;String&gt; mySet = new HashSet&lt;String&gt;();     Collections.addAll(mySet, strings);      //Add the set     listPreference.setValues(mySet);      //Listen for changes, I'm not sure if this is how it's meant to work, but it does :/     listPreference.setOnPreferenceChangeListener(new Preference.OnPreferenceChangeListener() {         public boolean onPreferenceChange(Preference preference, Object o) {              HashSet hashSet = (HashSet) o;             Iterator stringIterator = hashSet.iterator();             boolean[] states = {false, false, false};             String prefString;              while (stringIterator.hasNext()) {                  prefString = (String) stringIterator.next();                  if (prefString == null)                     continue;                  if (prefString.compareTo(ProcessList.PREF_SERVICES + mAppWidgetId) == 0)                     states[0] = true;                 else if (prefString.compareTo(ProcessList.PREF_INACTIVE + mAppWidgetId) == 0)                     states[1] = true;                 else if (prefString.compareTo(ProcessList.PREF_INTERNAL + mAppWidgetId) == 0)                     states[2] = true;              }              PreferenceManager                     .getDefaultSharedPreferences(getActivity())                     .edit()                     .putBoolean(ProcessList.PREF_SERVICES + mAppWidgetId, states[0])                     .putBoolean(ProcessList.PREF_INACTIVE + mAppWidgetId, states[1])                     .putBoolean(ProcessList.PREF_INTERNAL + mAppWidgetId, states[2])                     .commit();              return true;         }     });      preferenceCategory.addPreference(listPreference);"
"package com.XXXXXXXX.aspects;  import lombok.extern.slf4j.Slf4j; import org.aspectj.lang.ProceedingJoinPoint; import org.aspectj.lang.annotation.Around; import org.aspectj.lang.annotation.Aspect; import org.aspectj.lang.annotation.Pointcut; import org.springframework.security.core.context.SecurityContextHolder; import org.springframework.security.core.userdetails.UserDetails; import org.springframework.stereotype.Component;  @Component @Aspect @Slf4j public class LoggerAspect {      private final static String DOMAIN = ""XXXXXXXX"";      private static String getCurrentUser() {         String username = ""Unknown"";         try {             Object principal = SecurityContextHolder.getContext().                     getAuthentication().                     getPrincipal();             if (principal instanceof UserDetails) {                 username = ((UserDetails) principal).getUsername();             } else {                 username = principal.toString();             }         } catch (Exception e) {         }         return username;     }      @Pointcut(""within(com.XXXXXXXX.services..*)"")     public void inServiceLayer() {     }      @Pointcut(""execution(* getMatcherInfo(..)) || execution(* resetCounter(..))"")     public void notToAdvise() {     }      @Around(""com.XXXXXXXX.aspects.LoggerAspect.inServiceLayer() &amp;&amp; !com.XXXXXXXX.aspects.LoggerAspect.notToAdvise()"")     public Object doLogging(ProceedingJoinPoint pjp)             throws Throwable {         long start = System.nanoTime();         StringBuilder sb = new StringBuilder(DOMAIN);         sb.append('/').                 append(getCurrentUser()).                 append("" accessing "").                 append(pjp.getSignature().                 getDeclaringTypeName()).                 append('.').                 append(pjp.getSignature().                 getName());         log.trace(""START: "" + sb.toString());         Object retVal = pjp.proceed(pjp.getArgs());         long duration = System.nanoTime() - start;         log.trace(""STOP: "" + duration / 1000000 + "" msec. "" + sb.toString());         return retVal;     } }"
"try {      String shopName = jComboBox1.getSelectedItem().toString();     String actionCode = jComboBox2.getSelectedItem().toString();      HashMap&lt;String, Object&gt; map = new HashMap&lt;String, Object&gt;();     map.put(""storeName"", shopName);     map.put(""actionCode"", actionCode);      URL reportFileURL = getClass().getResource(""../ireps/AccessCounter.jrxml"");     File reportFile = new File(reportFileURL.toURI());     JasperDesign jasperDesign = JRXmlLoader.load(reportFile);     JasperReport jasperReport = JasperCompileManager.compileReport(jasperDesign);     JasperPrint jasperPrint = JasperFillManager.fillReport(jasperReport, map, con);      JasperViewer jv = new JasperViewer(jasperPrint);     JDialog viewer = new JDialog(this, ""Batch Report"", true);     viewer.setBounds(jv.getBounds());     viewer.getContentPane().add(jv.getContentPane());     viewer.setResizable(true);     viewer.setIconImage(jv.getIconImage());     viewer.setVisible(true);  } catch (JRException exc) {    System.out.println(exc.getMessage()); } catch (URISyntaxException exs) {    System.out.println(exs.getMessage()); }"
"LayoutInflater inflater = (LayoutInflater)EEActionListDetail.this.getSystemService(Context.LAYOUT_INFLATER_SERVICE);     Display display = getWindowManager().getDefaultDisplay();      int width = display.getWidth()/2;     int height = display.getHeight()/2;      View pop = inflater.inflate(R.layout.popupemail,null,false);     pop.measure(View.MeasureSpec.UNSPECIFIED,View.MeasureSpec.UNSPECIFIED);     height = pop.getMeasuredHeight();     width = pop.getMeasuredWidth()+200;     pu = new PopupWindow(pop,width,height,true);     pu.showAtLocation(findViewById(R.id.ll3),Gravity.CENTER,1,1);      Button brnSend = (Button)pu.getContentView().findViewById(R.id.btnSend);     Button close = (Button)pu.getContentView().findViewById(R.id.close);      Subject = (EditText)pu.getContentView().findViewById(R.id.subject);     Message = (EditText)pu.getContentView().findViewById(R.id.message);      close.setOnClickListener(new View.OnClickListener() {          @Override         public void onClick(View v) {             pu.dismiss();          }     });     brnSend.setOnClickListener(new View.OnClickListener() {          @Override         public void onClick(View v) {             for(int j=0;j&lt;EmailArray.size();j++){                 String EmailSent = EmailArray.get(j);                 SendEmailALL(EmailSent);             }         }     });"
public class BulkSMSContactsDataModel extends ListDataModel&lt;BulkSMSContacts&gt; implements SelectableDataModel&lt;BulkSMSContacts&gt; {      public BulkSMSContactsDataModel() {   }    public BulkSMSContactsDataModel(List&lt;BulkSMSContacts&gt; data) {       super(data);   }    @Override   public BulkSMSContacts getRowData(String rowKey) {             List&lt;BulkSMSContacts&gt; contacts = (List&lt;BulkSMSContacts&gt;) new yourDao.getListOfBulkSMSContacts(); //yourDAO :BulkSMSContactsSelector i guess     for(BulkSMSContacts c : contacts) {           if(String.valueOf(c.getContactId()).equals(rowKey))               return c;       }        return null;   }    @Override   public Object getRowKey(BulkSMSContacts obj) {       return String.valueOf(obj.getContactId());   }
